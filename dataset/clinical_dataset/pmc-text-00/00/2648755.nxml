<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208112</article-id><article-id pub-id-type="pmc">2648755</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S13</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S13</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>DNA motif alignment by evolving a population of Markov chains</article-title></title-group><contrib-group><contrib id="A1" corresp="yes" contrib-type="author"><name><surname>Bi</surname><given-names>Chengpeng</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>cbi@cmh.edu</email></contrib></contrib-group><aff id="I1"><label>1</label>Bioinformatics and Intelligent Computing Lab, Division of Clinical Pharmacology, Children's Mercy Hospitals, Kansas City, Missouri, USA</aff><aff id="I2"><label>2</label>Schools of Medicine, and Computing and Engineering, University of Missouri, Kansas City, Missouri, USA</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S13</fpage><lpage>S13</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S13"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Bi; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Bi; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Bi               Chengpeng                                             cbi@cmh.edu            </dc:author><dc:title>            DNA motif alignment by evolving a population of Markov chains         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S13-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S13&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>Deciphering <italic>cis</italic>-regulatory elements or <italic>de novo </italic>motif-finding in genomes still remains elusive although much algorithmic effort has been expended. The Markov chain Monte Carlo (MCMC) method such as Gibbs motif samplers has been widely employed to solve the <italic>de novo </italic>motif-finding problem through sequence local alignment. Nonetheless, the MCMC-based motif samplers still suffer from local maxima like EM.</p><p>Therefore, as a prerequisite for finding good local alignments, these motif algorithms are often independently run a multitude of times, but without information exchange between different chains. Hence it would be worth a new algorithm design enabling such information exchange.</p></sec><sec><title>Results</title><p>This paper presents a novel motif-finding algorithm by evolving a population of Markov chains with information exchange (PMC), each of which is initialized as a random alignment and run by the Metropolis-Hastings sampler (MHS). It is progressively updated through a series of local alignments stochastically sampled. Explicitly, the PMC motif algorithm performs stochastic sampling as specified by a population-based proposal distribution rather than individual ones, and adaptively evolves the population as a whole towards a global maximum. The alignment information exchange is accomplished by taking advantage of the pooled motif site distributions. A distinct method for running multiple independent Markov chains (IMC) without information exchange, or dubbed as the IMC motif algorithm, is also devised to compare with its PMC counterpart.</p></sec><sec><title>Conclusion</title><p>Experimental studies demonstrate that the performance could be improved if pooled information were used to run a population of motif samplers. The new PMC algorithm was able to improve the convergence and outperformed other popular algorithms tested using simulated and biological motif sequences.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>Discovering <italic>cis</italic>-regulatory elements or DNA motifs in genomic sequences is fundamental to build genetic networks and important to understand gene regulation in biological and pathological processes [<xref ref-type="bibr" rid="B1">1</xref>]. Although much algorithmic effort has been expended, it still remains challenging (see recent reviews in [<xref ref-type="bibr" rid="B2">2</xref>,<xref ref-type="bibr" rid="B3">3</xref>]). Multiple sequence local alignment coupling with position weight matrix (PWM) updating, or PWM-based technique for short, has been widely used to solve the <italic>de novo </italic>motif discovery problem [<xref ref-type="bibr" rid="B2">2</xref>,<xref ref-type="bibr" rid="B3">3</xref>]. This problem is of combinatorial optimization, and it has proven NP-complete [<xref ref-type="bibr" rid="B4">4</xref>]. A motif model or PWM can be uniquely defined by a local alignment, and the PWM updating is applied to progressively calibrate the alignments until some specified criterion is met. In the following text, the terms local alignment and motif discovery are often interchangeable. Basically, the PWM updating technique consists of two broad approaches to approximating the local alignment solutions, deterministic and stochastic motif-finding algorithms. The deterministic local alignment algorithm developed by Lawrence and Reiley in 1990 [<xref ref-type="bibr" rid="B5">5</xref>] is rooted on the Expectation Maximization (EM) method [<xref ref-type="bibr" rid="B6">6</xref>]. EM has been widely applied in various scientific computing since its introduction due to its simplicity and efficiency [<xref ref-type="bibr" rid="B7">7</xref>]. The EM motif algorithm has spawned a plethora of its variations (see review in [<xref ref-type="bibr" rid="B8">8</xref>] and references therein), for example, a popular motif algorithms called MEME is an enhanced EM version [<xref ref-type="bibr" rid="B9">9</xref>].</p><p>The stochastic local alignment method is the second approach in the PWM updating. It has its origin in Markov chain Monte Carlo (MCMC) methods [<xref ref-type="bibr" rid="B10">10</xref>] pioneered by Metropolis et al. in 1953 [<xref ref-type="bibr" rid="B11">11</xref>] and generalized later on by Hastings [<xref ref-type="bibr" rid="B12">12</xref>]. The earliest MCMC-based motif discovery algorithm is called Gibbs motif sampler developed in 1993 [<xref ref-type="bibr" rid="B13">13</xref>], and later many other MCMC-based motif samplers have been investigated such as BioProspector [<xref ref-type="bibr" rid="B14">14</xref>]. Moreover, the EM algorithm relates to the MCMC algorithms in the sense that it can be viewed as a forerunner of the Gibbs sampler in its data augmentation version [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B15">15</xref>,<xref ref-type="bibr" rid="B16">16</xref>], also as seen in a recent comparative study on these two approaches to detecting protein domains [<xref ref-type="bibr" rid="B17">17</xref>]. The MCMC algorithms have some appealing features better than EM, for example, they can escape from the local optima suffered by the EM algorithms. Most importantly, MCMC can be used as a general framework for solving a wide range of complex problems where EM often fails, because for these problems computing the expectation or maximization steps as required in EM often become infeasible. In particular, MCMC provides a framework for drawing samples from a complicated target distribution that cannot be sampled with simpler deterministic methods.</p><p>In practical sequence alignment, the MCMC sampling algorithms may also suffer from local maxima like EM [<xref ref-type="bibr" rid="B3">3</xref>]. To remedy this limitation, a MCMC motif algorithm is often run a multitude of times each starting from different points, that is, there is a population of Markov chains running in parallel. This simple strategy is strongly recommended and should be able to efficiently explore the probability landscape with multiple modes [<xref ref-type="bibr" rid="B3">3</xref>]. The population-based Monte Carlo methods serve two purposes, that is, to improve or diagnose convergence [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B18">18</xref>] and escape from local maxima [<xref ref-type="bibr" rid="B3">3</xref>]. It can be classified into two categories: (1) running multiple independent Markov chains (IMC) without any information exchange between chains, and (2) enabling information exchange among a population of Markov chains (PMC). It is straightforward to implement IMC for any MCMC-based samplers. In real world, IMC is often encouraged in running MCMC motif samplers. However, as up to now PMC is rarely concerned with in sequence local alignment [<xref ref-type="bibr" rid="B3">3</xref>]. In literature, PMC exists in a diversity of forms. For example, parallel tempering (PT) evolves R Markov chains each attaching a different temperature [<xref ref-type="bibr" rid="B19">19</xref>]. Chains in PT exchanges information by swapping two states that are generated by mutation, and accepted by a modified Metropolis-Hasting rule. Note that PT is the population-based simulated annealing algorithm and it only exchanges information pairwise. The real PMC algorithm should be able to exchange information at the population level, for example, the evolutionary Monte Carlo (EMC) [<xref ref-type="bibr" rid="B20">20</xref>] and population MCMC [<xref ref-type="bibr" rid="B21">21</xref>]. This paper presents the PMC motif-finding algorithm, a novel local alignment method. It evolves a population of Markov chains (PMC) with information exchange, each chain being updated according to the population-based or pooled proposal distributions and Metropolis-Hasting rule. Experimental studies demonstrate that the new algorithm was able to improve the convergence as well as evolve some better local alignments while compared to IMC and other motif algorithms tested.</p></sec><sec><title>Results</title><sec><title>Metropolis-Hastings sampler for local alignment</title><p>A Metropolis-Hastings motif sampler (MHS) was first devised to carry out multiple local alignment. MHS run a single Markov chain initialized from a random alignment seed, which is the so-called initial alignment (<bold>A</bold><sup>(0) </sup>with <italic>t </italic>= 0 step). A motif model or PWM matrix &#x00398;<sup>(<italic>t</italic>) </sup>at step <italic>t </italic>can be derived from such a sequence alignment (<bold>A</bold><sup>(<italic>t</italic>)</sup>). Then a Monte Carlo simulation is processed as follows: first scanning all sequences by the motif model built at step <italic>t</italic>. The scanning process simply calculates the probabilities of each potential motif sites on the input sequences using equation (1). Second, new samples are drawn from each sequence according to proposed distributions built from the sites scanned in the step <italic>t</italic>. Third, a energy function as defined in equation (3) is calculated, and the Metropolis-Hastings acceptance rate defined in equation (6) is applied to decide whether or not the new samples (i.e. new alignment) are passed to the next iteration. Finally, the above procedure is iterated for a number of iterations or cycles (<italic>C</italic>). A parallel MHS (i.e IMC) run the MHS motif sampler a multitude of times (<italic>R</italic>) independently without any information exchange, whereas the population-based MHS (i.e. PMC) run the same MHS sampler <italic>R </italic>times with information exchange enabled among all chains.</p><sec><title>Scanning function</title><p>The information weight function originally proposed by Kullback and Leibler in 1951 [<xref ref-type="bibr" rid="B22">22</xref>] is used to approximate the probability of a potential site (<italic>a</italic><sub><italic>i</italic></sub>) on sequence <italic>i </italic>(<italic>S</italic><sub><italic>i</italic></sub>) given the current motif model &#x00398;<sup>(<italic>t</italic>)</sup>,</p><p><disp-formula id="bmcM1"><label>(1)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S13-i1" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mi>p</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:msub>                                 <mml:mi>a</mml:mi>                                 <mml:mi>i</mml:mi>                              </mml:msub>                              <mml:mo>|</mml:mo>                              <mml:msup>                                 <mml:mstyle mathvariant="bold" mathsize="normal">                                    <mml:mi>A</mml:mi>                                 </mml:mstyle>                                 <mml:mrow>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>t</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:msup>                              <mml:mo>,</mml:mo>                              <mml:msup>                                 <mml:mi>&#x00398;</mml:mi>                                 <mml:mrow>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>t</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:msup>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>&#x0221d;</mml:mo>                              <mml:mstyle displaystyle="true">                                 <mml:munderover>                                    <mml:mo>&#x02211;</mml:mo>                                    <mml:mrow>                                       <mml:mi>j</mml:mi>                                       <mml:mo>=</mml:mo>                                       <mml:msub>                                          <mml:mi>a</mml:mi>                                          <mml:mi>i</mml:mi>                                       </mml:msub>                                    </mml:mrow>                                    <mml:msup>                                       <mml:mi>a</mml:mi>                                       <mml:mo>&#x02032;</mml:mo>                                    </mml:msup>                                 </mml:munderover>                                 <mml:mrow>                                    <mml:mstyle displaystyle="true">                                       <mml:munderover>                                          <mml:mo>&#x02211;</mml:mo>                                          <mml:mrow>                                             <mml:mi>k</mml:mi>                                             <mml:mo>=</mml:mo>                                             <mml:mi>A</mml:mi>                                          </mml:mrow>                                          <mml:mi>T</mml:mi>                                       </mml:munderover>                                       <mml:mrow>                                          <mml:mi>log</mml:mi>                                          <mml:mo>&#x02061;</mml:mo>                                          <mml:msup>                                             <mml:mrow>                                                <mml:mrow>                                                   <mml:mo>(</mml:mo>                                                   <mml:mrow>                                                      <mml:mfrac>                                                         <mml:mrow>                                                            <mml:msubsup>                                                               <mml:mi mathvariant="bold">&#x003b8;</mml:mi>                                                               <mml:mrow>                                                                  <mml:msup>                                                                     <mml:mi>j</mml:mi>                                                                     <mml:mo>&#x02032;</mml:mo>                                                                  </mml:msup>                                                                  <mml:mi>k</mml:mi>                                                               </mml:mrow>                                                               <mml:mrow>                                                                  <mml:mo stretchy="false">(</mml:mo>                                                                  <mml:mi>t</mml:mi>                                                                  <mml:mo stretchy="false">)</mml:mo>                                                               </mml:mrow>                                                            </mml:msubsup>                                                         </mml:mrow>                                                         <mml:mrow>                                                            <mml:msub>                                                               <mml:mi mathvariant="bold">&#x003b8;</mml:mi>                                                               <mml:mrow>                                                                  <mml:mn>0</mml:mn>                                                                  <mml:mi>k</mml:mi>                                                               </mml:mrow>                                                            </mml:msub>                                                         </mml:mrow>                                                      </mml:mfrac>                                                   </mml:mrow>                                                   <mml:mo>)</mml:mo>                                                </mml:mrow>                                             </mml:mrow>                                             <mml:mrow>                                                <mml:mi>&#x003b4;</mml:mi>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:msub>                                                   <mml:mi>S</mml:mi>                                                   <mml:mrow>                                                      <mml:mi>i</mml:mi>                                                      <mml:mi>j</mml:mi>                                                   </mml:mrow>                                                </mml:msub>                                                <mml:mo>,</mml:mo>                                                <mml:mi>k</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                             </mml:mrow>                                          </mml:msup>                                       </mml:mrow>                                    </mml:mstyle>                                 </mml:mrow>                              </mml:mstyle>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>where <italic>a' </italic>= <italic>a</italic><sub><italic>i </italic></sub>+ <italic>w </italic>- 1, <italic>j' = j </italic>- <italic>a</italic><sub><italic>i </italic></sub>+ 1, and <italic>&#x003b4; </italic>is the indicator function. The information weight function simply indicates how similar a motif nucleotide probability (<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S13-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>) is relative to the background (<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S13-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>). Therefore, a site gets a larger scanning probability if its motif sequence is more different than the background. The scanning function can be derived in the EM motif algorithms [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B8">8</xref>] or Gibbs motif samplers [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B17">17</xref>].</p></sec><sec><title>Scoring function</title><p>Given a set of unaligned sequences (<bold>S</bold>), each local alignment can be treated as a configuration (<italic>v</italic>) in the whole local alignment space. The potential energy of a configuration (i.e. a local alignment <bold>A</bold><sup>(<italic>t</italic>)</sup>) is defined by,</p><p><disp-formula id="bmcM2"><label>(2)</label><italic>H</italic>(<italic>v</italic>) = <italic>H</italic>(&#x00398;<sup>(<italic>t</italic>)</sup>, <bold>A</bold><sup>(<italic>t</italic>)</sup>, <bold>S</bold>),</disp-formula></p><p>where <bold>A </bold>is the missing data (i.e. the motif sites), <bold>S </bold>is the observed data and &#x00398; is a parameter matrix (or a motif model) to be estimated. Note that the potential energy has its real biological meaning, for example, it may indicate the protein-DNA binding affinity [<xref ref-type="bibr" rid="B23">23</xref>,<xref ref-type="bibr" rid="B24">24</xref>] or energy of a protein three-dimensional configuration [<xref ref-type="bibr" rid="B10">10</xref>]. Assuming the Boltzmann distribution, one can compute the probability of such a configuration (<italic>p</italic>(<italic>v</italic>)). Although the energy function <italic>H</italic>(&#x000b7;) can be defined in any forms of interests, here a simple local alignment log-likelihood function [<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>] is used, which is given as,</p><p><disp-formula id="bmcM3"><label>(3)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S13-i4" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mi>H</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:msup>                                 <mml:mstyle mathvariant="bold" mathsize="normal">                                    <mml:mi>A</mml:mi>                                 </mml:mstyle>                                 <mml:mrow>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>t</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:msup>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>&#x02261;</mml:mo>                              <mml:mi>Q</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:msup>                                 <mml:mi>&#x00398;</mml:mi>                                 <mml:mrow>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>t</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:msup>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>=</mml:mo>                              <mml:mo>|</mml:mo>                              <mml:msup>                                 <mml:mstyle mathvariant="bold" mathsize="normal">                                    <mml:mi>A</mml:mi>                                 </mml:mstyle>                                 <mml:mrow>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>t</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:msup>                              <mml:mo>|</mml:mo>                              <mml:mstyle displaystyle="true">                                 <mml:munderover>                                    <mml:mo>&#x02211;</mml:mo>                                    <mml:mrow>                                       <mml:mi>j</mml:mi>                                       <mml:mo>=</mml:mo>                                       <mml:mn>0</mml:mn>                                    </mml:mrow>                                    <mml:mi>w</mml:mi>                                 </mml:munderover>                                 <mml:mrow>                                    <mml:mstyle displaystyle="true">                                       <mml:munderover>                                          <mml:mo>&#x02211;</mml:mo>                                          <mml:mrow>                                             <mml:mi>k</mml:mi>                                             <mml:mo>=</mml:mo>                                             <mml:mi>A</mml:mi>                                          </mml:mrow>                                          <mml:mi>T</mml:mi>                                       </mml:munderover>                                       <mml:mrow>                                          <mml:msub>                                             <mml:mi>&#x003c4;</mml:mi>                                             <mml:mi>t</mml:mi>                                          </mml:msub>                                          <mml:mo stretchy="false">(</mml:mo>                                          <mml:msub>                                             <mml:mi mathvariant="bold">&#x003b8;</mml:mi>                                             <mml:mrow>                                                <mml:mi>j</mml:mi>                                                <mml:mi>k</mml:mi>                                             </mml:mrow>                                          </mml:msub>                                          <mml:mo stretchy="false">)</mml:mo>                                       </mml:mrow>                                    </mml:mstyle>                                 </mml:mrow>                              </mml:mstyle>                              <mml:mo>,</mml:mo>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>where |<bold>A</bold>| is the aligned motif sites, and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S13-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msubsup><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1.0</mml:mn><mml:mo>/</mml:mo><mml:msubsup><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> is a negative entropy function. The energy function described as above and its variants have been widely adopted in maximum likelihood [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B17">17</xref>] or maximum a posterior based local alignment algorithms [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B14">14</xref>].</p></sec><sec><title>MHS sampling</title><p>The probability of a local alignment follows the Boltzmann distribution as,</p><p><disp-formula id="bmcM4"><label>(4)</label><italic>p</italic>(<bold>A|S</bold>) = <italic>Z</italic><sup>-1 </sup>exp{-<italic>&#x003bb;H</italic>(<bold>A</bold>)},</disp-formula></p><p>where <italic>&#x003bb; </italic>= 1/<italic>k</italic><sub><italic>B</italic></sub><italic>T</italic>, and <italic>Z </italic>is a normalization constant. Given the current local alignment (<bold>A</bold><sup>(<italic>t</italic>)</sup>, &#x00398;<sup>(<italic>t</italic>)</sup>), a new local alignment (<bold>A</bold><sup>(<italic>n</italic>)</sup>) is proposed according to the following proposal distribution,</p><p><disp-formula id="bmcM5"><label>(5)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S13-i6" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mi>P</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:msup>                                 <mml:mstyle mathvariant="bold" mathsize="normal">                                    <mml:mi>A</mml:mi>                                 </mml:mstyle>                                 <mml:mrow>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>n</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:msup>                              <mml:mo>|</mml:mo>                              <mml:msup>                                 <mml:mstyle mathvariant="bold" mathsize="normal">                                    <mml:mi>A</mml:mi>                                 </mml:mstyle>                                 <mml:mrow>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>t</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:msup>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>=</mml:mo>                              <mml:mstyle displaystyle="true">                                 <mml:munderover>                                    <mml:mo>&#x0220f;</mml:mo>                                    <mml:mrow>                                       <mml:mi>i</mml:mi>                                       <mml:mo>=</mml:mo>                                       <mml:mn>1</mml:mn>                                    </mml:mrow>                                    <mml:mi>N</mml:mi>                                 </mml:munderover>                                 <mml:mrow>                                    <mml:mi>p</mml:mi>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:msub>                                       <mml:mi>a</mml:mi>                                       <mml:mi>i</mml:mi>                                    </mml:msub>                                    <mml:mo>|</mml:mo>                                    <mml:msup>                                       <mml:mstyle mathvariant="bold" mathsize="normal">                                          <mml:mi>A</mml:mi>                                       </mml:mstyle>                                       <mml:mrow>                                          <mml:mo stretchy="false">(</mml:mo>                                          <mml:mi>t</mml:mi>                                          <mml:mo stretchy="false">)</mml:mo>                                       </mml:mrow>                                    </mml:msup>                                    <mml:mo>,</mml:mo>                                    <mml:msup>                                       <mml:mi>&#x00398;</mml:mi>                                       <mml:mrow>                                          <mml:mo stretchy="false">(</mml:mo>                                          <mml:mi>t</mml:mi>                                          <mml:mo stretchy="false">)</mml:mo>                                       </mml:mrow>                                    </mml:msup>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:mstyle>                              <mml:mo>.</mml:mo>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>As noted, the proposal distribution assumes each sequence is independently sampled. The proposed alignment is either accepted or rejected according to the Metropolis-Hastings rule, and its acceptance rate (<italic>&#x003b1;</italic><sub><italic>H</italic></sub>) is defined as,</p><p><disp-formula id="bmcM6"><label>(6)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S13-i7" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:msub>                                 <mml:mi>&#x003b1;</mml:mi>                                 <mml:mi>H</mml:mi>                              </mml:msub>                              <mml:mo>=</mml:mo>                              <mml:mi>min</mml:mi>                              <mml:mo>&#x02061;</mml:mo>                              <mml:mrow>                                 <mml:mo>{</mml:mo>                                 <mml:mrow>                                    <mml:mn>1</mml:mn>                                    <mml:mo>,</mml:mo>                                    <mml:mi>exp</mml:mi>                                    <mml:mo>&#x02061;</mml:mo>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>&#x003bb;</mml:mi>                                    <mml:mi>&#x00394;</mml:mi>                                    <mml:mi>H</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                    <mml:mfrac>                                       <mml:mrow>                                          <mml:mi>P</mml:mi>                                          <mml:mo stretchy="false">(</mml:mo>                                          <mml:msup>                                             <mml:mstyle mathvariant="bold" mathsize="normal">                                                <mml:mi>A</mml:mi>                                             </mml:mstyle>                                             <mml:mrow>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>n</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                             </mml:mrow>                                          </mml:msup>                                          <mml:mo>|</mml:mo>                                          <mml:msup>                                             <mml:mstyle mathvariant="bold" mathsize="normal">                                                <mml:mi>A</mml:mi>                                             </mml:mstyle>                                             <mml:mrow>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>t</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                             </mml:mrow>                                          </mml:msup>                                          <mml:mo stretchy="false">)</mml:mo>                                       </mml:mrow>                                       <mml:mrow>                                          <mml:mi>P</mml:mi>                                          <mml:mo stretchy="false">(</mml:mo>                                          <mml:msup>                                             <mml:mstyle mathvariant="bold" mathsize="normal">                                                <mml:mi>A</mml:mi>                                             </mml:mstyle>                                             <mml:mrow>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>t</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                             </mml:mrow>                                          </mml:msup>                                          <mml:mo>|</mml:mo>                                          <mml:msup>                                             <mml:mstyle mathvariant="bold" mathsize="normal">                                                <mml:mi>A</mml:mi>                                             </mml:mstyle>                                             <mml:mrow>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>n</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                             </mml:mrow>                                          </mml:msup>                                          <mml:mo stretchy="false">)</mml:mo>                                       </mml:mrow>                                    </mml:mfrac>                                 </mml:mrow>                                 <mml:mo>}</mml:mo>                              </mml:mrow>                              <mml:mo>,</mml:mo>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>where &#x00394;<italic>H </italic>= <italic>H</italic>(<bold>A</bold><sup>(<italic>n</italic>)</sup>) - <italic>H</italic>(<bold>A</bold><sup>(<italic>t</italic>)</sup>). The transition probability from alignment <bold>A</bold><sup>(<italic>t</italic>) </sup>to <bold>A</bold><sup>(<italic>n</italic>) </sup>is thus expressed as follows: <italic>T</italic>(<bold>A</bold><sup>(<italic>n</italic>)</sup>|<bold>A</bold><sup>(<italic>t</italic>)</sup>) = <italic>P</italic>(<bold>A</bold><sup>(<italic>n</italic>)</sup>|<bold>A</bold><sup>(<italic>t</italic>)</sup>)<italic>&#x003b1;</italic><sub><italic>H</italic></sub>(<bold>A</bold><sup>(<italic>n</italic>)</sup>|<bold>A</bold><sup>(<italic>t</italic>)</sup>). The MHS algorithm keeps updating the current best alignment and associated maximum energy along the sampling process or Markov chain. The output is the final best alignment (<bold>A</bold>*) and its corresponding maximum energy (<italic>H</italic><sub><italic>max</italic></sub>) as well as the associated best motif model (&#x00398;*). It should be pointed out that the energy maximization is equivalent to the minimization, that is, the optimizations max{<italic>H</italic>} and min{-<italic>H</italic>} are the same.</p><p>The IMC version of the MHS motif algorithm can be easily implemented in parallel. Let <italic>R </italic>independent Markov chains each starting from a different initial alignment, and then the IMC algorithm run <italic>R </italic>chains separately. Thus, one can send each run (i.e. a single MHS sampler) to a different compute node for execution. A set of the best alignments collected from all samplers in nodes can be sorted out and output the top best alignments as the potential solutions (note that the top-10 solutions are output as the default).</p></sec></sec><sec><title>The PMC motif-finding algorithm</title><p>Running multiple independent Markov chains (i.e. IMC) was originally designed to evaluate convergence [<xref ref-type="bibr" rid="B15">15</xref>], and later was found of its efficiency in improving convergence [<xref ref-type="bibr" rid="B18">18</xref>]. The goal of multiple local alignment is to uncover the target motifs hidden in a set of unaligned sequences as fast as possible. This requires that a MCMC motif-finding algorithm be able to efficiently explore the alignment space and in the same time locate as many near-optimal motifs as possible. In addition, to be practical, a Markov chain should be quickly converged since biological sequence alignment is a quite large-scale problem. As mentioned before, IMC technique is used in motif-finding on regular basis. However, it does not allow information exchange between chains. The idea of the PMC motif-finding algorithm is simply proposing the sampling distribution based on the current population of alignments, rather than on each individual. Since the transition matrix is based on the current population, the transition matrix of a single chain may be not stationary, but it evolves as a whole population which is stationary. It is hoped that such population-based information exchange would be able to improve the motif-finding performance and convergence as well. The PMC motif algorithm first initializes a population of R independent alignments (<bold>A</bold><sup>(<italic>r</italic>0)</sup>: <italic>r </italic>= 1, &#x022ef;, <italic>R</italic>). Each individual alignment at step <italic>t </italic>(<bold>A</bold><sup>(<italic>rt</italic>)</sup>) can be uniquely mapped to a PWM model &#x00398;<sup>(<italic>rt</italic>)</sup>, which can be used to scan sequences the same as in a single MHS motif sampler described as above. Now the proposal distribution is based on the current population of alignments <bold>A</bold><sup>(<italic>rt</italic>)</sup>. After scanning step, each individual often generates different distributions of site probabilities, <italic>p</italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S13-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>|<bold>A</bold><sup>(<italic>rt</italic>)</sup>): <italic>r </italic>= 1, &#x022ef;, <italic>R</italic>, here <italic>p</italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S13-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>|&#x000b7;) is the site probability on location (<italic>a</italic><sub><italic>i</italic></sub>) of sequence <italic>i </italic>in the <italic>r</italic>-th Markov chain. To summarize the current population of site probabilities on each sequence location (<italic>a</italic><sub><italic>i</italic></sub>), its expectation <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S13-i9" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>(<italic>a</italic><sub><italic>i</italic></sub>|<italic>R</italic>, <italic>t</italic>) and variance <italic>&#x003c3; </italic>(<italic>a</italic><sub><italic>i</italic></sub>|<italic>R</italic>, <italic>t</italic>) can be estimated as follows,</p><p><disp-formula id="bmcM7"><label>(7)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S13-i10" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mover accent="true">                              <mml:mi>p</mml:mi>                              <mml:mo>&#x000af;</mml:mo>                           </mml:mover>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:msub>                              <mml:mi>a</mml:mi>                              <mml:mi>i</mml:mi>                           </mml:msub>                           <mml:mo>|</mml:mo>                           <mml:mi>R</mml:mi>                           <mml:mo>,</mml:mo>                           <mml:mi>t</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mi>E</mml:mi>                           <mml:mo stretchy="false">[</mml:mo>                           <mml:mi>p</mml:mi>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:msub>                              <mml:mi>a</mml:mi>                              <mml:mi>i</mml:mi>                           </mml:msub>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo stretchy="false">]</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>r</mml:mi>                                    <mml:mo>=</mml:mo>                                    <mml:mn>1</mml:mn>                                 </mml:mrow>                                 <mml:mi>R</mml:mi>                              </mml:munderover>                              <mml:mrow>                                 <mml:mi>p</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:msubsup>                                    <mml:mi>a</mml:mi>                                    <mml:mi>i</mml:mi>                                    <mml:mi>r</mml:mi>                                 </mml:msubsup>                                 <mml:mo>|</mml:mo>                                 <mml:msup>                                    <mml:mstyle mathvariant="bold" mathsize="normal">                                       <mml:mi>A</mml:mi>                                    </mml:mstyle>                                    <mml:mrow>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>r</mml:mi>                                       <mml:mi>t</mml:mi>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                 </mml:msup>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mo>/</mml:mo>                                 <mml:mi>R</mml:mi>                                 <mml:mo>;</mml:mo>                              </mml:mrow>                           </mml:mstyle>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p><disp-formula id="bmcM8"><label>(8)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S13-i11" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msup>                              <mml:mi>&#x003c3;</mml:mi>                              <mml:mn>2</mml:mn>                           </mml:msup>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:msub>                              <mml:mi>a</mml:mi>                              <mml:mi>i</mml:mi>                           </mml:msub>                           <mml:mo>|</mml:mo>                           <mml:mi>R</mml:mi>                           <mml:mo>,</mml:mo>                           <mml:mi>t</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>r</mml:mi>                                    <mml:mo>=</mml:mo>                                    <mml:mn>1</mml:mn>                                 </mml:mrow>                                 <mml:mi>R</mml:mi>                              </mml:munderover>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:msup>                                          <mml:mrow>                                             <mml:mo stretchy="false">[</mml:mo>                                             <mml:mi>p</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msubsup>                                                <mml:mi>a</mml:mi>                                                <mml:mi>i</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msubsup>                                             <mml:mo>|</mml:mo>                                             <mml:msup>                                                <mml:mstyle mathvariant="bold" mathsize="normal">                                                   <mml:mi>A</mml:mi>                                                </mml:mstyle>                                                <mml:mrow>                                                   <mml:mo stretchy="false">(</mml:mo>                                                   <mml:mi>r</mml:mi>                                                   <mml:mi>t</mml:mi>                                                   <mml:mo stretchy="false">)</mml:mo>                                                </mml:mrow>                                             </mml:msup>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mover accent="true">                                                <mml:mi>p</mml:mi>                                                <mml:mo>&#x000af;</mml:mo>                                             </mml:mover>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>a</mml:mi>                                                <mml:mi>i</mml:mi>                                             </mml:msub>                                             <mml:mo>|</mml:mo>                                             <mml:mi>R</mml:mi>                                             <mml:mo>,</mml:mo>                                             <mml:mi>t</mml:mi>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo stretchy="false">]</mml:mo>                                          </mml:mrow>                                          <mml:mn>2</mml:mn>                                       </mml:msup>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mi>R</mml:mi>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mn>1</mml:mn>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mrow>                           </mml:mstyle>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>One would argue that a larger variance (<italic>&#x003c3;</italic>) may lead to a slow convergence. Thus the population-based proposal distribution is defined as,</p><p><disp-formula id="bmcM9"><label>(9)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-S1-S13-i12" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mover accent="true">                              <mml:mi>P</mml:mi>                              <mml:mo>&#x000af;</mml:mo>                           </mml:mover>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:msup>                              <mml:mstyle mathvariant="bold" mathsize="normal">                                 <mml:mi>A</mml:mi>                              </mml:mstyle>                              <mml:mrow>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>r</mml:mi>                                 <mml:mi>n</mml:mi>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mrow>                           </mml:msup>                           <mml:mo>|</mml:mo>                           <mml:msup>                              <mml:mstyle mathvariant="bold" mathsize="normal">                                 <mml:mi>A</mml:mi>                              </mml:mstyle>                              <mml:mrow>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>r</mml:mi>                                 <mml:mi>t</mml:mi>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mrow>                           </mml:msup>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x0220f;</mml:mo>                                 <mml:mrow>                                    <mml:mi>i</mml:mi>                                    <mml:mo>=</mml:mo>                                    <mml:mn>1</mml:mn>                                 </mml:mrow>                                 <mml:mi>N</mml:mi>                              </mml:munderover>                              <mml:mrow>                                 <mml:mover accent="true">                                    <mml:mi>p</mml:mi>                                    <mml:mo>&#x000af;</mml:mo>                                 </mml:mover>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:msub>                                    <mml:mi>a</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                                 <mml:mo>|</mml:mo>                                 <mml:mi>R</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>t</mml:mi>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mrow>                           </mml:mstyle>                           <mml:mo>,</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where <italic>r </italic>= 1,&#x022ef;, <italic>R</italic>. Each individual alignment so proposed is either accepted or rejected according to the Metropolis-Hastings rule, and the population-based acceptance rate (<italic>&#x003b1;</italic><sub><italic>P</italic></sub>) is defined as follows,</p><p><disp-formula id="bmcM10"><label>(10)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-10-S1-S13-i13" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>&#x003b1;</mml:mi>                              <mml:mi>P</mml:mi>                           </mml:msub>                           <mml:mo>=</mml:mo>                           <mml:mi>min</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:mrow>                              <mml:mo>{</mml:mo>                              <mml:mrow>                                 <mml:mn>1</mml:mn>                                 <mml:mo>,</mml:mo>                                 <mml:msup>                                    <mml:mi>e</mml:mi>                                    <mml:mrow>                                       <mml:mi>&#x003bb;</mml:mi>                                       <mml:mi>&#x00394;</mml:mi>                                       <mml:msup>                                          <mml:mi>H</mml:mi>                                          <mml:mi>r</mml:mi>                                       </mml:msup>                                    </mml:mrow>                                 </mml:msup>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mover accent="true">                                          <mml:mi>P</mml:mi>                                          <mml:mo>&#x000af;</mml:mo>                                       </mml:mover>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msup>                                          <mml:mstyle mathvariant="bold" mathsize="normal">                                             <mml:mi>A</mml:mi>                                          </mml:mstyle>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mi>r</mml:mi>                                             <mml:mi>n</mml:mi>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:msup>                                       <mml:mo>|</mml:mo>                                       <mml:msup>                                          <mml:mstyle mathvariant="bold" mathsize="normal">                                             <mml:mi>A</mml:mi>                                          </mml:mstyle>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mi>r</mml:mi>                                             <mml:mi>t</mml:mi>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:msup>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mover accent="true">                                          <mml:mi>P</mml:mi>                                          <mml:mo>&#x000af;</mml:mo>                                       </mml:mover>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msup>                                          <mml:mstyle mathvariant="bold" mathsize="normal">                                             <mml:mi>A</mml:mi>                                          </mml:mstyle>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mi>r</mml:mi>                                             <mml:mi>t</mml:mi>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:msup>                                       <mml:mo>|</mml:mo>                                       <mml:msup>                                          <mml:mstyle mathvariant="bold" mathsize="normal">                                             <mml:mi>A</mml:mi>                                          </mml:mstyle>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mi>r</mml:mi>                                             <mml:mi>n</mml:mi>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:msup>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mrow>                              <mml:mo>}</mml:mo>                           </mml:mrow>                           <mml:mo>,</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where &#x00394;<italic>H</italic><sup><italic>r </italic></sup>= <italic>H</italic>(<bold>A</bold><sup>(<italic>rn</italic>)</sup>) - <italic>H</italic>(<bold>A</bold><sup>(<italic>rt</italic>)</sup>). The <italic>&#x003b1;</italic><sub><italic>P </italic></sub>rule is independently applied to all chains in the population.</p><p>This would ensure that each chain evolves independently, but adaptively progresses as a member in the population towards a unified direction.</p></sec><sec><title>Comparison of sampling trajectories</title><p>The trajectories were plotted using the original CRP binding data set. The IMC version run the MHS algorithm 5 times (i.e. <italic>R </italic>= 5), each being independent. The PMC algorithm was run in a population of either 5 or 10 individual chains, and the population evolved together. The sampling trajectories were plotted in Figure <xref ref-type="fig" rid="F1">1A&#x02013;1C</xref>. Five chains were largely differing in the IMC case, that is, some converged quickly whereas others were very slow (Figure <xref ref-type="fig" rid="F1">1A</xref>). Note that these chains started from different initializations and ended up with distinct trajectories or equilibrium points. For the population-based motif algorithm (i.e. the PMC version), all chains (i.e. <italic>R </italic>= 5 or 10) quickly converged to the same global equilibrium level, as displayed in Figure <xref ref-type="fig" rid="F1">1B</xref> and <xref ref-type="fig" rid="F1">1C</xref>. This nicely illustrated that PMC improved the convergence in each chains. Moreover, the PMC alignment with <italic>R </italic>= 5 reached its maximum <italic>H</italic>'s around iteration 24, whereas the PMC alignment with <italic>R </italic>= 10 achieved its maxima around iteration 45. This reveals that a larger population may slow down the convergence possibly due to a bigger variance (<italic>&#x003c3;</italic><sup>2</sup>). Besides, more chains in the population may generate more dominant motif sites that compete for the equilibrium points. As a result, it should spend more time in burn-in phase before reaching a global equilibrium as more chains are added to the population. However, a larger population could explore more space. It is very hard to determine an optimal size, as it may be data-dependent.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Trajectories of MC chains</bold>. The trajectories were plotted using the CRP binding data. Both IMC and PMC run the same MHS algorithm <italic>r </italic>times, but with different strategies as described in the text. (A) IMC with <italic>r </italic>= 5, (B) PMC, <italic>r </italic>= 5, (C) PMC, <italic>r </italic>= 10. Each arrow points to the alignment with the highest likelihood <italic>H</italic><sub><italic>max</italic></sub>.</p></caption><graphic xlink:href="1471-2105-10-S1-S13-1"/></fig><p>On the other hand, the IMC version took the longest to come up with the best alignment at iteration 93 in 3 out of 5 chains. In addition, the IMC chains ended up with different results (Figure <xref ref-type="fig" rid="F1">1A</xref>), because some initial seeds result in good alignments with high energy (<italic>H</italic>), but others in bad alignments with low <italic>H</italic>. This nicely demonstrates that a prerequisite for achieving good alignment solutions would be running multiple times of a MCMC-based sampler, which provides more opportunities of being able to search more space and thus escape from local maxima, as already suggested in the literature [<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B17">17</xref>]. As noted in Figure <xref ref-type="fig" rid="F1">1B&#x02013;1C</xref>, all PMC chains quickly converged to the same equilibrium, which produced a global optimal solution rather than a set of different solutions exhibited in IMC (Figure <xref ref-type="fig" rid="F1">1A</xref>).</p><p>Figure <xref ref-type="fig" rid="F2">2</xref> summarizes the algorithm performance in different length groups of simulated CRP binding data sets. Both IMC and PMC versions successfully detected the planted motifs when <italic>L </italic>&#x02264; 400 bp. PMC performed slightly better than IMC in each case. Overall, both performance dropped off as the background sequence becomes longer. They failed when the sequence length <italic>L </italic>&#x02265; 800 bp. This is because a long random background sequence provides high chance of generating decoy signals that are highly conserved. To systematically test this kind of subtle motif discovery and further show the capability of the PMC motif-finding algorithm, the following section tested the well-formulated subtle motif problem.</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Performance comparison</bold>. The CRP binding motifs were planted in simulated background sequences with different lengths. Both IMC and PMC showed the same trend, that is, their performances go down as the sequence becomes longer.</p></caption><graphic xlink:href="1471-2105-10-S1-S13-2"/></fig></sec><sec><title>Subtle motif discovery</title><p>The planted (<italic>l</italic>, <italic>d</italic>)-motif problem is a typical subtle motif-finding problem first considered by Sagot [<xref ref-type="bibr" rid="B25">25</xref>], and later was rigorously formulated by Pevzner and Sze [<xref ref-type="bibr" rid="B26">26</xref>]. Here the motif width is denoted as <italic>l </italic>instead of <italic>w </italic>in order to be consistent with the original problem definition. Since this problem came to exist, it has been challenging every motif-finding algorithms without exception [<xref ref-type="bibr" rid="B27">27</xref>]. It is commonly thought that position weight matrix (PWM)-based motif algorithms such as the EM motif-finders [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B9">9</xref>] and Gibbs motif samplers [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B14">14</xref>] are unable to solve the problem [<xref ref-type="bibr" rid="B26">26</xref>,<xref ref-type="bibr" rid="B27">27</xref>]. This section revisited the planted motif problem using the IMC and PMC algorithms developed in the paper, and compared with two other algorithms, Weeder [<xref ref-type="bibr" rid="B28">28</xref>] and Projection [<xref ref-type="bibr" rid="B27">27</xref>], which were specifically designed for tackling the planted problem. Table <xref ref-type="table" rid="T1">1</xref> summarized the performance comparison of the five motif discovery algorithms tested in the 10 planted (<italic>l</italic>, <italic>d</italic>)-motif cases. One can divide the 10 cases into two categories: the 5 easy cases, i.e. (11,2), (13,3), (15,4), (17,5) and (19,6), and the 5 tough cases, i.e. (10,2), (12,3), (14,4), (16,5) and (18,6). The easy cases are those planted motifs with slightly high conservation, whereas the tough cases with relatively low conservation. Overall, the PMC algorithm outperformed other algorithms with the grand average <italic>nla </italic>= 0.65. Assuming that a case is successfully detected if more than half planted sites are uncovered (<italic>nla </italic>&#x02265; 0.5). The PMC algorithm successfully detected almost all planted motifs with <italic>nla </italic>ranging from 0.55 to 0.93, and it failed in two very tough cases, (16,5) and (18,6). Among these detected cases, PMC predicted better than others in most cases (see the bolded numbers in Table <xref ref-type="table" rid="T1">1</xref>) except for two cases, that is, Projection had the best <italic>nla </italic>= 0.84 in (17,5) and IMC with the best with <italic>nla </italic>= 0.96 in (11,2). Nonetheless, PMC still performed quite well in the two cases with <italic>nla </italic>= 0.93 in (11,2) and <italic>nla </italic>= 0.76 in (17,5). Projection is the second best predictor with average performance of <italic>nla </italic>= 0.53. Projection effectively located the 4 easy cases, (11,2), (13,3), (17,5) and (19,6) with <italic>nla </italic>= 0.95, 0.85, 0.84, 0.64, respectively. PMC achieved higher precision than Projection in the tough (10,2) case with <italic>nla </italic>= 0.73 vs. 0.53, as well as in the (19,6) case with <italic>nla </italic>= 0.75 vs. 0.64 as manifested in Table <xref ref-type="table" rid="T1">1</xref>. Projection did not succeed in uncovering the remaining 4 tough cases: (12,3), (14,4), (16,5) and (18,6). Notably, previous report on Projection demonstrated its excellent performance in all planted cases [<xref ref-type="bibr" rid="B27">27</xref>], whereas this report showed discrepancies on it using the new unbiased motif data with the carefully chosen background sequences (see Methods). The difference may imply that Projection's performance is likely heavily dependent on the composition of the planted motifs used and their background sequences as well. Notice that although Projection adopted the random projection technique to pre-select a set of initial aligning seeds, it runs the EM algorithm as its final step that still suffers from local optimum. Taken together, results show that Projection did significantly improve the EM algorithm's performance (compare the average <italic>nla</italic>: 0.53 vs. 0.41), nonetheless, it still suffers from local maxima especially in subtle cases. The experiments allowed Projection to know the exact <italic>d</italic>'s in each cases, that is not required in other algorithms (and thus it may be not fair to other algorithms compared).</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Comparison using (<italic>l, d</italic>)-motifs. Note that here EM is DEM [<xref ref-type="bibr" rid="B8">8</xref>]. The number in bold corresponds to the best predictor in that case row.</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center" colspan="5">Algorithms</td></tr><tr><td align="center">(<italic>l</italic>, <italic>d</italic>)</td><td align="center">WEE</td><td align="center">PRO</td><td align="center">EM</td><td align="center">IMC</td><td align="center">PMC</td></tr></thead><tbody><tr><td align="center">10,2</td><td align="center">0.46</td><td align="center">0.53</td><td align="center">0.32</td><td align="center">0.42</td><td align="center"><bold>0.73</bold></td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">11,2</td><td align="center">0.74</td><td align="center">0.95</td><td align="center">0.47</td><td align="center"><bold>0.96</bold></td><td align="center">0.93</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">12,3</td><td align="center">0.27</td><td align="center">0.30</td><td align="center">0.29</td><td align="center">0.22</td><td align="center"><bold>0.59</bold></td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">13,3</td><td align="center">0.44</td><td align="center"><bold>0.85</bold></td><td align="center">0.43</td><td align="center">0.72</td><td align="center"><bold>0.85</bold></td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">14,4</td><td align="center">0.29</td><td align="center">0.25</td><td align="center">0.31</td><td align="center">0.21</td><td align="center"><bold>0.55</bold></td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">15,4</td><td align="center">0.27</td><td align="center">0.67</td><td align="center">0.40</td><td align="center">0.50</td><td align="center"><bold>0.75</bold></td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">16,5</td><td align="center">0.20</td><td align="center">0.16</td><td align="center">0.32</td><td align="center">0.13</td><td align="center">0.28</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">17,5</td><td align="center">0.23</td><td align="center"><bold>0.84</bold></td><td align="center">0.59</td><td align="center">0.39</td><td align="center">0.76</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">18,6</td><td align="center">0.20</td><td align="center">0.12</td><td align="center">0.34</td><td align="center">0.14</td><td align="center">0.32</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">19,6</td><td align="center">0.20</td><td align="center">0.64</td><td align="center">0.58</td><td align="center">0.26</td><td align="center"><bold>0.75</bold></td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">ave</td><td align="center">0.33</td><td align="center">0.53</td><td align="center">0.41</td><td align="center">0.40</td><td align="center"><bold>0.65</bold></td></tr></tbody></table></table-wrap><p>The IMC and EM motif-finders performed nearly equal on average (i.e. 0.40 vs. 0.41). These poor results achieved are in tune with previous reports [<xref ref-type="bibr" rid="B26">26</xref>,<xref ref-type="bibr" rid="B27">27</xref>], that is, the EM and MCMC-based motif algorithms had difficulties in solving the planted motif problem. IMC only correctly predicted three easy cases: (11,2), (13,3) and (15,4) with average <italic>nla </italic>= 0.96, 0.72 and 0.50, respectively, whereas EM barely uncovered two easy cases with long motif widths: (17,5) and (19,6) with <italic>nla </italic>= 0.59 and 0.58, respectively. Notice that the PMC algorithm is significantly better than its independent counterpart IMC in almost all the simulated cases. It is evident that the PMC motif algorithm is superior to IMC, see the 25% increment on average performance (i.e. 0.65 vs. 0.40). However, in finding highly conserved motifs, IMC and PMC may perform approximately the same, as will be shown in the JASPAR benchmarks.</p><p>Weeder only detected the (11,2) case and failed the remaining cases with average performance of <italic>nla </italic>= 0.33. Previous studies showed that Weeder was one of the best motif predictors in mammalian promoter regions [<xref ref-type="bibr" rid="B29">29</xref>], it may imply that a highly heterogeneous word frequency distribution made a major contribution to its success in real biological cases, whereas the word frequencies in the simulated backgrounds were nearly uniformly distributed, that may render the motif-finding much more difficulty to Weeder. In addition, Weeder may be preferred in non-oops motif discovery, because its strategy is that selecting as many significant words as possible and put all of them in the candidate list. In difficult situations, while other algorithms totally fail, Weeder may still have the chance to find some meaningful signals. However, such winning strategy becomes the weakness in <italic>oops </italic>motif discovery, because the more motifs reported, the higher false positives incurred. Currently, there is no way to force Weeder run as an <italic>oops </italic>model.</p></sec><sec><title>Testing JASPAR benchmark</title><p>In order to test the algorithm performance using the JASPAR data sets, one needs to generate simulated promoter sequences since the original JASPAR sequences are too short (about 25 bp on average). The simulated eukaryotic promoter sequences were generated by zero-order Markov model and they were composed of 45% GC content, which conforms to the ENCODE promoter regions [<xref ref-type="bibr" rid="B1">1</xref>]. Each JASPAR binding site was implanted into one simulated promoter sequence of length 500 bp. Note that the longer the sequence, the harder to locate the target as demonstrated in Figure <xref ref-type="fig" rid="F2">2</xref>. The 500-bp long sequence is approximately the same size as in a ChIP-chip data set, and should be a moderate size to challenge each algorithms tested. The Weeder and Projection programs were run the same as in the planted motif cases. For Projection, when <italic>l </italic>= 9 bp, <italic>d </italic>is still set to 2 mismatches, and when <italic>l </italic>= 20 &#x02013; 22 bp, <italic>d </italic>= 7 &#x02013; 8 mismatches as an extension to the original problem. Here the EM motif algorithm used is the popular MEME [<xref ref-type="bibr" rid="B9">9</xref>] run as its defaults.</p><p>Table <xref ref-type="table" rid="T2">2</xref> summarized the results of the five motif-finding algorithms. Compared to the planted motif problem, all algorithms tested using the JASPAR data carried out excellent jobs of finding almost all the experimentally verified motifs, the overall performance ranging from <italic>nla </italic>= 0.58 to 0.84. The PMC algorithm is still the best predictor with the average <italic>nla </italic>= 0.84, and IMC is very close to it with accuracy at <italic>nla </italic>= 0.82. MEME and Projection performed equally well with the average accuracy at <italic>nla </italic>= 0.75. Like in the planted motif cases, Weeder is the poorest predictor with average <italic>nla </italic>= 0.58 in the JASPAR data sets. In fact, Weeder predicted about 67% sites correctly, however, it also predicted more non-sites, and thus its average performance was decreased a bit. Notice that in the <italic>w </italic>= 9 case, both PMC and IMC predicted correctly whereas others failed.</p><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Comparison using JASPAR. Note that here EM is MEME [<xref ref-type="bibr" rid="B9">9</xref>].</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center" colspan="5">Algorithms</td></tr><tr><td align="center"><italic>w</italic></td><td align="center">WEE</td><td align="center">EM</td><td align="center">PRO</td><td align="center">IMC</td><td align="center">PMC</td></tr></thead><tbody><tr><td align="center">9</td><td align="center">0.38</td><td align="center">0.39</td><td align="center">0.43</td><td align="center">0.53</td><td align="center">0.53</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">10</td><td align="center">0.55</td><td align="center">0.65</td><td align="center">0.63</td><td align="center">0.65</td><td align="center">0.77</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">11</td><td align="center">0.48</td><td align="center">0.73</td><td align="center">0.74</td><td align="center">0.80</td><td align="center">0.80</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">12</td><td align="center">0.73</td><td align="center">0.79</td><td align="center">0.84</td><td align="center">0.88</td><td align="center">0.90</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">13</td><td align="center">0.21</td><td align="center">0.75</td><td align="center">0.77</td><td align="center">0.82</td><td align="center">0.85</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">14</td><td align="center">0.65</td><td align="center">0.82</td><td align="center">0.82</td><td align="center">0.91</td><td align="center">0.87</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">15</td><td align="center">0.90</td><td align="center">0.90</td><td align="center">0.90</td><td align="center">0.97</td><td align="center">0.97</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">16</td><td align="center">0.53</td><td align="center">0.79</td><td align="center">0.73</td><td align="center">0.85</td><td align="center">0.95</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">20</td><td align="center">0.82</td><td align="center">0.90</td><td align="center">0.89</td><td align="center">0.94</td><td align="center">0.94</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="center">ave</td><td align="center">0.58</td><td align="center">0.75</td><td align="center">0.75</td><td align="center">0.82</td><td align="center">0.84</td></tr></tbody></table></table-wrap><p>The above experimental results illustrated the ability of the PMC algorithm to predict the binding sites not only in the simulated subtle motif data, but also in the experimentally verified data. PMC did outperform its independent counterpart IMC. In other words, information exchange between multiple Markov chains as implemented in PMC improved the convergence and the motif prediction as well. If a population of MHS motif samplers evolves towards a common target function, it would be expected that the performance might be improved, because pooled information is used to inform each individual proposal distribution. Suppose an individual chain from one sampler starts from a bad point and it definitely results in a poor solution while evolving independently. Now, if the population information is used to define its proposal distribution, that would render the poor chain much better with the benefit of being a member, as illustrated in Figure <xref ref-type="fig" rid="F1">1</xref>.</p></sec></sec><sec><title>Discussion</title><p>This paper presents a novel PMC motif-finding algorithm by evolving a population of Markov chains. The PMC motif algorithm exchanges local alignment information between individual chains by applying a pooled proposal distribution to all chains, and thus each individual chain can adaptively evolve towards a population-level equilibrium or global target function. Experimental studies demonstrate that the new PMC algorithm was able to improve the convergence and evolve better alignment solutions while compared to its multiple independent Markov chains method (IMC) and other algorithms. Further investigation into the population MCMC methods may be as follows: (1) disturbance added to the PMC chains may assist in exploring the alignment space, for example, one can incorporate genetic operators such as crossover and mutation into the PMC procedure; (2) fine-tuning sampling parameters might be informative to boost the accuracy of subtle motif discovery.</p><p>On the other hand, genetic algorithms [<xref ref-type="bibr" rid="B30">30</xref>], a class of adaptive global search methods modeled after biological systems, have been recently tried to overcome the limitations inherent in EM [<xref ref-type="bibr" rid="B31">31</xref>] as well as in MCMC [<xref ref-type="bibr" rid="B32">32</xref>]. It can be expected that computational intelligence techniques, which include genetic algorithms, neural networks and swarm intelligence, are likely to play important roles in sequence motif alignment.</p></sec><sec sec-type="methods"><title>Methods</title><sec><title>Multiple sequence local alignment</title><p>The motif discovery problem is simply defined as: finding some recurrent short sequence patterns or motifs that are likely embedded in a given set of biological related sequences (<bold>S</bold>), for example, upstream promoter regions of co-regulated genes or enriched binding sequences in ChIP-chip experiments among others. Multiple local alignment is the most widely used method to locate over-represented sites in a given sequence set. The aligned over-represented sites are then used to build a frequency matrix that depicts a conserved domain or motif. Let <bold>S </bold>= {<italic>S</italic><sub>1</sub>, ..., <italic>S</italic><sub><italic>i</italic></sub>, ..., <italic>S</italic><sub><italic>N</italic></sub>} denote the sequence data set. Let <italic>L</italic><sub><italic>i </italic></sub>be the length of the sequence <italic>i </italic>(<italic>S</italic><sub><italic>i</italic></sub>) and <italic>S</italic><sub><italic>ij </italic></sub>denote a residue symbol taking on a value in <italic>K</italic>, for instance, <italic>K </italic>= {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>} is an alphabet of DNA sequences. If only one motif per sequence (i.e. <italic>oops </italic>model) is assumed, there are <italic>N </italic>motifs in total for <italic>N </italic>sequences. A zero or one motif per sequence (i.e. <italic>zoops</italic>) model is also frequently used. Nonetheless, both <italic>oops </italic>and <italic>zoops </italic>models assume that sequence data come from a two-component multinomial mixture model: (1) the background model, assuming that residues at non-motif positions follow an independent and identical multinomial distribution (<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-10-S1-S13-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>); and (2) the <italic>w</italic>-mer motif model (or <italic>w</italic>-motif), assuming that residues within the motif are independent but not identical, in other words, residues at different motif positions come from different multinomial distributions (<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1471-2105-10-S1-S13-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>).</p><p>Let <italic>A</italic><sub><italic>i </italic></sub>be an indicator variable drawn from the location space <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17" name="1471-2105-10-S1-S13-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:semantics></mml:math></inline-formula> of sequence <italic>i</italic>, <bold>A </bold>= [<italic>A</italic><sub>1</sub>, ..., <italic>A</italic><sub><italic>i</italic></sub>, ..., <italic>A</italic><sub><italic>N</italic></sub>]<sup><italic>T </italic></sup>be the set of indicator variables representing the motif start sites (i.e. a local alignment) in the sequences, and <italic>w </italic>be the motif width. The total number of local alignments (<italic>V</italic>) can be generally expressed as: <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18" name="1471-2105-10-S1-S13-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x0220f;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>|</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>, and here the number of motif sites on sequence <italic>i </italic>is defined as: |<italic>A</italic><sub><italic>i</italic></sub>| = &#x003a3;<sub><italic>l </italic></sub><italic>A</italic><sub><italic>il</italic></sub>. Therefore, if |<italic>A</italic><sub><italic>i</italic></sub>| = 1 for all <italic>i</italic>, it is an <italic>oops </italic>model, otherwise it is a <italic>zoops </italic>or multiple-site model. The total number of motif sites is |<bold>A</bold>| = &#x003a3;<sub><italic>i </italic></sub>|<italic>A</italic><sub><italic>i</italic></sub>|. Alternatively, an indicator variable <italic>a</italic><sub><italic>i </italic></sub>= <italic>l </italic>is used to represent the motif starting at position <italic>l </italic>on sequence <italic>i</italic>, which is equivalent to <italic>A</italic><sub><italic>il </italic></sub>= 1. Note that <italic>a</italic><sub><italic>i </italic></sub>= 0 means no motifs found on sequence <italic>i</italic>. If multiple sites occur on a sequence, a vector (<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19" name="1471-2105-10-S1-S13-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>) is used to store all the positions. Obviously a motif indicator vector <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20" name="1471-2105-10-S1-S13-i17" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02208;</mml:mo><mml:msub><mml:mi mathvariant="script">P</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> ({1, 2, ..., <italic>L</italic><sub><italic>i </italic></sub>- <italic>w </italic>+ 1}), here <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M21" name="1471-2105-10-S1-S13-i18" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">P</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> is the power set of the <italic>i</italic>-th sequence motif sites. The alignment of motif sites is initialized by randomly generating a set of motif start sites (i.e. <bold>A</bold><sup>(0) </sup>or equivalently <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M22" name="1471-2105-10-S1-S13-i19" overflow="scroll"><mml:semantics><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mi>N</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:semantics></mml:math></inline-formula>) and then it is progressively refined until convergence.</p></sec><sec><title>Evaluating the weight function</title><p>The information weight function defined in equation (1) needs estimation of two parameters: motif (<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M23" name="1471-2105-10-S1-S13-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>) and background (<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M24" name="1471-2105-10-S1-S13-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>). Suppose a counting matrix derived from a DNA motif alignment, {<italic>c</italic><sub><italic>jk</italic></sub>}<sup><italic>w </italic>&#x000d7; 4</sup>, here <italic>c</italic><sub><italic>jk </italic></sub>is the number of the nucleotide <italic>k </italic>counted on position <italic>j </italic>in the motif alignment used, and then the information weight function (<italic>&#x003c4;</italic><sub><italic>jk</italic></sub>), as originally defined by Kullback and Leibler in 1951 [<xref ref-type="bibr" rid="B22">22</xref>], is computed as,</p><p><disp-formula id="bmcM11"><label>(11)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M25" name="1471-2105-10-S1-S13-i20" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>&#x003c4;</mml:mi>                              <mml:mrow>                                 <mml:mi>j</mml:mi>                                 <mml:mi>k</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo>=</mml:mo>                           <mml:mi>log</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi mathvariant="bold">&#x003b8;</mml:mi>                                    <mml:mrow>                                       <mml:mi>j</mml:mi>                                       <mml:mi>k</mml:mi>                                    </mml:mrow>                                 </mml:msub>                              </mml:mrow>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi mathvariant="bold">&#x003b8;</mml:mi>                                    <mml:mrow>                                       <mml:mn>0</mml:mn>                                       <mml:mi>k</mml:mi>                                    </mml:mrow>                                 </mml:msub>                              </mml:mrow>                           </mml:mfrac>                           <mml:mo>=</mml:mo>                           <mml:mi>log</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>c</mml:mi>                                    <mml:mrow>                                       <mml:mi>j</mml:mi>                                       <mml:mi>k</mml:mi>                                    </mml:mrow>                                 </mml:msub>                                 <mml:mo>+</mml:mo>                                 <mml:msub>                                    <mml:mi>&#x003b2;</mml:mi>                                    <mml:mi>k</mml:mi>                                 </mml:msub>                              </mml:mrow>                              <mml:mrow>                                 <mml:mstyle displaystyle="true">                                    <mml:msubsup>                                       <mml:mo>&#x02211;</mml:mo>                                       <mml:mrow>                                          <mml:mi>k</mml:mi>                                          <mml:mo>=</mml:mo>                                          <mml:mn>1</mml:mn>                                       </mml:mrow>                                       <mml:mrow>                                          <mml:mo>|</mml:mo>                                          <mml:mi>K</mml:mi>                                          <mml:mo>|</mml:mo>                                       </mml:mrow>                                    </mml:msubsup>                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>c</mml:mi>                                          <mml:mrow>                                             <mml:mi>j</mml:mi>                                             <mml:mi>k</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo>+</mml:mo>                                       <mml:mo>|</mml:mo>                                       <mml:mover accent="true">                                          <mml:mi>&#x003b2;</mml:mi>                                          <mml:mo>&#x02192;</mml:mo>                                       </mml:mover>                                       <mml:mo>|</mml:mo>                                    </mml:mrow>                                 </mml:mstyle>                              </mml:mrow>                           </mml:mfrac>                           <mml:mo>&#x02212;</mml:mo>                           <mml:mi>log</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:msub>                              <mml:mi mathvariant="bold">&#x003b8;</mml:mi>                              <mml:mrow>                                 <mml:mn>0</mml:mn>                                 <mml:mi>k</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo>,</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where <italic>&#x003c4;</italic><sub><italic>jk </italic></sub>is the information weight of the base <italic>k </italic>on motif position <italic>j</italic>. The pseudo-counts <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M26" name="1471-2105-10-S1-S13-i21" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> are added to avoid zero counting in a motif alignment due to small sample, <italic>&#x003b2;</italic><sub><italic>k </italic></sub>is the pseudo-count of the base <italic>k</italic>, and |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M27" name="1471-2105-10-S1-S13-i21" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>&#x003b2;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>| = &#x003a3;<sub><italic>k </italic></sub><italic>&#x003b2;</italic><sub><italic>k</italic></sub>. It is often set as follows: <italic>&#x003b2;</italic><sub><italic>k </italic></sub>= 1.25/4 for a DNA sequence [<xref ref-type="bibr" rid="B33">33</xref>]. The background distribution <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M28" name="1471-2105-10-S1-S13-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> can be estimated from the sequences or user-specified. Note that the expectation of the information weight defines the relative entropy function [<xref ref-type="bibr" rid="B34">34</xref>] or information content [<xref ref-type="bibr" rid="B24">24</xref>].</p></sec><sec><title>Overall objective function</title><p>Suppose each alignment is thought of as a hidden state in the alignment space, the motif discovery problem can be formulated as finding the optimized alignment state (<italic>v</italic>*) among the entire alignment space. Index a state by <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M29" name="1471-2105-10-S1-S13-i22" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>v</mml:mi><mml:mo>&#x02261;</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>A</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:semantics></mml:math></inline-formula>, and let the potential energy of state <italic>v </italic>be <italic>H</italic><sup>(<italic>v</italic>) </sup>= <italic>H</italic>(<bold>S</bold>, <bold>A</bold>) where <bold>A </bold>is the alignment corresponding to the state <italic>v</italic>. The energy may be related to an alignment score or the motif sequence specificity/binding energy [<xref ref-type="bibr" rid="B23">23</xref>]. Then at equilibrium the probability of state <italic>v</italic>, <italic>p</italic>(<italic>v</italic>), is calculated as,</p><p><disp-formula id="bmcM12"><label>(12)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M30" name="1471-2105-10-S1-S13-i23" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>p</mml:mi>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>v</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mn>1</mml:mn>                              <mml:mrow>                                 <mml:mi>Z</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>&#x003bb;</mml:mi>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mrow>                           </mml:mfrac>                           <mml:mi>exp</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:mo>{</mml:mo>                           <mml:mo>&#x02212;</mml:mo>                           <mml:mi>&#x003bb;</mml:mi>                           <mml:mi>H</mml:mi>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mstyle mathvariant="bold" mathsize="normal">                              <mml:mi>S</mml:mi>                           </mml:mstyle>                           <mml:mo>,</mml:mo>                           <mml:mstyle mathvariant="bold" mathsize="normal">                              <mml:mi>A</mml:mi>                           </mml:mstyle>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>}</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where the normalizing constant is defined as,</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M31" name="1471-2105-10-S1-S13-i24" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>Z</mml:mi>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>&#x003bb;</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:mrow>                                 <mml:msub>                                    <mml:mo>&#x0222b;</mml:mo>                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi mathvariant="script">P</mml:mi>                                          <mml:mn>1</mml:mn>                                       </mml:msub>                                    </mml:mrow>                                 </mml:msub>                                 <mml:mrow>                                    <mml:mo>&#x022ef;</mml:mo>                                    <mml:mstyle displaystyle="true">                                       <mml:mrow>                                          <mml:msub>                                             <mml:mo>&#x0222b;</mml:mo>                                             <mml:mrow>                                                <mml:msub>                                                   <mml:mi mathvariant="script">P</mml:mi>                                                   <mml:mi>N</mml:mi>                                                </mml:msub>                                             </mml:mrow>                                          </mml:msub>                                          <mml:mrow>                                             <mml:msup>                                                <mml:mi>e</mml:mi>                                                <mml:mrow>                                                   <mml:mo>&#x02212;</mml:mo>                                                   <mml:mi>&#x003bb;</mml:mi>                                                   <mml:mi>H</mml:mi>                                                   <mml:mo stretchy="false">(</mml:mo>                                                   <mml:mstyle mathvariant="bold" mathsize="normal">                                                      <mml:mi>S</mml:mi>                                                   </mml:mstyle>                                                   <mml:mo>,</mml:mo>                                                   <mml:mstyle mathvariant="bold" mathsize="normal">                                                      <mml:mi>A</mml:mi>                                                   </mml:mstyle>                                                   <mml:mo stretchy="false">)</mml:mo>                                                </mml:mrow>                                             </mml:msup>                                             <mml:mi>d</mml:mi>                                             <mml:msub>                                                <mml:mover accent="true">                                                   <mml:mi>a</mml:mi>                                                   <mml:mo>&#x02192;</mml:mo>                                                </mml:mover>                                                <mml:mn>1</mml:mn>                                             </mml:msub>                                             <mml:mo>&#x022ef;</mml:mo>                                             <mml:mi>d</mml:mi>                                             <mml:msub>                                                <mml:mover accent="true">                                                   <mml:mi>a</mml:mi>                                                   <mml:mo>&#x02192;</mml:mo>                                                </mml:mover>                                                <mml:mi>N</mml:mi>                                             </mml:msub>                                          </mml:mrow>                                       </mml:mrow>                                    </mml:mstyle>                                    <mml:mo>.</mml:mo>                                 </mml:mrow>                              </mml:mrow>                           </mml:mstyle>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>Therefore, the optimized alignment state (<italic>v</italic>*) is the one with the maximum probability (<italic>p</italic>*). If <italic>v</italic>* is found, then the parameter estimation (&#x00398;*) is done. However, computing the partition function or normalized constant (i.e. <italic>Z</italic>) is commonly intractable, because the alignment problem has proven <italic>NP</italic>-complete [<xref ref-type="bibr" rid="B4">4</xref>]. Markov chain Monte Carlo methods are frequently applied to approximate this kind of hard problem. This paper defined the maximum log-likelihood as the potential energy function, see equation (3).</p></sec><sec><title>Metropolis-Hastings sampler</title><p>Since it is hard to draw a sample directly according to equation (11), the Monte Carlo optimization methods such as the Metropolis-Hastings sampling (MHS) algorithm are often employed to iteratively draw a series of samples according to a proposed probability distribution such as the one in equation (5). Therefore, the sequence local alignment can be formulated as a Markov chain Monte Carlo (MCMC) optimization problem. Note that MCMC is a general framework for approximation methods in search of a large space characterized by complicated or unknown functions.</p><p>In solving the sequence local alignment problem, MHS generates samples (e.g. <bold>A</bold>) from a probability distribution <italic>p</italic>(&#x000b7;), and explores the local alignment space &#x003a9;(<bold>S</bold>) using a Markov chain. MCMC does not sample directly from <italic>p</italic>(&#x000b7;), but only requires that the density <italic>p</italic>(<italic>v</italic>) can be evaluated within a multiplicative constant <italic>p</italic>(<italic>v</italic>) = <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M32" name="1471-2105-10-S1-S13-i25" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>(<italic>v</italic>)/<italic>Z </italic>and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M33" name="1471-2105-10-S1-S13-i25" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>(<italic>v</italic>) is the un-normalized target distribution. In equation (4), <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M34" name="1471-2105-10-S1-S13-i25" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> = exp{-<italic>&#x003bb;H</italic>(&#x000b7;)}. A Markov chain is a discrete-time stochastic process {<bold>A</bold><sup>(0)</sup>, <bold>A</bold><sup>(1)</sup>, &#x022ef;} with property that the state <bold>A</bold><sup>(<italic>t</italic>)</sup>given all previous values {<bold>A</bold><sup>(0)</sup>, <bold>A</bold><sup>(1)</sup>, &#x022ef; <bold>A</bold><sup>(<italic>t</italic>-1)</sup>} only depends on <bold>A</bold><sup>(<italic>t</italic>-1)</sup>: P(<bold>A</bold><sup>(<italic>t</italic>)</sup>|<bold>A</bold><sup>(0)</sup>, <bold>A</bold><sup>(1)</sup>, &#x022ef; <bold>A</bold><sup>(<italic>t</italic>-1)</sup>) = <italic>P</italic>(<bold>A</bold><sup>(<italic>t</italic>)</sup>|<bold>A</bold><sup>(<italic>t</italic>-1)</sup>). We call <italic>P</italic>(&#x000b7;|&#x000b7;) the transition matrix of the Markov chain. <italic>P</italic>(&#x000b7;|&#x000b7;) is stationary, that is to say, independent of time or step (<italic>t</italic>).</p><p>The MHS sampler starts with any alignment <bold>A</bold><sup>(0) </sup>by randomly initializing a seed. Notice there exists a one-to-one map: <bold>A</bold><sup>(<italic>t</italic>) </sup>&#x02192; &#x00398;<sup>(<italic>t</italic>)</sup>. Then the MHS algorithm iterates the following two steps: (1) Propose a random perturbation of the current state (<italic>t</italic>), i.e., <bold>A</bold><sup>(<italic>t</italic>) </sup>&#x02192; <bold>A</bold>', where <bold>A</bold><sup>' </sup>can be viewed as generating from a proposal distribution <italic>P</italic>(<bold>A</bold><sup>(<italic>t</italic>) </sup>&#x02192; <bold>A</bold>') = <italic>P</italic>(<bold>A</bold>'|<bold>A</bold><sup>(<italic>t</italic>)</sup>) by a series of independent random sampling. Then, one can toss a Bernoulli coin with probability of <italic>&#x003b1;</italic><sub><italic>H </italic></sub>coming up heads: if heads show up, accepts the new move: <bold>A</bold><sup>(<italic>t</italic>+1) </sup>= <bold>A</bold>'; otherwise stay as it was: <bold>A</bold><sup>(<italic>t</italic>+1) </sup>= <bold>A</bold><sup>(<italic>t</italic>)</sup>.</p></sec><sec><title>Parallel MHS samplers</title><p>MCMC algorithms are often sequentially applied. A single chain is run for a long time until it converges to a stationary distribution. The states visited during the initial stage (i.e. burn-in phase) are usually thought to be unreliable and thus samples are discarded if reconstructing the density. However, this burn-in time should be short enough (i.e. well-mixing) to ensure the computational efficiency. The burn-in time is indeed depending on the initial points. A helpful strategy to select a good seed is simply running multiple independent MCMC chains, each of which starts with a different seed [<xref ref-type="bibr" rid="B18">18</xref>]. Suppose there are <italic>R </italic>parallel chains each of which is independent, and let the ensemble of alignments be <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M35" name="1471-2105-10-S1-S13-i26" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>v</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> = (<italic>v</italic><sub>1</sub>, &#x022ef;, <italic>v</italic><sub><italic>R</italic></sub>), then the Boltzmann distribution of the ensemble is given rise to,</p><p><disp-formula id="bmcM13"><label>(13)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M36" name="1471-2105-10-S1-S13-i27" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>p</mml:mi>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mover accent="true">                              <mml:mi>v</mml:mi>                              <mml:mo>&#x02192;</mml:mo>                           </mml:mover>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x0220f;</mml:mo>                                 <mml:mrow>                                    <mml:mi>r</mml:mi>                                    <mml:mo>=</mml:mo>                                    <mml:mn>1</mml:mn>                                 </mml:mrow>                                 <mml:mi>R</mml:mi>                              </mml:munderover>                              <mml:mrow>                                 <mml:mi>p</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:msub>                                    <mml:mi>v</mml:mi>                                    <mml:mi>r</mml:mi>                                 </mml:msub>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mo>=</mml:mo>                                 <mml:mfrac>                                    <mml:mn>1</mml:mn>                                    <mml:mrow>                                       <mml:msup>                                          <mml:mi>Z</mml:mi>                                          <mml:mi>R</mml:mi>                                       </mml:msup>                                    </mml:mrow>                                 </mml:mfrac>                                 <mml:mi>exp</mml:mi>                                 <mml:mo>&#x02061;</mml:mo>                                 <mml:mo>{</mml:mo>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:mstyle displaystyle="true">                                    <mml:munderover>                                       <mml:mo>&#x02211;</mml:mo>                                       <mml:mrow>                                          <mml:mi>r</mml:mi>                                          <mml:mo>=</mml:mo>                                          <mml:mn>1</mml:mn>                                       </mml:mrow>                                       <mml:mi>R</mml:mi>                                    </mml:munderover>                                    <mml:mrow>                                       <mml:mi>&#x003bb;</mml:mi>                                       <mml:mi>H</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msub>                                          <mml:mi>v</mml:mi>                                          <mml:mi>r</mml:mi>                                       </mml:msub>                                       <mml:mo stretchy="false">)</mml:mo>                                       <mml:mo>}</mml:mo>                                    </mml:mrow>                                 </mml:mstyle>                              </mml:mrow>                           </mml:mstyle>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>The above function treats the temperature (<italic>T</italic>) as constant and can be easily extended to a temperature variable (<italic>T</italic><sub><italic>r</italic></sub>) attached to a MCMC chain [<xref ref-type="bibr" rid="B20">20</xref>]. Notice that there are no information exchange among these chains. The population-based MCMC (i.e. PMC) simulates samples according to a pooled proposal distribution, that is, <italic>v</italic><sub><italic>r </italic></sub>comes from the <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M37" name="1471-2105-10-S1-S13-i9" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>(<italic>v</italic><sub><italic>r</italic></sub>) defined in equation (7) rather than the <italic>p</italic>(<italic>v</italic><sub><italic>r</italic></sub>) in equation (4) as information exchange occurs among chains.</p></sec><sec><title>Performance evaluation</title><p>The nucleotide-level accuracy (<italic>nla</italic>) metric is defined to evaluate the motif-finding algorithm performance based on the known alignment (<bold>O</bold>) and predicted alignment (<bold>A</bold>). Let <italic>o</italic><sub><italic>i </italic></sub>be the known motif position of sequence <italic>i</italic>, and <italic>a</italic><sub><italic>i </italic></sub>be the predicted motif position on the same sequence. The function <italic>nla </italic>is defined as,</p><p><disp-formula id="bmcM14"><label>(14)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M38" name="1471-2105-10-S1-S13-i28" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>n</mml:mi>                           <mml:mi>l</mml:mi>                           <mml:mi>a</mml:mi>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mstyle mathvariant="bold" mathsize="normal">                              <mml:mi>O</mml:mi>                           </mml:mstyle>                           <mml:mo>,</mml:mo>                           <mml:mstyle mathvariant="bold" mathsize="normal">                              <mml:mi>A</mml:mi>                           </mml:mstyle>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mn>1</mml:mn>                              <mml:mrow>                                 <mml:mo>|</mml:mo>                                 <mml:mstyle mathvariant="bold" mathsize="normal">                                    <mml:mi>A</mml:mi>                                 </mml:mstyle>                                 <mml:mo>|</mml:mo>                              </mml:mrow>                           </mml:mfrac>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>i</mml:mi>                                    <mml:mo>=</mml:mo>                                    <mml:mn>1</mml:mn>                                 </mml:mrow>                                 <mml:mrow>                                    <mml:mo>|</mml:mo>                                    <mml:mstyle mathvariant="bold" mathsize="normal">                                       <mml:mi>A</mml:mi>                                    </mml:mstyle>                                    <mml:mo>|</mml:mo>                                 </mml:mrow>                              </mml:munderover>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mo>|</mml:mo>                                       <mml:msub>                                          <mml:mi>a</mml:mi>                                          <mml:mi>i</mml:mi>                                       </mml:msub>                                       <mml:mo>&#x02229;</mml:mo>                                       <mml:msub>                                          <mml:mi>o</mml:mi>                                          <mml:mi>i</mml:mi>                                       </mml:msub>                                       <mml:mo>|</mml:mo>                                    </mml:mrow>                                    <mml:mi>w</mml:mi>                                 </mml:mfrac>                              </mml:mrow>                           </mml:mstyle>                           <mml:mo>,</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where |<bold>A</bold>| is the number of motif sites, |<italic>a</italic><sub><italic>i </italic></sub>&#x02229; <italic>o</italic><sub><italic>i</italic></sub>| is the size of overlapping block between the predicted and observed motifs from the sequence <italic>i</italic>. The predicted alignment may exactly match the observed (<italic>nla </italic>= 1.0) or have some phase shifts (0.0 &#x0003c;<italic>nla </italic>&#x0003c; 1.0) or completely misaligned (<italic>nla </italic>= 0.0).</p></sec><sec><title>Motif-finders and their parameter settings</title><p>Both IMC and PMC versions run the same MHS motif-finding algorithms, and they were executed in the same parameter settings. The PMC population size was <italic>R </italic>= 20 as the default in all cases if not specified otherwise. The MEME algorithm (version 3.5.4) was also tested in the JASPAR data sets, and its parameters were set as its defaults except that MEME was notified of running the <italic>oops </italic>model, and the exact motif lengths were given as its input like other algorithms tested. The Projection algorithm [<xref ref-type="bibr" rid="B27">27</xref>] was specifically designed to deal with the planted (<italic>l</italic>, <italic>d</italic>)-motif discovery, and it requires the input of the <italic>l </italic>and <italic>d</italic>. The Projection program version 0.42 was tested with the same simulation data. Note that other algorithms tested do not require the <italic>d </italic>input. For example, to run the planted (10,2)-motif case, Projection executes the following command: "<italic>findmotif -l 10 -d 2 -M 20 -s seqfile</italic>". Projection can be downloaded from the website [<xref ref-type="bibr" rid="B35">35</xref>].</p><p>The Weeder algorithm [<xref ref-type="bibr" rid="B28">28</xref>] is one of the best motif predictors in mammalian promoters [<xref ref-type="bibr" rid="B29">29</xref>], however, its performance may be largely dependent on the nucleotide composition of real promoter regions. Several pre-calculated tables of word frequencies for various species (6-mers and 8-mers) come with the Weeder software. To cope with this requirement, new word frequency tables (6-mer and 8-mer words) were generated, for example, in the uniform case, each word was simply given frequency at 1. For other zero-order Markov backgrounds, first compute a w-word with minimum frequency: <italic>f</italic><sub><italic>min </italic></sub>= (<bold>&#x003b8;</bold><sub>0<italic>k</italic>'</sub>)<sup><italic>w</italic></sup>, here <italic>k</italic>' is the nucleotide with the least probability and adjust the value to 1.0, and accordingly other words with the frequency <italic>f</italic><sub><italic>word </italic></sub>are set to &#x0230a;<italic>f</italic><sub><italic>word</italic></sub>/<italic>f</italic><sub><italic>min </italic></sub>+ 0.5&#x0230b; (personal communication with Dr. Giulio Pavesi). The Weeder program version 1.31 was run with all the simulated data like this: "<italic>weederlauncher.out seqfile bk large A</italic>", here <italic>bk </italic>is the generated word frequency table. The Weeder user's manual can be found on the website [<xref ref-type="bibr" rid="B36">36</xref>].</p></sec><sec><title>Experimental data sets tested</title><p>The first example used is the gold standard CRP data set [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>], which consists of 18 experimentally determined binding sequences (<italic>w </italic>= 22 bp) each being embedded within a 105 bp promoter sequence. The motif width is set as 22 base pairs long according to the verified site length. The local alignment is performed on both forward and reverse DNA strands. The motif discovery problem becomes more difficulty as the sequence length gets longer. To test the length (<italic>L</italic>) effect, the 18 verified sites were planted into different data sets, each being different sequence length: i.e. <italic>L </italic>= 100, 200, 400, 800 and 16,000 bp long. The simulated background sequences were generated based on the zero-order Markov model (<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M39" name="1471-2105-10-S1-S13-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> = [0.302, 0.183, 0.209, 0.306]<sup><italic>T</italic></sup>), which was estimated according to the original CRP data set.</p><p>Besides the length effect, other major factors such as the degree of motif conservation also have heavily impact on the performance. The data sets of the planted (<italic>l</italic>, <italic>d</italic>)-motif problem were generated as follows: given a fixed <italic>l</italic>-mer short motif (<italic>l </italic>= 10 to 19 bp), one generates 20 background sequences (<italic>N </italic>= 20) each with 600 bp long (<italic>L </italic>= 600), and each background sequence was randomly embedded with a variant of the consensus. A variant motif is a substring derived from the consensus with exactly <italic>d</italic>-position mutation (<italic>d </italic>= 2 to 6). The background distribution used in simulation is <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M40" name="1471-2105-10-S1-S13-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold">&#x003b8;</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> = [0.3, 0.2, 0.2, 0.3]<sup><italic>T</italic></sup>. Each simulation was repeated 20 times and all simulated data sets were fed to the five algorithms tested. All computing jobs were submitted to the Apple Xserve cluster facility located in Children's Mercy Hospital's main campus. Notice that the same motif sets were also planted in two other backgrounds: [0.25, 0.25, 0.25, 0.25] and [0.2, 0.3, 0.3, 0.2], and similar conclusions could be drawn (data not shown.)</p><p>The JASPAR web server [<xref ref-type="bibr" rid="B37">37</xref>] provides experimentally verified binding sites data sets of eukaryotic transcription factors (TFs). However, the vast majority of these binding data were obtained by the SELEX method [<xref ref-type="bibr" rid="B24">24</xref>] that tested randomly generated double-strand oligonucleotides rather than genomic DNA sequences (personal communication with Dr. Boris Lenhard). Note that these verified motifs are highly conserved, each being short sequence (i.e. 25 bp on average). To challenge the <italic>de novo </italic>motif algorithms, these verified sites were planted into randomly simulated background sequences, each being 500 bp. A subset of the JASPAR binding sites was used to test the algorithms in the paper, that includes those TFs with more than 25 verified binding sequences and the motif width is at least 9 bp (i.e <italic>w </italic>&#x02265; 9), as detailed in Table <xref ref-type="table" rid="T2">2</xref>.</p></sec></sec><sec><title>Competing interests</title><p>The author declares that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>CB performed the work and wrote the manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>The author would like to express his thanks to Dr. Boris Lenhard for discussing on the JASPAR data as well as to Dr. Giulio Pavesi for providing guidance on generating word frequency tables of simulated sequences.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Birney</surname><given-names>E</given-names></name><name><surname>Stamatoyannopoulos</surname><given-names>JA</given-names></name><name><surname>Dutta</surname><given-names>A</given-names></name><name><surname>Guigo</surname><given-names>R</given-names></name><name><surname>Gingeras</surname><given-names>TR</given-names></name><name><surname>Margulies</surname><given-names>EH</given-names></name><name><surname>Weng</surname><given-names>Z</given-names></name><etal></etal></person-group><article-title>Identification and analysis of functional elements in 1% of the human genome by the ENCODE pilot project</article-title><source>Science</source><year>2007</year><volume>447</volume><fpage>799</fpage><lpage>816</lpage></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>MacIsaac</surname><given-names>KD</given-names></name><name><surname>Fraenkel</surname><given-names>E</given-names></name></person-group><article-title>Practical strategies for discovering regulatory DNA sequence motifs</article-title><source>PLoS Computat Biol</source><year>2006</year><volume>2</volume><fpage>e36</fpage><pub-id pub-id-type="doi">10.1371/journal.pcbi.0020026</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ji</surname><given-names>H</given-names></name><name><surname>Wong</surname><given-names>WW</given-names></name></person-group><article-title>Computational biology: Towards deciphering gene regulatory information in mammalian genomes</article-title><source>Biometrics</source><year>2006</year><volume>62</volume><fpage>645</fpage><lpage>663</lpage><pub-id pub-id-type="pmid">16984301</pub-id><pub-id pub-id-type="doi">10.1111/j.1541-0420.2006.00625.x</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>L</given-names></name><name><surname>Jiang</surname><given-names>T</given-names></name></person-group><article-title>On the complexity of multiple sequence alignment</article-title><source>J Comput Biol</source><year>1994</year><volume>1</volume><fpage>337</fpage><lpage>348</lpage><pub-id pub-id-type="pmid">8790475</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lawrence</surname><given-names>CE</given-names></name><name><surname>Reilly</surname><given-names>AA</given-names></name></person-group><article-title>An expectation maximization algorithm for the identification and characterization of common sites in unaligned biopolymer sequences</article-title><source>Proteins: Structure, Function and Genetics</source><year>1990</year><volume>7</volume><fpage>41</fpage><lpage>51</lpage><pub-id pub-id-type="doi">10.1002/prot.340070105</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Dempster</surname><given-names>AP</given-names></name><name><surname>Laird</surname><given-names>AM</given-names></name><name><surname>Rubin</surname><given-names>DB</given-names></name></person-group><article-title>Maximum likelihood from incomplete data via the EM algorithm (with discussion)</article-title><source>J Roy Statist Soc Ser B</source><year>1977</year><volume>39</volume><fpage>1</fpage><lpage>38</lpage></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Meng</surname><given-names>XL</given-names></name><name><surname>Dyk</surname><given-names>D</given-names></name></person-group><article-title>The EM algorithm &#x02013; an old folk-song sung to a fast new tune</article-title><source>J Roy Statist Soc Ser B</source><year>1997</year><volume>59</volume><fpage>511</fpage><lpage>567</lpage><pub-id pub-id-type="doi">10.1111/1467-9868.00082</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bi</surname><given-names>CP</given-names></name></person-group><article-title>SEAM: A stochastic EM-type algorithm for motif-finding in biopolymer sequences</article-title><source>J Bioinform Comput Biol</source><year>2007</year><volume>5</volume><fpage>47</fpage><lpage>77</lpage><pub-id pub-id-type="pmid">17477491</pub-id><pub-id pub-id-type="doi">10.1142/S0219720007002527</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bailey</surname><given-names>T</given-names></name><name><surname>Elkan</surname><given-names>C</given-names></name></person-group><article-title>Unsupervised learning of multiple motifs in biopolymers using expectation maximization</article-title><source>Machine Learning</source><year>1995</year><volume>21</volume><fpage>51</fpage><lpage>80</lpage></citation></ref><ref id="B10"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>JS</given-names></name></person-group><source>Monte Carlo Strategies in Scientific Computing</source><year>2002</year><publisher-name>New York: Springer-Verlag</publisher-name></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Metropolis</surname><given-names>N</given-names></name><name><surname>Rosenbluth</surname><given-names>AW</given-names></name><name><surname>Rosenbluth</surname><given-names>MN</given-names></name><name><surname>Teller</surname><given-names>A</given-names></name><name><surname>Teller</surname><given-names>H</given-names></name></person-group><article-title>Equations of state calculations by fast computing machines</article-title><source>J Chem Phys</source><year>1953</year><volume>21</volume><fpage>1087</fpage><lpage>1091</lpage><pub-id pub-id-type="doi">10.1063/1.1699114</pub-id></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hastings</surname><given-names>WK</given-names></name></person-group><article-title>Monte Carlo sampling methods using Markov chains and their applications</article-title><source>Biometrika</source><year>1970</year><volume>57</volume><fpage>97</fpage><lpage>109</lpage><pub-id pub-id-type="doi">10.1093/biomet/57.1.97</pub-id></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lawrence</surname><given-names>CE</given-names></name><name><surname>Altschul</surname><given-names>SF</given-names></name><name><surname>Boguski</surname><given-names>MS</given-names></name><name><surname>Liu</surname><given-names>JS</given-names></name><name><surname>Neuwald</surname><given-names>AF</given-names></name><name><surname>Wootton</surname><given-names>JC</given-names></name></person-group><article-title>Detecting subtle sequence signals: A Gibbs sampling strategy for multiple alignment</article-title><source>Science</source><year>1993</year><volume>262</volume><fpage>208</fpage><lpage>214</lpage><pub-id pub-id-type="pmid">8211139</pub-id><pub-id pub-id-type="doi">10.1126/science.8211139</pub-id></citation></ref><ref id="B14"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>X</given-names></name><name><surname>Brutlag</surname><given-names>DL</given-names></name><name><surname>Liu</surname><given-names>JS</given-names></name></person-group><article-title>BioProspector: Discovering conserved DNA motifs in upstream regulatory regions of co-expressed genes</article-title><source>Proc Pacific Symposium on Biocomputing (PSB)</source><year>2001</year><fpage>127</fpage><lpage>138</lpage></citation></ref><ref id="B15"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Robert</surname><given-names>CP</given-names></name><name><surname>Casella</surname><given-names>G</given-names></name></person-group><source>Monte Carlo Statistical Methods</source><year>1999</year><publisher-name>New York: Springer</publisher-name></citation></ref><ref id="B16"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>van Dyk</surname><given-names>DA</given-names></name><name><surname>Meng</surname><given-names>XL</given-names></name></person-group><article-title>The art of data augmentation</article-title><source>J Comput Graph Stat</source><year>2001</year><volume>10</volume><fpage>1</fpage><lpage>50</lpage><pub-id pub-id-type="doi">10.1198/10618600152418584</pub-id></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bi</surname><given-names>CP</given-names></name></person-group><article-title>Data augmentation algorithms for detecting conserved domains in protein sequences: A comparative study</article-title><source>J Proteome Res</source><year>2008</year><volume>7</volume><fpage>192</fpage><lpage>201</lpage><pub-id pub-id-type="pmid">18081244</pub-id><pub-id pub-id-type="doi">10.1021/pr070475q</pub-id></citation></ref><ref id="B18"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Gilks</surname><given-names>WR</given-names></name><name><surname>Richardson</surname><given-names>S</given-names></name><name><surname>Spielgelhalter</surname><given-names>DJ</given-names></name></person-group><source>Markov Chain Monte Carlo in Practice</source><year>1996</year><publisher-name>New York: Chapman and Hall</publisher-name></citation></ref><ref id="B19"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Geyer</surname><given-names>CJ</given-names></name></person-group><article-title>Markov chain Monte Carlo maximum likelihood</article-title><source>Computing Science and Statistics: Proc of the 23rd Symposium on the Interface</source><year>1991</year><fpage>156</fpage><lpage>163</lpage></citation></ref><ref id="B20"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Liang</surname><given-names>F</given-names></name><name><surname>Wong</surname><given-names>WH</given-names></name></person-group><article-title>Evolutionary Monte Carlo: Applications to <italic>C</italic><sub><italic>p </italic></sub>model sampling and change point problem</article-title><source>Statistica Sinica</source><year>2000</year><volume>10</volume><fpage>317</fpage><lpage>342</lpage></citation></ref><ref id="B21"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Laskey</surname><given-names>KB</given-names></name><name><surname>Myers</surname><given-names>J</given-names></name></person-group><article-title>Population Markov chain Monte Carlo</article-title><source>Machine Learning</source><year>2003</year><volume>50</volume><fpage>175</fpage><lpage>196</lpage><pub-id pub-id-type="doi">10.1023/A:1020206129842</pub-id></citation></ref><ref id="B22"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kullback</surname><given-names>S</given-names></name><name><surname>Leibler</surname><given-names>RA</given-names></name></person-group><article-title>On information and sufficiency</article-title><source>Ann Math Statist</source><year>1951</year><volume>22</volume><fpage>79</fpage><lpage>86</lpage><pub-id pub-id-type="doi">10.1214/aoms/1177729694</pub-id></citation></ref><ref id="B23"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Berg</surname><given-names>O</given-names></name><name><surname>von Hippel</surname><given-names>PH</given-names></name></person-group><article-title>Selection of DNA binding sites by regulatory proteins: Statistical-mechanical theory and application to operators and promoters</article-title><source>Journal of Molecular Biology</source><year>1987</year><volume>193</volume><fpage>723</fpage><lpage>750</lpage><pub-id pub-id-type="pmid">3612791</pub-id><pub-id pub-id-type="doi">10.1016/0022-2836(87)90354-8</pub-id></citation></ref><ref id="B24"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Stormo</surname><given-names>GD</given-names></name></person-group><article-title>DNA binding sites: representation and discovery</article-title><source>Bioinformatics</source><year>2000</year><volume>16</volume><fpage>16</fpage><lpage>23</lpage><pub-id pub-id-type="pmid">10812473</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/16.1.16</pub-id></citation></ref><ref id="B25"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Sagot</surname><given-names>MF</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Lucchesi C, Moura A</surname></name></person-group><article-title>Spelling approximate repeated or common motifs using a suffix tree</article-title><source>Theoretical informatics, 1380</source><year>1998</year><fpage>111</fpage><lpage>127</lpage></citation></ref><ref id="B26"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pevzner</surname><given-names>P</given-names></name><name><surname>Sze</surname><given-names>SH</given-names></name></person-group><article-title>Combinatorial approaches to finding subtle signals in DNA sequences</article-title><source>Proc First ISMB Conference</source><year>2000</year><volume>1</volume><fpage>269</fpage><lpage>278</lpage></citation></ref><ref id="B27"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Buhler</surname><given-names>J</given-names></name><name><surname>Tompa</surname><given-names>M</given-names></name></person-group><article-title>Finding motifs using random projection</article-title><source>Journal of Computational Biology</source><year>2002</year><volume>9</volume><fpage>225</fpage><lpage>242</lpage><pub-id pub-id-type="pmid">12015879</pub-id><pub-id pub-id-type="doi">10.1089/10665270252935430</pub-id></citation></ref><ref id="B28"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pavesi</surname><given-names>G</given-names></name><name><surname>Mauri</surname><given-names>G</given-names></name><name><surname>Pesole</surname><given-names>G</given-names></name></person-group><article-title>An algorithm for finding signals of unknown length in DNA sequences</article-title><source>Bioinformatics</source><year>2001</year><volume>17</volume><fpage>S207</fpage><lpage>S214</lpage><pub-id pub-id-type="pmid">11473011</pub-id></citation></ref><ref id="B29"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Tompa</surname><given-names>M</given-names></name><name><surname>Li</surname><given-names>N</given-names></name><name><surname>Bailey</surname><given-names>TL</given-names></name><name><surname>Church</surname><given-names>GM</given-names></name><name><surname>De Moor</surname><given-names>B</given-names></name><etal></etal></person-group><article-title>Assessing computational tools for the discovery of transcription factor binding sites</article-title><source>Nat Biotechnol</source><year>2005</year><volume>23</volume><fpage>137</fpage><lpage>144</lpage><pub-id pub-id-type="pmid">15637633</pub-id><pub-id pub-id-type="doi">10.1038/nbt1053</pub-id></citation></ref><ref id="B30"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Holland</surname><given-names>JH</given-names></name></person-group><source>Adaptation in Natural and Artificial Systems</source><year>1975</year><publisher-name>Ann Arbor: Michigan: The University of Michigan Press</publisher-name></citation></ref><ref id="B31"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Bi</surname><given-names>CP</given-names></name></person-group><article-title>A genetic-based EM motif-finding algorithm for biological sequence analysis</article-title><source>Proceeding of IEEE Symposium on Computational Intelligence in Bioinformatics and Computational Biology, IEEE</source><year>2007</year><fpage>275</fpage><lpage>282</lpage></citation></ref><ref id="B32"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Bi</surname><given-names>CP</given-names></name></person-group><article-title>Evolutionary Metropolis sampling in sequence alignment space</article-title><source>Proc 2008 IEEE Congress on Evolutionary Computation (CEC), IEEE</source><year>2008</year><fpage>189</fpage><lpage>194</lpage></citation></ref><ref id="B33"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Frith</surname><given-names>MC</given-names></name><name><surname>Hansen</surname><given-names>U</given-names></name><name><surname>Spouge</surname><given-names>JL</given-names></name><name><surname>Weng</surname><given-names>Z</given-names></name></person-group><article-title>Finding functional sequence elements by multiple local alignment</article-title><source>Nucleic Acids Res</source><year>2004</year><volume>32</volume><fpage>189</fpage><lpage>200</lpage><pub-id pub-id-type="pmid">14704356</pub-id><pub-id pub-id-type="doi">10.1093/nar/gkh169</pub-id></citation></ref><ref id="B34"><citation citation-type="book"><person-group person-group-type="author"><name><surname>MacKay</surname><given-names>DJC</given-names></name></person-group><source>Information Theory, Inference, and Learning Algorithms</source><year>2003</year><publisher-name>New York: Cambridge University Press</publisher-name></citation></ref><ref id="B35"><citation citation-type="other"><article-title>The Projection Software</article-title><ext-link ext-link-type="uri" xlink:href="http://www.cse.wustl.edu/~jbuhler/pgt/"/></citation></ref><ref id="B36"><citation citation-type="other"><article-title>The Weeder Software</article-title><ext-link ext-link-type="uri" xlink:href="http://159.149.109.9/modtools/"/></citation></ref><ref id="B37"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sandelin</surname><given-names>A</given-names></name><name><surname>Alkema</surname><given-names>W</given-names></name><name><surname>Engstrom</surname><given-names>P</given-names></name><name><surname>Wasserman</surname><given-names>WW</given-names></name><name><surname>Lenhard</surname><given-names>B</given-names></name></person-group><article-title>JASPAR: an open-access database for eukaryotic transcription factor binding profiles</article-title><source>Nucleic Acids Res</source><year>2004</year><volume>32</volume><fpage>D91</fpage><lpage>D94</lpage><pub-id pub-id-type="pmid">14681366</pub-id><pub-id pub-id-type="doi">10.1093/nar/gkh012</pub-id></citation></ref></ref-list></back></article>