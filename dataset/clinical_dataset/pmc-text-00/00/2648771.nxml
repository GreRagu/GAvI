<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208148</article-id><article-id pub-id-type="pmc">2648771</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S46</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S46</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Towards comprehensive structural motif mining for better fold annotation in the "twilight zone" of sequence dissimilarity</article-title></title-group><contrib-group><contrib id="A1" contrib-type="author"><name><surname>Jia</surname><given-names>Yi</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>jiayi@ittc.ku.edu</email></contrib><contrib id="A2" corresp="yes" contrib-type="author"><name><surname>Huan</surname><given-names>Jun</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>jhuan@ittc.ku.edu</email></contrib><contrib id="A3" contrib-type="author"><name><surname>Buhr</surname><given-names>Vincent</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>vbuhr@ittc.ku.edu</email></contrib><contrib id="A4" contrib-type="author"><name><surname>Zhang</surname><given-names>Jintao</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>jtzhang@ittc.ku.edu</email></contrib><contrib id="A5" contrib-type="author"><name><surname>Carayannopoulos</surname><given-names>Leonidas N</given-names></name><xref ref-type="aff" rid="I3">3</xref><email>Icarayan@im.wustl.edu</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Electrical Engineering &#x00026; Computer Science, University of Kansas, Lawrence, KS, 66045, USA</aff><aff id="I2"><label>2</label>Department of Molecular Biosciences, The University of Kansas, Lawrence, KS 66046, USA</aff><aff id="I3"><label>3</label>School of Medicine, Washington University in St. Louis, St. Louis, MO 63130, USA</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S46</fpage><lpage>S46</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S46"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Jia et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Jia et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Jia               Yi                              jiayi@ittc.ku.edu            </dc:author><dc:title>            Towards comprehensive structural motif mining for better fold annotation in the "twilight zone" of sequence dissimilarity         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S46-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S46&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>Automatic identification of structure fingerprints from a group of diverse protein structures is challenging, especially for proteins whose divergent amino acid sequences may fall into the "twilight-" or "midnight-" zones where pair-wise sequence identities to known sequences fall below 25% and sequence-based functional annotations often fail.</p></sec><sec><title>Results</title><p>Here we report a novel graph database mining method and demonstrate its application to protein structure pattern identification and structure classification. The biologic motivation of our study is to recognize common structure patterns in "immunoevasins", proteins mediating virus evasion of host immune defense. Our experimental study, using both viral and non-viral proteins, demonstrates the efficiency and efficacy of the proposed method.</p></sec><sec><title>Conclusion</title><p>We present a theoretic framework, offer a practical software implementation for incorporating prior domain knowledge, such as substitution matrices as studied here, and devise an efficient algorithm to identify approximate matched frequent subgraphs. By doing so, we significantly expanded the analytical power of sophisticated data mining algorithms in dealing with large volume of complicated and noisy protein structure data. And without loss of generality, choice of appropriate compatibility matrices allows our method to be easily employed in domains where subgraph labels have some uncertainty.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>Genomics efforts continue to yield a myriad of new protein sequences. Among the most valuable are those expressed by mammalian pathogens, organisms that successfully grow and disseminate despite a hostile host immunologic environment. A subset of pathogen-encoded proteins, "immunoevasins", facilitate this success by mediating cellular adhesion and entry, and by distorting the interactions of host receptors and cell-surface ligands [<xref ref-type="bibr" rid="B1">1</xref>]. Study of immunoevasins gives insight into host-defense mechanisms, insight that can help guide development of therapies and vaccines against refractory organisms [<xref ref-type="bibr" rid="B2">2</xref>].</p><p>Though immunoevasins frequently possess protein-recognition domain (PRD) folds common to mammalian proteins of immunologic importance, their divergent amino acid sequences may fall into the "twilight-" or "midnight-" zones where pair-wise sequence identities to known sequences fall below 25% and purely sequence-based attempts at annotations often fail [<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B4">4</xref>].</p><p>To better annotate these, and any other highly divergent sequences, more generally, some means of explicitly incorporating three-dimensional structural information into the sequence evaluation is required. Inclusion of even rudimentary structural considerations enhances the performance of sequence scoring heuristics such as local alignment tools [<xref ref-type="bibr" rid="B5">5</xref>] and hidden Markov models (HMM) [<xref ref-type="bibr" rid="B6">6</xref>]. Indeed an HMM constrained with crystallographically determined secondary structure data allowed discovery of a previously unsuspected MHC class I-like immunoevasin in the genomes of orthopoxviruses [<xref ref-type="bibr" rid="B7">7</xref>]. A vast literature covers various schemes for structural data incorporation and fold classification. Nevertheless, much progress remains to be made [<xref ref-type="bibr" rid="B8">8</xref>].</p><p>We are pursuing an approach whereby structural patterns common to a protein fold are collected, assessed for their classification value, and mapped onto statistical models of protein sequences (e.g. HMMs, support vector machines (SVMs), and conditional random fields). As a first step, a comprehensive and objective means is required of identifying and assessing the above common structure patterns, or structure fingerprints.</p><p>Automatic identification of structure fingerprints from a group of diverse protein structures is challenging for a number of reasons. First, we have only limited knowledge about the possible location, composition, and geometric shape of these structure patterns. Second, protein structures are large geometric objects that typically contain hundreds of amino acids with thousands of atoms and chemical bonds. Third, due to accumulated mutations in evolution the same structure pattern may appear slightly different in different proteins. If we use terms from computer algorithm design, we say that the problem of automatic structure pattern identification is challenging since (1) the problem has a large combinatory search space (meaning patterns may occur in any part of a protein and in any subset of a group of proteins) and (2) we should use approximate matching rather than exact matching in retrieving such patterns (meaning that we should tolerate certain level of geometric distortion and amino acid mismatch in search for common structure patterns).</p><p>In this paper we demonstrate a novel data mining technique that efficiently extracts and scores structure pattern from diverse proteins. Specifically in our method, we encode a protein structure as a geometric graph where a node represents an amino acid residue and an edge represents a physical or a chemical interaction between a pair of residues. We encode structural motifs as subgraphs of a geometric graph and we identify conserved structure fingerprints by searching for frequently occurring approximately subgraphs in a group of graph represented proteins.</p><p>Our contributions in designing a new graph data mining method are to develop a solid theoretic framework, to offer a practical software implementation for incorporating prior domain knowledge, such as substitution matrices as studied here, and to devise an efficient algorithm to identify approximate matched frequent subgraphs. By doing so, we expanded the analytical power of data mining algorithms in dealing with large volume of complicated and noisy protein structure data. As evaluated in our driving biological application of recognizing common structure patterns in immunoevasins, our proposed method identifies many structure patterns and affords better structure classification accuracy compared to existing graph mining algorithms.</p><p>The rest of the paper is organized in the following way. In the <italic>Related Work </italic>section, we give an overview of related work on subgraph mining and protein structure pattern identification. In the <italic>Methods </italic>section, we introduce the technique about how to translate protein structures into graphs, provide our model for approximate subgraph mining, and present the details of our algorithm. In the <italic>Results </italic>section, we show an empirical study of the proposed algorithm using protein structure data sets. In the <italic>Discussion </italic>section, we discuss the biological significance of the structural motifs mined by our method. Finally in the <italic>Conclusions </italic>section, we conclude with a short discussion of our approach.</p></sec><sec><title>Related work</title><p>There is an extensive body of literature on comparing and classifying proteins using multiple sequence or structure alignment, such as VAST [<xref ref-type="bibr" rid="B9">9</xref>] and DALI [<xref ref-type="bibr" rid="B10">10</xref>]. Here we focus on the recent algorithmic techniques for discovering structure motifs from protein structures. The methods can be classified into the following five types:</p><p>&#x02022; Depth-first search, starting from simple geometric patterns such as triangles, progressively finding larger patterns [<xref ref-type="bibr" rid="B11">11</xref>-<xref ref-type="bibr" rid="B13">13</xref>].</p><p>&#x02022; Geometric hashing, originally developed in computer vision, applied pairwise between protein structures to identify structure motifs [<xref ref-type="bibr" rid="B14">14</xref>-<xref ref-type="bibr" rid="B16">16</xref>].</p><p>&#x02022; String pattern matching methods that encode the local structure and sequence information of a protein as a string, and apply string search algorithms to derive motifs [<xref ref-type="bibr" rid="B17">17</xref>-<xref ref-type="bibr" rid="B19">19</xref>].</p><p>&#x02022; Delaunay Tessellation (DT) [<xref ref-type="bibr" rid="B20">20</xref>-<xref ref-type="bibr" rid="B22">22</xref>] partitioning the structure into an aggregate of non-overlapping, irregular tetrahedra thus identifying all unique nearest neighbor residue quadruplets for any protein [<xref ref-type="bibr" rid="B22">22</xref>].</p><p>&#x02022; Graph matching methods comparing protein structures modeled as graphs and discovering structure motifs by finding recurring subgraphs [<xref ref-type="bibr" rid="B23">23</xref>-<xref ref-type="bibr" rid="B29">29</xref>].</p><p>Graph database mining is an active research field in data mining research. The goal of graph database mining is to locate useful and interpretable patterns in a large volume of graph data. Recent exact matching graph mining algorithms can be roughly divided into three categories. The first category uses the level-wise search strategy, which includes AGM [<xref ref-type="bibr" rid="B30">30</xref>] and FSG [<xref ref-type="bibr" rid="B31">31</xref>]. And the second category takes the depth-first search strategy, which includes gSpan [<xref ref-type="bibr" rid="B32">32</xref>] and FFSM [<xref ref-type="bibr" rid="B33">33</xref>]. The third category works by mining frequent trees, for which SPIN [<xref ref-type="bibr" rid="B34">34</xref>] and GASTON [<xref ref-type="bibr" rid="B35">35</xref>] are the representative. There are many other existing graph mining algorithms, and we refer to [<xref ref-type="bibr" rid="B36">36</xref>] for a recent survey.</p><p>Frequent subgraph mining with approximate matching capability has also been investigated. The current approximate subgraph mining algorithms can be divided into four categories: (1) proximity measures between graphs [<xref ref-type="bibr" rid="B37">37</xref>-<xref ref-type="bibr" rid="B39">39</xref>], (2) given a proximity measurement, compute representative frequent subgraphs [<xref ref-type="bibr" rid="B40">40</xref>], (3) pattern discovery in a single large graph [<xref ref-type="bibr" rid="B41">41</xref>], and (4) pattern discovery from a group of graphs. The last category is what we concentrate on. For algorithms in (4), SUBDUE [<xref ref-type="bibr" rid="B42">42</xref>] does not claim completeness. Monkey [<xref ref-type="bibr" rid="B43">43</xref>] handles only edge missing and edge label mismatch. Partially Labeled Graphs [<xref ref-type="bibr" rid="B44">44</xref>] uses a wild card method to handle node label mismatches. The algorithm may be viewed as a special case of our algorithm.</p><p>Different from the existing work, to our best knowledge, we are the first group that incorporates a probability matrix in a graph mining method. We also developed a general framework to fully utilize a probability matrix for approximate match, which we can apply to a number of different applications. In addition, we have developed two ways to demonstrate the statistical significance of the patterns mined from a graph database. Statistical significance is an important but often overlooked issue in evaluating the quality of identified pattern in frequent pattern mining. Finally we offered a practical implementation and evaluated its performance using the synthetic sets.</p></sec><sec sec-type="methods"><title>Methods</title><p>In this section, we first briefly describe the technique that translates protein structures into graphs. Then we demonstrate our method called <bold>APGM</bold>(<bold>AP</bold>proximate <bold>G</bold>raph <bold>M</bold>ining) with two steps: introducing the theoretic model, and showing our algorithm in detail.</p><sec><title>Almost-Delaunay graph</title><p>Since the protein backbone trace defines the overall protein conformation, we choose the <italic>C</italic><sub><italic>&#x003b1; </italic></sub>atoms as the nodes of protein graphs. Based on this simplified protein model, we compute edges using Almost-Delaunay Tesselation [<xref ref-type="bibr" rid="B45">45</xref>]. The Almost-Delaunay edges are a superset of the Delaunay edges. All nearest neighbor residues connected by Delaunay edges are defined using Delaunay Tessellation [<xref ref-type="bibr" rid="B46">46</xref>]. This tessellation is defined for a finite set of points by an empty sphere property: A pair of points is joined by an edge iff one can find an empty sphere whose boundary contains those two points. The definition of the Delaunay Tessellation depends on the precise coordinate values given to its points, but these coordinate values are not exact in the case of proteins due to measurement imprecision and atomic motions. In order to address this problem, Almost-Delaunay Edges are defined by relaxing the empty sphere property to say that a pair of points <italic>p </italic>and <italic>q </italic>is joined by an Almost-Delaunay edge with parameter <italic>&#x003b5;</italic>, or AD(<italic>&#x003b5;</italic>), if by perturbing all points by at most <italic>&#x003b5;</italic>, <italic>p </italic>and <italic>q </italic>can be made to lie on an empty sphere. In Figure <xref ref-type="fig" rid="F1">1</xref>, we show one segment of the 3D structure and the corresponding AD graph of 1FP5A Immunoglobulin C1-type protein as an example. More detailed information is available in [<xref ref-type="bibr" rid="B45">45</xref>] and [<xref ref-type="bibr" rid="B47">47</xref>].</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>3D structure and corresponding graph of one sample protein</bold>. <bold>Upper: </bold>One segment of the 3D structure of the 1FP5A Immunoglobulin C1-type protein (the paired Fc<italic>&#x003b5; </italic>3 and 4 domains of IgE). <bold>Lower: </bold>The corresponding graph. Vertices are <italic>C</italic><sub><italic>&#x003b1; </italic></sub>atoms. Covalent edges are represented in heavy magenta while non-covalent edges defined by Almost Delaunay Tesselation(<italic>&#x003b5; </italic>= 0.1) appear in thin blue.</p></caption><graphic xlink:href="1471-2105-10-S1-S46-1"/></fig></sec><sec><title>Theoretic framework</title><sec><title>Definition 1</title><p><italic>A </italic><bold><italic>labeled graph </italic></bold><italic>G is a 5-tuple G </italic>= {<italic>V</italic>, <italic>E</italic>, &#x003a3;<sub><italic>V</italic></sub>, &#x003a3;<sub><italic>E</italic></sub>, <italic>&#x003bb;</italic>) <italic>where V is the set of vertices of G and E </italic>&#x02286; <italic>V </italic>&#x000d7; <italic>V is the set of undirected edges of G</italic>. &#x003a3;<sub><italic>V </italic></sub><italic>and </italic>&#x003a3;<sub><italic>E</italic></sub><italic> are (disjoint) sets of labels. And labeling function &#x003bb;</italic>: <italic>V </italic>&#x02192; &#x003a3;<sub><italic>V </italic></sub>&#x0222a; <italic>E </italic>&#x02192; &#x003a3;<sub><italic>E </italic></sub><italic>maps vertices and edges in G to their labels. A </italic><bold><italic>graph database </italic></bold><italic>D is a set of graphs</italic>.</p><p>We also use <italic>V</italic>[<italic>G</italic>] to denote the node set of a graph <italic>G </italic>and <italic>E</italic>[<italic>G</italic>] to denote the edge set of <italic>G</italic>. We also use &#x003a3;<sub><italic>V</italic>[<italic>G</italic>] </sub>to denote the node labels, &#x003a3;<sub><italic>E</italic>[<italic>G</italic>] </sub>to denote edge labels, and <italic>&#x003bb;</italic><sub><italic>G </italic></sub>to denote the labeling function for a graph <italic>G</italic>. Before we introduce approximate matching, we define compatibility matrix, which offers a probability framework for approximate subgraph mining.</p></sec><sec><title>Definition 2</title><p><italic>A </italic><bold><italic>compatibility matrix </italic></bold><italic>M </italic>= (<italic>m</italic><sub><italic>i</italic>,<italic>j</italic></sub>) <italic>is an n </italic>&#x000d7; <italic>n matrix indexed by symbols from a label set </italic>&#x003a3; <italic>(n </italic>= |&#x003a3;|<italic>). An entry m</italic><sub><italic>i</italic>,<italic>j</italic></sub><italic>(</italic>0 &#x02264; <italic>m</italic><sub><italic>i</italic>,<italic>j </italic></sub>&#x02264; 1, &#x003a3;<sub><italic>j</italic></sub><italic>m</italic><sub><italic>i</italic>,<italic>j </italic></sub>= 1<italic>) in M is the probability that the label i is replaced by the label j</italic>.</p><p>A compatibility matrix <italic>M </italic>is <italic>stable </italic>if the diagonal entry is the largest one in the row (i.e. <italic>M</italic><sub><italic>i</italic>,<italic>i </italic></sub>&#x0003e; <italic>M</italic><sub><italic>i</italic>,<italic>j</italic></sub>, for all <italic>j </italic>&#x02260; <italic>i</italic>). A compatibility matrix being stable means that any label <italic>i </italic>is more likely to be replaced by itself rather than by any other symbol. For our biological application, we consider substitution matrices as being, in essence, stable matrices since most or all rows fit the criterion. For example, in the BLOSUM62 substitution matrix, there is only one violation of the criterion &#x02013; the row for methionine(MET). Hence for the rest of the discussion, we will treat substitution matrices as stable compatibility matrices.</p><p><bold>Example 1. </bold><italic>We show a graph database D with three labeled graphs P, Q, R on the left side of </italic>Figure <xref ref-type="fig" rid="F2">2</xref>. <italic>In this database, the node label set is </italic>{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} <italic>and the edge label set is </italic>{<italic>x</italic>, <italic>y</italic>}. <italic>On the right part of </italic>Figure <xref ref-type="fig" rid="F2">2</xref>, <italic>we show a compatibility matrix M, which is a 2D matrix indexed by the set of node labels in D. The probability that the vertex label a is substituted by b is m</italic><sub><italic>a</italic>,<italic>b </italic></sub>= 0.3. <italic>In M, we use probability </italic>0 <italic>to simplify the matrix. In reality these probabilities are never </italic>0.</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Graph database and compatibility matrix</bold>. Example of a graph database <italic>D </italic>and a compatibility matrix <italic>M</italic>.</p></caption><graphic xlink:href="1471-2105-10-S1-S46-2"/></fig></sec><sec><title>Definition 3</title><p><italic>A labeled graph G </italic>= {<italic>V</italic>, <italic>E</italic>, &#x003a3;<sub><italic>V</italic></sub>, &#x003a3;<sub><italic>E</italic></sub>, <italic>&#x003bb;</italic>} <italic>is </italic><bold><italic>approximately subgraph isomorphic </italic></bold><italic>to another graph G' </italic>= {<italic>V'</italic>, <italic>E'</italic>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S46-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003a3;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>V</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S46-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003a3;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, <italic>&#x003bb;'</italic>} <italic>if there exists an injection f </italic>: <italic>V </italic>&#x02192; <italic>V' such that</italic></p><p>&#x02022; &#x0220f;<sub><italic>u</italic>&#x02208;<italic>V</italic></sub><italic>M</italic><sub><italic>&#x003bb;</italic>(<italic>u</italic>),<italic>&#x003bb;'</italic>(<italic>f</italic>(<italic>u</italic>)) </sub>&#x02265; <italic>&#x003c4;</italic>, <italic>and</italic></p><p>&#x02022; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S46-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mo>&#x0220f;</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02208;</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:msup><mml:mi>M</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mrow><mml:mi>&#x003bb;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mi>&#x003bb;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>&#x02265;</mml:mo><mml:msup><mml:mi>&#x003c4;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula></p><p>The injection <italic>f </italic>is an <italic>approximate subgraph isomorphism </italic>between <italic>G </italic>and <italic>G'</italic>. <italic>M </italic>is a compatibility matrix for node label sets &#x003a3;<sub><italic>V </italic></sub>&#x0222a; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S46-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003a3;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>V</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>. <italic>M' </italic>is a compatibility matrix for edge label sets &#x003a3;<sub><italic>E </italic></sub>&#x0222a; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S46-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003a3;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>. In an edge compatibility matrix, we assume &#x003a3;<sub><italic>E </italic></sub>and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S46-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003a3;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> both contain a special label called empty edge. In this way, we handle both topology distortion (missing edges) and edge label mismatches in the same unified way through an edge compatibility matrix. <italic>&#x003c4; </italic>(0 &#x0003c;<italic>&#x003c4; </italic>&#x02264; 1) is the threshold for node mismatch and <italic>&#x003c4;'</italic>(0 &#x0003c;<italic>&#x003c4;' </italic>&#x02264; 1) is the threshold for edge mismatch.</p><p>For simplicity in the following discussion, we assume that we only need to handle node label mismatches (i.e. corresponding edge relations and corresponding edge labels should exactly match each other in matching two graphs). In principle, edge label mismatch (including missing edges) can be handled in a similar way as node label mismatch. Hence our assumption does not reduce the complexity of algorithm design, but the assumption significantly simplifies our demonstration and makes our algorithm easy of access.</p><p>With the assumption, the new definition of approximate subgraph isomorphism is:</p></sec><sec><title>Definition 4</title><p><italic>A graph G is </italic><bold><italic>approximate subgraph isomorphic </italic></bold><italic>to another graph G', denoted by G </italic>&#x02286;<sub><italic>a </italic></sub><italic>G' if there exists a 1-1 injection f V</italic>[<italic>G</italic>] <italic>to V</italic>[<italic>G'</italic>], <italic>such that</italic></p><p>&#x02022; &#x0220f;<sub><italic>u</italic>&#x02208;<italic>V </italic></sub><italic>M</italic><sub><italic>&#x003bb;</italic>(<italic>u</italic>),<italic>&#x003bb;'</italic>(<italic>f</italic>(<italic>u</italic>)) </sub>&#x02265; <italic>&#x003c4;</italic>,</p><p>&#x02022; &#x02200; <italic>u</italic>, <italic>v </italic>&#x02208; <italic>V</italic>, (<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E </italic>&#x021d4; (<italic>f</italic>(<italic>u</italic>), <italic>f</italic>(<italic>v</italic>)) &#x02208; <italic>E', and</italic></p><p>&#x02022; &#x02200; (<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E</italic>, <italic>&#x003bb;</italic>(<italic>u</italic>, <italic>v</italic>) = <italic>&#x003bb;</italic>(<italic>f</italic>(<italic>u</italic>), <italic>f</italic>(<italic>v</italic>))</p><p>Given a node injection <italic>f </italic>from graph <italic>G </italic>to <italic>G'</italic>, the co-domain of <italic>f </italic>is an <italic>embedding </italic>of <italic>G </italic>in <italic>G'</italic>. <italic>M </italic>is a compatibility matrix for node label sets &#x003a3;<sub><italic>V </italic></sub>&#x0222a; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S46-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003a3;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>V</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>. The <italic>approximate subgraph isomorphism score </italic>of <italic>f</italic>, denoted by <italic>S</italic><sub><italic>f</italic></sub>(<italic>G, G'</italic>), is the product of normalized probabilities: <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S46-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>G</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:mo>&#x0220f;</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>&#x003bb;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mi>&#x003bb;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>&#x003bb;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>&#x003bb;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>. For the case of exception in mutation matrix, we use <italic>MAX</italic>(<italic>M</italic><sub><italic>&#x003bb;</italic>(<italic>u</italic>), *</sub>) as the normalizing factor instead of <italic>M</italic><sub><italic>&#x003bb;</italic>(<italic>u</italic>),<italic>&#x003bb;</italic>(<italic>u</italic>)</sub>. For a pair of graphs, there may be many different ways of mapping nodes from one graph to another and hence may have different approximate isomorphism scores. The <italic>approximate matching score </italic>(score for simplicity) between two graphs, denoted by <italic>S</italic>(<italic>G</italic>, <italic>G'</italic>), is the largest approximate subgraph isomorphism score, or</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S46-i5" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mi>S</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>G</mml:mi>                              <mml:mo>,</mml:mo>                              <mml:msup>                                 <mml:mi>G</mml:mi>                                 <mml:mo>&#x02032;</mml:mo>                              </mml:msup>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>=</mml:mo>                              <mml:munder>                                 <mml:mrow>                                    <mml:mi>max</mml:mi>                                    <mml:mo>&#x02061;</mml:mo>                                 </mml:mrow>                                 <mml:mi>f</mml:mi>                              </mml:munder>                              <mml:mo>{</mml:mo>                              <mml:msub>                                 <mml:mi>S</mml:mi>                                 <mml:mi>f</mml:mi>                              </mml:msub>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>G</mml:mi>                              <mml:mo>,</mml:mo>                              <mml:msup>                                 <mml:mi>G</mml:mi>                                 <mml:mo>&#x02032;</mml:mo>                              </mml:msup>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>}</mml:mo>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>Similarly, we define exact subgraph isomorphism below.</p></sec><sec><title>Definition 5</title><p><italic>A graph G is </italic><bold><italic>subgraph isomorphic </italic></bold><italic>to another graph G', denoted by G </italic>&#x02286; <italic>G' if there exists a 1-1 injection f from the node set V of a graph G to V' of a graph G', such that</italic></p><p>&#x02022; &#x02200; <italic>u </italic>&#x02208; <italic>V</italic>, <italic>&#x003bb;</italic>(<italic>u</italic>) = <italic>&#x003bb;'</italic>(<italic>f</italic>(<italic>u</italic>))</p><p>&#x02022; &#x02200; <italic>u</italic>, <italic>v </italic>&#x02208; <italic>V</italic>, (<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E </italic>&#x021d4; (<italic>f</italic>(<italic>u</italic>), <italic>f</italic>(<italic>v</italic>)) &#x02208; <italic>E'</italic>, <italic>and</italic></p><p>&#x02022; &#x02200; (<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E</italic>, <italic>&#x003bb;</italic>(<italic>u</italic>, <italic>v</italic>) = <italic>&#x003bb;</italic>(<italic>f</italic>(<italic>u</italic>), <italic>f</italic>(<italic>v</italic>))</p><p><bold>Example 2. </bold><italic>In </italic>Figure <xref ref-type="fig" rid="F2">2</xref>, <italic>we show a graph database D </italic>= {<italic>P</italic>, <italic>Q</italic>, <italic>R</italic>} <italic>and a compatibility matrix M. We set isomorphism threshold &#x003c4; </italic>= 0.4 <italic>and with this threshold, graph P is approximate subgraph isomorphic to graph Q with the approximate subgraph isomorphic score equaling </italic>0.6. <italic>To see this, there are a total of 6 different ways to map nodes of P to those of Q. The only two that satisfy edge label constraints are f</italic><sub>1 </sub>= <italic>p</italic><sub>1 </sub>&#x02192; <italic>q</italic><sub>1 </sub><italic>p</italic><sub>2 </sub>&#x02192; <italic>q</italic><sub>2 </sub><italic>p</italic><sub>3 </sub>&#x02192; <italic>q</italic><sub>3 </sub><italic>and f</italic><sub>2 </sub>= <italic>p</italic><sub>1 </sub>&#x02192; <italic>q</italic><sub>2 </sub><italic>p</italic><sub>2 </sub>&#x02192; <italic>q</italic><sub>1 </sub><italic>p</italic><sub>3 </sub>&#x02192; <italic>q</italic><sub>3</sub>. <italic>The approximate subgraph isomorphism score of f</italic><sub>1 </sub><italic>equals that of f</italic><sub>2</sub>.</p></sec><sec><title>Definition 6</title><p><italic>Given a graph database D, an isomorphism threshold &#x003c4;, a support threshold &#x003c3; </italic>(0 &#x0003c;<italic>&#x003c3; </italic>&#x02264; 1), <italic>the </italic><bold><italic>support value </italic></bold><italic>of a graph G, denoted by sup</italic><sub><italic>G</italic></sub>, <italic>is the average score of the graph to graphs in the database:</italic></p><p><disp-formula id="bmcM1"><label>(1)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S46-i6" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mi>s</mml:mi>                              <mml:mi>u</mml:mi>                              <mml:mi>p</mml:mi>                              <mml:mi>G</mml:mi>                              <mml:mo>=</mml:mo>                              <mml:mstyle displaystyle="true">                                 <mml:munder>                                    <mml:mo>&#x02211;</mml:mo>                                    <mml:mrow>                                       <mml:msup>                                          <mml:mi>G</mml:mi>                                          <mml:mo>&#x02032;</mml:mo>                                       </mml:msup>                                       <mml:mo>&#x02208;</mml:mo>                                       <mml:mi>D</mml:mi>                                       <mml:mo>,</mml:mo>                                       <mml:mi>G</mml:mi>                                       <mml:msub>                                          <mml:mo>&#x02286;</mml:mo>                                          <mml:mi>a</mml:mi>                                       </mml:msub>                                       <mml:msup>                                          <mml:mi>G</mml:mi>                                          <mml:mo>&#x02032;</mml:mo>                                       </mml:msup>                                    </mml:mrow>                                 </mml:munder>                                 <mml:mrow>                                    <mml:mi>S</mml:mi>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>G</mml:mi>                                    <mml:mo>,</mml:mo>                                    <mml:msup>                                       <mml:mi>G</mml:mi>                                       <mml:mo>&#x02032;</mml:mo>                                    </mml:msup>                                    <mml:mo stretchy="false">)</mml:mo>                                    <mml:mo>/</mml:mo>                                    <mml:mo>|</mml:mo>                                    <mml:mi>D</mml:mi>                                    <mml:mo>|</mml:mo>                                 </mml:mrow>                              </mml:mstyle>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p><italic>G </italic>is a <italic>frequent approximate subgraph </italic>if its support value is at least <italic>&#x003c3;</italic>. With this definition, we only use those graphs that a subgraph <italic>G </italic>is approximate subgraph isomorphic to (controlled by the parameter <italic>&#x003c4;</italic>) to compute the support value of <italic>G</italic>. We do this to filter out low quality (but potentially many) graph matchings in counting the support value of a subgraph. For a moderate sized graph database (100 1000), according our experience, the number of frequent subgraphs identified is usually not sensitive to the isomorphism threshold, which makes sense since low quality graph matching has low "weight" in the support computation nevertheless.</p></sec><sec><title>Problem statement</title><p>Given a graph database <italic>D</italic>, an isomorphism threshold <italic>&#x003c4;</italic>, a compatibility matrix <italic>M</italic>, and a support threshold <italic>&#x003c3;</italic>, the <bold>approximate subgraph mining </bold>problem is to find all the frequent approximate subgraphs in <italic>D</italic>. In Figure <xref ref-type="fig" rid="F3">3</xref>, we show all the frequent approximate subgraphs in the graph database <italic>D </italic>shown in Figure <xref ref-type="fig" rid="F2">2</xref>. By comparison with the frequent subgraphs acquired by the exact graph mining, the approximate mining method identifies meaningful patterns that cannot be identified by exact graph mining methods. Since the support value of approximate subgraph mining and that of frequent subgraph mining have different meaning, it is generally hard to do a comparison of approximate subgraph mining and that of frequent subgraph mining. Fortunately with the assumption of stable compatibility matrix, we can see frequent subgraph mining as a special case of approximate subgraph mining.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>Example of frequent subgraphs and approximate frequent subgraphs</bold>. Given the graph database <italic>D </italic>in <italic>Figure </italic>2 and the support threshold <italic>&#x003c3; </italic>= 2/3,the left side shows the frequent subgraphs mined by the general exact graph mining. Given the compatibility matrix <italic>M </italic>in <italic>Figure </italic>2, isomorphism threshold <italic>&#x003c4; </italic>= 0<italic>:</italic>4, and support threshold <italic>&#x003c3; </italic>= 2/3. The right side presents the frequent approximate subgraphs in <italic>D</italic>.</p></caption><graphic xlink:href="1471-2105-10-S1-S46-3"/></fig><p><bold>Example 3. </bold><italic>Given a graph database D, a compatibility matrix M in </italic>Figure <xref ref-type="fig" rid="F2">2</xref>, <italic>the support threshold &#x003c3; </italic>= 2/3 <italic>and isomorphism threshold &#x003c4; </italic>= 0<italic>:</italic>4, <italic>we show how to calculate the isomorphism score and support value for the approximate frequent patterns in </italic>Figure <xref ref-type="fig" rid="F3">3</xref>.</p><p><disp-formula><italic>S</italic>(<italic>A</italic><sub>1</sub>, <italic>P</italic>) = 1, <italic>S</italic>(<italic>A</italic><sub>1</sub>, <italic>Q</italic>) = 1, <italic>S</italic>(<italic>A</italic><sub>1</sub>, <italic>R</italic>) = 1, <italic>Sup</italic>(<italic>A</italic><sub>1</sub>) = 3/3;</disp-formula></p><p><disp-formula><italic>S</italic>(<italic>A</italic><sub>2</sub>, <italic>P</italic>) = 1, <italic>S</italic>(<italic>A</italic><sub>2</sub>, <italic>Q</italic>) = 1, <italic>S</italic>(<italic>A</italic><sub>2</sub>, <italic>R</italic>) = 1, <italic>Sup</italic>(<italic>A</italic><sub>2</sub>) = 3/3;</disp-formula></p><p><disp-formula><italic>S</italic>(<italic>A</italic><sub>3</sub>, <italic>P</italic>) = 1, <italic>S</italic>(<italic>A</italic><sub>3</sub>, <italic>Q</italic>) = 0.6, <italic>S</italic>(<italic>A</italic><sub>3</sub>, <italic>R</italic>) = 0.4, <italic>Sup</italic>(<italic>A</italic><sub>3</sub>) = 2/3;</disp-formula></p><p><disp-formula><italic>S</italic>(<italic>A</italic><sub>4</sub>, <italic>P</italic>) = 1, <italic>S</italic>(<italic>A</italic><sub>4</sub>, <italic>Q</italic>) = 0.6, <italic>S</italic>(<italic>A</italic><sub>4</sub>, <italic>R</italic>) = 0.4, <italic>Sup</italic>(<italic>A</italic><sub>4</sub>) = 2/3.</disp-formula></p></sec></sec><sec><title>Algorithm design</title><p>Here we demonstrate a new algorithm APGM for approximate subgraph mining. APGM starts with frequent single node subgraphs. At a subsequent step, it adds a node to an existing pattern to create new subgraph patterns and identify their support value. If none of the resulting subgraphs are frequent, APGM backtracks. APGM stops when no more patterns need to be searched. Before we proceed to the algorithmic details, we introduce the following definitions to facilitate the demonstration of the APGM algorithm.</p><sec><title>Definition 7</title><p><italic>Given a graph T, one of the embeddings e </italic>= <italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>,&#x022ef;,<italic>v</italic><sub><italic>k </italic></sub><italic>of T, a node v is a </italic><bold><italic>neighbor </italic></bold><italic>of e if &#x02203;u </italic>&#x02208; <italic>e</italic>, (<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E</italic>[<italic>G</italic>].</p><p>In other words, a neighbor node of a embedding <italic>e </italic>is any node that connects to at least one node in <italic>e</italic>. The <italic>neighbor set </italic>of an embedding <italic>e</italic>, denoted by <italic>N</italic>(<italic>e</italic>), is the set of <italic>e</italic>'s neighbors.</p></sec><sec><title>Definition 8</title><p><italic>Given a graph T, one of the embeddings e </italic>= <italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>,&#x022ef;,<italic>v</italic><sub><italic>k </italic></sub><italic>of T in a graph G, a node v &#x02208; N</italic>(<italic>e</italic>), <italic>and a node label l, the </italic><bold><italic>approximate subgraph</italic></bold>, <italic>denoted by </italic>G|<sub><italic>T</italic>,<italic>e</italic>,<italic>v</italic>,<italic>l</italic></sub>, <italic>is a graph </italic>(<italic>V', E'</italic>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S46-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003a3;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>V</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S46-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003a3;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, <italic>&#x003bb;'</italic>) <italic>such that</italic></p><p>&#x02022; <italic>V' </italic>= {<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>,&#x022ef;,<italic>v</italic><sub><italic>k</italic></sub>} &#x0222a; <italic>v</italic></p><p>&#x02022; <italic>E' </italic>= <italic>V' </italic>&#x000d7; <italic>V' </italic>&#x02229; <italic>E</italic>[<italic>G</italic>]</p><p>&#x02022; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-S1-S46-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003a3;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>V</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> = &#x003a3;<sub><italic>V</italic></sub></p><p>&#x02022; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-10-S1-S46-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003a3;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> = &#x003a3;<sub><italic>E</italic></sub></p><p>&#x02022; &#x02200; <italic>u </italic>&#x02208; <italic>e </italic>: <italic>&#x003bb;'</italic>(<italic>u</italic>) = <italic>&#x003bb;</italic><sub><italic>T</italic></sub>(<italic>u</italic>)</p><p>&#x02022; <italic>&#x003bb;'</italic>(<italic>v</italic>) = <italic>l</italic></p><p>&#x02022; &#x02200; <italic>u</italic>, <italic>v </italic>&#x02208; <italic>e </italic>: <italic>&#x003bb;'</italic>((<italic>u</italic>, <italic>v</italic>)) = <italic>&#x003bb;</italic><sub><italic>G</italic></sub>((<italic>u</italic>, <italic>v</italic>))</p><p><bold>Example 4. </bold><italic>In </italic>Figure <xref ref-type="fig" rid="F4">4</xref>, <italic>we show a pattern T and one of its embeddings e </italic>= (<italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>) <italic>in a graph Q. Node s</italic><sub>3 </sub><italic>is a </italic>neighbor node <italic>of e since it connects to at least one node of e (in fact both). Given a node label l ="a", we obtain an approximate subgraph G' </italic>= <italic>Q</italic>|<sub><italic>T</italic>,<italic>e</italic>,<italic>v</italic>,<italic>l</italic></sub><italic>of Q shown in the same figure. The G' has an embedding e' </italic>= (<italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>, <italic>s</italic><sub>3</sub>) <italic>in Q and the score of the embedding is </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-10-S1-S46-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mfrac><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mfrac><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>0.6</mml:mn></mml:mrow></mml:semantics></mml:math></inline-formula>. <italic>(Recall the score of an embedding is the multiplication of the probability of observed node label replacement, normalized by the probability of node label self-replacement.)</italic></p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>Approximate subgraph</bold>. A pattern <italic>T</italic>, a graph <italic>Q </italic>and approximate subgraph <italic>G' </italic>of <italic>Q</italic>.</p></caption><graphic xlink:href="1471-2105-10-S1-S46-4"/></fig><p>With the two definitions, we present the pseudo code of APGM below. follows.</p><p><bold>Algorithm 1. </bold><italic>APGM_MAIN(D, M, &#x003c4;, &#x003c3;)</italic></p><p>1: Begin</p><p><italic>2: C </italic>&#x02190; {<italic>frequent single node</italic>}</p><p><italic>3: F </italic>&#x02190; <italic>C</italic></p><p><italic>4: <bold>for </bold>each T </italic>&#x02208; <italic>C </italic><bold><italic>do</italic></bold></p><p><italic>5: &#x000a0;&#x000a0;&#x000a0;APGM_SEARCH</italic>(<italic>T</italic>, <italic>&#x003c4;</italic>, <italic>&#x003c3;</italic>, <italic>F</italic>)</p><p><italic>6: </italic><bold>                     <italic>end for</italic>                  </bold></p><p>7: return F</p><p>8: End</p><p><bold>Algorithm 2. </bold><italic>APGM_SEARCH(T, &#x003c4;, &#x003c3;, F)</italic></p><p>1: Begin</p><p><italic>2: C </italic>&#x02190; &#x02205;</p><p><italic>3: <bold>for </bold>each </italic>(<italic>e, v</italic>), <italic>e is an embedding of T in G, v </italic>&#x02208; <italic>N</italic>(<italic>e</italic>) <bold><italic>do</italic></bold></p><p><italic>4: &#x000a0;&#x000a0;&#x000a0;CL </italic>&#x02190; <italic>approximateLabelSet(T, G, e, v)</italic></p><p><italic>5: &#x000a0;&#x000a0;&#x000a0;<bold>for </bold>each l &#x02208; CL </italic><bold>                     <italic>do</italic>                  </bold></p><p><italic>6: &#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;X </italic>&#x02190; <italic>G</italic>|<sub><italic>T</italic>, <italic>e</italic>, <italic>v</italic>, <italic>l</italic></sub></p><p><italic>7: &#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;C </italic>&#x02190; <italic>C </italic>&#x0222a; {<italic>X</italic>}</p><p><italic>8: </italic>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1471-2105-10-S1-S46-i8" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">H</mml:mi></mml:semantics></mml:math></inline-formula>(<italic>X</italic>) = <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17" name="1471-2105-10-S1-S46-i8" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">H</mml:mi></mml:semantics></mml:math></inline-formula>(<italic>X</italic>) &#x0222a; (<italic>e</italic>, <italic>v</italic>)</p><p><italic>9: </italic><bold>&#x000a0;&#x000a0;&#x000a0;<italic>end for</italic></bold></p><p><italic>10: </italic><bold>                     <italic>end for</italic>                  </bold></p><p>11: remove infrequent T from C</p><p><italic>12: F </italic>&#x02190; <italic>F </italic>&#x0222a; <italic>C</italic></p><p><italic>13: <bold>for </bold>each T </italic>&#x02208; <italic>C </italic><bold><italic>do</italic></bold></p><p><italic>14: &#x000a0;&#x000a0;&#x000a0;APGM_SEARCH</italic>(<italic>T</italic>, <italic>&#x003c4;</italic>, <italic>&#x003c3;</italic>, <italic>F</italic>)</p><p><italic>15: </italic><bold>                     <italic>end for</italic>                  </bold></p><p>16: End</p><p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18" name="1471-2105-10-S1-S46-i8" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">H</mml:mi></mml:semantics></mml:math></inline-formula> is a hash function to store candidate subgraphs and their embeddings. The hash key of the function in our implementation is a canonical code of the subgraph <italic>X</italic>, which is a unique string presentation of a graph. We use the Canonical Adjacency matrix (CAM) and the Canonical Adjacency Matrix code, developed in [<xref ref-type="bibr" rid="B48">48</xref>], to compute the canonical code of a graph.</p><p><bold>Algorithm 3. </bold><italic>approximateLabelSet(T, G, e, v)</italic></p><p>1: Begin</p><p><italic>2: R </italic>&#x02190; &#x02205;</p><p><italic>3: l</italic><sub>0 </sub>&#x02190; <italic>&#x003bb;</italic><sub><italic>G</italic></sub>(<italic>v</italic>)</p><p><italic>4: <bold>for </bold>each l </italic>&#x02208; &#x003a3;<sub><italic>V</italic>[<italic>G</italic>] </sub><bold><italic>do</italic></bold></p><p><italic>5: </italic><bold>&#x000a0;&#x000a0;&#x000a0;<italic>if </italic></bold><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19" name="1471-2105-10-S1-S46-i9" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mi>S</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>e</mml:mi>                              <mml:mo>,</mml:mo>                              <mml:mi>T</mml:mi>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>&#x000d7;</mml:mo>                              <mml:mfrac>                                 <mml:mrow>                                    <mml:mi>M</mml:mi>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:msub>                                       <mml:mi>l</mml:mi>                                       <mml:mn>0</mml:mn>                                    </mml:msub>                                    <mml:mo>,</mml:mo>                                    <mml:mi>l</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                                 <mml:mrow>                                    <mml:mi>M</mml:mi>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:msub>                                       <mml:mi>l</mml:mi>                                       <mml:mn>0</mml:mn>                                    </mml:msub>                                    <mml:mo>,</mml:mo>                                    <mml:msub>                                       <mml:mi>l</mml:mi>                                       <mml:mn>0</mml:mn>                                    </mml:msub>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:mfrac>                              <mml:mo>&#x02265;</mml:mo>                              <mml:mi>&#x003c4;</mml:mi>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></inline-formula><bold>                     <italic>then</italic>                  </bold></p><p><italic>6: &#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;R </italic>&#x02190; <italic>R </italic>&#x0222a; <italic>l</italic></p><p><italic>7: </italic><bold>&#x000a0;&#x000a0;&#x000a0;<italic>end if</italic></bold></p><p><italic>8: </italic><bold>                     <italic>end for</italic>                  </bold></p><p>9: return R</p><p>10: End</p><p><bold>Example 5. </bold><italic>Applying APGM to the graph database shown in </italic>Figure <xref ref-type="fig" rid="F2">2</xref><italic>with the support threshold &#x003c3; </italic>= 2/3 <italic>and the isomorphism threshold &#x003c4; </italic>= 0.4, <italic>we identify one frequent single-node pattern a (shown as A</italic><sub>1 </sub><italic>in </italic>Figure <xref ref-type="fig" rid="F3">3</xref><italic>). Adding one node to the pattern A</italic><sub>1</sub>, <italic>there are two candidate single-edge patterns and both of them are frequent. These two are shown as A</italic><sub>2 </sub><italic>and A</italic><sub>3 </sub><italic>in the same figure. From pattern A</italic><sub>2</sub>, <italic>we enumerate one additional pattern A</italic><sub>4</sub>. <italic>We stop here since there is no more candidate patterns to explore</italic>.</p></sec></sec></sec><sec><title>Results</title><sec><title>Experimental setup</title><p>We performed all the experiments on a cluster with 256 Intel Xeon 3.2 Ghz EM64T processors with 4 GB memory each. The approximate graph mining algorithm was implemented in the C++ language and compiled by using the g++ compiler in Linux environment with -O3 optimization.</p><p>We downloaded all protein structures from Protein Data Bank (PDB). We followed [<xref ref-type="bibr" rid="B45">45</xref>] to use the same software as [<xref ref-type="bibr" rid="B47">47</xref>] to calculate Almost-Delaunay(AD) for graph representation of protein geometry. We took BLOSUM62 as the compatibility matrix and back-calculated the conditional probability matrix by following the procedure described in [<xref ref-type="bibr" rid="B49">49</xref>]. We normalized the matrix according to <italic>Definition</italic>4.</p></sec><sec><title>Data set</title><p>We investigated two immunologically relevant protein domain families: the Immunoglobulin V set and the Immunoglobulin C1 set. Immunoglobulin domains are among those used by immunoevasins [<xref ref-type="bibr" rid="B50">50</xref>,<xref ref-type="bibr" rid="B51">51</xref>]. We collected proteins from SCOP release 1.69. For each family we created a culled set of proteins with maximal pairwise sequence identity percentage below some threshold by using PISCES server [<xref ref-type="bibr" rid="B52">52</xref>](Immunoglobulin C1 set below 40%, and Immunoglobulin V set below 30%). The characteristics of the complete domain sequence sets are shown in Table <xref ref-type="table" rid="T1">1</xref>. And the PDB IDs of individual proteins for the two culled sets are shown in Table <xref ref-type="table" rid="T2">2</xref>.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Characteristics of domain sequence sets</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="left">Immunoglobulin C1 Set</td><td align="left">Immunoglobulin V Set</td></tr></thead><tbody><tr><td align="left">Number of Proteins</td><td align="left">1786</td><td align="left">371</td></tr><tr><td colspan="3"><hr></hr></td></tr><tr><td align="left">Average Length</td><td align="left">210</td><td align="left">194</td></tr><tr><td colspan="3"><hr></hr></td></tr><tr><td align="left">Maximum Length</td><td align="left">457</td><td align="left">444</td></tr><tr><td colspan="3"><hr></hr></td></tr><tr><td align="left">Minimum Length</td><td align="left">98</td><td align="left">99</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Immunoevasins protein lists for research</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center">PDB ID of proteins in Immunoglobulin C1 set</td></tr></thead><tbody><tr><td align="left">Proteins for Feature Extraction(10):</td><td align="left">1<italic>fp</italic>5<italic>a </italic>1<italic>onqa </italic>1<italic>ogad </italic>1<italic>pqza </italic>1<italic>t</italic>7<italic>va </italic>1<italic>l</italic>6<italic>xa </italic>1<italic>je</italic>6<italic>a </italic>1<italic>mjul </italic>1<italic>uvqb </italic>1<italic>dn</italic>0<italic>b</italic></td></tr><tr><td colspan="2"><hr></hr></td></tr><tr><td align="left">Proteins for Leave-one-out Testing(11):</td><td align="left">1<italic>nfda </italic>1<italic>uvqa </italic>1<italic>q</italic>0<italic>xl </italic>1<italic>mjuh </italic>1<italic>a</italic>6<italic>za </italic>1<italic>k</italic>5<italic>na </italic>1<italic>hdma </italic>3<italic>frua </italic>1<italic>ogae </italic>1<italic>hdmb </italic>1<italic>k</italic>5<italic>nb</italic></td></tr><tr><td colspan="2"><hr></hr></td></tr><tr><td></td><td align="center">PDB ID of proteins in Immunoglobulin V set</td></tr><tr><td colspan="2"><hr></hr></td></tr><tr><td align="left">Proteins for Feature Extraction(10):</td><td align="left">1<italic>pkoa </italic>1<italic>ogad </italic>1<italic>npua </italic>1<italic>cdca </italic>1<italic>jmaa </italic>1<italic>fo</italic>0<italic>b </italic>1<italic>nkoa </italic>1<italic>mjuh </italic>1<italic>nfdb </italic>1<italic>qfoa</italic></td></tr><tr><td colspan="2"><hr></hr></td></tr><tr><td align="left">Proteins for Leave-one-out Testing(9):</td><td align="left">1<italic>zcza </italic>1<italic>f</italic>97<italic>a </italic>1<italic>eaja </italic>1<italic>mjul </italic>1<italic>cida </italic>1<italic>neua </italic>1<italic>cdya </italic>1<italic>hkfa </italic>1<italic>nezg</italic></td></tr></tbody></table></table-wrap></sec><sec><title>Experimental protocol</title><p>We randomly divided proteins from each family into two groups: 10 proteins to serve as sources for feature extraction, and the remainder(positive sample) for training and testing in "leave-one-out" cross validation. A negative sample set of the the same size as the positive sample set was randomly chosen from PDB. The negative sample was used along with the positive sample in testing. The complete flowchart of our experiment procedure is shown in Figure <xref ref-type="fig" rid="F5">5</xref>. During this experimental research, we mined frequent clique subgraphs [<xref ref-type="bibr" rid="B53">53</xref>] in order to enforce biological constraints on the patterns. We compared APGM with the exact graph mining methods MGM [<xref ref-type="bibr" rid="B53">53</xref>]. We chose MGM as the counterpart for the comparison because it is an available clique pattern mining algorithm. (Any exact match method with clique constraint should provide the same number of patterns from a graph database.)</p><fig position="float" id="F5"><label>Figure 5</label><caption><p>The procedure of experimental research.</p></caption><graphic xlink:href="1471-2105-10-S1-S46-5"/></fig></sec><sec><title>Number of patterns identified</title><p>We identified frequent approximate subgraph patterns from 10 positive proteins in each family. There are two parameters that may have significant influence on the set of mined patterns. The first is the support threshold(<italic>&#x003c3;</italic>) and the second is the isomorphism threshold(<italic>&#x003c4;</italic>). For simplicity, in following experiments in this section we use the new support threshold <italic>&#x003c3;' </italic>= <italic>&#x003c3; </italic>&#x000d7; |<italic>D</italic>|, |<italic>D</italic>| is the size of graph database, and the same change applied in support value. In Figure <xref ref-type="fig" rid="F6">6</xref>, we run APGM with different combinations of <italic>&#x003c4; </italic>and <italic>&#x003c3; </italic>and collect the total number of identified patterns. Our results show that the total number of patterns is not sensitive to the isomorphism threshold, and rather depends on the support threshold heavily. Such fact eases the worry that the parameter <italic>&#x003c4; </italic>may be too strong for deciding the number of patterns.</p><fig position="float" id="F6"><label>Figure 6</label><caption><p><bold>Number of patterns for Immunoglobulin C1 set acquired by APGM</bold>. Example of a graph database <italic>D </italic>and a compatibility matrix <italic>M</italic>.</p></caption><graphic xlink:href="1471-2105-10-S1-S46-6"/></fig><p>For the purpose of comparison, the number of patterns mined by two mining methods are shown in Table <xref ref-type="table" rid="T3">3</xref> and <xref ref-type="table" rid="T4">4</xref>, and the number of patterns acquired by APGM from Immunoglobulin C1 proteins are also shown in Figure <xref ref-type="fig" rid="F6">6</xref>. In our experiment, we treat a pattern set with the number more than 10000 as a meaningless one because our sample space is comparatively small and the isomorphism check is computationally expensive. From Table <xref ref-type="table" rid="T4">4</xref>, we see that exact match fails to provide useful patterns on the Immunoglobulin V proteins, which is the typical data set with very noisy background. In comparison, APGM does find some pattern set with a reasonable size in such situation. (We only use rough parameter combination grids to do the pattern search. If we increase the precision of <italic>&#x003c4; </italic>and <italic>&#x003c3;</italic>, more patterns will be found.) In order to evaluate the quality of these patterns, we use the identified frequent subgraphs in classification tests as discussed below.</p><table-wrap position="float" id="T3"><label>Table 3</label><caption><p>Number of patterns by APGM(<italic>&#x003c4; </italic>= 0.35) and MGM on Immunoglobulin C1</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center" colspan="5">Support Threshold(<italic>&#x003c3;</italic>)</td></tr><tr><td></td><td colspan="5"><hr></hr></td></tr><tr><td></td><td align="left">6</td><td align="left">5.5</td><td align="left">5</td><td align="left">4.5</td><td align="left">4</td></tr></thead><tbody><tr><td align="left"><italic>APGM</italic>(<italic>&#x003c4; </italic>= 0.35)</td><td align="left">17</td><td align="left">24</td><td align="left">141</td><td align="left">202</td><td align="left">841</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="left"><italic>MGM</italic></td><td align="left">16</td><td align="left">16</td><td align="left">126</td><td align="left">126</td><td align="left">660</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T4"><label>Table 4</label><caption><p>Number of patterns by APGM(<italic>&#x003c4; </italic>= 0.75) and MGM on Immunoglobulin V</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center" colspan="5">Support Threshold(<italic>&#x003c3;</italic>)</td></tr><tr><td></td><td colspan="5"><hr></hr></td></tr><tr><td></td><td align="left">6</td><td align="left">5.5</td><td align="left">5</td><td align="left">4.5</td><td align="left">4</td></tr></thead><tbody><tr><td align="left"><italic>APGM</italic>(<italic>&#x003c4; </italic>= 0.75)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">160</td><td align="left">14686</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="left"><italic>MGM</italic></td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">13911</td></tr></tbody></table></table-wrap></sec><sec><title>Classification performance</title><p>In this experimental section, we used <italic>libsvm </italic>SVM package [<xref ref-type="bibr" rid="B54">54</xref>] for protein structure classification. We treat each mined pattern as a feature and a protein is represented as a feature vector <italic>V </italic>= (<italic>v</italic><sub><italic>i</italic></sub>) where <italic>i </italic>&#x02264; <italic>i </italic>&#x02264; <italic>n </italic>and <italic>n </italic>is the total number of identified features. <italic>v</italic><sub><italic>i </italic></sub>is 1, if the related feature occurs in the protein and otherwise <italic>v</italic><sub><italic>i </italic></sub>is 0. We used the linear kernel and default parameters for SVM leave-one-out cross validation. The classification results are summarized in Table <xref ref-type="table" rid="T5">5</xref> and <xref ref-type="table" rid="T6">6</xref>. For some parameter combinations, there are no accuracies &#x02013; an event which happens under two circumstances. First, there are no patterns found. Second, the pattern set is too big to be useful. From the tables we see that the classifications with APGM-based feature highly outperform those based on exact match. For Immunoglobulin C1 set, the classification based on feature identified by MGM only can reach 73%, while APGM is between 69%~91%. For Immunoglobulin V set, since the exact match method cannot mine any meaningful patterns, it fails in classification, while by using APGM, we have the accuracy around 78%. This shows that our APGM has more capability to mine useful structure information from very noisy background than general exact match graph mining algorithms.</p><table-wrap position="float" id="T5"><label>Table 5</label><caption><p>Classification accuracy of APGM (<italic>&#x003c4; </italic>= 0.35) and MGM on Immunoglobulin C1 Set</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center" colspan="5">Support Threshold(<italic>&#x003c3;</italic>)</td></tr><tr><td></td><td colspan="5"><hr></hr></td></tr><tr><td></td><td align="left">6</td><td align="left">5.5</td><td align="left">5</td><td align="left">4.5</td><td align="left">4</td></tr></thead><tbody><tr><td align="left"><italic>APGM</italic></td><td align="left">68.18%</td><td align="left">77.27%</td><td align="left">86.36%</td><td align="left">90.91%</td><td align="left">81.82%</td></tr><tr><td colspan="6"><hr></hr></td></tr><tr><td align="left"><italic>MGM</italic></td><td align="left">72.73%</td><td align="left">72.73%</td><td align="left">72.73%</td><td align="left">72.73%</td><td align="left">72.73%</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T6"><label>Table 6</label><caption><p>Classification accuracy of APGM <italic>&#x003c4; </italic>= 0.75) and MGM on Immunoglobulin V set</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center" colspan="4">Support Threshold (<italic>&#x003c3;</italic>)</td></tr><tr><td></td><td colspan="4"><hr></hr></td></tr><tr><td></td><td align="left">6</td><td align="left">5.5</td><td align="left">5</td><td align="left">4.5</td></tr></thead><tbody><tr><td align="center"><italic>APGM</italic></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">77.78%</td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center"><italic>MGM</italic></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><table-wrap-foot><p>TP, true positive; FP, false positive; TN, true negative; FN, false negative.</p><p>Accuracy = (TN+TP)/(TN+TP+FN+FP).</p><p>- means accuracies are unavailable.</p></table-wrap-foot></table-wrap></sec><sec><title>Statistical significance of patterns</title><p>In order to further demonstrate the quality of the patterns mined by using APGM, we chose the parameter combination with the best accuracy for the Immunoglobulin C1 proteins and the Immunoglobulin V proteins to check the distribution and significance of patterns. Figure <xref ref-type="fig" rid="F7">7</xref> shows the number of the patterns that the 11 Immunoglobulin C1 proteins contain and the significance scores. Figure <xref ref-type="fig" rid="F8">8</xref> shows those for the 9 Immunoglobulin V proteins. Proteins in Figure <xref ref-type="fig" rid="F7">7</xref> and <xref ref-type="fig" rid="F8">8</xref> are numbered according to their appearance order in in Table <xref ref-type="table" rid="T2">2</xref>. For example protein "10" in Figure <xref ref-type="fig" rid="F7">7</xref> is protein 1nfa (chain A). The proteins in Figure <xref ref-type="fig" rid="F7">7</xref> and <xref ref-type="fig" rid="F8">8</xref> are sorted according to the number of patterns contained in the proteins. The significance score <italic>P </italic>is defined as follows.</p><p><disp-formula id="bmcM2"><label>(2)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20" name="1471-2105-10-S1-S46-i10" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mtable>                              <mml:mtr>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:mi>P</mml:mi>                                       <mml:mo>=</mml:mo>                                       <mml:mi>log</mml:mi>                                       <mml:mo>&#x02061;</mml:mo>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:msup>                                                <mml:mi>f</mml:mi>                                                <mml:mo>+</mml:mo>                                             </mml:msup>                                             <mml:mo>/</mml:mo>                                             <mml:msup>                                                <mml:mi>N</mml:mi>                                                <mml:mo>+</mml:mo>                                             </mml:msup>                                          </mml:mrow>                                          <mml:mrow>                                             <mml:msup>                                                <mml:mi>f</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                             </mml:msup>                                             <mml:mo>/</mml:mo>                                             <mml:msup>                                                <mml:mi>N</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                             </mml:msup>                                          </mml:mrow>                                       </mml:mfrac>                                       <mml:mo>,</mml:mo>                                       <mml:mi>i</mml:mi>                                       <mml:mi>f</mml:mi>                                       <mml:mtext>&#x000a0;</mml:mtext>                                       <mml:msup>                                          <mml:mi>f</mml:mi>                                          <mml:mo>&#x02212;</mml:mo>                                       </mml:msup>                                       <mml:mo>&#x02260;</mml:mo>                                       <mml:mn>0</mml:mn>                                    </mml:mrow>                                 </mml:mtd>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:msup>                                          <mml:mi>f</mml:mi>                                          <mml:mo>+</mml:mo>                                       </mml:msup>                                       <mml:mo>&#x02260;</mml:mo>                                       <mml:mn>0</mml:mn>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                           </mml:mtable>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><fig position="float" id="F7"><label>Figure 7</label><caption><p><bold>Distribution and significance of features among Immunoglobulin C1 Proteins. Upper: </bold>Distribution of frequent subgraph features among Immunoglobulin C1 proteins. <bold>Lower: </bold>Significance of frequent subgraph features among Immunoglobulin C1 proteins. Both figures are constructed for the set for classification. There are 202 patterns that are mined with the support threshold <italic>&#x003c3; </italic>= 4.5 and the isomorphism threshold <italic>&#x003c4; </italic>= 0.35.</p></caption><graphic xlink:href="1471-2105-10-S1-S46-7"/></fig><fig position="float" id="F8"><label>Figure 8</label><caption><p><bold>Distribution and significance of features among Immunoglobulin V proteins. Upper: </bold>Distribution of frequent subgraph features among Immunoglobulin V proteins. <bold>Lower: </bold>Significance of frequent subgraph features among Immunoglobulin V proteins. Both figures are constructed for the set for classification. There are 160 patterns that are mined with the support threshold <italic>&#x003c3; </italic>= 4.5 and the isomorphism threshold <italic>&#x003c4; </italic>= 0.75.</p></caption><graphic xlink:href="1471-2105-10-S1-S46-8"/></fig><p>There are three special cases of <italic>P</italic>'s value. If <italic>f</italic><sup>- </sup>= 0 and <italic>f</italic><sup>+ </sup>&#x02260; 0, we set <italic>P </italic>= 10; if <italic>f</italic><sup>- </sup>= 0 and <italic>f</italic><sup>+ </sup>&#x02260; 0, we set <italic>P </italic>= -10; and if <italic>f</italic><sup>- </sup>= 0 and <italic>f</italic><sup>+ </sup>= 0, we set <italic>P </italic>= 0.</p><p>Although the patterns do not distribute uniformly among Immunoglobulin C1 proteins, they cover all the positive proteins. The significance score of these patterns shows strong bias toward the Immunoglobulin C1 proteins, and among 202 only 30 noise features(<italic>P </italic>= -10) exist. For Immunoglobulin V proteins, the features miss two positive proteins, but these features are highly correlated with positive samples with all <italic>P </italic>equalling 10.</p></sec><sec><title>Computational performance</title><p>Since the support value of approximate subgraph mining and that of frequent subgraph mining have different meaning, it is generally hard to compare the computational performance of approximate subgraph mining and that of frequent subgraph mining. If <italic>&#x003c4; </italic>is less than 1, approximate subgraph mining may obtain more patterns than that of general frequent subgraph mining by taking more running time. Because of this reason, we use the <italic>pattern discovery rate </italic>("rate" for simplicity), which is computed as the number of discovered patterns <italic>N </italic>divided by the running time <italic>t</italic>. We use rate rather than running time as the criteria to compare computational efficiencies of different algorithms. We evaluated the computational efficiency of APGM with synthetic data sets.</p><p>We generated the synthetic data set by the same synthetic graph generator as [<xref ref-type="bibr" rid="B56">56</xref>]. The synthetic graph generator takes the following set of parameters: <italic>D </italic>is the total number of graphs; <italic>T </italic>is the average size of graph; <italic>I </italic>is the average size of potentially frequent subgraphs; <italic>L </italic>is the number of potentially frequent subgraphs; <italic>V </italic>is the number of vertex labels; <italic>E </italic>is the number of edge labels. The default parameter values that we use are <italic>D </italic>= 10000, <italic>T </italic>= 30, <italic>I </italic>= 11, <italic>L </italic>= 200, <italic>E </italic>= 20, <italic>V </italic>= 20.</p><p>We compare the performance rate between MGM and APGM using different isomorphism threshold values (and hence introduce different level of approximate matching). We use the support threshold (<italic>&#x003c3;</italic>) defined in <italic>Definition</italic>6 in this experiment. From Figure <xref ref-type="fig" rid="F9">9</xref>, we see that with the change of isomorphism threshold, performance of APGM differs narrowly. Even if APGM takes approximate matching, its performance is very similar with MGM. Indeed, with some values of support threshold, APGM with low isomorphism threshold (<italic>&#x003c4; </italic>= 0.6) even has much higher rates.</p><fig position="float" id="F9"><label>Figure 9</label><caption><p><bold>Computational performance comparison</bold>. We compared the computational performance between APGM and MGM using synthetic data sets. APGM used isomorphism threshold <italic>&#x003c4; </italic>= 1.0, 0.8, 0.7, 0.6. Given the patterns' number <italic>N </italic>and running time <italic>t </italic>(<italic>s</italic>), <italic>rate </italic>= <italic>N/t</italic>.</p></caption><graphic xlink:href="1471-2105-10-S1-S46-9"/></fig></sec></sec><sec><title>Discussion</title><p>Finding features (corresponding to packing motifs) that discriminate one protein family from random selected proteins motivated us to further investigate the possibility of examining these motifs as characteristic signatures of a protein family. We investigated the spatial distribution of the residues covered by our mined structure motifs in individual proteins. We found the residues of structure motifs are highly centralized on a limited number of positions for each protein. We picked up the protein 1mju (chain l) in Immunoglobulin C1 set as one example. 202 patterns, which we obtained, maps to 21 amino acids among the total of 219 residues in 1mju. Through literature search, we found residues identified by APGM are related to the known functional sites in the protein. For example, position 200 and 202 are residues in contact with ligand GOL1406 as studied in [<xref ref-type="bibr" rid="B55">55</xref>]. Both positions are not discovered by the exact pattern mining method. This result suggests that APGM is more sensitive in recognizing functional related residues, as compared to exact pattern mining methods. However, we admit that comprehensive experimental study, involving multiple protein families, is needed before we could draw the conclusion convincingly.</p></sec><sec><title>Conclusion</title><p>In this paper we present a novel data mining algorithm, <bold>APGM</bold>(<bold>AP</bold>proximate <bold>G</bold>raph <bold>M</bold>ining), to perform structure comparison and structure motif identification in diverse proteins. In our method we encode structural motifs as subgraphs of geometric graph of proteins. Instead of using a general graph mining method to extract frequent subgraph motifs, we have developed the approximate graph mining algorithm and taken advantage of known substitution matrices in protein structure motif identification. Compared with general graph mining algorithms, APGM not only offers more qualified patterns that achieve higher classification accuracy, but also shows a reasonable computational performance. By applying this method to other protein families, "structure fingerprints" can be collected and used in domain classification schemes where structural information is desired. Furthermore, without loss of generality, choice of appropriate compatibility matrices allows our method to be employed in any domain where subgraph labels have some uncertainty. For example, networks of personal contacts "mutate" as people die or change employment. Compatibility matrices assigning probabilities of 'label substitution' within families or organizations may allow the essential natures of personal contact subgraphs to be preserved nevertheless.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>YJ developed methods, implemented the software, and drafted the manuscript. VB and JZ were involved in testing the data set. JH was responsible for all aspects of the project, and helped revise the manuscript. LC provided advices on the biological aspect of the work, and helped revise the manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>This work has been partially supported by the Kansas IDeA Network for Biomedical Research Excellence (NIH/NCRR award #P20 RR016475) and a NIH grant #R01 GM868665.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>J</surname><given-names>L</given-names></name><name><surname>HL</surname><given-names>P</given-names></name></person-group><article-title>Antigen presentation and the ubiquitin-proteasome system in host-pathogen interactions</article-title><source>Adv Immunol</source><year>2006</year><volume>92</volume><fpage>225</fpage><lpage>305</lpage><pub-id pub-id-type="pmid">17145306</pub-id></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Judson</surname><given-names>KA</given-names></name><name><surname>Lubinski</surname><given-names>JM</given-names></name><name><surname>Jiang</surname><given-names>M</given-names></name><name><surname>Chang</surname><given-names>Y</given-names></name><name><surname>Eisenberg</surname><given-names>RJ</given-names></name><name><surname>Cohen</surname><given-names>GH</given-names></name><name><surname>Friedman</surname><given-names>HM</given-names></name></person-group><article-title>Blocking Immune Evasion as a Novel Approach for Prevention and Treatment of Herpes Simplex Virus Infection</article-title><source>J Virol</source><year>2003</year><volume>77</volume><fpage>12639</fpage><lpage>12645</lpage><pub-id pub-id-type="pmid">14610186</pub-id></citation></ref><ref id="B3"><citation citation-type="book"><person-group person-group-type="author"><name><surname>RF</surname><given-names>D</given-names></name></person-group><source>Of URFs and ORFs: A Primer on How to Analyze Derived Amino Acid Sequences</source><year>1986</year><volume>92</volume><publisher-name>Mill Valley: University Science Books</publisher-name></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>B</surname><given-names>R</given-names></name></person-group><article-title>Twilight zone of protein sequence alignments</article-title><source>Protein Eng</source><year>1999</year><volume>12</volume><fpage>85</fpage><lpage>94</lpage><pub-id pub-id-type="pmid">10195279</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>JU</surname><given-names>B</given-names></name><name><surname>R</surname><given-names>L</given-names></name><name><surname>D</surname><given-names>E</given-names></name></person-group><article-title>A method to identify protein sequences that fold into a known three-dimensional structure</article-title><source>Science</source><volume>253</volume><fpage>164</fpage><lpage>170</lpage><comment>1991 Jul 12</comment><pub-id pub-id-type="pmid">1853201</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hargbo</surname><given-names>J</given-names></name><name><surname>Elofsson</surname><given-names>A</given-names></name></person-group><article-title>Hidden Markov models that use predicted secondary structures for fold recognition</article-title><source>Proteins</source><year>1999</year><volume>36</volume><fpage>68</fpage><lpage>76</lpage><pub-id pub-id-type="pmid">10373007</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Campbell</surname><given-names>JA</given-names></name><name><surname>Trossman</surname><given-names>DS </given-names></name><name><surname>WM</surname><given-names>WM</given-names></name><name><surname>Carayannopoulos</surname><given-names>LN</given-names></name></person-group><article-title>Zoonotic orthopoxviruses encode a high-affinity antagonist of NKG2D</article-title><source>J Exp Med </source><volume>204</volume><fpage>1311</fpage><lpage>7</lpage><comment></comment><pub-id pub-id-type="pmid">17548517</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kryshtafovych</surname><given-names>A</given-names></name><name><surname>Venclovas</surname><given-names>C</given-names></name><name><surname>Fidelis</surname><given-names>K</given-names></name><name><surname>Moult</surname><given-names>J</given-names></name></person-group><article-title>Progress over the first decade of CASP experiments</article-title><source>Proteins</source><year>2005</year><volume>61</volume><fpage>225</fpage><lpage>236</lpage><pub-id pub-id-type="pmid">16187365</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gibrat</surname><given-names>J</given-names></name><name><surname>Madej</surname><given-names>T</given-names></name><name><surname>Bryant</surname><given-names>S</given-names></name></person-group><article-title>Surprising similarities in structure comparison</article-title><source>Curr Opin Struct Biol</source><year>1996</year><volume>6</volume><fpage>377</fpage><lpage>385</lpage><pub-id pub-id-type="pmid">8804824</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Holm</surname><given-names>L</given-names></name><name><surname>Sander</surname><given-names>C</given-names></name></person-group><article-title>Mapping the protein universe</article-title><source>Science</source><year>1996</year><volume>273</volume><fpage>595</fpage><lpage>602</lpage><pub-id pub-id-type="pmid">8662544</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bradley</surname><given-names>P</given-names></name><name><surname>Kim</surname><given-names>PS</given-names></name><name><surname>Berger</surname><given-names>B</given-names></name></person-group><article-title>TRILOGY: Discovery of sequence-structure patterns across diverse proteins</article-title><source>Proc Natl Acad Sci USA </source><year>2002</year><volume>99</volume><fpage>8500</fpage><lpage>8505</lpage><pub-id pub-id-type="pmid">12084910</pub-id></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Russell</surname><given-names>RB</given-names></name></person-group><article-title>Detection of protein three-dimensional side-chain patterns: new examples of convergent evolution</article-title><source>Journal of Molecular Biology</source><year>1998</year><volume>279</volume><fpage>1211</fpage><lpage>1227</lpage><pub-id pub-id-type="pmid">9642096</pub-id></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Stark</surname><given-names>A</given-names></name><name><surname>Russell</surname><given-names>R</given-names></name></person-group><article-title>Annotation in three dimensions. PINTS: Patterns in Non-homologous Tertiary Structures</article-title><source>Nucleic Acids Res</source><year>2003</year><volume>31</volume><fpage>3341</fpage><lpage>4</lpage><pub-id pub-id-type="pmid">12824322</pub-id></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Barker</surname><given-names>J</given-names></name><name><surname>Thornton</surname><given-names>J</given-names></name></person-group><article-title>An algorithm for constraint-based structural template matching: application to 3D templates with statistical analysis</article-title><source>Bioinformatics</source><year>2003</year><volume>19</volume><fpage>1644</fpage><lpage>9</lpage><pub-id pub-id-type="pmid">12967960</pub-id></citation></ref><ref id="B15"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Nussinov</surname><given-names>R</given-names></name><name><surname>Wolfson</surname><given-names>HJ</given-names></name></person-group><article-title>efficient detection of three-dimensional structural motifs in biological macromolecules by computer vision techniques</article-title><source>PNAS</source><year>1991</year><volume>88</volume><fpage>10495</fpage><lpage>99</lpage><pub-id pub-id-type="pmid">1961713</pub-id></citation></ref><ref id="B16"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Wallace</surname><given-names>A</given-names></name><name><surname>Borkakoti</surname><given-names>N</given-names></name><name><surname>Thornton</surname><given-names>J</given-names></name></person-group><article-title>TESS: a geometric hashing algorithm for deriving 3D coordinate templates for searching structural databases. Application to enzyme active sites</article-title><source>Protein Sci</source><year>1997</year><volume>6</volume><fpage>2308</fpage><lpage>23</lpage><pub-id pub-id-type="pmid">9385633</pub-id></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jonassen</surname><given-names>I</given-names></name><name><surname>Eidhammer</surname><given-names>I</given-names></name><name><surname>Conklin</surname><given-names>D</given-names></name><name><surname>Taylor</surname><given-names>WR</given-names></name></person-group><article-title>Structure motif discovery and mining the PDB</article-title><source>Bioinformatics</source><year>2002</year><volume>18</volume><fpage>362</fpage><lpage>367</lpage><pub-id pub-id-type="pmid">11847094</pub-id></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jonassen</surname><given-names>I</given-names></name><name><surname>Eidhammer</surname><given-names>I</given-names></name><name><surname>Taylor</surname><given-names>WR</given-names></name></person-group><article-title>Discovery of local packing motifs in protein structures</article-title><source>Proteins</source><year>1999</year><volume>34</volume><fpage>206</fpage><lpage>219</lpage><pub-id pub-id-type="pmid">10022356</pub-id></citation></ref><ref id="B19"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Taylor</surname><given-names>WR</given-names></name><name><surname>Jonassen</surname><given-names>I</given-names></name></person-group><article-title>A Method for Evaluating Structural Models using Structural Patterns</article-title><source>Proteins</source><year>2004</year></citation></ref><ref id="B20"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Cammer</surname><given-names>S</given-names></name><name><surname>Carter</surname><given-names>C</given-names></name><name><surname>Tropsha</surname><given-names>A</given-names></name></person-group><article-title>Identification of sequence-specific tertiary packing motifs in protein structures using Delaunay tessellation</article-title><source>Lecture notes in Computational Science and Engineering</source><year>2002</year><volume>24</volume><fpage>477</fpage><lpage>494</lpage></citation></ref><ref id="B21"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Krishnamoorthy</surname><given-names>B</given-names></name><name><surname>Tropsha</surname><given-names>A</given-names></name></person-group><article-title>Development of a four-body statistical pseudo-potential to discriminate native from non-native protein conformations</article-title><source>Bioinformatics</source><year>2003</year><volume>19</volume><fpage>1540</fpage><lpage>48</lpage><pub-id pub-id-type="pmid">12912835</pub-id></citation></ref><ref id="B22"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Tropsha</surname><given-names>A</given-names></name><name><surname>Carter</surname><given-names>C</given-names></name><name><surname>Cammer</surname><given-names>S</given-names></name><name><surname>Vaisman</surname><given-names>I</given-names></name></person-group><article-title>Simplicial neighborhood analysis of protein packing (SNAPP) : a computational geometry approach to studying proteins</article-title><source>Methods Enzymol</source><year>2003</year><volume>374</volume><fpage>509</fpage><lpage>544</lpage><pub-id pub-id-type="pmid">14696387</pub-id></citation></ref><ref id="B23"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Artymiuk</surname><given-names>PJ</given-names></name><name><surname>Poirrette</surname><given-names>AR</given-names></name><name><surname>Grindley</surname><given-names>HM</given-names></name><name><surname>Rice</surname><given-names>DW</given-names></name><name><surname>Willett</surname><given-names>P</given-names></name></person-group><article-title>A Graph-theoretic Approach to the Identification of Three-dimensional Patterns of Amino Acid Side-chains in Protein Structures</article-title><source>Journal of Molecular Biology</source><volume>243</volume><fpage>327</fpage><lpage>44</lpage><pub-id pub-id-type="pmid">7932758</pub-id></citation></ref><ref id="B24"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Grindley</surname><given-names>H</given-names></name><name><surname>Artymiuk</surname><given-names>P</given-names></name><name><surname>Rice</surname><given-names>D</given-names></name><name><surname>Willet</surname><given-names>P</given-names></name></person-group><article-title>Identification of tertiary structure resemblance in proteins using a maximal common subgraph isomorphism algorithm</article-title><source>J Mol biol</source><year>1993</year><volume>229</volume><fpage>707</fpage><lpage>721</lpage><pub-id pub-id-type="pmid">8381875</pub-id></citation></ref><ref id="B25"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Huan</surname><given-names>J</given-names></name><name><surname>Wang</surname><given-names>W</given-names></name><name><surname>Bandyopadhyay</surname><given-names>D</given-names></name><name><surname>Snoeyink</surname><given-names>J</given-names></name><name><surname>Prins</surname><given-names>J</given-names></name><name><surname>Tropsha</surname><given-names>A</given-names></name></person-group><article-title>Mining Protein Family Specific Residue Packing Patterns &#x0003e;From Protein Structure Graphs</article-title><source>Proceedings of the 8th Annual International Conference on Research in Computational Molecular Biology (RECOMB)</source><year>2004</year><fpage>308</fpage><lpage>315</lpage></citation></ref><ref id="B26"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Milik</surname><given-names>M</given-names></name><name><surname>Szalma</surname><given-names>S</given-names></name><name><surname>Olszewski</surname><given-names>K</given-names></name></person-group><article-title>Common Structural Cliques: a tool for protein structure and function analysis</article-title><source>Protein Eng</source><year>2003</year><volume>16</volume><fpage>543</fpage><lpage>52</lpage><pub-id pub-id-type="pmid">12968072</pub-id></citation></ref><ref id="B27"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Spriggs</surname><given-names>RV</given-names></name><name><surname>Artymiuk</surname><given-names>PJ</given-names></name><name><surname>Willett</surname><given-names>P</given-names></name></person-group><article-title>Searching for patterns of amino acids in 3D protein structures</article-title><source>J Chem Inf Comput Sci</source><year>2003</year><volume>43</volume><fpage>412</fpage><lpage>421</lpage><pub-id pub-id-type="pmid">12653503</pub-id></citation></ref><ref id="B28"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Stark</surname><given-names>A</given-names></name><name><surname>Shkumatov</surname><given-names>A</given-names></name><name><surname>Russell</surname><given-names>RB</given-names></name></person-group><article-title>Finding functional sites in structural genomics proteins</article-title><source>Structure (Camb)</source><year>2004</year><volume>12</volume><fpage>1405</fpage><lpage>1412</lpage><pub-id pub-id-type="pmid">15296734</pub-id></citation></ref><ref id="B29"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Wangikar</surname><given-names>P</given-names></name><name><surname>Tendulkar</surname><given-names>A</given-names></name><name><surname>Ramya</surname><given-names>S</given-names></name><name><surname>Mali</surname><given-names>D</given-names></name><name><surname>Sarawagi</surname><given-names>S</given-names></name></person-group><article-title>Functional sites in protein families uncovered via an objective and automated graph theoretic approach</article-title><source>J Mol Biol</source><year>2003</year><volume>326</volume><fpage>955</fpage><lpage>978</lpage><pub-id pub-id-type="pmid">12581652</pub-id></citation></ref><ref id="B30"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Inokuchi</surname><given-names>A</given-names></name><name><surname>Washio</surname><given-names>T</given-names></name><name><surname>Motoda</surname><given-names>H</given-names></name></person-group><article-title>An apriori-based algorithm for mining frequent substructures from graph data</article-title><source>PKDD'00</source><year>2000</year><fpage>13</fpage><lpage>23</lpage></citation></ref><ref id="B31"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Kuramochi</surname><given-names>M</given-names></name><name><surname>Karypis</surname><given-names>G</given-names></name></person-group><article-title>Frequent Subgraph Discovery</article-title><source>Proc International Conference on Data Mining'01</source><year>2001</year><fpage>313</fpage><lpage>320</lpage></citation></ref><ref id="B32"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Yan</surname><given-names>X</given-names></name><name><surname>Han</surname><given-names>J</given-names></name></person-group><article-title>gSpan: Graph-Based Substructure Pattern Mining</article-title><source>Proc International Conference on Data Mining'02</source><year>2002</year><fpage>721</fpage><lpage>724</lpage></citation></ref><ref id="B33"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Huan</surname><given-names>J</given-names></name><name><surname>Wang</surname><given-names>W</given-names></name><name><surname>Prins</surname><given-names>J</given-names></name></person-group><article-title>Efficient mining of frequent subgraphs in the presence of isomorphism</article-title><source>Proc of ICDM</source><year>2003</year></citation></ref><ref id="B34"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Huan</surname><given-names>J</given-names></name><name><surname>Prins</surname><given-names>WWJ</given-names></name><name><surname>Yang</surname><given-names>J</given-names></name></person-group><article-title>SPIN: Mining Maximal Frequent Subgraphs from Graph Databases</article-title><source>Proceedings of the 10th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source><year>2004</year><fpage>581</fpage><lpage>586</lpage></citation></ref><ref id="B35"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Nijssen</surname><given-names>S</given-names></name><name><surname>Kok</surname><given-names>J</given-names></name></person-group><article-title>A quickstart in frequent structure mining can make a difference</article-title><source>Proceedings of the 10th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source><year>2004</year><fpage>647</fpage><lpage>652</lpage></citation></ref><ref id="B36"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Han</surname><given-names>J</given-names></name><name><surname>Cheng</surname><given-names>H</given-names></name><name><surname>Xin</surname><given-names>D</given-names></name><name><surname>Yan</surname><given-names>X</given-names></name></person-group><article-title>Frequent Pattern Mining: Current Status and Future Directions</article-title><source>Data Mining and Knowledge Discovery</source><year>2007</year><volume>14</volume></citation></ref><ref id="B37"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Koren</surname><given-names>Y</given-names></name><name><surname>North</surname><given-names>SC</given-names></name><name><surname>Volinsky</surname><given-names>C</given-names></name></person-group><article-title>Measuring and extracting proximity in networks</article-title><source>KDD</source><year>2006</year><fpage>245</fpage><lpage>255</lpage></citation></ref><ref id="B38"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Tong</surname><given-names>H</given-names></name><name><surname>Koren</surname><given-names>Y</given-names></name><name><surname>Faloutsos</surname><given-names>C</given-names></name></person-group><article-title>Fast Direction-Aware Proximity for Graph Mining</article-title></citation></ref><ref id="B39"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Yan</surname><given-names>X</given-names></name><name><surname>Zhu</surname><given-names>F</given-names></name><name><surname>Yu</surname><given-names>PS</given-names></name><name><surname>Ha</surname><given-names>J</given-names></name></person-group><article-title>Feature based substructure similarity search</article-title><source>ACM Transactions on Database Systems</source><year>2006</year></citation></ref><ref id="B40"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Hasan</surname><given-names>M</given-names></name><name><surname>Chaoji</surname><given-names>V</given-names></name><name><surname>Salem</surname><given-names>S</given-names></name><name><surname>jeremy</surname><given-names>Besson</given-names></name><name><surname>Zaki</surname><given-names>M</given-names></name></person-group><article-title>ORIGAMI: Mining Representative Orthogonal Graph Patterns</article-title><source>Proc 2007 Int Conf on Data Mining (ICDM'07)</source><year>2007</year></citation></ref><ref id="B41"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>C</given-names></name><name><surname>Yan</surname><given-names>X</given-names></name><name><surname>Zhu</surname><given-names>F</given-names></name><name><surname>Han</surname><given-names>J</given-names></name></person-group><article-title>gapprox: Mining frequent approximate patterns from a massive network</article-title><source>Proc 2007 Int Conf on Data Mining (ICDM'07)</source><year>2007</year></citation></ref><ref id="B42"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Holder</surname><given-names>LB</given-names></name><name><surname>Cook</surname><given-names>DJ</given-names></name><name><surname>Djoko</surname><given-names>S</given-names></name></person-group><article-title>Substructures discovery in the subdue system</article-title><source>Proc AAAI'94 Workshop Knowledge Discovery in Databases</source><year>1994</year><fpage>169</fpage><lpage>180</lpage></citation></ref><ref id="B43"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Zhang</surname><given-names>S</given-names></name><name><surname>Yang</surname><given-names>J</given-names></name><name><surname>Cheedella</surname><given-names>V</given-names></name></person-group><article-title>Monkey: Approximate Graph Mining Based on Spanning Trees</article-title><source>Data Engineering, 2007 ICDE 2007 IEEE 23rd International Conference</source><year>2007</year><fpage>1247</fpage><lpage>1249</lpage></citation></ref><ref id="B44"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Vanetik</surname><given-names>N</given-names></name><name><surname>Gudes</surname><given-names>E</given-names></name></person-group><article-title>Mining Frequent Labeled and Partially Labeled Graph Patterns</article-title><pub-id pub-id-type="pmid">9575583</pub-id></citation></ref><ref id="B45"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Bandyopadhyay</surname><given-names>D</given-names></name><name><surname>Snoeyink</surname><given-names>J</given-names></name></person-group><article-title>Almost-Delaunay Simplices : Nearest Neighbor Relations for Imprecise Points</article-title><source>ACM-SIAM Symposium On Distributed Algorithms</source><year>2004</year><fpage>403</fpage><lpage>412</lpage></citation></ref><ref id="B46"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Delaunay</surname><given-names>B</given-names></name></person-group><article-title>Sur la sphere vide. A la memoire de Georges Voronoi</article-title><source>Izv Akad Nauk SSSR, Otdelenie Matematicheskih i Estestvennyh Nauk</source><year>1934</year><volume>7</volume><fpage>793C800</fpage></citation></ref><ref id="B47"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Huan</surname><given-names>J</given-names></name><name><surname>Wang</surname><given-names>W</given-names></name><name><surname>Bandyopadhyay</surname><given-names>D</given-names></name><name><surname>Snoeyink</surname><given-names>J</given-names></name><name><surname>Prins</surname><given-names>J</given-names></name><name><surname>Tropsha</surname><given-names>A</given-names></name></person-group><article-title>Mining Family Specific Residue Packing Patterns from Protein Structure Graphs</article-title><source>Proceedings of the 8th Annual International Conference on Research in Computational Molecular Biology (RECOMB)</source><year>2004</year><fpage>308</fpage><lpage>315</lpage></citation></ref><ref id="B48"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Huan</surname><given-names>J</given-names></name><name><surname>Wang</surname><given-names>W</given-names></name><name><surname>Prins</surname><given-names>J</given-names></name></person-group><article-title>Efficient Mining of Frequent Subgraph in the Presence of Isomorphism</article-title><source>Proceedings of the 3rd IEEE International Conference on Data Mining (ICDM)</source><year>2003</year><fpage>549</fpage><lpage>552</lpage></citation></ref><ref id="B49"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Eddy</surname><given-names>SR</given-names></name></person-group><article-title>Where did the BLOSUM62 alignment score matrix come from</article-title><source>Nature Biotechnology</source><year>2004</year><volume>22</volume><fpage>1035</fpage><lpage>1036</lpage><pub-id pub-id-type="pmid">15286655</pub-id></citation></ref><ref id="B50"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kelly</surname><given-names>G</given-names></name><etal></etal></person-group><article-title>Structure of the cell-adhesion fragment of intimin from enteropathogenic Escherichia coli</article-title><source>Nature Struct Biol</source><year>1999</year><volume>6</volume><fpage>313</fpage><lpage>318</lpage><pub-id pub-id-type="pmid">10201396</pub-id></citation></ref><ref id="B51"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hamburger</surname><given-names>Z</given-names></name><etal></etal></person-group><article-title>Crystal structure of invasin: a bacterial integrin-binding protein</article-title><source>Science</source><year>1999</year><volume>286</volume><fpage>291</fpage><lpage>295</lpage><pub-id pub-id-type="pmid">10514372</pub-id></citation></ref><ref id="B52"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>G</given-names></name><name><surname>Dunbrack</surname><given-names>RL</given-names></name><name><surname>PISCES</surname><given-names>J</given-names></name></person-group><article-title>A Protein Sequence Culling Server</article-title><source>Bioinformatics</source><year>2003</year><volume>19</volume><fpage>1589</fpage><lpage>1591</lpage><pub-id pub-id-type="pmid">12912846</pub-id></citation></ref><ref id="B53"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Huan</surname><given-names>J</given-names></name><name><surname>Bandyopadhyay</surname><given-names>D</given-names></name><name><surname>Snoeyink</surname><given-names>J</given-names></name><name><surname>Prins</surname><given-names>J</given-names></name><name><surname>Tropsha</surname><given-names>A</given-names></name><name><surname>Wang</surname><given-names>W</given-names></name></person-group><article-title>Distance-based identification of spatial motifs in proteins using constrained frequent subgraph mining</article-title><source>Proceedings of the IEEE Computational Systems Bioinformatics (CSB)</source><year>2006</year></citation></ref><ref id="B54"><citation citation-type="other"><article-title>LIBSVM</article-title><ext-link ext-link-type="uri" xlink:href="http://www.csie.ntu.edu.tw/~cjlin/libsvm"/></citation></ref><ref id="B55"><citation citation-type="other"><article-title>PDBsum Structure Database</article-title><ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/thornton-srv/databases/cgi-bin/pdbsum"/></citation></ref><ref id="B56"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Kuramochi</surname><given-names>M</given-names></name><name><surname>Karypis</surname><given-names>G</given-names></name></person-group><article-title>Frequent subgraph discovery</article-title><source>Proc International Conference on Data Mining01</source><year>2001</year><fpage>313C320</fpage></citation></ref></ref-list></back></article>