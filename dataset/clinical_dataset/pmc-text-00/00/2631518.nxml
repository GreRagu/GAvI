<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19126200</article-id><article-id pub-id-type="pmc">2631518</article-id><article-id pub-id-type="publisher-id">1471-2105-10-4</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-4</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group></article-categories><title-group><article-title>Comparison of public peak detection algorithms for MALDI mass spectrometry data analysis</article-title></title-group><contrib-group><contrib id="A1" corresp="yes" contrib-type="author"><name><surname>Yang</surname><given-names>Chao</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>yorkey@ust.hk</email></contrib><contrib id="A2" contrib-type="author"><name><surname>He</surname><given-names>Zengyou</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>eezyhe@ust.hk</email></contrib><contrib id="A3" contrib-type="author"><name><surname>Yu</surname><given-names>Weichuan</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>eeyu@ust.hk</email></contrib></contrib-group><aff id="I1"><label>1</label>Laboratory for Bioinformatics and Computational Biology, Department of Electronic and Computer Engineering, The Hong Kong University of Science and Technology, Clear Water Bay, Hong Kong, PR China</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>6</day><month>1</month><year>2009</year></pub-date><volume>10</volume><fpage>4</fpage><lpage>4</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/4"/><history><date date-type="received"><day>19</day><month>7</month><year>2008</year></date><date date-type="accepted"><day>6</day><month>1</month><year>2009</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2009 Yang et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Yang et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Yang               Chao                              yorkey@ust.hk            </dc:author><dc:title>            Comparison of public peak detection algorithms for MALDI mass spectrometry data analysis         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(1): 4-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:1&#x0003c;4&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>In mass spectrometry (MS) based proteomic data analysis, peak detection is an essential step for subsequent analysis. Recently, there has been significant progress in the development of various peak detection algorithms. However, neither a comprehensive survey nor an experimental comparison of these algorithms is yet available. The main objective of this paper is to provide such a survey and to compare the performance of single spectrum based peak detection methods.</p></sec><sec><title>Results</title><p>In general, we can decompose a peak detection procedure into three consequent parts: smoothing, baseline correction and peak finding. We first categorize existing peak detection algorithms according to the techniques used in different phases. Such a categorization reveals the differences and similarities among existing peak detection algorithms. Then, we choose five typical peak detection algorithms to conduct a comprehensive experimental study using both simulation data and real MALDI MS data.</p></sec><sec><title>Conclusion</title><p>The results of comparison show that the continuous wavelet-based algorithm provides the best average performance.</p></sec></abstract></article-meta></front><body><sec><title>Background</title><p>Proteome research requires the analysis of large-volume protein data in a high-throughput manner. Mass Spectrometry (MS) is a common analytical tool in proteome research. It can be used as a technique to measure masses of proteins/peptides in complex mixtures obtained from biological samples. This provides tremendous potential to study disease proteome and to identify drug targets directly at the protein/peptide level [<xref ref-type="bibr" rid="B1">1</xref>].</p><p>In a typical proteomic experiment, a huge volume (e.g. 1 GB) of MS data is often generated. Each of MS spectra consists of two large vectors corresponding to mass to charge ratio (<italic>m</italic>/<italic>z</italic>) and intensity value, respectively. The first step in proteomic data analysis is to extract peptide induced signals (i.e., peaks) from raw MS spectra. Peak detection is not only a feature extraction step, but also an indispensable step for subsequent protein identification, quantification and discovery of disease-related biomarkers [<xref ref-type="bibr" rid="B2">2</xref>,<xref ref-type="bibr" rid="B3">3</xref>]. However, peak detection is a challenging task since mass spectra are often corrupted by noise. As a result, various algorithms have been proposed to facilitate the identification of informative peaks that correspond to true peptide signals. These algorithms differ from each other in their principles, implementations and performance. In order to provide a comprehensive comparison of existing peak detection algorithms and extract reasonable criteria for developing new peak detection methods, we need to answer the following questions:</p><p>1. What's the working mechanism of an algorithm?</p><p>2. What are the differences and common points among different algorithms?</p><p>3. What is their performance in MS data analysis?</p><p>To address the above questions, we study the peak detection process using a common framework: smoothing, baseline correction and peak finding. Such a decomposition enables us to better elucidate the fundamental principles underlying different peak detection algorithms. More importantly, it helps us to clearly identify the differences and similarities among existing peak detection algorithms.</p><p>We describe each part in the peak detection process with particular emphasis on their technical details, hoping that this can help readers implement their own peak detection algorithms.</p><p>During evaluation, we choose five typical peak detection algorithms to conduct a comparative experimental study. In the experiments, we use both simulation data and real MALDI MS data for performance comparison. The results show that the continuous wavelet-based algorithm provides the best average performance.</p><p>The remainder of this paper is organized as follows: section 2 provides details on existing peak detection algorithms and highlights their differences and similarities; section 3 conducts a performance comparison on some typical peak detection algorithms using simulation data and real MALDI MS data; section 4 concludes the paper.</p></sec><sec sec-type="methods"><title>Methods</title><sec><title>Peak Detection Process</title><p>Usually, peptide signals appear as local maxima (i.e., peaks) in MS spectra. However, detecting these signals still remains challenging due to the following reasons:</p><p>(1) Some peptides with low abundance may be buried by noise, causing high false positive rate of peak detection.</p><p>(2) The chemical, ionization, and electronic noise often result in a decreasing curve in the background of MALDI/SELDI MS data, which is referred to as baseline [<xref ref-type="bibr" rid="B4">4</xref>]. The existence of baseline produces strong bias in peak detection. It is desirable to remove baseline before peak detection.</p><p>To facilitate peak detection, we often use the framework shown in Figure <xref ref-type="fig" rid="F1">1</xref>. It should be noted that smoothing and baseline correction may switch their locations in the pipeline. Figure <xref ref-type="fig" rid="F2">2</xref> gives a concrete example of peak detection by showing the result after each step of the pipeline.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Peak detection framework</bold>. The input mass spectrum is transformed into a list of peaks.</p></caption><graphic xlink:href="1471-2105-10-4-1"/></fig><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>An example of the peak detection process</bold>. (a) A raw spectrum, (b) the spectrum after smoothing, (c) the spectrum after smoothing and baseline correction and (d) final peak detection results with peaks marked as circles.</p></caption><graphic xlink:href="1471-2105-10-4-2"/></fig></sec><sec><title>Categorization</title><p>Existing peak detection algorithms can be categorized according to the methods used in each step of peak detection process. Table <xref ref-type="table" rid="T1">1</xref> lists some popular MS data analysis methods and their peak detection functions. In this paper, we use CWT to denote MassSpecWavelet and LMS to denote Local Maximum Search. Similarities and differences among these methods can be addressed from the table. Here we would like to highlight the following:</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Open source software packages for MS data analysis</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center"><bold>Program</bold></td><td align="center"><bold>S</bold></td><td align="center"><bold>B</bold></td><td align="center"><bold>P</bold></td><td align="center"><bold>Web link</bold></td></tr></thead><tbody><tr><td align="center">Cromwell [<xref ref-type="bibr" rid="B12">12</xref>]</td><td align="center">S7</td><td align="center">B1</td><td align="center">P1, P4</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.mdanderson.org/software.html"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">LCMS-2D [<xref ref-type="bibr" rid="B20">20</xref>]</td><td align="center">-</td><td align="center">B5</td><td align="center">P1, P2</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://www.bioc.aecom.yu.edu/labs/angellab/"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">LIMPIC [<xref ref-type="bibr" rid="B21">21</xref>]</td><td align="center">S4</td><td align="center">B2</td><td align="center">P1, P3</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/8/101/additional/"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">LMS [<xref ref-type="bibr" rid="B22">22</xref>]</td><td align="center">S3</td><td align="center">B2</td><td align="center">P1, P4</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.ust.hk/LMS.zip"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">MapQuant [<xref ref-type="bibr" rid="B16">16</xref>]</td><td align="center">S1,S2,S3</td><td align="center">-</td><td align="center">P7</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://arep.med.harvard.edu/MapQuant/download.html"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">CWT [<xref ref-type="bibr" rid="B10">10</xref>]</td><td align="center">S5</td><td align="center">B4</td><td align="center">P1, P6</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://www.bioconductor.org/packages/devel/bioc/html/MassSpecWavelet.html"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">msInspect [<xref ref-type="bibr" rid="B23">23</xref>]</td><td align="center">S6</td><td align="center">B2</td><td align="center">P5</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://proteomics.fhcrc.org/CPL/msinspect.html"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">mzMine [<xref ref-type="bibr" rid="B24">24</xref>]</td><td align="center">S1, S2</td><td align="center">-</td><td align="center">P1, P2, P8</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://mzmine.sourceforge.net/download.shtml"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">OpenMS [<xref ref-type="bibr" rid="B15">15</xref>]</td><td align="center">S5</td><td align="center">B4</td><td align="center">P7</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://open-ms.sourceforge.net/index.php"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">PROcess [<xref ref-type="bibr" rid="B13">13</xref>]</td><td align="center">S1</td><td align="center">B2, B3</td><td align="center">P1, P2, P5</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://www.bioconductor.org/packages/devel/bioc/html/PROcess.html"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">PreMS [<xref ref-type="bibr" rid="B25">25</xref>]</td><td align="center">S7</td><td align="center">B1</td><td align="center">P1, P4</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://sourceforge.net/projects/prepms"/></td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center">XCMS [<xref ref-type="bibr" rid="B8">8</xref>]</td><td align="center">S3</td><td align="center">-</td><td align="center">P1, P4</td><td align="center"><ext-link ext-link-type="uri" xlink:href="http://www.bioconductor.org/packages/1.8/bioc/html/xcms.html"/></td></tr></tbody></table><table-wrap-foot><p>Here "<bold>S</bold>" denotes smoothing filter, "<bold>B</bold>" denotes baseline correction method, "<bold>P</bold>" denotes peak finding criterion and "-" means smoothing or baseline correction method is not used. Cromwell, LIMPIC, LMS, CWT, and PROcess are designed for single spectrum peak detection. LCMS-2D, MapQuant, msInspect, mzMine, OpenMS and XCMS are designed for LC-MS (Liquid Chromatography Mass Spectrometry) data analysis. PreMS is a GUI (Graphic User Interface) package based on Cromwell.</p></table-wrap-foot></table-wrap><p>(1) The algorithms in Table <xref ref-type="table" rid="T1">1</xref> are chosen according to three criteria:</p><p>&#x02022; The software is mainly designed for MS data pre-processing.</p><p>&#x02022; The software is open source.</p><p>&#x02022; The software is described in a publication.</p><p>(2) In Table <xref ref-type="table" rid="T1">1</xref>, S1-S7, B1-B5 and P1-P8 denote different smoothing methods, baseline correction methods and peak finding criteria, respectively. We shall provide their details in subsequent sub-sections.</p><p>&#x02022; Smoothing</p><p>S1: Moving average filter</p><p>S2: Savitzky-Golay filter</p><p>S3: Gaussian filter</p><p>S4: Kaiser window</p><p>S5: Continuous Wavelet Transform</p><p>S6: Discrete Wavelet Transform</p><p>S7: Undecimated Discrete Wavelet Transform</p><p>&#x02022; Baseline Correction</p><p>B1: Monotone minimum</p><p>B2: Linear interpolation</p><p>B3: Loess</p><p>B4: Continuous Wavelet Transform</p><p>B5: Moving average of minima</p><p>&#x02022; Peak Finding Criterion</p><p>P1: SNR</p><p>P2: Detection/Intensity threshold</p><p>P3: Slopes of peaks</p><p>P4: Local maximum</p><p>P5: Shape ratio</p><p>P6: Ridge lines</p><p>P7: Model-based criterion</p><p>P8: Peak width</p></sec><sec><title>Smoothing Filters</title><p>These methods usually apply traditional signal processing techniques such as moving average filter, Savitzky-Golay filter and Gaussian filter. For an input spectrum, we represent it as [<italic>m</italic>/<italic>z</italic>, <italic>x</italic>] with the first element as <italic>m</italic>/<italic>z </italic>vector and the second element as intensity vector (with equal length). To facilitate descriptions in signal processing, we further use <italic>x</italic>(<italic>t</italic>) to denote the continuous form of intensity vector and use <italic>x</italic>[<italic>n</italic>] to denote the discrete form of intensity vector. Here <italic>t </italic>and <italic>n </italic>serve as indexing variables. The input spectrum is always discrete. We use the continuous form to be consistent with the original description. In real applications, we usually sample the continuous filter to obtain its discrete form. We can obtain <italic>m</italic>/<italic>z </italic>values from <italic>m</italic>/<italic>z </italic>vector easily by using the corresponding indexing variable as well. A spectrum after smoothing can be expressed as <italic>y</italic>[<italic>n</italic>] = <italic>x</italic>[<italic>n</italic>] * <italic>w</italic>[<italic>n</italic>] for discrete case and <italic>y</italic>(<italic>t</italic>) = <italic>x</italic>(<italic>t</italic>) * <italic>w</italic>(<italic>t</italic>) for continuous case, where * denotes convolution operation. In above equations, <italic>w</italic>[<italic>n</italic>] and <italic>w</italic>(<italic>t</italic>) are a weight vector and a weight function, respectively. The use of different <italic>w</italic>[<italic>n</italic>] and <italic>w</italic>(<italic>t</italic>) will lead to different filters.</p><p>S1: <bold>Moving average filter </bold>[<xref ref-type="bibr" rid="B5">5</xref>]:</p><p>The output of the moving average filter <italic>y</italic>[<italic>n</italic>] reads:</p><p><disp-formula id="bmcM1"><label>(1)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-4-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>&#x02217;</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle><mml:mo>,</mml:mo></mml:mrow></mml:semantics></mml:math></disp-formula></p><p>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-4-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>, -<italic>k </italic>&#x02264; <italic>n </italic>&#x02264; <italic>k</italic>. The odd number 2<italic>k </italic>+ 1 denotes filter width. The greater the filter width, the more intense the smoothing effect.</p><p>S2: <bold>Savitzky-Golay filter</bold>:</p><p>The Saviztky-Golay filtering can be considered as a generalized moving average filter. It performs a least squares fit of a small set of consecutive data points to a polynomial and takes the central point of the fitted polynomial curve as output.</p><p>The smoothed data point <italic>y</italic>[<italic>n</italic>] after Savitzky-Golay filtering is given by the following equation:</p><p><disp-formula id="bmcM2"><label>(2)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-4-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>&#x02217;</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:semantics></mml:math></disp-formula></p><p>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-4-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>, -<italic>k </italic>&#x02264; <italic>n </italic>&#x02264; <italic>k</italic>. Here, <italic>A</italic><sub><italic>i </italic></sub>controls the polynomial order. Figure <xref ref-type="fig" rid="F3">3(a)</xref> shows Savitzky-Golay filters with different polynomial orders. For more information about <italic>A</italic><sub><italic>i</italic></sub>, please refer to [<xref ref-type="bibr" rid="B6">6</xref>].</p><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>Smoothing filters</bold>. In (a), "PO" stands for polynomial order of polynomial fitting in Savitzky-Golay filter. In (b), <italic>&#x003c3; </italic>is the standard deviation. In (c), <italic>&#x003b1; </italic>determines the shape of Kaiser window. In (d), <italic>a </italic>is the scale of the wavelet.</p></caption><graphic xlink:href="1471-2105-10-4-3"/></fig><p>S3: <bold>Gaussian filter</bold></p><p>After a signal <italic>x</italic>(<italic>t</italic>) passing Gaussian filter, the output reads:</p><p><disp-formula id="bmcM3"><label>(3)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-4-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02217;</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mi>&#x0221e;</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:mi>&#x0221e;</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:mrow></mml:mstyle><mml:mo>,</mml:mo></mml:mrow></mml:semantics></mml:math></disp-formula></p><p>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-4-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi></mml:mrow></mml:msqrt><mml:mi>&#x003c3;</mml:mi></mml:mrow></mml:mfrac><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>&#x003c3;</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:semantics></mml:math></inline-formula>. The degree of smoothing is determined by the standard deviation <italic>&#x003c3;</italic>. In fact, we can view Gaussian filter as a weighted moving average filter. This filter sets larger weight factors for points in the center and smaller weight factors for points away from the center. Figure <xref ref-type="fig" rid="F3">3(b)</xref> shows Gaussian filters with different <italic>&#x003c3;</italic>.</p><p>Some researchers use the second-derivative of Gaussian to perform smoothing. Their argument is that the second-derivative of Gaussian can implicitly remove background when smoothing signals [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B8">8</xref>].</p><p>S4: <bold>Kaiser window</bold></p><p>After a signal passing a Kaiser window:</p><p><disp-formula id="bmcM4"><label>(4)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-4-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>&#x02217;</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>&#x0221e;</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:mi>&#x0221e;</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle><mml:mo>,</mml:mo></mml:mrow></mml:semantics></mml:math></disp-formula></p><p>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-4-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:mfrac><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msqrt></mml:mrow><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>, 0 &#x02264; <italic>n </italic>&#x02264; <italic>N</italic>. <italic>&#x003b1; </italic>determines the shape of the Kaiser window. A large <italic>&#x003b1; </italic>indicates a sharp Kaiser window. <italic>N </italic>denotes the width of window. <italic>I</italic><sub>0 </sub>is zeroth-order modified Bessel function of the first kind [<xref ref-type="bibr" rid="B9">9</xref>]. Figure <xref ref-type="fig" rid="F3">3(c)</xref> shows two Kaiser windows with different <italic>&#x003b1; </italic>values.</p><p>S5, S6, S7: <bold>Wavelet based filters</bold></p><p>Wavelet can be grouped as continuous wavelet transform and discrete wavelet transform. The continuous wavelet transform can be written as</p><p><disp-formula id="bmcM5"><label>(5)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-4-i9" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02217;</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>a</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mi>&#x0221e;</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:mi>&#x0221e;</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>&#x003c8;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>&#x003c4;</mml:mi></mml:mrow><mml:mi>a</mml:mi></mml:mfrac><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:mrow></mml:mstyle><mml:mo>,</mml:mo></mml:mrow></mml:semantics></mml:math></disp-formula></p><p>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-4-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>a</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac><mml:mi>&#x003c8;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mi>t</mml:mi><mml:mi>a</mml:mi></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. a denotes scale and <italic>&#x003c8; </italic>denotes mother wavelet function. In continuous wavelet analysis, Du <italic>et al </italic>[<xref ref-type="bibr" rid="B10">10</xref>]choose Mexican Hat wavelet. Mexican Hat wavelet reads as:</p><p><disp-formula id="bmcM6"><label>(6)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-4-i11" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c8;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>2</mml:mn><mml:mrow><mml:msqrt><mml:mn>3</mml:mn></mml:msqrt><mml:msup><mml:mi>&#x003c0;</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:semantics></mml:math></disp-formula></p><p>Then <italic>w</italic>(<italic>t</italic>) forms a scaled Mexican Hat wavelet. Figure <xref ref-type="fig" rid="F3">3(d)</xref> shows <italic>w</italic>(<italic>t</italic>) with different <italic>a</italic>. Here, <italic>a </italic>determines the width of the wavelet. With different <italic>a</italic>, we can use <italic>w</italic>(<italic>t</italic>) to model peaks with different width. This is especially important for low-resolution data in which peak width varies a lot. Peaks with higher <italic>m</italic>/<italic>z </italic>values tend to have larger width. Using fixed-window filters will not perform well in this case. Discrete wavelet transform computes on scales and translations based on the power of two. Figure <xref ref-type="fig" rid="F4">4</xref> shows a typical method for computing discrete wavelet transform, where <italic>h</italic>[<italic>n</italic>] is a high-pass filter and <italic>g</italic>[<italic>n</italic>] is a low-pass filter. The procedure to compute discrete wavelet transform is as follows:</p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>The process of computing DWT</bold>. Here "&#x02193; 2" means down sampling by 2, <italic>h</italic>[<italic>n</italic>] is a high-pass filter and <italic>g</italic>[<italic>n</italic>] is a low-pass filter.</p></caption><graphic xlink:href="1471-2105-10-4-4"/></fig><p>(1) Signal is decomposed simultaneously by a low-pass filter <italic>g</italic>[<italic>n</italic>] and a high-pass filter <italic>h</italic>[<italic>n</italic>].</p><p>(2) The output of <italic>h</italic>[<italic>n</italic>] is then down sampled by two to generate detail coefficients and the output of <italic>g</italic>[<italic>n</italic>] is down sampled by two to generate approximation coefficients. The coefficients obtained from the output of <italic>h</italic>[<italic>n</italic>] are named level one coefficients.</p><p>(3) The output of <italic>g</italic>[<italic>n</italic>] goes through another group of high-pass filter and low-pass filter. Steps (1) and (2) go on until we obtain the last level of coefficients.</p><p>The advantage of discrete wavelet transform over continuous wavelet transform is its efficiency because it only computes on the scales and positions based on the power of two, while the redundancy of continuous wavelet transform makes the interpretation of MS peak detection easier [<xref ref-type="bibr" rid="B10">10</xref>].</p><p>Discrete wavelet transform is shift-variant. To achieve shift invariance, undecimated discrete wavelet transform has been proposed [<xref ref-type="bibr" rid="B11">11</xref>,<xref ref-type="bibr" rid="B12">12</xref>].</p></sec><sec><title>Baseline Correction</title><p>Baseline correction is typically a two-step process: (1) estimating the baseline and (2) subtracting the baseline from the signal. In the following, we list details of some commonly used baseline correction methods. Since baseline substraction is straightforward, we mainly focus on the baseline estimation procedure in different methods.</p><p>B1: <bold>Monotone minimum</bold></p><p>This method includes two steps to estimate baseline. The first step is to compute the difference, which can be used to determine the slope of each point. Then, this method starts from the leftmost point <italic>A </italic>in the spectrum and continues the following procedure until the rightmost point is reached:</p><p>&#x02022; If the slope of a local point <italic>A </italic>is smaller than zero, a nearest point <italic>B </italic>to the right of <italic>A </italic>whose slope is larger than zero is located. All points between <italic>A </italic>and <italic>B </italic>serve as baseline between <italic>A </italic>and <italic>B</italic>.</p><p>&#x02022; If the slope of a local point <italic>A </italic>is larger than zero, a nearest points <italic>B </italic>to the right of <italic>A </italic>whose intensity is smaller than <italic>A </italic>is located. The intensity of every point on the result baseline between <italic>A </italic>and <italic>B </italic>equals to the intensity of <italic>A</italic>.</p><p>&#x02022; Let <italic>A </italic>= <italic>B</italic>.</p><p>B2: <bold>Linear interpolation</bold></p><p>Linear interpolation takes two steps to estimate baseline:</p><p>&#x02022; Divide the raw spectrum into small segments and use the mean, the minimum or the median of the points in each segment as the baseline point.</p><p>&#x02022; Generate a baseline for the raw spectrum by linearly interpolating baseline points across all small segments.</p><p>B3: <bold>Loess</bold></p><p>First, it divides the raw spectrum into small segments. Then, in each small segment, it computes the quantile. After that, it estimates a predictor in every small segment for baseline estimation. The predictor in each small segment is obtained using the following rules:</p><p>&#x02022; If the intensity of a point <italic>A </italic>is smaller than the quantile in the segment, then the intensity of corresponding point on predictor equals the intensity of <italic>A</italic>.</p><p>&#x02022; If the intensity of a point is larger than or equal to the quantile in the segment, then the intensity of corresponding point on predictor equals the quantile.</p><p>Baseline is obtained by applying local polynomial regression fitting to the predictor.</p><p>B4: <bold>Continuous Wavelet Transform</bold></p><p>In local regions, baselines are monotonic. Baseline can be modeled as the following function:</p><p><disp-formula id="bmcM7"><label>(7)</label><italic>Base </italic>= <italic>B</italic>(<italic>t</italic>) + <italic>C</italic>,</disp-formula></p><p>where <italic>C </italic>is a constant and <italic>B</italic>(<italic>t</italic>) is an odd function [<xref ref-type="bibr" rid="B10">10</xref>]. The continuous wavelet transform of the equation reads:</p><p><disp-formula id="bmcM8"><label>(8)</label><italic>Base</italic>(<italic>a</italic>, <italic>b</italic>) = &#x0222b; <italic>B</italic>(<italic>t</italic>)<italic>&#x003c8;</italic><sub><italic>a</italic>,<italic>b</italic></sub>(<italic>t</italic>)<italic>dt </italic>+ &#x0222b; <italic>C&#x003c8;</italic><sub><italic>a</italic>,<italic>b</italic></sub>(<italic>t</italic>)<italic>dt</italic>,</disp-formula></p><p>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-4-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>&#x003c8;</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>a</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac><mml:mi>&#x003c8;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mi>a</mml:mi></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. Because wavelet function has zero mean, the second term of equation (8) is</p><p>zero. If we use a symmetric wavelet function (like Mexican Hat wavelet), the first item in Equation (8) is also zero. Thus, continuous wavelet transform removes baseline automatically.</p><p>B5: <bold>Moving average of minima</bold></p><p>This method uses two steps to estimate baseline:</p><p>&#x02022; Estimate a rough baseline by finding local minimum within a two Da window for each point.</p><p>&#x02022; Use a moving window to smooth the rough baseline obtained in the first step.</p></sec><sec><title>Peak Finding Criteria</title><p>There are many peak detection methods. Most methods detect peaks after smoothing and baseline correction. However, it should be noted that there is a special case, CWT does not have explicit smoothing and baseline correction steps. Du <italic>et al</italic>. [<xref ref-type="bibr" rid="B10">10</xref>] claim that baseline can be removed if continuous wavelet transform is carried out on a raw spectrum. We have shown this fact in Section Baseline Correction. In the following, we illustrate the criteria used by different algorithms to find similarities among different algorithms.</p><p>P1: <bold>SNR</bold></p><p>SNR stands for signal to noise ratio. Different methods define noise differently. Below are two examples:</p><p>&#x02022; Noise is estimated as 95-percentage quantile of absolute continuous wavelet transform (CWT) coefficients of scale one within a local window [<xref ref-type="bibr" rid="B10">10</xref>].</p><p>&#x02022; Noise is estimated as the median of the absolute deviation (MAD) of points within a window [<xref ref-type="bibr" rid="B13">13</xref>].</p><p>P2: <bold>Detection/Intensity threshold</bold></p><p>This threshold is used to filter out small peaks in flat regions. In these regions, the median of the absolute deviation (MAD) is quite small, which may result in big SNR. Using SNR alone may identify many noisy points as peaks.</p><p>P3: <bold>Slopes of peaks</bold></p><p>This criterion uses the shape of peaks to remove false peak candidates. In order to compute the left slope and the right slope of a peak, both the left end point and the right end point of the peak need to be identified. Peak candidate is discarded if both left slope and right slope are less than a threshold. The threshold is defined as half of the local noise level [<xref ref-type="bibr" rid="B14">14</xref>].</p><p>P4: <bold>Local maximum</bold></p><p>A peak is a local maximum of <italic>N </italic>neighboring points.</p><p>P5: <bold>Shape ratio</bold></p><p>Peak area is computed as the area under the curve within a small distance of a peak candidate. Shape ratio is computed as the peak area divided by the maximum of all peak areas. The shape ratio of a peak must be larger than a threshold.</p><p>P6: <bold>Ridge lines</bold></p><p>Ridge lines are obtained in the following steps:</p><p>&#x02022; Carry out continuous wavelet transform on raw spectrum. This step produces 2-D coefficient matrix with size of <italic>M </italic>&#x000d7; <italic>N</italic>, where <italic>M </italic>is the number of scales and <italic>N </italic>is the length of spectrum.</p><p>&#x02022; Connect nearest local maximal coefficients of adjacent scales to obtain ridge lines. The distance between two adjacent points on a ridge line should be smaller than a window size.</p><p>&#x02022; Use a variable <italic>gap </italic>to count how many successive times that a local maximal coefficient can not find its nearest counterpart in the next scale. If the <italic>gap </italic>is larger than a given threshold, the ridge line is dropped.</p><p>Ridge lines are used in the following ways:</p><p>&#x02022; False peaks are removed if the length of their ridge lines are smaller than a given threshold supplied by users.</p><p>&#x02022; The width of a peak is proportional to the scale corresponding to the maximum amplitude on the ridge line [<xref ref-type="bibr" rid="B10">10</xref>]. A peak candidate is dropped if its width is not in a given range.</p><p>P7: <bold>Model-based criterion</bold></p><p>The application of this criterion consists of three steps:</p><p>&#x02022; Locate the endpoints of both sides for each peak. The left endpoint and right endpoint of a peak define its peak area.</p><p>&#x02022; Estimate the centroid for each peak. For <italic>m</italic>/<italic>z </italic>axis, the centroid of a peak is computed as intensity-weighted average of points within the peak area [<xref ref-type="bibr" rid="B15">15</xref>].</p><p>&#x02022; Use a model function to fit peaks.</p><p>Different methods choose different model functions to fit peaks. OpenMS [<xref ref-type="bibr" rid="B15">15</xref>] chooses asymmetric Lorentzian or sech<sup>2 </sup>function while MapQuant [<xref ref-type="bibr" rid="B16">16</xref>] uses Gaussian function to fit peaks.</p><p>P8: <bold>Peak width</bold></p><p>The two end points of a peak define its peak area. The intensities of all points within the peak area should be larger than a given noise level. A simple way to locate a peak area is to start from a point with intensity above a given noise level and move to the right until we run into a point with intensity below the noise level.</p><p>After peak end points have been identified, peak width is computed as the mass difference of right end point and left end point. The peak width should be within a given range.</p></sec></sec><sec><title>Results and discussion</title><sec><title>Data Description and Algorithm Selection</title><p>In comparison, we use one group of simulation data and one group of real MALDI MS data. The low resolution simulation data is downloaded from the website of M. D. Anderson Cancer Center [<xref ref-type="bibr" rid="B17">17</xref>,<xref ref-type="bibr" rid="B18">18</xref>]. The high resolution real data is obtained from Aurum Data Set [<xref ref-type="bibr" rid="B19">19</xref>], which contains known purified and tryptic-digested proteins. For simulation data, the number of true peaks in a spectrum is around 70 on average. The <italic>m</italic>/<italic>z </italic>range is between 400 Da and 64800 Da. The mass variation is: &#x00394;<italic>m </italic>&#x02208; [0.251 <italic>Da</italic>, 3.915 <italic>Da</italic>]. The median of SNR is around 0.675. For real data, the number of true peaks in a spectrum varies from 50 and 100. The <italic>m</italic>/<italic>z </italic>range is between 800 Da and 3500 Da. The mass variation is: &#x00394;<italic>m </italic>&#x02208; [0.016 <italic>Da</italic>, 0.034 <italic>Da</italic>]. The median of SNR is around 4.854. The reader is referred to additional file <xref ref-type="supplementary-material" rid="S1">1</xref> for more details on the data.</p><p>Software programs for LC-MS data analysis consider additional information along the LC-axis during peak detection. In order to obtain a fair comparison, here we only focus on single spectrum based peak detection algorithms. According to this criterion, only five algorithms in Table <xref ref-type="table" rid="T1">1</xref> will remain: Cromwell, CWT, LMS, LIMPIC and PROcess. These algorithms are designed to analyze MALDI MS data. They can also be used to analyze MS/MS data in a spectrum by spectrum manner. It should be noted that these methods are very representative as LC-MS oriented programs also use similar ideas for peak detection along the <italic>m</italic>/<italic>z </italic>axis.</p></sec><sec><title>Evaluation Criteria</title><p>In simulation data, the list of ground-truth peaks is the input before data generation. In real data, the trypsin-digested theoretical peaks (without adding isotope masses) are used as the ground-truth peaks. In both cases, a detected peak is labeled as a false peak if its mass is not within the &#x000b1; 1% error range of the expected <italic>m</italic>/<italic>z </italic>value. Multiple peaks within the error range will be considered as one peak. We use false discovery rate (FDR) and sensitivity to measure the performance of algorithms. False discovery rate is defined as the number of falsely identified peaks divided by the total number of peaks found by algorithms. Sensitivity is defined as the number of correctly identified peaks divided by the total number of true peaks. For two algorithms with the same false discovery rate, the larger the sensitivity, the better the algorithm performance.</p><p>It is difficult for two algorithms to produce the same false discovery rate. Here we divide false discovery rate into small segments. Such segments have clear interpretations. For example, the FDR [0,0.1] range reveals the algorithm's ability to recognize the most abundant (based on SNR) peaks in the spectrum. Every time when we obtain peak lists, both false discovery rates and sensitivity are computed. We group the sensitivity together if the corresponding false discovery rates fall into the same small segment. Then average values of sensitivity in the same group are computed. The average value of sensitivity is used to evaluate the performance of one algorithm in that area.</p><p>As ground truth is known for both simulation data and real data in this paper, the ROC curve is probably the most informative measure for evaluation of different peak detection methods. However, the false discovery rates of wavelet-based methods are limited to a relatively small range across all possible parameter settings. On one hand, this reflects the robustness of wavelet-based methods. On the other hand, the plot of ROC curve becomes difficult in wavelet-based methods. Here we use the following alternative method to conduct performance comparison: we select four regions of false discovery rate:[0, 0.1), [0.2, 0.3), [0.4, 0.5), [0.6, 0.7) and compare sensitivity of different algorithms in these regions using boxplot. Such strategy is capable of providing an overall performance evaluation since it is roughly a "discrete" ROC curve in four regions. Moreover, the boxplots illustrate the performance variances of different algorithms.</p><p>Different programs have different parameters to adjust when performing peak detection. Since it is very time consuming to optimize each algorithm using all potential combinations of different parameters, we mainly test combinations of parameters that are related to peak finding and use default values for other parameters. Please refer to additional file <xref ref-type="supplementary-material" rid="S2">2</xref> for more details.</p></sec><sec><title>Comparison of Algorithms Using Simulation Data</title><p>The simulation data is generated using a model that incorporates some characteristics of real MALDI-TOF mass spectrometers: The simulation engine takes a peak list with both <italic>m</italic>/<italic>z </italic>values and intensity values as input and generates an artificial spectrum as output. The user-specified peaks are labeled as the ground-truth during data generation, while other peaks are labeled as false peaks in the simulation spectrum. In addition, the simulation engine assumes that the isotopic distribution follows the Bernoulli distribution. It also includes exponential baseline curve and Gaussian additive noise.</p><p>This data set has 25 groups of data and each group has 100 spectra. Each spectrum has a true peak list provided by data set. We directly use these peak lists as ground truth in our experiment. We use different parameter settings to perform peak detection repeatedly on 100 spectra in the same group, and then compute the average value of sensitivity with corresponding false discovery rates locating in the same small region. For each algorithm, we obtain 25 average values of sensitivity in each small region.</p><p>Figure <xref ref-type="fig" rid="F5">5</xref> shows the performance of five algorithms. CWT provides the best performance among these algorithms. Our explanation is that the use of wavelets in baseline modeling/correction and the use of ridge lines enable CWT-based algorithm to achieve better performance.</p><fig position="float" id="F5"><label>Figure 5</label><caption><p><bold>Performance of different algorithms at different false discovery rates using simulation data</bold>. In this figure, (a), (b), (c) and (d) show the average sensitivity when false discovery rate is around 0.05, 0.25, 0.45 and 0.65, respectively.</p></caption><graphic xlink:href="1471-2105-10-4-5"/></fig></sec><sec><title>Comparison of Algorithms Using Aurum Data</title><p>Aurum Dataset is a high resolution data set, which contains spectra from 246 known, individually purified and trypsin-digested protein samples with an ABI 4700 MALDI TOF/TOF mass spectrometer. In the experiments, we do not use MS/MS data and limit our analysis only to MS spectra. For each MS spectrum, we generate the ground truth peaks in silico using the following parameters: trypsin digestion with a maximum of one missed cleavage, monoisotopic peaks and single charge state. We also consider some typical PTMs (Post-Translational Modifications): carboxyamidomethyl cysteine as the fixed modification and oxidation of methionine as the variable modification. Note that peptides having missed cleavages and PTMs are also used to generate ground-truth peaks. After obtaining the theoretic peak list, we merge identical peaks into one peak and delete peaks whose <italic>m</italic>/<italic>z </italic>values are not in the range between 800 Da and 3500 Da. We select 200 spectra, and divide the spectra into eight groups. We perform the same performance test as we did for the simulation data.</p><p>Figure <xref ref-type="fig" rid="F6">6</xref> shows the performance of these five methods. The noisy nature of real data causes larger performance variations of most methods in this experiment. LIMPIC achieves comparable performance as CWT in Figure <xref ref-type="fig" rid="F6">6(b)</xref> and outperforms CWT in Figure <xref ref-type="fig" rid="F6">6(c)</xref>. On average, CWT provides the best results.</p><fig position="float" id="F6"><label>Figure 6</label><caption><p><bold>Performance of different algorithms at different false discovery rates using Aurum data</bold>. In this figure, (a), (b), (c) and (d) show the average sensitivity when false discovery rate is around 0.05, 0.25, 0.45 and 0.65, respectively.</p></caption><graphic xlink:href="1471-2105-10-4-6"/></fig></sec><sec><title>Report of Running Time</title><p>For high-throughput data analysis, high efficiency is always desirable. In Table <xref ref-type="table" rid="T2">2</xref>, we list the average running time of different algorithms on both simulation data and Aurum data, respectively. We obtain the running time of different algorithms using their original software packages on the same PC. It should be noted that these programs are implemented in different languages. Even without considering the implementation efficiency, complexity comparison is reasonable only for programs implemented in the same language. In this sense, Table <xref ref-type="table" rid="T2">2</xref> only serves as a reference for those readers who are interested in computational cost.</p><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Average processing time per spectrum using different programs</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center"><bold>Program</bold></td><td align="center"><bold>Platform</bold></td><td align="center"><bold>Time for Simulation data (Second)</bold></td><td align="center"><bold>Time for Real Data (Second)</bold></td></tr></thead><tbody><tr><td align="center">Cromwell</td><td align="center">Matlab</td><td align="center">0.21</td><td align="center">1.71</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">LMS</td><td align="center">Matlab</td><td align="center">0.50</td><td align="center">3.23</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">LIMPIC</td><td align="center">Matlab</td><td align="center">1.74</td><td align="center">1.59</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">CWT</td><td align="center">R</td><td align="center">3.31</td><td align="center">11.00</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">PROcess</td><td align="center">R</td><td align="center">4.56</td><td align="center">33.21</td></tr></tbody></table></table-wrap></sec><sec><title>Parameter Tuning</title><p>When the false discovery rate is 5%, half of true peaks are not detected; when 90% of true peaks are detected, many other identified peaks are noise peaks. We use the <italic>F</italic>1 measure to measure the performance of an algorithm by compromising between false discovery rate and sensitivity. The <italic>F</italic>1 measure is defined as:</p><p><disp-formula id="bmcM9"><label>(9)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-4-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>F</mml:mi><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>F</mml:mi><mml:mi>D</mml:mi><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x000d7;</mml:mo><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>F</mml:mi><mml:mi>D</mml:mi><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:semantics></mml:math></disp-formula></p><p>The larger <italic>F</italic>1 is, the better a parameter combination will be. We exhaustively try combination of parameters and count the numbers that a parameter combination provides the maximal <italic>F</italic>1. The parameter combination that produces the largest number of maximal <italic>F</italic>1 is considered as the best combination. We also test the peak detection precision for each algorithm with its best parameter combination. For readers who are interested in parameter settings, please refer to the additional file <xref ref-type="supplementary-material" rid="S2">2</xref> for more information.</p></sec></sec><sec><title>Conclusion</title><p>In this paper, we provide a comprehensive survey of existing peak detection methods. In addition, we compare performance of five single spectrum based peak detection algorithms. Results show that CWT provides the best performance.</p><p>The reasons that CWT provides the best performance are two-fold:</p><p>(1) CWT optimally characterizes the shape of peaks in mass spectra. In a real spectrum, peak width varies a lot [<xref ref-type="bibr" rid="B10">10</xref>]. Hence smoothing the spectrum using fixed-window filters may fail. CWT avoids the problem by performing multi-scale smoothing.</p><p>(2) True peptide-related peaks are more consistent at multiple scales than false positive peaks that are mainly caused by high frequency noise. The concept of forming ridge lines in CWT effiectively removes false positive peaks.</p><p>Algorithms studied in this paper mainly focus on how to identify peak positions correctly. They ignore how to compute peak abundance, which is very important in some applications (e.g. protein quantification). In our future work, we plan to study the issue of peak detection in LC-MS data. It will be interesting to see if additional information along the LC-axis may help to improve peak detection results.</p></sec><sec><title>Authors' contributions</title><p>CY performed the implementations and drafted the manuscript. ZH participated in the categorization of related work. WY conceived the study and finalized the manuscript. All authors read and approved the final manuscript.</p></sec><sec sec-type="supplementary-material"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="S1"><caption><title>Additional file 1</title><p><bold>Data and results</bold>. This file lists the data used in this paper and the results for the experiments.</p></caption><media xlink:href="1471-2105-10-4-S1.doc" mimetype="application" mime-subtype="msword"><caption><p>Click here for file</p></caption></media></supplementary-material><supplementary-material content-type="local-data" id="S2"><caption><title>Additional file 2</title><p><bold>Parameter setting</bold>. This file gives parameters settings in experiments for each program compared in this work.</p></caption><media xlink:href="1471-2105-10-4-S2.doc" mimetype="application" mime-subtype="msword"><caption><p>Click here for file</p></caption></media></supplementary-material></sec></body><back><ack><sec><title>Acknowledgements</title><p>We are grateful to the anonymous reviewers for their valuable comments and suggestions, which greatly helped us improve the manuscript. This work was supported with the GRF Grant 621707 from the Hong Kong Research Grant Council, a research proposal competition award RPC07/08.EG25 and a postdoctoral fellowship award from the Hong Kong University of Science and Technology.</p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Aebersold</surname><given-names>R</given-names></name><name><surname>Mann</surname><given-names>M</given-names></name></person-group><article-title>Mass spectrometry-based proteomics</article-title><source>Nature</source><year>2003</year><volume>422</volume><fpage>198</fpage><lpage>207</lpage><pub-id pub-id-type="pmid">12634793</pub-id></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gras</surname><given-names>R</given-names></name><name><surname>M&#x000fc;ller</surname><given-names>M</given-names></name><name><surname>Gasteiger</surname><given-names>E</given-names></name><name><surname>Gay</surname><given-names>S</given-names></name><name><surname>Binz</surname><given-names>PA</given-names></name><name><surname>Bienvenut</surname><given-names>W</given-names></name><name><surname>Hoogland</surname><given-names>C</given-names></name><name><surname>Sanchez</surname><given-names>JC</given-names></name><name><surname>Bairoch</surname><given-names>A</given-names></name><name><surname>Hochstrasser</surname><given-names>DF</given-names></name><name><surname>Appel</surname><given-names>RD</given-names></name></person-group><article-title>Improving protein identification from peptide mass fingerprinting through a parameterized multi-level scoring algorithm and an optimized peak detection</article-title><source>Electrophoresis</source><year>1999</year><volume>20</volume><fpage>3535</fpage><lpage>3550</lpage><pub-id pub-id-type="pmid">10612280</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Adam</surname><given-names>BL</given-names></name><name><surname>Qu</surname><given-names>Y</given-names></name><name><surname>Davis</surname><given-names>JW</given-names></name><name><surname>Ward</surname><given-names>MD</given-names></name><name><surname>Clements</surname><given-names>MA</given-names></name><name><surname>Cazares</surname><given-names>LH</given-names></name><name><surname>Semmes</surname><given-names>OJ</given-names></name><name><surname>Schellhammer</surname><given-names>PF</given-names></name><name><surname>Yasui</surname><given-names>Y</given-names></name><name><surname>Feng</surname><given-names>Z</given-names></name><name><surname>Wright</surname><given-names>GL</given-names></name></person-group><article-title>Serum protein fingerprinting coupled with a pattern-matching algorithm distinguishes prostate cancer from benign prostate hyperplasia and healthy men</article-title><source>Cancer Research</source><year>2002</year><volume>62</volume><fpage>3609</fpage><lpage>3614</lpage><pub-id pub-id-type="pmid">12097261</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Malyarenko</surname><given-names>DI</given-names></name><name><surname>Cooke</surname><given-names>WE</given-names></name><name><surname>Adam</surname><given-names>BL</given-names></name><name><surname>Malik</surname><given-names>G</given-names></name><name><surname>Chen</surname><given-names>H</given-names></name><name><surname>Tracy</surname><given-names>ER</given-names></name><name><surname>Trosset</surname><given-names>MW</given-names></name><name><surname>Sasinowski</surname><given-names>M</given-names></name><name><surname>Semmes</surname><given-names>OJ</given-names></name><name><surname>Manos</surname><given-names>DM</given-names></name></person-group><article-title>Enhancement of sensitivity and resolution of surface-enhanced laser desorption/ionization time-of-flight mass spectrometric records for serum peptides using time-series analysis techniques</article-title><source>Clinical Chemistry</source><year>2005</year><volume>51</volume><fpage>65</fpage><lpage>74</lpage><pub-id pub-id-type="pmid">15550476</pub-id></citation></ref><ref id="B5"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Oppenheim</surname><given-names>AV</given-names></name><name><surname>Schafer</surname><given-names>RW</given-names></name><name><surname>Buck</surname><given-names>JR</given-names></name></person-group><source>Discrete-time signal processing</source><year>1999</year><edition>second</edition><publisher-name>Prentice Hall</publisher-name></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Savitzky</surname><given-names>A</given-names></name><name><surname>Golay</surname><given-names>MJE</given-names></name></person-group><article-title>Smoothing and differentiation of data by simplified least squares procedures</article-title><source>Analytical Chemistry</source><year>1964</year><volume>36</volume><fpage>1627</fpage><lpage>1639</lpage></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Danielsson</surname><given-names>R</given-names></name><name><surname>Bylund</surname><given-names>D</given-names></name><name><surname>Markides</surname><given-names>KE</given-names></name></person-group><article-title>Matched filtering with background suppression for improved quality of base peak chromatograms and mass spectra in liquid chromatography-mass spectrometry</article-title><source>Analytica Chimica Acta</source><year>2002</year><volume>454</volume><fpage>167</fpage><lpage>184</lpage></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Smith</surname><given-names>CA</given-names></name><name><surname>Want</surname><given-names>EJ</given-names></name><name><surname>Maille</surname><given-names>GO</given-names></name><name><surname>Abagyan</surname><given-names>R</given-names></name><name><surname>Siuzdak</surname><given-names>G</given-names></name></person-group><article-title>XCMS: processing mass spectrometry data for metabolite profiling using nonlinear peak alignment, matching, and identification</article-title><source>Analytical Chemistry</source><year>2006</year><volume>78</volume><fpage>779</fpage><lpage>787</lpage><pub-id pub-id-type="pmid">16448051</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kaiser</surname><given-names>JF</given-names></name><name><surname>Schafer</surname><given-names>RW</given-names></name></person-group><article-title>On the use of the <italic>I</italic><sub>0</sub>-Sinh window for spectrum analysis</article-title><source>IEEE Transactions on Acoustics, Speech, and Signal Processing</source><year>1980</year><volume>28</volume><fpage>105</fpage><lpage>107</lpage></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Du</surname><given-names>P</given-names></name><name><surname>Kibbe</surname><given-names>WA</given-names></name><name><surname>Lin</surname><given-names>SM</given-names></name></person-group><article-title>Improved peak detection in mass spectrum by incorporating continuous wavelet transform-based pattern matching</article-title><source>Bioinformatics</source><year>2006</year><volume>22</volume><fpage>2059</fpage><lpage>2065</lpage><pub-id pub-id-type="pmid">16820428</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lang</surname><given-names>M</given-names></name><name><surname>Guo</surname><given-names>H</given-names></name><name><surname>Odegard</surname><given-names>JE</given-names></name><name><surname>Burrus</surname><given-names>CS</given-names></name></person-group><article-title>Noise reduction using an undecimated discrete wavelet transform</article-title><source>IEEE Signal Processing Letters</source><year>1996</year><volume>3</volume><fpage>10</fpage><lpage>12</lpage></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Coombes</surname><given-names>KR</given-names></name><name><surname>Tsavachidis</surname><given-names>S</given-names></name><name><surname>Morris</surname><given-names>JS</given-names></name><name><surname>Baggerly</surname><given-names>KA</given-names></name><name><surname>Hung</surname><given-names>MC</given-names></name><name><surname>Kuerer</surname><given-names>HM</given-names></name></person-group><article-title>Improved peak detection and quantification of mass spectrometry data acquired from surface-enhanced laser desorption and ionization by denoising spectra with the undecimated discrete wavelet transform</article-title><source>Proteomics</source><year>2005</year><volume>5</volume><fpage>4107</fpage><lpage>4117</lpage><pub-id pub-id-type="pmid">16254928</pub-id></citation></ref><ref id="B13"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Li</surname><given-names>X</given-names></name><name><surname>Gentleman</surname><given-names>R</given-names></name><name><surname>Lu</surname><given-names>X</given-names></name><name><surname>Shi</surname><given-names>Q</given-names></name><name><surname>Iglehart</surname><given-names>JD</given-names></name><name><surname>Harris</surname><given-names>L</given-names></name><name><surname>Miron</surname><given-names>A</given-names></name></person-group><article-title>SELDI-TOF mass spectrometry Protein Data</article-title><source>Bioinformatics and Computational Biology Solutions Using R and Bioconductor</source><year>2005</year><publisher-name>Springer</publisher-name><fpage>91</fpage><lpage>109</lpage></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Coombes</surname><given-names>KR</given-names></name><name><surname>Fritsche</surname><given-names>HA</given-names></name><name><surname>Clarke</surname><given-names>C</given-names></name><name><surname>Chen</surname><given-names>J</given-names></name><name><surname>Baggerly</surname><given-names>KA</given-names></name><name><surname>Morris</surname><given-names>JS</given-names></name><name><surname>Xiao</surname><given-names>L</given-names></name><name><surname>Hung</surname><given-names>M</given-names></name><name><surname>Kuerer</surname><given-names>HM</given-names></name></person-group><article-title>Quality control and peak finding for proteomics data collected from nipple aspirate fluid by surface-enhanced laser desorption and ionization</article-title><source>Clinical Chemistry</source><year>2003</year><volume>49</volume><fpage>1615</fpage><lpage>1623</lpage><pub-id pub-id-type="pmid">14500586</pub-id></citation></ref><ref id="B15"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Lange</surname><given-names>E</given-names></name><name><surname>Gropl</surname><given-names>C</given-names></name><name><surname>Reinert</surname><given-names>K</given-names></name><name><surname>Kohlbacher</surname><given-names>O</given-names></name><name><surname>Hildebrandt</surname><given-names>A</given-names></name></person-group><article-title>High-accuracy peak picking of proteomics data using wavelet techniques</article-title><source>Pac Symp Biocomput</source><year>2006</year><publisher-name>Maui, Hawaii, USA</publisher-name><fpage>243</fpage><lpage>254</lpage><pub-id pub-id-type="pmid">17094243</pub-id></citation></ref><ref id="B16"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Leptos</surname><given-names>KC</given-names></name><name><surname>Sarracino</surname><given-names>DA</given-names></name><name><surname>Jaffe</surname><given-names>JD</given-names></name><name><surname>Krastins</surname><given-names>B</given-names></name><name><surname>Church</surname><given-names>GM</given-names></name></person-group><article-title>MapQuant: Open-source software for large-scale protein quantification</article-title><source>Proteomics</source><year>2006</year><volume>6</volume><fpage>1770</fpage><lpage>1782</lpage><pub-id pub-id-type="pmid">16470651</pub-id></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Coombes</surname><given-names>KR</given-names></name><name><surname>Koomen</surname><given-names>JM</given-names></name><name><surname>Baggerly</surname><given-names>KA</given-names></name><name><surname>Morris</surname><given-names>JS</given-names></name><name><surname>Kobayashi</surname><given-names>R</given-names></name></person-group><article-title>Understanding the characteristics of mass spectrometry data through the use of simulation</article-title><source>Cancer Informatics</source><year>2005</year><volume>1</volume><fpage>41</fpage><lpage>52</lpage></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Morris</surname><given-names>JS</given-names></name><name><surname>Coombes</surname><given-names>KR</given-names></name><name><surname>Koomen</surname><given-names>J</given-names></name><name><surname>Baggerly</surname><given-names>KA</given-names></name><name><surname>Kobayashi</surname><given-names>R</given-names></name></person-group><article-title>Feature extraction and quantification for mass spectrometry in biomedical applications using the mean spectrum</article-title><source>Bioinformatics</source><year>2005</year><volume>21</volume><fpage>1764</fpage><lpage>1775</lpage><pub-id pub-id-type="pmid">15673564</pub-id></citation></ref><ref id="B19"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Falkner</surname><given-names>JA</given-names></name><name><surname>Veine</surname><given-names>DM</given-names></name><name><surname>Kachman</surname><given-names>M</given-names></name><name><surname>Walker</surname><given-names>A</given-names></name><name><surname>Strahler</surname><given-names>JR</given-names></name><name><surname>Andrews</surname><given-names>PC</given-names></name></person-group><article-title>Validated MALDI-TOF/TOF mass spectra for protein standards</article-title><source>J Am Soc Mass Spectrom</source><year>2007</year><volume>18</volume><fpage>850</fpage><lpage>855</lpage><pub-id pub-id-type="pmid">17329120</pub-id></citation></ref><ref id="B20"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Du</surname><given-names>P</given-names></name><name><surname>Sudha</surname><given-names>R</given-names></name><name><surname>Prystowsky</surname><given-names>MB</given-names></name><name><surname>Angeletti</surname><given-names>RH</given-names></name></person-group><article-title>Data reduction of isotope-resolved LC-MS spectra</article-title><source>Bioinformatics</source><year>2007</year><volume>23</volume><fpage>1394</fpage><lpage>1400</lpage><pub-id pub-id-type="pmid">17496000</pub-id></citation></ref><ref id="B21"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Mantini</surname><given-names>D</given-names></name><name><surname>Petrucci</surname><given-names>F</given-names></name><name><surname>Pieragostino</surname><given-names>D</given-names></name><name><surname>DelBoccio</surname><given-names>P</given-names></name><name><surname>Nicola</surname><given-names>MD</given-names></name><name><surname>Ilio</surname><given-names>CD</given-names></name><name><surname>Federici</surname><given-names>G</given-names></name><name><surname>Sacchetta</surname><given-names>P</given-names></name><name><surname>Comani</surname><given-names>S</given-names></name><name><surname>Urbani</surname><given-names>A</given-names></name></person-group><article-title>LIMPIC: a computational method for the separation of protein MALDI-TOF-MS signals from noise</article-title><source>BMC Bioinformatics</source><year>2007</year><volume>8</volume><fpage>101</fpage><pub-id pub-id-type="pmid">17386085</pub-id></citation></ref><ref id="B22"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Yasui</surname><given-names>Y</given-names></name><name><surname>Pepe</surname><given-names>M</given-names></name><name><surname>Thompson</surname><given-names>ML</given-names></name><name><surname>Adam</surname><given-names>BL</given-names></name><name><surname>Wright</surname><given-names>GL</given-names></name><name><surname>Qu</surname><given-names>Y</given-names></name><name><surname>Potter</surname><given-names>JD</given-names></name><name><surname>Winget</surname><given-names>M</given-names></name><name><surname>Thornquist</surname><given-names>M</given-names></name><name><surname>Feng</surname><given-names>Z</given-names></name></person-group><article-title>A data-analytic strategy for protein biomarker discovery:profiling of high-dimensional proteomic data for cancer detection</article-title><source>Biostatistics</source><year>2003</year><volume>4</volume><fpage>449</fpage><lpage>463</lpage><pub-id pub-id-type="pmid">12925511</pub-id></citation></ref><ref id="B23"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bellew</surname><given-names>M</given-names></name><name><surname>Coram</surname><given-names>M</given-names></name><name><surname>Fitzgibbon</surname><given-names>M</given-names></name><name><surname>Igra</surname><given-names>M</given-names></name><name><surname>Randolph</surname><given-names>T</given-names></name><name><surname>Wang</surname><given-names>P</given-names></name><name><surname>May</surname><given-names>D</given-names></name><name><surname>Eng</surname><given-names>J</given-names></name><name><surname>Fang</surname><given-names>R</given-names></name><name><surname>Lin</surname><given-names>CW</given-names></name><name><surname>Chen</surname><given-names>JZ</given-names></name><name><surname>Goodlett</surname><given-names>D</given-names></name><name><surname>Whiteaker</surname><given-names>J</given-names></name><name><surname>Paulovich</surname><given-names>A</given-names></name><name><surname>McIntosh</surname><given-names>M</given-names></name></person-group><article-title>A suite of algorithms for the comprehensive analysis of complex protein mixtures using high-resolution LC-MS</article-title><source>Bioinformatics</source><year>2006</year><volume>22</volume><fpage>1902</fpage><lpage>1909</lpage><pub-id pub-id-type="pmid">16766559</pub-id></citation></ref><ref id="B24"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Katajamaa</surname><given-names>M</given-names></name><name><surname>Miettinen</surname><given-names>J</given-names></name><name><surname>Oresic</surname><given-names>M</given-names></name></person-group><article-title>MZmine: Toolbox for processing and visualization of mass spectrometry based molecular profile data</article-title><source>Bioinformatics</source><year>2006</year><volume>22</volume><fpage>634</fpage><lpage>636</lpage><pub-id pub-id-type="pmid">16403790</pub-id></citation></ref><ref id="B25"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Karpievitch</surname><given-names>YV</given-names></name><name><surname>Hill</surname><given-names>EG</given-names></name><name><surname>Smolka</surname><given-names>AJ</given-names></name><name><surname>Morris</surname><given-names>JS</given-names></name><name><surname>Coombes</surname><given-names>KR</given-names></name><name><surname>Baggerly</surname><given-names>KA</given-names></name><name><surname>Almeida</surname><given-names>JS</given-names></name></person-group><article-title>PrepMS: TOF MS data graphical preprocessing tool</article-title><source>Bioinformatics</source><year>2007</year><volume>23</volume><fpage>264</fpage><lpage>265</lpage><pub-id pub-id-type="pmid">17121773</pub-id></citation></ref></ref-list></back></article>