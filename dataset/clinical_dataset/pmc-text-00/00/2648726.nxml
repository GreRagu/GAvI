<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208177</article-id><article-id pub-id-type="pmc">2648726</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S72</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S72</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Minimizing recombinations in consensus networks for phylogeographic studies</article-title></title-group><contrib-group><contrib id="A1" corresp="yes" contrib-type="author"><name><surname>Parida</surname><given-names>Laxmi</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>parida@us.ibm.com</email></contrib><contrib id="A2" contrib-type="author"><name><surname>Javed</surname><given-names>Asif</given-names></name><xref ref-type="aff" rid="I2">2</xref><xref ref-type="aff" rid="I4">4</xref><email>javeda@cs.rpi.edu</email></contrib><contrib id="A3" contrib-type="author"><name><surname>Mel&#x000e9;</surname><given-names>Marta</given-names></name><xref ref-type="aff" rid="I3">3</xref><xref ref-type="aff" rid="I4">4</xref><email>marta.mele@upf.edu</email></contrib><contrib id="A4" contrib-type="author"><name><surname>Calafell</surname><given-names>Francesc</given-names></name><xref ref-type="aff" rid="I3">3</xref><email>francesc.calafell@upf.edu</email></contrib><contrib id="A5" contrib-type="author"><name><surname>Bertranpetit</surname><given-names>Jaume</given-names></name><xref ref-type="aff" rid="I3">3</xref><email>jaume.bertranpetit@upf.edu</email></contrib><contrib id="A6" contrib-type="author"><collab>Genographic Consortium</collab></contrib></contrib-group><aff id="I1"><label>1</label>Computational Biology Center, IBM T J Watson Research, Yorktown, USA</aff><aff id="I2"><label>2</label>Department of Computer Science, Rensselaer Polytechnic Institute, New York, USA</aff><aff id="I3"><label>3</label>Biologia Evolutiva, Universitat Pompeu Fabra, Barcelona, Catalonia, Spain</aff><aff id="I4"><label>4</label>Work done during an internship at IBM T J Watson Research Center</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S72</fpage><lpage>S72</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S72"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Parida et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Parida et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Parida               Laxmi                              parida@us.ibm.com            </dc:author><dc:title>            Minimizing recombinations in consensus networks for phylogeographic studies         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S72-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S72&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>We address the problem of studying recombinational variations in (human) populations. In this paper, our focus is on one computational aspect of the general task: Given two networks <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2</sub>, with both mutation and recombination events, defined on overlapping sets of extant units the objective is to compute a consensus network <italic>G</italic><sub>3 </sub>with minimum number of additional recombinations. We describe a polynomial time algorithm with a guarantee that the number of computed new recombination events is within <italic>&#x003f5; </italic>= <italic>sz</italic>(<italic>G</italic><sub>1</sub>, <italic>G</italic><sub>2</sub>) (function <italic>sz </italic>is a well-behaved function of the sizes and topologies of <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2</sub>) of the optimal <italic>number </italic>of recombinations. To date, this is the best known result for a network consensus problem.</p></sec><sec><title>Results</title><p>Although the network consensus problem can be applied to a variety of domains, here we focus on structure of human populations. With our preliminary analysis on a segment of the human Chromosome X data we are able to infer ancient recombinations, population-specific recombinations and more, which also support the widely accepted 'Out of Africa' model. These results have been verified independently using traditional manual procedures. To the best of our knowledge, this is the first recombinations-based characterization of human populations.</p></sec><sec><title>Conclusion</title><p>We show that our mathematical model identifies recombination spots in the individual haplotypes; the aggregate of these spots over a set of haplotypes defines a recombinational landscape that has enough signal to detect continental as well as population divide based on a short segment of Chromosome X. In particular, we are able to infer ancient recombinations, population-specific recombinations and more, which also support the widely accepted 'Out of Africa' model. The agreement with mutation-based analysis can be viewed as an indirect validation of our results and the model. Since the model in principle gives us more information embedded in the networks, in our future work, we plan to investigate more non-traditional questions via these structures computed by our methodology.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>Reconstructing the recombinational history of a DNA fragment has proved to be a difficult problem and can only be achieved at small scales. Nonetheless the reconstruction of the history of long fragments, is of great interest to geneticists. Although the mutational history of adjacent fragments is independent, this is not true for recombinational history: thus merging adjoining networks add a new level of richness in complexity in terms of the suite of recombination events that shape variations within and across populations (both populations substructures as well as possible migratory history).</p><p>This paper explores the combinatorics involved in incorporating recombination events into the topology. While it is possible to give loose bounds on the number of recombination events using some convenient and clever variation of the <italic>Four Gamete Rule </italic>[<xref ref-type="bibr" rid="B1">1</xref>], the actual enumeration of the recombinations by a careful exploration of the underlying combinatorics will tighten this bound, as well as give additional information such as participating lineages, time-ordering of the recombination events and so on. However, it is important to note that the corresponding combinatorial optimization problem cannot be solved exactly unless P = NP [<xref ref-type="bibr" rid="B2">2</xref>,<xref ref-type="bibr" rid="B3">3</xref>]. Nevertheless, there have been various efforts to give a good estimate of a bound on this number (see [<xref ref-type="bibr" rid="B4">4</xref>] and citations therein).</p><p>In this paper, we address the problem of computing a consensus a pair of phylogenetic networks <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2 </sub>to give <italic>G</italic><sub>3 </sub>with a minimum number of new recombination events to jointly explain <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2</sub>. Such a network <italic>G</italic><sub>3 </sub>satisfies certain characteristics due to the very nature of its genesis: this is called a <italic>compatible </italic>network [<xref ref-type="bibr" rid="B5">5</xref>]. In this paper we presented a topology-based methodology to understand genetic variations in human haplotype data: We first cluster (possibly overlapping) haplotypes that display no evidence of recombinations and a representative haplotype of each cluster is extracted for the next phase. Then exploiting the coherence seen in such data, each haplotype is recoded using patterns of SNPs (patterns seen across different haplotypes). Finally, a network is constructed from the recoded representative haplotypes. Using a divide-and-conquer paradigm, the haplotype is segmented to give simple structures and then these individual structures are merged to give a unified topology using a DSR Scheme (see <italic>Methods</italic>). Clearly, each stage is algorithmically non-trivial, however optimizing the number of recombination events in the merging phase is a critical component. This is our focus in this paper. The interested reader is directed to [<xref ref-type="bibr" rid="B5">5</xref>] for other details including the rationale of the model.</p><p>In this paper, we analyze the performance of the DSR Scheme in two ways. Firstly, we give a mathematical evaluation of the algorithm. In other words, how far are we from the optimal number of new recombinations that explain the data? We show that the greedy polynomial time DSR based algorithm guarantees that the number of computed new recombination events is within <italic>&#x003f5; </italic>= <italic>sz</italic>(<italic>G</italic><sub>1</sub>, <italic>G</italic><sub>2</sub>) (see Eqn 2) of the optimal number of recombinations. To date, this is the best known result for a network consensus problem. Note that the computation of consensus trees (or networks) is a very battered problem in literature. Thus, although our model is derived from the special setting discussed above, the problem and its solution is of interest in a general context involving reticulation events. See for example [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B7">7</xref>]. The ideas in pair-wise consensus is easily extendible to <italic>k</italic>-wise consensus.</p><p>Secondly, we examine how well the algorithm performs on real data. We apply the method on 100 Kb segment of high SNP density in the recombining part of the X chromosome. With our preliminary analysis from a phylogeographic viewpoint, we are able to infer ancient recombinations, population-specific recombinations and more (see <italic>Experimental Results</italic>) which also support the widely accepted 'Out of Africa' model. These results are consistent with established mutation-based methods: thus this can be taken as an indirect validation of our analysis and the methodology.</p></sec><sec sec-type="methods"><title>Methods</title><p>Here we discuss the underlying mathematical model. We are given <italic>H </italic>units or extant individuals, each of which has <italic>F </italic>features. Each feature is a SNP (Single Nucleotide Polymorphism) and a unit is a haplotype. To keep the paper self-contained in this section we reproduce the notation used in [<xref ref-type="bibr" rid="B5">5</xref>]. A <italic>network G </italic>is a directed acyclic graph (DAG) and is defined as follows: It has three kinds of nodes. A node with no incoming edge is a <italic>root </italic>node and <italic>G </italic>may have multiple root nodes. A node with no outgoing edges is a <italic>leaf </italic>node. Each leaf node is labeled with nonempty sets haplotype labels. Every other node is an <italic>internal </italic>node. A node has at most two incoming edges. When a node has exactly one incoming edge, it is called a <italic>mutation node </italic>and the incoming edge is called a <italic>mutation edge</italic>. When the node has two incoming edges, the node is called a <italic>recombination </italic>or a <italic>hybrid </italic>or a <italic>reticulation </italic>node and the incoming edges are called <italic>recombination </italic>or <italic>reticulation edges</italic>. The direction of the edges is always towards the leaf nodes which in the figures in this paper is downwards. To avoid clutter, only the recombination edges display the direction as arrows.</p><p>Associated with a network <italic>G </italic>is a segmentation <italic>S</italic>. The <italic>segmentation S </italic>is a partition of the <italic>F </italic>features into some <italic>k</italic>(&#x02264; <italic>F</italic>) (nonoverlapping) subsets. When the features are ordered say as <italic>f</italic><sub>1</sub>, <italic>f</italic><sub>2</sub>, <italic>f</italic><sub>3</sub>,..., <italic>f</italic><sub><italic>F</italic></sub>, they can be simply written as the closed interval [1, <italic>F</italic>], and the segmentation is a collection of non-overlapping intervals. For example, if <italic>F </italic>= 5, a possible segmentation of interval [1,5] is: <italic>S </italic>= {[1,2], [3,4], [5,5]}. The three individual segments are <italic>s</italic><sub>1 </sub>= [1,2], <italic>s</italic><sub>2 </sub>= [3,4] and <italic>s</italic><sub>3 </sub>= [5,5] with <italic>S </italic>= {<italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>, <italic>s</italic><sub>3</sub>}. For convenience, the three segments are denoted simply by the consecutive integer labels 1, 2 and 3 and to keep clarity of exposition, <italic>S </italic>is written simply as <italic>S </italic>= {1, 2, 3}. Then each feature <italic>f </italic>is written as <italic>s</italic>: <italic>f </italic>where <italic>s </italic>is the segment label that the feature <italic>f </italic>belongs to.</p><p>For a segmentation <italic>S</italic>, the labeling of the edges of <italic>G </italic>are as follows: (1) Mutation edge: Every mutation edge <italic>e </italic>incident on a node <italic>v</italic>, has a non-empty label, <italic>lbl</italic>. Each member, <italic>s</italic>: <italic>f</italic>, of the label is interpreted as feature <italic>f </italic>in segment <italic>s</italic>. (Note that <italic>f </italic>itslf may have the form '2:3' as in Figure <xref ref-type="fig" rid="F1">1</xref>. Now, if <italic>f </italic>is associated with segment 9, the label is written as 9:2:3.) Further, each element appears at most once in an edge label in <italic>G</italic>. (2) Recombination edge: The two recombination edges, <italic>e</italic><sub>1 </sub>and <italic>e</italic><sub>2</sub>, incident on a recombination node <italic>v </italic>are labeled by sets of segment labels <italic>lbl</italic><sub>1 </sub>and <italic>lbl</italic><sub>2 </sub>with <italic>lbl</italic><sub>1</sub>&#x02260; <italic>lbl</italic><sub>2</sub>. For example <italic>lbl</italic><sub>1 </sub>= {1, 3} denoting that <italic>e</italic><sub>1 </sub>is labeled with the segment labels 1 and 3.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p>In (a) &#x00026; (b) <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2 </sub>have segmentation <italic>S </italic>= {2, 3, 4}. (b) The two parents of node 'R' have labels {4, 2} and {3, 2}. Thus, the network restricted to segment label 2, shown in (c), has a closed path defined by the nodes labeled 'Z', 'W', 'U', 'R' and 'V'. Hence the network in (b) is not compatible.</p></caption><graphic xlink:href="1471-2105-10-S1-S72-1"/></fig><p>For a segment <italic>s </italic>&#x02208; <italic>S</italic>, <italic>Restricted</italic>(<italic>G</italic>, <italic>s</italic>) is the network obtained by doing the following two operations:(1) Removing all recombination edges in <italic>G </italic>that do not have the element <italic>s </italic>in the true edge label <italic>lbl'</italic>. (2) From each mutation edge label in <italic>G</italic>, removing the elements of the form <italic>s</italic>: <italic>f</italic>, for any <italic>f</italic>, from the edge label. For a concrete example see Figures <xref ref-type="fig" rid="F1">1(b)</xref> and <xref ref-type="fig" rid="F1">1(c)</xref>. This definition is easily extended to multiple segments as <italic>Restricted</italic>(<italic>G</italic>, <italic>S'</italic>), where <italic>S' </italic>&#x02286; <italic>S</italic>.</p><p><italic>G </italic>is always associated with a segmentation <italic>S </italic>of the <italic>F </italic>features, hence written as (<italic>G</italic>, <italic>S</italic>). Note that <italic>G </italic>cannot be any arbitrary network. It must satisfy the following: for each <italic>s </italic>&#x02208; <italic>S</italic>, <italic>Restricted</italic>(<italic>G</italic>, <italic>s</italic>) is devoid of recombinations. Such a network is termed <italic>compatible</italic>. The <italic>Consensus Compatible Network Problem </italic>is defined as follows [<xref ref-type="bibr" rid="B5">5</xref>]: Given two compatible networks (<italic>G</italic><sub>1</sub>, <italic>S</italic><sub>1</sub>) and (<italic>G</italic><sub>2</sub>, <italic>S</italic><sub>2</sub>) with no common features (thus <italic>S</italic><sub>1 </sub>&#x02229; <italic>S</italic><sub>2 </sub>= &#x02205;), the task is to compute a compatible network (<italic>G</italic><sub>3</sub>, <italic>S</italic><sub>1</sub>&#x0222a; <italic>S</italic><sub>2</sub>) with the minimum number of additional recombination nodes such that (<italic>G</italic><sub>1</sub>, <italic>S</italic><sub>1</sub>) is isomorphic to <italic>Restricted</italic>(<italic>G</italic><sub>3</sub>, <italic>S</italic><sub>1</sub>) and (<italic>G</italic><sub>2</sub>, <italic>S</italic><sub>2</sub>) to <italic>Restricted</italic>(<italic>G</italic><sub>3</sub>, <italic>S</italic><sub>2</sub>).</p><p>In the remainder of the paper, we refer to (<italic>G</italic>, <italic>S</italic>) simply as <italic>G</italic>, and segmentation <italic>S </italic>will be clear from context.</p><sec><title>The Dominant Subdominant Recombinant (DSR) framework</title><p>The DSR scheme to solve the problem and its proof of correctness was presented in [<xref ref-type="bibr" rid="B5">5</xref>]. The method is an iterative, bottom-up working at one <italic>level </italic>of <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2 </sub>at a time. The level of a node is defined as the maximum distance to a leafnode.</p><p>The same level is also associated with any edge <italic>e </italic>incident on the node written as <italic>level</italic>(<italic>e, G</italic>). A leaf is at level 0. The method gets its name from the need to give one of three possible assignments, Dominant (D) or Subdominant (S) or Recombinant (R), to nodes at each iteration, which is central to this scheme.</p></sec><sec><title>Matrix <italic>X</italic><sub><italic>l</italic></sub></title><p>Let <italic>G </italic>have <italic>t </italic>roots. For root <italic>v</italic><sub><italic>i </italic></sub>introduce an incoming edge <italic>e</italic><sub><italic>i</italic></sub>, 1 &#x02264; <italic>i </italic>&#x02264; <italic>t</italic>. Then the <italic>height </italic>of <italic>G </italic>is defined as <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S72-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>t</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>level</italic>(<italic>e</italic><sub><italic>i</italic></sub>, <italic>G</italic>)). Let <italic>l</italic><sub>max </sub>(<italic>l</italic><sub>min</sub>) be the maximum (minimum) of the heights of <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2</sub>. For a fixed level <italic>l</italic>, let (<italic>i </italic>= 1, 2), <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S72-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>E</mml:mi><mml:mi>i</mml:mi><mml:mi>l</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> = {<italic>e </italic>is an edge in <italic>G</italic><sub><italic>i </italic></sub>| <italic>level</italic>(<italic>e</italic>, <italic>G</italic><sub><italic>i</italic></sub>) = <italic>l</italic>}. Then intersection <italic>n</italic><sub><italic>l </italic></sub>&#x000d7; <italic>m</italic><sub><italic>l </italic></sub>matrix <italic>X</italic><sub><italic>l </italic></sub>is defined as <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S72-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>E</mml:mi><mml:mn>1</mml:mn><mml:mi>l</mml:mi></mml:msubsup><mml:mo>&#x000d7;</mml:mo><mml:msubsup><mml:mi>E</mml:mi><mml:mn>2</mml:mn><mml:mi>l</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> and an example is shown in Fig <xref ref-type="fig" rid="F2">2</xref>. In the algorithm the intersection matrix, <italic>X</italic><sub><italic>l </italic></sub>had dimensions (<italic>n</italic><sub><italic>l </italic></sub>+ 1) &#x000d7; (<italic>m</italic><sub><italic>l </italic></sub>+ 1) as this extra last row (column) with header '-<italic>&#x003d5;</italic>-' is required to take care of elements that are not covered by the rest of the columns (or rows). An empty entry is shown as '&#x02205;'. In <italic>X</italic><sub>1 </sub>the exact entries can be computed and for <italic>X</italic><sub><italic>l</italic></sub>, <italic>l </italic>&#x0003e; 1 and the non-empty entries are identified by '{&#x000b7;}'. Further, let <italic>x</italic><sub><italic>l </italic></sub>be the number of non-empty entries in <italic>X</italic><sub><italic>l</italic></sub>. See Figure <xref ref-type="fig" rid="F2">2</xref> for an example.</p><fig position="float" id="F2"><label>Figure 2</label><caption><p>Given trees <italic>T</italic><sub>1 </sub>in (a) and <italic>T</italic><sub>2 </sub>in (b), each of height 3. (c) These two trees define <italic>X</italic><sub><italic>l</italic></sub>, 1 &#x02264; <italic>l </italic>&#x02264; 3, for each level <italic>l</italic>. Note that the entries in <italic>X</italic><sub><italic>l</italic></sub>, <italic>l </italic>&#x0003e; 1 differ in details depending on the choices the DSR algorithm makes. While '&#x02205;' denotes an empty set, '?' (including '{&#x000b7;}') could be either empty or non-empty, again depending on the choices the DSR Scheme makes.</p></caption><graphic xlink:href="1471-2105-10-S1-S72-2"/></fig></sec><sec><title>DSR assignment rules</title><p>The non-empty entries of <italic>X</italic><sub><italic>l </italic></sub>are given a DSR assignment. Note that at least two conditions are required for a viable compatible network <italic>G</italic><sub>3</sub>. (Rule 1): Each row (column) in matrix <italic>X</italic><sub><italic>l </italic></sub>has at most one dominant. If the row (column) has no dominant, then it has at most one subdominant. (Rule 2): A non-recombinant element can have another non-recombinant in its row or its column but not both. As a result of the DSR assignments to the entries on <italic>X</italic><sub><italic>l</italic></sub>, the rows and columns also get implicitly assigned as follows. A row (column) that has a dominant entry is assigned dominant. A row (column) that is not assigned dominant but has a subdominant in the row (column) gets assigned subdominant. A row (column) that has only recombinants in the row (column) is assigned recombinant. Note that only dominant rows (columns) contribute to entries in <italic>X</italic><sub><italic>l</italic>'</sub>, <italic>l' </italic>&#x0003e; <italic>l</italic>. Figures <xref ref-type="fig" rid="F4">4</xref> and <xref ref-type="fig" rid="F5">5</xref> give two different assignments giving the two different networks in Figure <xref ref-type="fig" rid="F3">3</xref> (a) and (b) respectively. Using a simple <italic>greedy </italic>optimization approach, we include a third rule. (Rule 3): Minimize the number of recombinants in <italic>X</italic><sub><italic>l</italic></sub>. Complete examples are worked out in Figures <xref ref-type="fig" rid="F4">4</xref>, <xref ref-type="fig" rid="F5">5</xref>, <xref ref-type="fig" rid="F6">6</xref> and <xref ref-type="fig" rid="F7">7</xref> for the interested reader.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p>(a) &#x00026; (b) Two possible consensus networks <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2 </sub>for two input trees <italic>T</italic><sub>1 </sub>and <italic>T</italic><sub>2 </sub>of Figure 2. (c) The edge labels of <italic>G</italic><sub>2 </sub>have been locally shuffled keeping the exact same topology.</p></caption><graphic xlink:href="1471-2105-10-S1-S72-3"/></fig><fig position="float" id="F4"><label>Figure 4</label><caption><p><italic>X</italic>-matrices of Network <italic>G</italic><sub>1 </sub>of Figure 3(a). The <italic>X</italic><sub><italic>l </italic></sub>matrix is shown on the top and the DSR assignment shown in the bottom row for each <italic>l</italic>, 1 &#x02264; <italic>l </italic>&#x02264; 3.</p></caption><graphic xlink:href="1471-2105-10-S1-S72-4"/></fig><fig position="float" id="F5"><label>Figure 5</label><caption><p><italic>X</italic>-matrices of Network <italic>G</italic><sub>2 </sub>of Figure 3(b). Also see Figure 4 for a description of the matrices.</p></caption><graphic xlink:href="1471-2105-10-S1-S72-5"/></fig><fig position="float" id="F6"><label>Figure 6</label><caption><p>Consensus of a tree and a network.</p></caption><graphic xlink:href="1471-2105-10-S1-S72-6"/></fig><fig position="float" id="F7"><label>Figure 7</label><caption><p>Stepwise construction of <italic>G</italic><sub>3 </sub>of Figure 6(c) as consensus of <italic>T</italic><sub>1 </sub>and <italic>G</italic><sub>2</sub>: (a)&#x02013;(e) The <italic>X </italic>matrices and the DSR assignments. (f)&#x02013;(j) The construction of <italic>G</italic><sub>3 </sub>using the DSR assignments of (a)&#x02013;(e).</p></caption><graphic xlink:href="1471-2105-10-S1-S72-7"/></fig></sec><sec><title>Approximation factor of the greedy DSR scheme</title><p>In this section, we compute the approximation factor [<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>] of the greedy version of the DSR Scheme. Let the number of new recombination events produced by the DSR algorithm in <italic>G</italic><sub>3 </sub>be <italic>N</italic><sub>DSR</sub>. Let the optimal number of new recombinations be <italic>N</italic><sub>opt</sub>. We use the following definition of the true approximation factor:</p><p><disp-formula id="bmcM1"><label>(1)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S72-i4" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>a</mml:mi>                           <mml:mi>p</mml:mi>                           <mml:mi>p</mml:mi>                           <mml:mi>r</mml:mi>                           <mml:mi>o</mml:mi>                           <mml:msub>                              <mml:mi>x</mml:mi>                              <mml:mrow>                                 <mml:mi>t</mml:mi>                                 <mml:mi>r</mml:mi>                                 <mml:mi>u</mml:mi>                                 <mml:mi>e</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>N</mml:mi>                                    <mml:mrow>                                       <mml:mtext>DSR</mml:mtext>                                    </mml:mrow>                                 </mml:msub>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:msub>                                    <mml:mi>N</mml:mi>                                    <mml:mrow>                                       <mml:mtext>opt</mml:mtext>                                    </mml:mrow>                                 </mml:msub>                              </mml:mrow>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>N</mml:mi>                                    <mml:mrow>                                       <mml:mtext>opt</mml:mtext>                                    </mml:mrow>                                 </mml:msub>                              </mml:mrow>                           </mml:mfrac>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>For given graphs <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2 </sub>let <italic>z</italic><sub><italic>l </italic></sub>= max(<italic>n</italic><sub><italic>l</italic></sub>, <italic>m</italic><sub><italic>l</italic></sub>) where <italic>n</italic><sub><italic>l </italic></sub>&#x0003e; 0 and <italic>m</italic><sub><italic>l </italic></sub>&#x0003e; 0 are the number of nodes at level <italic>l </italic>in <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2 </sub>respectively. Further, let <italic>Z </italic>be the sum of all <italic>z</italic><sub><italic>l </italic></sub>over all the levels (excluding the leaf level). Let <italic>L</italic><sub><italic>v</italic></sub>(<italic>G</italic>) be all the leafnodes (extant units) reachable from node <italic>v </italic>in <italic>G</italic>. For each level, <italic>l </italic>&#x0003e; 0, i.e. excluding the leafnodes, consider <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S72-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>G</italic><sub>1</sub>), 1 &#x02264; <italic>i </italic>&#x02264; <italic>n</italic><sub><italic>l</italic></sub>, where each <italic>v</italic><sub><italic>i </italic></sub>is at level <italic>l </italic>in <italic>G</italic><sub>1</sub>. Similarly consider <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S72-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>G</italic><sub>2</sub>), 1 &#x02264; <italic>i </italic>&#x02264; <italic>m</italic><sub><italic>l</italic></sub>, where each <italic>u</italic><sub><italic>i </italic></sub>is at level <italic>l </italic>in <italic>G</italic><sub>2</sub>. Let <italic>x</italic><sub><italic>l </italic></sub>be the number of non-empty intersections between the two collection of sets and let <italic>Y </italic>be the sum of <italic>x</italic><sub><italic>l </italic></sub>over all the levels (excluding leaf level). Note that if <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2 </sub>are the same (isomorphic) graphs then <italic>Y </italic>= <italic>Z </italic>and <italic>N</italic><sub>opt </sub>= 0.</p></sec><sec><title>Theorem 1</title><p><disp-formula id="bmcM2"><label>(2)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S72-i7" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>a</mml:mi>                           <mml:mi>p</mml:mi>                           <mml:mi>p</mml:mi>                           <mml:mi>r</mml:mi>                           <mml:mi>o</mml:mi>                           <mml:msub>                              <mml:mi>x</mml:mi>                              <mml:mrow>                                 <mml:mi>t</mml:mi>                                 <mml:mi>r</mml:mi>                                 <mml:mi>u</mml:mi>                                 <mml:mi>e</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo>&#x02264;</mml:mo>                           <mml:mfrac>                              <mml:mi>Z</mml:mi>                              <mml:mrow>                                 <mml:mi>max</mml:mi>                                 <mml:mo>&#x02061;</mml:mo>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo>,</mml:mo>                                 <mml:mi>Y</mml:mi>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:mi>Z</mml:mi>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mrow>                           </mml:mfrac>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p><italic>Proof: </italic>Let <italic>N</italic><sub>max </sub>(<italic>N</italic><sub>min</sub>) be the maximum (minimum) number of new recombinations produced by the DSR scheme over all possible DSR assignments. Then we first show the following:</p><p><disp-formula id="bmcM3"><label>(3)</label><italic>N</italic><sub>min</sub>&#x02264; <italic>N</italic><sub>opt</sub>&#x02264; <italic>N</italic><sub>DSR</sub>&#x02264; <italic>N</italic><sub>max</sub>.</disp-formula></p><p>Clearly <italic>N</italic><sub>opt</sub>&#x02264; <italic>N</italic><sub>max </sub>holds (else it contradicts the optimality of <italic>N</italic><sub>opt</sub>). Next we have to show that <italic>N</italic><sub>min </sub>&#x02264; <italic>N</italic><sub>opt </sub>holds as well. For this we need a few more characterizations of the network.</p></sec><sec><title>Recombination node descriptor <italic>F</italic><sub>1</sub>|<italic>F</italic><sub>2</sub></title><p>Let <italic>Y </italic>be the set all given haplotypes (or taxa). A <italic>split </italic>or <italic>bipartition </italic>is written as <italic>Z</italic><sub>1</sub>|<italic>Z</italic><sub>2 </sub>where <italic>Z</italic><sub>1 </sub>and <italic>Z</italic><sub>2 </sub>are nonoverlapping subsets of <italic>Y </italic>with <italic>Y </italic>= <italic>Z</italic><sub>1</sub>&#x0222a; <italic>Z</italic><sub>2</sub>. A <italic>tripartition Z</italic><sub>1</sub>|<italic>Z</italic><sub>2</sub>|<italic>Z</italic><sub>3 </sub>is defined similarly. In earlier works (see [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B2">2</xref>] and citations therein) a mutation event has been associated with a bipartition of <italic>Y </italic>and a recombination event with a tripartition. However, the latter requires certain restrictions in the form of network <italic>G</italic>, i.e., a recombination node cannot be a direct descendent of another recombination node. Here we define recombination nodes as a bipartition of an appropriate subset of features.</p><p>For a fixed segment <italic>s</italic>, let <italic>s</italic>-path be a path in the graph with mutation edge(s) and recombinant edge(s) with <italic>s </italic>in its label. For any <italic>v</italic>, note that there is a unique <italic>s</italic>-path from a root to <italic>v</italic>. Further, let <italic>v </italic>be a recombination node and <italic>lbl</italic><sub>1 </sub>and <italic>lbl</italic><sub>2 </sub>be the labels of the two incoming (recombination) edges <italic>u</italic><sub>1</sub><italic>v </italic>and <italic>u</italic><sub>2</sub><italic>v </italic>respectively. For <italic>s</italic><sub>1 </sub>&#x02208; <italic>lbl</italic><sub>1 </sub>but <italic>s</italic><sub>1 </sub>&#x02209; <italic>lbl</italic><sub>2</sub>, let feature <italic>f</italic><sub>1 </sub>be such that <italic>s</italic><sub>1 </sub>: <italic>f</italic><sub>1 </sub>is in the label of the closest mutation edge on the <italic>s</italic><sub>1</sub>-path from <italic>v</italic>. Then <italic>F</italic><sub>1 </sub>is the set of all such features. <italic>F</italic><sub>2 </sub>is defined similarly. For example in <italic>G</italic><sub>1 </sub>of Figure <xref ref-type="fig" rid="F1">1(a)</xref>, consider the recombination leafnode labeled with haplotype <italic>a</italic>. Here <italic>lbl</italic><sub>1 </sub>= {2}, <italic>lbl</italic><sub>2 </sub>= {3} and the descriptor for this node is <italic>F</italic><sub>1</sub>|<italic>F</italic><sub>2 </sub>= {2:4}|{3:5}. For the recombination node labeled 'R', <italic>lbl</italic><sub>1 </sub>= {4}, <italic>lbl</italic><sub>2 </sub>= {2, 3} and the descriptor is <italic>F</italic><sub>1</sub>|<italic>F</italic><sub>2 </sub>= {4:7} | {2:9, 3:8}.</p></sec><sec><title>Isomorphism (<italic>G</italic><sub>1 </sub>&#x02261; <italic>G</italic><sub>2</sub>))</title><p>Let <italic>L</italic><sub><italic>v</italic></sub>(<italic>G</italic>) be all the leafnodes (extant units) reachable from node <italic>v</italic>. Let <italic>s</italic>: <italic>f </italic>be in the label of the unique incoming edge on mutation node <italic>v </italic>and then let <italic>L</italic><sub><italic>s</italic>: <italic>f </italic></sub>(<italic>G</italic>) be the same as <italic>L</italic><sub><italic>v</italic></sub>. Two compatible networks <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2 </sub>on the same segmentation <italic>S </italic>are <italic>isomorphic </italic>(or identical), written as <italic>G</italic><sub>1 </sub>&#x02261; <italic>G</italic><sub>2</sub>, if the following two conditions hold: (1) For each element <italic>s</italic>: <italic>f </italic>in <italic>G</italic><sub>1</sub>, <italic>L</italic><sub><italic>s</italic>: <italic>f </italic></sub>(<italic>G</italic><sub>1</sub>) = <italic>L</italic><sub><italic>s</italic>: <italic>f </italic></sub>(<italic>G</italic><sub>2</sub>) and viceversa, and, (2) For each recombination node <italic>v </italic>in <italic>G</italic><sub>1 </sub>with descriptor <italic>F</italic><sub>1</sub>|<italic>F</italic><sub>2</sub>, there exists a recombination node in <italic>G</italic><sub>2 </sub>with the same descriptor and viceversa.</p></sec><sec><title>Canonical form</title><p>It is possible to bubble <italic>up </italic>or <italic>down </italic>an element in the mutation edge label to obtain <italic>G' </italic>such that <italic>G' </italic>&#x02261; <italic>G</italic>. Our convention will be to bubble <italic>down </italic>the element of the mutation edge label, towards a leafnode. A network <italic>G </italic>is in the <italic>canonical form </italic>(1) if no node has only one outgoing edge and (2) if no element of any mutation edge label can be bubbled down to obtain <italic>G' </italic>with <italic>G' </italic>&#x02261; <italic>G</italic>. For example see Figure <xref ref-type="fig" rid="F3">3</xref>. Since the levels of nodes in a canonical network are unique, the following can be readily verified (see also concrete examples in Figures <xref ref-type="fig" rid="F2">2</xref> and <xref ref-type="fig" rid="F6">6</xref>).</p><p><bold>Lemma 1 </bold><italic>Let G</italic><sub>3 </sub><italic>be the consensus of G</italic><sub>1 </sub><italic>and G</italic><sub>2 </sub><italic>which are in canonical forms, with l</italic><sub>max </sub><italic>(l</italic><sub>min</sub><italic>) as the maximum (minimum) of the heights of G</italic><sub>1 </sub><italic>and G</italic><sub>2</sub>. <italic>Then there exist some X-matrices, X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>,..., <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S72-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula><italic>whose DSR assignments produce G</italic><sub>3</sub>. <italic>This is written as G</italic><sub>3 </sub>&#x02245;<italic> X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ...,<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S72-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>.</p><p><italic>Back to the proof: </italic>We have to show that <italic>N</italic><sub>min </sub>&#x02264; <italic>N</italic><sub>opt </sub>holds. Assume the contrary, i.e., <italic>N</italic><sub>opt </sub>&#x0003c;<italic>N</italic><sub>min</sub>. In other words, the optimal number of new recombinations is even lower than the minimum produced by the algorithm over all possible choices. Then consider this network <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S72-i9" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>G</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> with <italic>N</italic><sub>opt </sub>new recombinations. Then by Lemma 1, there exist a sequence of <italic>X</italic>-matrices <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S72-i9" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>G</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> &#x02245; <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S72-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> with some DSR assignments for each <italic>X</italic><sub><italic>l</italic></sub>. Thus by these choices of the algorithm <italic>N</italic><sub>min </sub>&#x02264; <italic>N</italic><sub>opt </sub>must hold, again leading to a contradiction.</p><p>Hence <italic>N</italic><sub>opt </sub>&#x0226e; <italic>N</italic><sub>min</sub>. Here ends the proof of correctness of Eqn 3. Next, we give a few characterizations of</p><p>the DSR assignment to facilitate the counting of the new recombinations.</p></sec><sec><title>Type I &#x00026; II (new) recombination events</title><p>Let <italic>v </italic>be a recombination node in <italic>G</italic><sub>3 </sub>with labels <italic>lbl</italic><sub>1 </sub>and <italic>lbl</italic><sub>2 </sub>on the two incoming edges and descriptor <italic>F</italic><sub>1</sub>|<italic>F</italic><sub>2</sub>. The recombination event is <italic>new </italic>if, without loss of generality, <italic>lbl</italic><sub>1</sub>&#x02286; <italic>S</italic><sub>1 </sub>and <italic>lbl</italic><sub>2</sub>&#x02286; <italic>S</italic><sub>2</sub>. In other words, this recombination node is a result of the consensus of <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2 </sub>(and not a recombination that existed in <italic>G</italic><sub>1 </sub>or <italic>G</italic><sub>2</sub>). A new recombination node <italic>v </italic>is of two types: Let <italic>e</italic><sub>1 </sub>(<italic>e</italic><sub>2</sub>) be a mutation edge in <italic>G</italic><sub>1 </sub>(<italic>G</italic><sub>2</sub>) with a label in <italic>F</italic><sub>1 </sub>(<italic>F</italic><sub>2</sub>). Without loss of generality, let <italic>level</italic>(<italic>e</italic><sub>1</sub>, <italic>G</italic><sub>1</sub>) = <italic>l</italic>. Then the recombination is of Type I at level <italic>l </italic>if <italic>level</italic>(<italic>e</italic><sub>2</sub>, <italic>G</italic><sub>2</sub>) = <italic>l </italic>and is of Type II at level <italic>l </italic>if <italic>level</italic>(<italic>e</italic><sub>2</sub>, <italic>G</italic><sub>2</sub>) &#x0003e; <italic>l</italic>. Further, let the number of (non-empty) entries assigned dominant be <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-S1-S72-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>D</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>, subdominant be <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-10-S1-S72-i11" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>S</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> and recombinant be <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-10-S1-S72-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>R</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> in an <italic>X</italic>-matrix <italic>X</italic><sub><italic>l</italic></sub>. Then the following can be verified.</p><p><bold>Lemma 2 </bold><italic>The number of Type I recombination events at level l in G</italic><sub>3 </sub><italic>is </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1471-2105-10-S1-S72-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>R</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>. <italic>The number of Type II recombination events at level l in G</italic><sub>3 </sub><italic>is </italic>&#x02264; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17" name="1471-2105-10-S1-S72-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>D</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>S</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>. <italic>Also, the number of recombination events in a network is bounded below (N</italic><sub>min</sub><italic>) by the number of Type I recombination events and above (N</italic><sub>max</sub><italic>) by the sum of the number of Type I and Type II recombination events</italic>.</p></sec><sec><title>Islands in <italic>X</italic></title><p>We now give tighter bounds on <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18" name="1471-2105-10-S1-S72-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>D</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19" name="1471-2105-10-S1-S72-i11" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>S</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20" name="1471-2105-10-S1-S72-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>R</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> for our analysis. Consider a bipartite graph <italic>B</italic>(<italic>V, E</italic>) with <italic>V </italic>partitioned into (1) <italic>n</italic><sub><italic>l </italic></sub>nodes, corresponding to the rows and (2) <italic>m</italic><sub><italic>l </italic></sub>nodes corresponding to the columns of <italic>X</italic><sub><italic>l</italic></sub>. The adjacency matrix <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M21" name="1471-2105-10-S1-S72-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>X</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> is obtained from <italic>X</italic><sub><italic>l </italic></sub>where an empty set entry is replaced with 0 and a non-empty set entry with 1. Let the number of connected components [<xref ref-type="bibr" rid="B10">10</xref>] of graph <italic>B</italic>(<italic>V, E</italic>) be <italic>C</italic><sub><italic>l</italic></sub>. Each connected component corresponds to an <italic>island </italic>in <italic>X</italic><sub><italic>l </italic></sub>which is a collection of rows and columns of <italic>X</italic><sub><italic>l</italic></sub>. Thus <italic>X</italic><sub><italic>l </italic></sub>is fragmented into <italic>C</italic><sub><italic>l </italic></sub>islands, <italic>X</italic><sub><italic>l</italic>,<italic>i</italic></sub>, written as: <italic>X</italic><sub><italic>l </italic></sub>= <italic>X</italic><sub><italic>l</italic>,1 </sub>+ <italic>X</italic><sub><italic>l</italic>,2 </sub>+ ... + <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M22" name="1471-2105-10-S1-S72-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>. See Figure <xref ref-type="fig" rid="F8">8</xref> for an example. Note that this fragmentation is for analysis purposes only. Further, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M23" name="1471-2105-10-S1-S72-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>, for any <italic>y</italic><sub><italic>l</italic>,<italic>i</italic></sub>, will be written simply as <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M24" name="1471-2105-10-S1-S72-i17" overflow="scroll"><mml:semantics><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>. Let island <italic>X</italic><sub><italic>l</italic>,<italic>i </italic></sub>have <italic>x</italic><sub><italic>l</italic>,<italic>i </italic></sub>non-empty entries and let the number of entries assigned <italic>Y </italic>(<italic>D </italic>or <italic>S </italic>or <italic>R</italic>) in <italic>X</italic><sub><italic>l</italic>,<italic>i </italic></sub>be <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M25" name="1471-2105-10-S1-S72-i18" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mi>Y</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>. Within an island the number of non-recombinants cannot exceed max(<italic>n</italic><sub><italic>l</italic>,<italic>i</italic></sub>, <italic>m</italic><sub><italic>l</italic>,<italic>i</italic></sub>) by Rules 1 and 2.</p><fig position="float" id="F8"><label>Figure 8</label><caption><p>(a) <italic>X</italic><sub><italic>l </italic></sub>has five rows and six columns. (b) The rows and columns have been permuted (shuffled) to reveal the three islands (or three connected components in the associated bipartite graph).</p></caption><graphic xlink:href="1471-2105-10-S1-S72-8"/></fig><p><bold>Lemma 3 </bold><italic>For each island X</italic><sub><italic>l</italic>,<italic>i</italic></sub>:</p><p><disp-formula id="bmcM4"><label>(4)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M26" name="1471-2105-10-S1-S72-i19" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msubsup>                              <mml:mi>n</mml:mi>                              <mml:mrow>                                 <mml:mi>l</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>i</mml:mi>                              </mml:mrow>                              <mml:mi>D</mml:mi>                           </mml:msubsup>                           <mml:mo>+</mml:mo>                           <mml:msubsup>                              <mml:mi>n</mml:mi>                              <mml:mrow>                                 <mml:mi>l</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>i</mml:mi>                              </mml:mrow>                              <mml:mi>S</mml:mi>                           </mml:msubsup>                           <mml:mo>=</mml:mo>                           <mml:mi>max</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:msub>                              <mml:mi>n</mml:mi>                              <mml:mrow>                                 <mml:mi>l</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>i</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo>,</mml:mo>                           <mml:msub>                              <mml:mi>m</mml:mi>                              <mml:mrow>                                 <mml:mi>l</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>i</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>,</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p><disp-formula id="bmcM5"><label>(5)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M27" name="1471-2105-10-S1-S72-i20" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msubsup>                              <mml:mi>n</mml:mi>                              <mml:mrow>                                 <mml:mi>l</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>i</mml:mi>                              </mml:mrow>                              <mml:mi>R</mml:mi>                           </mml:msubsup>                           <mml:mo>=</mml:mo>                           <mml:msub>                              <mml:mi>x</mml:mi>                              <mml:mrow>                                 <mml:mi>l</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>i</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo>&#x02212;</mml:mo>                           <mml:mi>max</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:msub>                              <mml:mi>n</mml:mi>                              <mml:mrow>                                 <mml:mi>l</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>i</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo>,</mml:mo>                           <mml:msub>                              <mml:mi>m</mml:mi>                              <mml:mrow>                                 <mml:mi>l</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>i</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>Eqn 4 follows from using Rule 3 in island <italic>X</italic><sub><italic>l</italic>,<italic>i </italic></sub>and Eqn 5 from <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M28" name="1471-2105-10-S1-S72-i21" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>n</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mi>D</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>n</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>n</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mi>R</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>.</p><p><italic>Back to the proof: </italic>Next, let <italic>N</italic><sub><italic>c </italic>max</sub>(&#x02265; <italic>N</italic><sub>max</sub>) and <italic>N</italic><sub><italic>c </italic>min</sub>(&#x02264; <italic>N</italic><sub>min</sub>) be some computable functions of the input (see Figure <xref ref-type="fig" rid="F9">9</xref>). Using Lemmas 2 and 3, we define appropriate (computable) <italic>N</italic><sub><italic>c </italic>max</sub>and <italic>N</italic><sub><italic>c </italic>min</sub>as follows:</p><fig position="float" id="F9"><label>Figure 9</label><caption><p>The relative positions of the different counts on the real line. See text for details.</p></caption><graphic xlink:href="1471-2105-10-S1-S72-9"/></fig><p><disp-formula id="bmcM6"><label>(6)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M29" name="1471-2105-10-S1-S72-i22" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>N</mml:mi>                              <mml:mrow>                                 <mml:mi>max</mml:mi>                                 <mml:mo>&#x02061;</mml:mo>                              </mml:mrow>                           </mml:msub>                           <mml:mo>&#x02264;</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mi>l</mml:mi>                                 <mml:mrow>                                    <mml:msub>                                       <mml:mi>l</mml:mi>                                       <mml:mrow>                                          <mml:mi>min</mml:mi>                                          <mml:mo>&#x02061;</mml:mo>                                       </mml:mrow>                                    </mml:msub>                                 </mml:mrow>                              </mml:munderover>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>x</mml:mi>                                    <mml:mi>l</mml:mi>                                 </mml:msub>                                 <mml:mo>=</mml:mo>                                 <mml:msub>                                    <mml:mi>N</mml:mi>                                    <mml:mrow>                                       <mml:mi>c</mml:mi>                                       <mml:mi>max</mml:mi>                                       <mml:mo>&#x02061;</mml:mo>                                    </mml:mrow>                                 </mml:msub>                              </mml:mrow>                           </mml:mstyle>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p><disp-formula id="bmcM7"><label>(7)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M30" name="1471-2105-10-S1-S72-i23" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mtable>                              <mml:mtr>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>N</mml:mi>                                          <mml:mrow>                                             <mml:mi>min</mml:mi>                                             <mml:mo>&#x02061;</mml:mo>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo>=</mml:mo>                                       <mml:mstyle displaystyle="true">                                          <mml:munderover>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>l</mml:mi>                                                <mml:mo>,</mml:mo>                                                <mml:mi>i</mml:mi>                                             </mml:mrow>                                             <mml:mrow>                                                <mml:msub>                                                   <mml:mi>l</mml:mi>                                                   <mml:mrow>                                                      <mml:mi>min</mml:mi>                                                      <mml:mo>&#x02061;</mml:mo>                                                   </mml:mrow>                                                </mml:msub>                                             </mml:mrow>                                          </mml:munderover>                                          <mml:mrow>                                             <mml:msubsup>                                                <mml:mi>n</mml:mi>                                                <mml:mrow>                                                   <mml:mi>l</mml:mi>                                                   <mml:mo>,</mml:mo>                                                   <mml:mi>i</mml:mi>                                                </mml:mrow>                                                <mml:mi>R</mml:mi>                                             </mml:msubsup>                                          </mml:mrow>                                       </mml:mstyle>                                       <mml:mo>=</mml:mo>                                       <mml:mstyle displaystyle="true">                                          <mml:munderover>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>l</mml:mi>                                                <mml:mo>,</mml:mo>                                                <mml:mi>i</mml:mi>                                             </mml:mrow>                                             <mml:mrow>                                                <mml:msub>                                                   <mml:mi>l</mml:mi>                                                   <mml:mrow>                                                      <mml:mi>min</mml:mi>                                                      <mml:mo>&#x02061;</mml:mo>                                                   </mml:mrow>                                                </mml:msub>                                             </mml:mrow>                                          </mml:munderover>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>x</mml:mi>                                                <mml:mrow>                                                   <mml:mi>l</mml:mi>                                                   <mml:mo>,</mml:mo>                                                   <mml:mi>i</mml:mi>                                                </mml:mrow>                                             </mml:msub>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mi>max</mml:mi>                                             <mml:mo>&#x02061;</mml:mo>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>n</mml:mi>                                                <mml:mrow>                                                   <mml:mi>l</mml:mi>                                                   <mml:mo>,</mml:mo>                                                   <mml:mi>i</mml:mi>                                                </mml:mrow>                                             </mml:msub>                                             <mml:mo>,</mml:mo>                                             <mml:msub>                                                <mml:mi>m</mml:mi>                                                <mml:mrow>                                                   <mml:mi>l</mml:mi>                                                   <mml:mo>,</mml:mo>                                                   <mml:mi>i</mml:mi>                                                </mml:mrow>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:mo>&#x02265;</mml:mo>                                       <mml:mstyle displaystyle="true">                                          <mml:munderover>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mi>l</mml:mi>                                             <mml:mrow>                                                <mml:msub>                                                   <mml:mi>l</mml:mi>                                                   <mml:mrow>                                                      <mml:mi>min</mml:mi>                                                      <mml:mo>&#x02061;</mml:mo>                                                   </mml:mrow>                                                </mml:msub>                                             </mml:mrow>                                          </mml:munderover>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>x</mml:mi>                                                <mml:mi>l</mml:mi>                                             </mml:msub>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mstyle displaystyle="true">                                                <mml:munderover>                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mi>l</mml:mi>                                                   <mml:mrow>                                                      <mml:msub>                                                         <mml:mi>l</mml:mi>                                                         <mml:mrow>                                                            <mml:mi>min</mml:mi>                                                            <mml:mo>&#x02061;</mml:mo>                                                         </mml:mrow>                                                      </mml:msub>                                                   </mml:mrow>                                                </mml:munderover>                                                <mml:mrow>                                                   <mml:mi>max</mml:mi>                                                   <mml:mo>&#x02061;</mml:mo>                                                   <mml:mo stretchy="false">(</mml:mo>                                                   <mml:msub>                                                      <mml:mi>n</mml:mi>                                                      <mml:mi>l</mml:mi>                                                   </mml:msub>                                                   <mml:mo>,</mml:mo>                                                   <mml:msub>                                                      <mml:mi>m</mml:mi>                                                      <mml:mi>l</mml:mi>                                                   </mml:msub>                                                   <mml:mo stretchy="false">)</mml:mo>                                                   <mml:mo>=</mml:mo>                                                   <mml:msub>                                                      <mml:mi>N</mml:mi>                                                      <mml:mrow>                                                         <mml:mi>c</mml:mi>                                                         <mml:mi>min</mml:mi>                                                         <mml:mo>&#x02061;</mml:mo>                                                      </mml:mrow>                                                   </mml:msub>                                                </mml:mrow>                                             </mml:mstyle>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                           </mml:mtable>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>Note that the greedy Rule 3 encourages fragmentation of <italic>X</italic><sub><italic>l</italic></sub>, <italic>l </italic>&#x0003e; 1, into islands and under the best case scenario we get <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M31" name="1471-2105-10-S1-S72-i24" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>D</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>n</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mi>l</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>min</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>, which is used in Eqn 7 above. Finally, using Eqn 1, we have</p><p><disp-formula id="bmcM8"><label>(8)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M32" name="1471-2105-10-S1-S72-i25" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mtable>                              <mml:mtr>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:mi>a</mml:mi>                                       <mml:mi>p</mml:mi>                                       <mml:mi>p</mml:mi>                                       <mml:mi>r</mml:mi>                                       <mml:mi>o</mml:mi>                                       <mml:msub>                                          <mml:mi>x</mml:mi>                                          <mml:mrow>                                             <mml:mi>t</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mi>u</mml:mi>                                             <mml:mi>e</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo>=</mml:mo>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>N</mml:mi>                                                <mml:mrow>                                                   <mml:mtext>DSR</mml:mtext>                                                </mml:mrow>                                             </mml:msub>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:msub>                                                <mml:mi>N</mml:mi>                                                <mml:mrow>                                                   <mml:mtext>opt</mml:mtext>                                                </mml:mrow>                                             </mml:msub>                                          </mml:mrow>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>N</mml:mi>                                                <mml:mrow>                                                   <mml:mtext>opt</mml:mtext>                                                </mml:mrow>                                             </mml:msub>                                          </mml:mrow>                                       </mml:mfrac>                                       <mml:mo>&#x02264;</mml:mo>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>N</mml:mi>                                                <mml:mrow>                                                   <mml:mi>c</mml:mi>                                                   <mml:mi>max</mml:mi>                                                   <mml:mo>&#x02061;</mml:mo>                                                </mml:mrow>                                             </mml:msub>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:msub>                                                <mml:mi>N</mml:mi>                                                <mml:mrow>                                                   <mml:mi>c</mml:mi>                                                   <mml:mi>min</mml:mi>                                                   <mml:mo>&#x02061;</mml:mo>                                                </mml:mrow>                                             </mml:msub>                                          </mml:mrow>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>N</mml:mi>                                                <mml:mrow>                                                   <mml:mi>c</mml:mi>                                                   <mml:mi>min</mml:mi>                                                   <mml:mo>&#x02061;</mml:mo>                                                </mml:mrow>                                             </mml:msub>                                          </mml:mrow>                                       </mml:mfrac>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:mo>&#x02248;</mml:mo>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>N</mml:mi>                                                <mml:mrow>                                                   <mml:mi>c</mml:mi>                                                   <mml:mi>max</mml:mi>                                                   <mml:mo>&#x02061;</mml:mo>                                                </mml:mrow>                                             </mml:msub>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:msub>                                                <mml:mi>N</mml:mi>                                                <mml:mrow>                                                   <mml:mi>c</mml:mi>                                                   <mml:mi>min</mml:mi>                                                   <mml:mo>&#x02061;</mml:mo>                                                </mml:mrow>                                             </mml:msub>                                          </mml:mrow>                                          <mml:mrow>                                             <mml:mi>max</mml:mi>                                             <mml:mo>&#x02061;</mml:mo>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mn>1</mml:mn>                                             <mml:mo>,</mml:mo>                                             <mml:msub>                                                <mml:mi>N</mml:mi>                                                <mml:mrow>                                                   <mml:mi>c</mml:mi>                                                   <mml:mi>min</mml:mi>                                                   <mml:mo>&#x02061;</mml:mo>                                                </mml:mrow>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mfrac>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                           </mml:mtable>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>The correctness of Eqn 2 is established by setting <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M33" name="1471-2105-10-S1-S72-i26" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>Z</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>min</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M34" name="1471-2105-10-S1-S72-i27" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mi>l</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>min</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>. Here ends the proof.</p></sec></sec><sec><title>Experimental results and discussion</title><p>In the last section we gave a mathematical proof of the tightness of the number of recombinations estimated by the model to explain the data. Also, in our earlier work we had presented results on simulation data with a general analysis of false positive and false negative errors. In this section, we discuss results on a segment of Chromosome X data and the plausibility of the results is verified independently by using traditional manual analysis. Due to the manual component in the verification process, here we use only small data sets.</p><sec><title>Chromosome X SNP data</title><p>We used a 100 Kb segment of high SNP density in the recombining part of the X chromosome, starting at genomic position 87,348,404 (Build 35). In Hapmap II [<xref ref-type="bibr" rid="B11">11</xref>], this segment contains 194 sites, of which only 175 are polymorphic in at least one population. Recombination rate is &#x02248; 0.7 cM/Mb, slightly below the &#x02248; 1 cM/Mb genomewide average. We chose this segment for two reasons. (1) It does not contain any genes. Thus variation in this region is less likely to have been shaped by natural selection and is more likely to reflect purely genomic processes. (2) The segment does not contain copy number variations or segmental duplications. These could induce genotyping errors possibly producing ectopic recombination events, which is not accounted for in the downstream analysis.</p><p>Further, we used only the haplotypes in the hemizygous males to avoid any phasing errors. These errors would manifest as phantom recombination events. The populations used were Yorubans from Nigeria (YRI; <italic>N </italic>= 30), Europeans (CEU, <italic>N </italic>= 30), and a pooled sample of Chinese and Japanese (ASN; <italic>N </italic>= 45).</p></sec><sec><title>Statistical analysis (using <italic>p</italic>-value estimations)</title><p>As a preprocessing step, exploiting the coherence seen in the data, each haplotype is recoded using blocks of <italic>g </italic>SNPs. Based on the combinatorial model, a network is constructed from the recoded representative haplotypes. Recall that first the haplotype is segmented to give simple structures and then these individual structures are merged with a small number of recombinations to give a unified topology. Here we discuss the choice of the value of <italic>g </italic>in our experiments. Let <italic>l </italic>be the number of distinct patterns of the <italic>g </italic>SNPs across the samples. Using this as a proxy for the extent of LD in this block, we estimate the <italic>p</italic>-value of the number <italic>l</italic>. Loosely speaking, when these <italic>g </italic>SNPs are in linkage equilibrium (or independent), <italic>l </italic>should be much larger than when they are in LD.</p><p>Let the number of samples be <italic>H </italic>and let the number of SNPs be <italic>F</italic>. Further, let <italic>V </italic>be a column vector of size <italic>H</italic>. Since the SNPs are assumed to be bi-allelic, <italic>V </italic>which represents the value of a SNP in the <italic>H </italic>samples is binary. We use two schemes, based on the mode of definition of the <italic>F </italic>vectors, to estimates the <italic>p</italic>-value. The range of values of <italic>l </italic>seen in our data is 2 &#x02264; <italic>l </italic>&#x0003c; 15 and we study the <italic>p</italic>-value estimates in this range using two schemes.</p><sec><title>RandV</title><p>In this scheme, <italic>V</italic><sub>1</sub>, <italic>V</italic><sub>2</sub>, ..., <italic>V</italic><sub><italic>F </italic></sub>are defined randomly. In other words, each entry of each <italic>V </italic>is picked independently and uniformly from a set of two alleles. We use 10000 replicates and the distribution of the number of <italic>g</italic>-sized patterns is shown in Fig <xref ref-type="fig" rid="F10">10</xref>. The <italic>p</italic>-values estimated based on this scheme is shown in the table below. The <italic>p</italic>-values are &#x02248; 0.0 for every value of <italic>l</italic>.</p><fig position="float" id="F10"><label>Figure 10</label><caption><p>Distribution of <italic>l </italic>for <italic>g </italic>= 5. Recall that the randV Scheme is independent of the region but the permV Scheme uses the population distribution of the region for a more realistic estimation.</p></caption><graphic xlink:href="1471-2105-10-S1-S72-10"/></fig></sec><sec><title>PermV</title><p>While the RandV scheme is not incorrect, we make some domain-dependent modifications to design another scheme. In the PermV scheme we (i) mimic the allele frequencies seen in the input data and (ii) use the population distribution, by ethnicity, of the screened samples in the chromosomal region. The individual <italic>V </italic>vectors are plucked from the <italic>X</italic>-Chromosome of the database (but the SNPs span the entire chromosome) and any untyped SNP (i.e., N in the database) in the vector is given a value in agreement with the allele frequency of that column. Further, we use only those <italic>V </italic>'s that have MAF &#x02265; 0.1. We again use 10000 replicates and for each replicate, we randomly permute the <italic>F </italic>vectors. The distribution of the number of <italic>g</italic>-sized patterns is shown in Fig <xref ref-type="fig" rid="F10">10(b)</xref>.</p><p>If for a block, <italic>l </italic>has an insignificant <italic>p</italic>-value, then the subsequent analysis risks becoming unreliable. We then reduce the grain size. An alternative is to discard the offending SNPs of the block, thus fragmenting the region. In our experiments we used a grain size <italic>g </italic>= 5 and the <italic>p</italic>-values obtained for this on all the regions were acceptable. The haplotypes are re-coded as sequence of these SNP patterns for the combinatorial analysis discussed in the <italic>Methods </italic>section.</p></sec></sec><sec><title>Result analysis</title><p>We show a sample network of a short segment of the chosen region in Figure <xref ref-type="fig" rid="F11">11</xref>. Here we summarize our observations from a phylogeographic viewpoint and answer only questions raised traditionally in this area. Table <xref ref-type="table" rid="T1">1</xref> shows the number of detected recombination events and how they are shared across populations. The observations (over the entire 100 Kb segment) are as follows: We discovered a total of 31 recombinations in the data. Seventeen recombinations are population-specific, and can be used to infer the recombinational diversity within a population. Assuming recombination rate is constant across populations, this is a function of the effective population size of each population. Four recombinations are shared among pairs of populations, and can be used as indicators of shared population ancestry. In this particular case, both Europeans and Asians share events with the African population, which is more recombinationally diverse. Ten recombinations are shared among all three populations, and they are presumably ancient events that occurred before the split of the three populations.</p><fig position="float" id="F11"><label>Figure 11</label><caption><p>The network on segment Chr X: 87390235&#x02013;87412114 of the three populations. The leafnodes are labeled with (a set of) clusters of the input haplotypes. A label on an internal node is for reference purposes only. An element of the edge label is to be interpreted as segment-id:position-id:pattern-id.</p></caption><graphic xlink:href="1471-2105-10-S1-S72-11"/></fig><table-wrap position="float" id="T1"><label>Table 1</label><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center">CEU</td><td align="center">ASN</td><td align="center">YRI</td></tr></thead><tbody><tr><td align="center">CEU</td><td align="center">2</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">ASN</td><td></td><td align="center">4</td><td align="center">3</td></tr><tr><td align="center">YRI</td><td></td><td></td><td align="center">11</td></tr></tbody></table><table-wrap-foot><p>CEU &#x00026; ASN &#x00026; YRI: 10</p></table-wrap-foot></table-wrap><p>Mutation-based studies of genetic diversity have shown exactly the same pattern: a larger diversity in Africans, and variation outside of Africa that is partially a subset of that in Africa. Our recombination-based results follow the same pattern, and, as the mutation data, fit the the "Out of Africa" model [<xref ref-type="bibr" rid="B12">12</xref>] for the origin of anatomically modern humans. Consistency with mutation data can be taken as an indirect validation of our analysis and the methodology. In our future work, we plan to investigate (raise as well as answer) more non-traditional questions.</p></sec></sec><sec><title>Conclusion</title><p>We have addressed the problem of studying recombinational variations in human populations. One of the contributions of this work is a guaranteed upper bound on the approximation factor (ratio of discovered new recombination events to the true optimal) in a greedy polynomial time algorithm to construct a consensus network. Such an assurance is of significance when dealing with data where there are no other reasonable means of cross-checking results. To date, this bound is the best known result for this problem. We use this scheme to study recombinational imprints in an appropriate segment of X chromosome from three populations. While the upper bound on the approximation is our theoretical contribution, our second contribution is the results on this data: With our preliminary analysis, we are able to infer ancient recombinations, population-specific recombinations and more, which also support the widely accepted 'Out of Africa' model. The agreement with mutation-based analysis can be viewed as an indirect validation of our results and the methodology. In our future work, we plan to investigate more non-traditional questions via the networks computed by our methodology.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>The work is a result of the synergistic efforts of all the authors. However, the brunt of each author's involvement is as follows. Design and analysis of the mathematical models: LP. Design and implementation of the algorithms: AJ. Design and implementation of the experiments: MM, FC and JB. Further, LP and JB were involved in conceiving and planning the recombinations project.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>We are thankful to Ajay Royyuru for his insightful comments on the work. We would also like to thank the anonymous referees for their helpful reviews.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Wilson</surname><given-names>EO</given-names></name></person-group><article-title>A consistency test for phylogenies based on contemporaneous species</article-title><source>Systematic Zoology</source><year>1965</year><volume>14</volume><fpage>214</fpage><lpage>220</lpage><pub-id pub-id-type="doi">10.2307/2411550</pub-id></citation></ref><ref id="B2"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Semple</surname><given-names>C</given-names></name><name><surname>Steel</surname><given-names>M</given-names></name></person-group><source>Phylogenetics</source><year>2003</year><publisher-name>Oxford University Press</publisher-name></citation></ref><ref id="B3"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Hein</surname><given-names>J</given-names></name><name><surname>Schierup</surname><given-names>MH</given-names></name><name><surname>Wiuf</surname><given-names>C</given-names></name></person-group><source>Gene Genealogies, Variation and Evolution: A Primer in Coalescent Theory</source><year>2005</year><publisher-name>Oxford University Press</publisher-name></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gusfield</surname><given-names>D</given-names></name><name><surname>Hickersona</surname><given-names>D</given-names></name><name><surname>Eddhua</surname><given-names>S</given-names></name></person-group><article-title>An efficiently computed lower bound on the number of recombinations in phylogenetic networks: Theory and empirical study</article-title><source>Discrete Applied Mathematics</source><year>2007</year><volume>155</volume><fpage>806</fpage><lpage>830</lpage><pub-id pub-id-type="doi">10.1016/j.dam.2005.05.044</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Parida</surname><given-names>L</given-names></name><name><surname>Mel&#x000e9;</surname><given-names>M</given-names></name><name><surname>Calafell</surname><given-names>F</given-names></name><name><surname>Bertranpetit</surname><given-names>J</given-names></name><collab>Genographic Consortium</collab></person-group><article-title>Estimating the ancestral recombinations graph (ARG) as compatible networks of SNP patterns</article-title><source>Journal of Computational Biology</source><year>2008</year><volume>15</volume><fpage>1133</fpage><lpage>1154</lpage><pub-id pub-id-type="pmid">18844583</pub-id><pub-id pub-id-type="doi">10.1089/cmb.2008.0065</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Huson</surname><given-names>DH</given-names></name><name><surname>Dezulian</surname><given-names>T</given-names></name><name><surname>Klopper</surname><given-names>T</given-names></name><name><surname>Steel</surname><given-names>MA</given-names></name></person-group><article-title>Phylogenetic super-networks from partial trees</article-title><source>IEEE/ACM TCBB</source><year>2004</year><volume>1</volume><fpage>151</fpage><lpage>158</lpage><pub-id pub-id-type="pmid">17051697</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Moret</surname><given-names>BME</given-names></name><name><surname>Nakhleh</surname><given-names>L</given-names></name><name><surname>Warnow</surname><given-names>T</given-names></name><name><surname>Linder</surname><given-names>CR</given-names></name><name><surname>Tholse</surname><given-names>A</given-names></name><name><surname>Padolina</surname><given-names>A</given-names></name><name><surname>Sun</surname><given-names>J</given-names></name><name><surname>R</surname><given-names>T</given-names></name></person-group><article-title>Phylogenetic networks: modeling, reconstructibility, and accuracy</article-title><source>IEEE/ACM TCBB</source><year>2004</year><volume>1</volume><fpage>13</fpage><lpage>23</lpage><pub-id pub-id-type="pmid">17048405</pub-id></citation></ref><ref id="B8"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Arora</surname><given-names>S</given-names></name><name><surname>Lund</surname><given-names>C</given-names></name></person-group><source>Hardness of approximations</source><year>1996</year><publisher-name>PWS Publishing Company</publisher-name><fpage>399</fpage><lpage>446</lpage></citation></ref><ref id="B9"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Vazirani</surname><given-names>V</given-names></name></person-group><source>Approximation Algorithms</source><year>2003</year><publisher-name>Springer</publisher-name></citation></ref><ref id="B10"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Cormen</surname><given-names>TH</given-names></name><name><surname>Leiserson</surname><given-names>CE</given-names></name><name><surname>Rivest</surname><given-names>RL</given-names></name></person-group><source>Introduction to Algorithms</source><year>1990</year><publisher-name>Cambridge, Massachusetts: The MIT Press</publisher-name></citation></ref><ref id="B11"><citation citation-type="other"><article-title>HapMap Phase 2</article-title><ext-link ext-link-type="uri" xlink:href="http://www.hapmap.org"/></citation></ref><ref id="B12"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Jobling</surname><given-names>MA</given-names></name><name><surname>Hurles</surname><given-names>M</given-names></name><name><surname>Tyler-Smith</surname><given-names>C</given-names></name></person-group><source>Human Evolutionary Genetics: Origins, Peoples and Disease</source><year>2004</year><publisher-name>Garland Publishing</publisher-name></citation></ref></ref-list></back></article>