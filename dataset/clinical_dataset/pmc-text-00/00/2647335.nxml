<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article" xml:lang="EN"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Front Neuroinformatics</journal-id><journal-id journal-id-type="publisher-id">Front. Neuroinform.</journal-id><journal-title>Frontiers in Neuroinformatics</journal-title><issn pub-type="epub">1662-5196</issn><publisher><publisher-name>Frontiers Research Foundation</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19242557</article-id><article-id pub-id-type="pmc">2647335</article-id><article-id pub-id-type="doi">10.3389/neuro.11.004.2009</article-id><article-categories><subj-group subj-group-type="heading"><subject>Neuroscience</subject><subj-group><subject>Original Research</subject></subj-group></subj-group></article-categories><title-group><article-title>Python for Information Theoretic Analysis of Neural Data</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Ince</surname><given-names>Robin A. A.</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="author-notes" rid="fn001">*</xref></contrib><contrib contrib-type="author"><name><surname>Petersen</surname><given-names>Rasmus S.</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author"><name><surname>Swan</surname><given-names>Daniel C.</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib><contrib contrib-type="author"><name><surname>Panzeri</surname><given-names>Stefano</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff3"><sup>3</sup></xref><xref ref-type="author-notes" rid="fn001">*</xref></contrib></contrib-group><aff id="aff1"><sup>1</sup><institution>Faculty of Life Sciences, University of Manchester</institution><country>Manchester, UK</country></aff><aff id="aff2"><sup>2</sup><institution>Bioinformatics Support Unit, Institute of Cell and Molecular Biosciences, Newcastle University</institution><country>Newcastle upon Tyne, UK</country></aff><aff id="aff3"><sup>3</sup><institution>Robotics, Brain and Cognitive Sciences Department, Italian Institute of Technology</institution><country>Genoa, Italy</country></aff><author-notes><fn fn-type="edited-by"><p>Edited by: Rolf K&#x000f6;tter, Radboud University Nijmegen, The Netherlands</p></fn><fn fn-type="edited-by"><p>Reviewed by: Osvaldo A. Rosso, The University of Newcastle, Australia; Pietro Berkes, Brandeis University, USA; John M. Beggs, Indiana University, USA</p></fn><corresp id="fn001">*Correspondence: Robin A. A. Ince, Faculty of Life Sciences, 3.614 Stopford Building, Oxford Road, Manchester, M13 9PT, UK. e-mail: <email>robin.ince@postgrad.manchester.ac.uk</email>; Stefano Panzeri, Robotics, Brain and Cognitive Sciences Department, Italian Institute of Technology, Via Morego, 30, 16163 Genoa, Italy. e-mail: <email>stefano.panzeri@iit.it</email></corresp></author-notes><pub-date pub-type="epreprint"><day>20</day><month>11</month><year>2008</year></pub-date><pub-date pub-type="epub"><day>11</day><month>2</month><year>2009</year></pub-date><pub-date pub-type="collection"><year>2009</year></pub-date><volume>3</volume><elocation-id>4</elocation-id><history><date date-type="received"><day>21</day><month>9</month><year>2008</year></date><date date-type="accepted"><day>27</day><month>1</month><year>2009</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2009 Ince, Petersen, Swan and Panzeri.</copyright-statement><copyright-year>2009</copyright-year><license license-type="open-access" xlink:href="http://www.frontiersin.org/licenseagreement"><p>This is an open-access article subject to an exclusive license agreement between the authors and the Frontiers Research Foundation, which permits unrestricted use, distribution, and reproduction in any medium, provided the original authors and source are credited.</p></license></permissions><abstract><p>Information theory, the mathematical theory of communication in the presence of noise, is playing an increasingly important role in modern quantitative neuroscience. It makes it possible to treat neural systems as stochastic communication channels and gain valuable, quantitative insights into their sensory coding function. These techniques provide results on how neurons encode stimuli in a way which is independent of any specific assumptions on which part of the neuronal response is signal and which is noise, and they can be usefully applied even to highly non-linear systems where traditional techniques fail. In this article, we describe our work and experiences using Python for information theoretic analysis. We outline some of the algorithmic, statistical and numerical challenges in the computation of information theoretic quantities from neural data. In particular, we consider the problems arising from limited sampling bias and from calculation of maximum entropy distributions in the presence of constraints representing the effects of different orders of interaction in the system. We explain how and why using Python has allowed us to significantly improve the speed and domain of applicability of the information theoretic algorithms, allowing analysis of data sets characterized by larger numbers of variables. We also discuss how our use of Python is facilitating integration with collaborative databases and centralised computational resources.</p></abstract><kwd-group><kwd>Python</kwd><kwd>information theory</kwd><kwd>neural coding</kwd><kwd>entropy</kwd><kwd>maximum entropy</kwd><kwd>bias</kwd><kwd>e-science</kwd></kwd-group><counts><fig-count count="3"/><table-count count="0"/><equation-count count="15"/><ref-count count="50"/><page-count count="15"/><word-count count="15184"/></counts></article-meta></front><body><sec><title>Introduction</title><p>Information theory (Cover and Thomas, <xref ref-type="bibr" rid="B6">2006</xref>; Shannon, <xref ref-type="bibr" rid="B42">1948</xref>), the mathematical theory of communication in the presence of noise, is playing an increasingly important role in modern quantitative neuroscience, because it makes it possible to treat neural systems as stochastic communication channels and gain valuable, quantitative insights into their sensory coding function (Borst and Theunissen, <xref ref-type="bibr" rid="B5">1999</xref>; Rieke et al., <xref ref-type="bibr" rid="B37">1999</xref>; Victor, <xref ref-type="bibr" rid="B49">2006</xref>). Information theory provides a set of fundamental mathematical quantities, such as entropy and mutual information, that quantify with meaningful numbers the reduction of uncertainty about stimuli gained from neural responses, without the need to make any specific assumption of what is signal and what is noise in the neuronal response.</p><p>Most laboratories (including ours) have so far implemented information theoretic analyses using MATLAB<sup>&#x000ae;</sup><xref ref-type="fn" rid="fn1">1</xref>. MATLAB is a numerical computing environment and programming language which is used by most neurophysiosiological laboratories to store, preprocess and plot experimental data. In our view, the reason for the choice of MATLAB for the implementation of such routines is that it allows interactive and rapid development of algorithms, though at the cost of some performance overhead. Traditionally, information calculations have not been demanding in terms of memory usage or CPU time because the information calculations were restricted to relatively small neural populations as a consequence of the limited sampling bias problem. Therefore, it has been convenient to perform the analysis with the tools used to obtain, preprocess and store the data. However, over the last few years, the CPU and memory requirements of information calculations for neural data has significantly increased. This is due to a number of reasons. First, the improvement of the techniques to correct for the sampling bias problem (Panzeri et al., <xref ref-type="bibr" rid="B31">2007</xref>) has allowed the information theoretic analysis of larger populations. Second, some of these bias corrections techniques are computationally intensive. Third, in the context of understanding whether the correlation structure of neural activity can be described by simple low order models, it has become important to compute distributions with maximum entropy in the presence of various sets of constraints (Schneidman et al., <xref ref-type="bibr" rid="B39">2006</xref>; Shlens et al., <xref ref-type="bibr" rid="B43">2006</xref>; Tang et al., <xref ref-type="bibr" rid="B45">2008</xref>). These calculations are particularly demanding in terms of processor and memory resources. Fourth, while most information analysis has been applied to spike trains, in the context of the development of brain machine interfaces it has become important to evaluate the information content of other types of brain signals, such as local field potentials (LFPs) or Electroencephalograms (EEGs) which are analog in nature and must be represented at each time step (Belitski et al., <xref ref-type="bibr" rid="B4">2008</xref>; Montemurro et al., <xref ref-type="bibr" rid="B23">2008</xref>; Rubino et al., <xref ref-type="bibr" rid="B38">2006</xref>; Waldert et al., <xref ref-type="bibr" rid="B50">2008</xref>). The manipulation of these signals stretches computational requirements much more than using spikes, which due to their sparse binary nature can be represented compactly, for example by storing only the spike arrival times.</p><p>The increased demand on the information theoretic routines raises the question of whether it may be advantageous for the scientific community to implement information theoretic algorithms for the analysis of neural data using platforms other than MATLAB. In the continuing development of these methods, we have recently started using Python, together with the numerical libraries NumPy and SciPy. We have found several key advantages to this change that make it more suitable for the analysis of the datasets we are currently studying and for future challenges such as implementing these methods into computational grids and clusters.</p><p>In this article, we first briefly present the principles of information theory and its importance to neuroscience. We then review some features of Python that are particularly useful for information theoretic analysis and consider in detail the implementation of the mathematical algorithms that are crucial for obtaining accurate and unbiased estimates of information from neural data. We also detail a method to compute the entropy of neural data given a number of plausible constraints, and we put particular emphasis on the specific advantages of Python in addressing these algorithmic challenges. We finally apply the methodology to real data recorded from the rat somatosensory cortex, and discuss the potential implications of wider use of Python in information theoretic analysis of the neural code.</p></sec><sec><title>Information Theory for Analysis of Neural Data</title><p>Information theory is a &#x0201c;mathematical theory of communication&#x0201d; developed in the 1940's by Claude Shannon at Bell Labs (Cover and Thomas, <xref ref-type="bibr" rid="B6">2006</xref>; Shannon, <xref ref-type="bibr" rid="B42">1948</xref>). It formalises, in a mathematically rigorous way, a measure of &#x0201c;information&#x0201d; in a system with applications to coding and transmission of that information. While it was originally developed for analysis of artificial systems, such as transmission of signals along a telegraph wire, the generality of the formulation means it can be usefully applied to a wide range of problems.</p><p>Consider an experiment in which an animal is presented with a stimulus <italic>s</italic> selected with probability <italic>P</italic>(<italic>s</italic>) from a stimulus set <bold>S</bold> consisting of S elements, and the consequent response (either of a single neuron or an ensemble of neurons) is recorded and quantified in a certain post-stimulus time window. The aim of information theoretic analysis is to gain insight into how the neurons represent the stimuli. In most applications this is done by examining the information content of different candidate neural codes. To carry out such an analysis, the first step is to choose the neural code. In practice this means choosing a way to quantify the neuronal response that reflects our assumption of what is most salient in it. For example, if we think that only spike counts (not the precise temporal pattern of spikes) are important, we choose a spike-count code: we define a post-stimulus response interval and count the number of spikes it contains on each repetition (trial) of a stimulus. In most cases, the neural response is quantified as a discrete, multi-dimensional array <bold>r</bold> = {<italic>r</italic><sub>1</sub>,&#x02026;, <italic>r<sub>L</sub></italic>} of dimension <italic>L</italic>. For example, to quantify the spike count response of a population of <italic>L</italic> cells, <italic>r<sub>i</sub></italic> would be the number of spikes emitted by cell i on a given trial in the response window. Alternatively, to quantify the spike timing response of a single neuron, the response window is divided into L bins of width &#x00394;<italic>t</italic>, so that <italic>r<sub>i</sub></italic> is the number of spikes fired in the <italic>i</italic>-th time bin (Strong et al., <xref ref-type="bibr" rid="B44">1998</xref>). Here &#x00394;<italic>t</italic> is the assumed time precision of the code and can be varied parametrically to characterize the temporal precision of the neural code. We denote by <bold>R</bold> the set of possible values taken by the response array.</p><p>Having quantified the response, the second step is to compute how much information can be extracted from the chosen response quantification. This allows an assessment of how good the candidate neural code is. The more the response of a neuron varies across a set of stimuli, the greater its ability to transmit information about those stimuli (de Ruyter van Steveninck et al., <xref ref-type="bibr" rid="B9">1997</xref>). The first step in measuring information is thus to measure the response variability. The most general way to do this is through the concept of <italic>Shannon entropy</italic>, referred to hereafter as <italic>entropy</italic>, which is a measure of the uncertainty associated with a random variable. Intuitively one can posit some desirable properties of any uncertainty measure. It should be <italic>continuous</italic>; that is small changes in the underlying probabilities should result in small changes in the uncertainty. It should be <italic>symmetric</italic>; that is the measure should not depend on the labelling or ordering of the variables and outcomes. The measure should take its maximum value when all outcomes are equally likely and for systems with uniform probabilities, the measure should increase with the number of outcomes. Finally, the measure should be <italic>additive</italic>; that is it should be independent of how the system is grouped or divided into parts. It can be shown (Cover and Thomas, <xref ref-type="bibr" rid="B6">2006</xref>) that any measure of uncertainty about the neural responses satisfying these properties has the form<disp-formula id="E1"><label>(1)</label><mml:math id="M1"><mml:mrow><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>r</mml:mi></mml:mstyle><mml:mo>&#x02208;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle></mml:mrow></mml:munder><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <italic>P</italic>(<bold>r</bold>) is the probability of observing response <bold>r</bold> across all trials to all stimuli. The response entropy quantifies how neuronal responses vary with the stimulus and thus sets the capacity of the spike train to convey information. In Eqs <xref ref-type="disp-formula" rid="E1">1</xref> and <xref ref-type="disp-formula" rid="E2">2</xref> the summation over <bold>r</bold> is over all possible neuronal responses. However, neurons are typically noisy; their responses to repetitions of an identical stimulus differ from trial to trial. <italic>H</italic>(<bold>R</bold>) reflects both variation of responses to different stimuli and variation due to trial-to-trial noise. Thus <italic>H</italic>(<bold>R</bold>) is not a pure measure of the stimulus information actually transmitted by the neuron. We can quantify the variability specifically due to noise, by measuring the so-called <italic>noise entropy</italic>, which is the entropy conditional on stimulus presentation:<disp-formula id="E2"><label>(2)</label><mml:math id="M2"><mml:mrow><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo>|</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle></mml:mrow></mml:munder><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:munder><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>r</mml:mi></mml:mstyle><mml:mo>&#x02208;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle></mml:mrow></mml:munder><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>r</mml:mi></mml:mstyle><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>r</mml:mi></mml:mstyle><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>The summation over <italic>s</italic> is over all possible stimuli. <italic>P</italic>(<bold>r</bold>|<italic>s</italic>) is the probability of observing a particular response <bold>r</bold> given that stimulus <italic>s</italic> is presented. Experimentally, <italic>P</italic>(<bold>r</bold>|<italic>s</italic>) is determined by repeating each stimulus on many trials, while recording the neuronal responses. The probability <italic>P</italic>(<italic>s</italic>) is usually chosen by the experimenter. The noise entropy quantifies the irreproducibility of the neuronal responses at fixed stimulus. The noisier is a neuron, the greater is <italic>H</italic>(<bold>R</bold>|<bold>S</bold>). The information that the neuronal response transmits about the stimulus is the difference between the response entropy and the noise entropy. This is known as the mutual information <italic>I</italic>(<bold>S</bold>; <bold>R</bold>) between stimuli and responses (in the following abbreviated to information).<disp-formula id="E3"><label>(3)</label><mml:math id="M3"><mml:mrow><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo>;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo>|</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>Mutual information quantifies how much of the information capacity provided by stimulus-evoked differences in neural activity is robust to the presence of trial-by-trial response variability (de Ruyter van Steveninck et al., <xref ref-type="bibr" rid="B9">1997</xref>). Alternatively, it quantifies the reduction of uncertainty about the stimulus that can be gained from observation of a single trial of the neural response.</p><p>The mutual information has a number of important qualities that make it well suited to characterizing how a response is modulated by the stimulus (Borst and Theunissen, <xref ref-type="bibr" rid="B5">1999</xref>; Fuhrmann Alpert et al., <xref ref-type="bibr" rid="B10">2007</xref>; Panzeri et al., <xref ref-type="bibr" rid="B29">2008</xref>; Rieke et al., <xref ref-type="bibr" rid="B37">1999</xref>). First, as outlined above, it quantifies the stimulus discriminability achieved from a single observation of the response, rather than from averaging responses over many observations. Second, <italic>I</italic>(<bold>S</bold>; <bold>R</bold>) is the most general measure of correlation between the stimuli and the neural responses, because it automatically takes into account contributions of correlations at all orders. Third, computing information does not require specifying a stimulus&#x02013;response model; it only requires computing the response probabilities in response to each stimulus condition. Therefore, the calculation of information does not require spelling out which stimulus features (e.g., contrast, orientation, etc.) are encoded. Fourth, <italic>I</italic>(<bold>S</bold>; <bold>R</bold>) takes into account the full stimulus&#x02013;response probabilities, which include all possible effects of stimulus-induced responses and noise. Thus, it does not require the signal to be modeled as a set of response functions plus noise and is applicable even to situations when such decompositions are difficult or dubious. The last three points show that information theory can, in principle, be applied to any type of neural signal, including responses such as LFPs or spikes that are clearly nonlinear and difficult to model by a set of standard functions. Fifth, it is possible to analyze and combine the information given by different measures of neural activity e.g. spike trains and LFPs. These two signals have a very different nature and signal to noise ratios. Therefore, a certain increase of the peak height of an LFP cannot be compared to a certain change in the spike train to understand how well LFPs or spikes encode stimuli. In contrast, with information theory the LFPs and spikes can be directly compared because information theory projects both signals onto a common scale that is meaningful in terms of stimulus knowledge.</p><p>Information theoretic techniques have been successfully used to address a number of questions about sensory coding. For example, they have been used to address the question of whether neurons convey information by millisecond precision spike timing or simply by the total number of emitted spikes (the spike count). The application of information theory to spike train analysis has showed that the ms-precise timing of spikes provides important information that cannot be extracted from spike counts (Panzeri et al., <xref ref-type="bibr" rid="B30">2001</xref>; Victor, <xref ref-type="bibr" rid="B48">1999</xref>, <xref ref-type="bibr" rid="B49">2006</xref>). Information theory has also been used to characterize the functional role of correlations in population activity, by investigating in which conditions correlations play a quantitatively important role in transmitting information about the stimulus (Averbeck et al., <xref ref-type="bibr" rid="B3">2006</xref>; Dan et al., <xref ref-type="bibr" rid="B7">1998</xref>; Hatsopoulos et al., <xref ref-type="bibr" rid="B13">1998</xref>; Latham and Nirenberg, <xref ref-type="bibr" rid="B17">2005</xref>; Panzeri, <xref ref-type="bibr" rid="B28">1999</xref>; Petersen et al., <xref ref-type="bibr" rid="B35">2001</xref>; Pola et al., <xref ref-type="bibr" rid="B36">2003</xref>) or in constraining the dynamic range of network responses (Schneidman et al., <xref ref-type="bibr" rid="B39">2006</xref>). Information theory has also been used to characterize the amount of interactions between neural populations (Honey et al., <xref ref-type="bibr" rid="B15">2007</xref>).</p></sec><sec><title>Why Python?</title><p>For many years, the de facto standard for many groups working in the area of neurophysiological data analysis has been MATLAB<sup>&#x000ae;</sup>. However, the Python programming language (van Rossum, <xref ref-type="bibr" rid="B47">1995</xref>) combined with the numerical and scientific libraries NumPy and SciPy (Jones et al., <xref ref-type="bibr" rid="B16">2001</xref>) provide a compelling alternative for scientific programming. Python is a modern, fully object-oriented programming language that is powerful, flexible and easy to learn. The NumPy library provides a multi-dimensional array object and associated vectorised operations, and SciPy enhances this with a range of scientific functions using the NumPy array object. The syntax is familiar to anyone coming from a background with MATLAB or another C derivative language and there are a comprehensive set of tools for plotting and interactive use (IPython and Matplotlib). Assignments are by reference rather than by copying, which allows finer grained control of memory usage, and there are several ways to rapidly extend the system with external code written in FORTRAN and C. The flexibility and good design of the Python language make large projects much more manageable than with MATLAB, where each function must reside in a separate file and refactoring to reduce code repetition grows increasingly difficult with project size. Python is a well developed language, with libraries available for almost any conceivable task, such as GUI development, network communication, support for different file formats, etc. It is possible to read and write MATLAB binary files, and even call MATLAB commands from within the Python environment, which allows for a smooth transition and means that time invested in an existing MATLAB code base is not wasted. Finally, the Python tool set is <italic>open source</italic><xref ref-type="fn" rid="fn2">2</xref>, rather than a proprietary product, which has several obvious advantages for scientific work. Its free availability allows better reproducibility of the results, since all interested parties are free to run the software without an expensive license. It is also inherently future-proof, since it will always be possible to obtain and use the version for which the code was written, whereas a commercial product may be withdrawn at some point in the future.</p></sec><sec><title>The Limited Sampling Bias Problem</title><p>A major difficulty when applying techniques involving information theoretic quantities to experimental systems, is that they require measurement of the full probability distributions of the variables involved. If we had an infinite amount of data, we could measure the true stimulus-response probabilities precisely. However, any real experiment only yields a finite number of trials from which these probabilities must be estimated. The estimated probabilities are subject to statistical error and necessarily fluctuate around their true values. The significance of these finite sampling fluctuations is that they lead to both statistical error (variance) and systematic error (called <italic>limited sampling bias</italic>) in estimates of entropies and information. This bias is the difference between the expected value of the quantity considered, computed from probability distributions estimated with <italic>N</italic> trials or samples, and its value computed from the true probability distribution. The bias constitutes a significant practical problem, because its magnitude is often of the order of the information values to be evaluated, and because it cannot be alleviated simply by averaging over many neurons with similar characteristics.</p><sec><title>Origins of the bias</title><p>The most direct way to compute information and entropies is to estimate the response probabilities as the histogram of the experimental frequency of each response across the available trials. Plugging in these empirical probability estimates into Eqs <xref ref-type="disp-formula" rid="E1 E2 E3">1&#x02013;3</xref> results in a direct estimate that we refer to as the &#x0201c;plug-in&#x0201d; method.</p><p>In general, both the full output entropy <italic>H</italic>(<bold>R</bold>) and the noise entropy <italic>H</italic>(<bold>R</bold>|<bold>S</bold>) are biased downwards. That is, the estimated value is less than the true value, and the estimated value increases with the number of trials used, asymptotically approaching the true value. Intuitively, this is because finite sampling means it is less likely that the full range of responses will be included and so the measured responses seem less variable than they really are. In addition, estimates of <italic>H</italic>(<bold>R</bold>|<bold>S</bold>) are significantly more biased than those of <italic>H</italic>(<bold>R</bold>), since the latter depends on <italic>P</italic>(<bold>r</bold>) which is calculated with data gathered across all stimuli and is better sampled than the conditional distributions, which are each sampled with data from a single stimulus only. The bias in the mutual information is then the difference between the bias of <italic>H</italic>(<bold>R</bold>) and that of <italic>H</italic>(<bold>R</bold>|<bold>S</bold>). This results in an upward bias in the information, since the magnitude of the bias of <italic>H</italic>(<bold>R</bold>|<bold>S</bold>) is greater, and its sign is reversed in Eq. <xref ref-type="disp-formula" rid="E3">3</xref>. Again, this makes sense intuitively, since the finite sampling can introduce spurious stimulus-dependent differences in the response probabilities, which make the stimuli seem more discernible and hence the neuron more informative than it really is.</p></sec><sec><title>Bias correction methods</title><p>Fortunately a number of techniques have been developed to address the issue of bias, and allow much more accurate estimates of information theoretic quantities than the &#x0201c;plug-in&#x0201d; method described above. Panzeri et al. (<xref ref-type="bibr" rid="B31">2007</xref>) provide a review of such methods, a selection of which are briefly outlined here. For other methods and approaches please see Panzeri et al. (<xref ref-type="bibr" rid="B31">2007</xref>) and Victor (<xref ref-type="bibr" rid="B49">2006</xref>).</p><sec><title>Panzeri&#x02013;treves (PT)</title><p>In the so-called <italic>asymptotic sampling regime</italic>, when the number of trials is large enough that every possible response occurs many times, an analytical approximation for the bias (i.e. the difference between the true value and the plug-in estimate) of entropies and information can be obtained (Miller, <xref ref-type="bibr" rid="B20">1955</xref>; Panzeri and Treves, <xref ref-type="bibr" rid="B32">1996</xref>).<disp-formula id="E4"><label>(4)</label><mml:math id="M4"><mml:mtable><mml:mtr><mml:mtd><mml:maligngroup/><mml:mi>B</mml:mi><mml:mi>I</mml:mi><mml:mi>A</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:malignmark/><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi><mml:mi>ln</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="false">[</mml:mo><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:maligngroup/><mml:mi>B</mml:mi><mml:mi>I</mml:mi><mml:mi>A</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo>|</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:malignmark/><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi><mml:mi>ln</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mstyle displaystyle="true"><mml:munder><mml:mo>&#x02211;</mml:mo><mml:mi>s</mml:mi></mml:munder><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>s</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:maligngroup/><mml:mi>B</mml:mi><mml:mi>I</mml:mi><mml:mi>A</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo>;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:malignmark/><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi><mml:mi>ln</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>&#x02211;</mml:mo><mml:mi>s</mml:mi></mml:munder><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>s</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mstyle></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>The value of the bias computed from the above expressions is then subtracted from the plug-in estimate to obtain the corrected values. This requires an estimate of the number of relevant responses <inline-formula><mml:math id="M5"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The simplest approach is to approximate <inline-formula><mml:math id="M6"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> by the count of responses that are observed at least once &#x02013; this is the &#x0201c;naive&#x0201d; count. However due to finite sampling this will be an underestimate of the true value. A Bayesian procedure (Panzeri and Treves, <xref ref-type="bibr" rid="B32">1996</xref>) can be used to obtain a more accurate value.</p></sec><sec><title>Quadratic extrapolation (QE)</title><p>In the asymptotic sampling regime, the bias of entropies and information can be approximated as second order expansions in 1/<italic>N</italic>, where <italic>N</italic> is the number of trials (Strong et al., <xref ref-type="bibr" rid="B44">1998</xref>; Treves and Panzeri, <xref ref-type="bibr" rid="B46">1995</xref>). For example, for the information:<disp-formula id="E5"><label>(5)</label><mml:math id="M7"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mtext>plugin</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo>;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mtext>true</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo>;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mfrac><mml:mi>a</mml:mi><mml:mi>N</mml:mi></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mi>b</mml:mi><mml:mrow><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p>This property can be exploited by calculating the estimates with subsets of the original data, with <italic>N</italic>/2 and <italic>N</italic>/4 trials and fitting the resulting values to the polynomial expression above. This allows an estimate of the parameters <italic>a</italic> and <italic>b</italic> and hence <italic>I</italic><sub>true</sub>(<bold>S</bold>; <bold>R</bold>). To use all available data, estimates of two subsets of size <italic>N</italic>/2 and four subsets of size <italic>N</italic>/4 are averaged to obtain the values for the extrapolation. Together with the full length data calculation, this requires seven different evaluations of the quantity being estimated.</p></sec><sec><title>Nemenman&#x02013;shafee&#x02013;bialek (NSB)</title><p>The NSB method (Nemenman et al., <xref ref-type="bibr" rid="B26">2002</xref>, <xref ref-type="bibr" rid="B25">2004</xref>) utilises a Bayesian inference approach and does not rely on the assumption of the asymptotic sampling regime. It is based on the principle that when estimating a quantity, the least bias will be achieved when assuming an a priori uniform distribution over the quantity. This method is more challenging to implement than the other methods, involving a large amount of function inversion and numerical integration. However, it often gives a significant improvement in the accuracy of the bias correction (Montemurro et al., <xref ref-type="bibr" rid="B22">2007b</xref>; Nemenman et al., <xref ref-type="bibr" rid="B26">2002</xref>, <xref ref-type="bibr" rid="B25">2004</xref>).</p></sec><sec><title>Shuffled information estimator (I<sub>sh</sub>)</title><p>Recently, an alternative method of estimating the mutual information has been proposed (Montemurro et al., <xref ref-type="bibr" rid="B22">2007b</xref>; Panzeri et al., <xref ref-type="bibr" rid="B31">2007</xref>). Unlike the methods above, this is a method for calculating the information only, and is not a general entropy bias correction. However, it can be used with the entropy corrections described above to obtain more accurate results. For this method, two new quantities are defined. <italic>H</italic><sub>ind</sub>(<bold>R</bold>|<bold>S</bold>) is the noise entropy that would be obtained if each individual component <italic>r<sub>i</sub></italic> of the response array <bold>r</bold> were independent of any other component <italic>r<sub>j</sub></italic> (<italic>i</italic> &#x02260; <italic>j</italic>) at fixed stimulus; that is the entropy calculated from the distribution <italic>P</italic><sub>ind</sub>(<bold>r</bold>|<italic>s</italic>)&#x02009;=&#x02009;&#x003a0;<sub><italic>i</italic></sub>&#x02009;<italic>P</italic>(<italic>r<sub>i</sub></italic>|<italic>s</italic>). Since this value depends only on the first order marginal values of the response, it has a small bias. <italic>H</italic><sub>sh</sub>(<bold>R</bold>|<bold>S</bold>) is the entropy that results when stimulus conditional response correlations are removed by &#x0201c;shuffling&#x0201d; the data. That is, for each stimulus <italic>s</italic>, the individual response components <italic>r<sub>i</sub></italic> are shuffled independently across trials, to obtain a new set of vector responses <bold>r</bold>. Both of these values provide estimates of the entropy of the system if correlations were removed and become equal for an infinite number of trials. However, with finite trials, <italic>H</italic><sub>ind</sub>(<bold>R</bold>|<bold>S</bold>) shows a small bias, while <italic>H</italic><sub>sh</sub>(<bold>R</bold>|<bold>S</bold>) shows a much larger bias, which is of the same order of magnitude as that of <italic>H</italic>(<bold>R</bold>|<bold>S</bold>), but typically slightly more negative. Using these properties, a so-called shuffled information estimator, <italic>I</italic><sub>sh</sub>, can be computed as<disp-formula id="E6"><label>(6)</label><mml:math id="M8"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mtext>sh</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo>;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mtext>ind</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo>|</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mtext>sh</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo>|</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mo>|</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>In the limit of a large number of trials <italic>I</italic><sub>sh</sub>(<bold>S</bold>; <bold>R</bold>)&#x02009;=&#x02009;<italic>I</italic>(<bold>S</bold>; <bold>R</bold>) since <italic>H</italic><sub>sh</sub>(<bold>R</bold>|<bold>S</bold>)&#x02009;=&#x02009;<italic>H</italic><sub>ind</sub>(<bold>R</bold>|<bold>S</bold>). For small numbers of trials, the biases of <italic>H</italic><sub>sh</sub>(<bold>R</bold>|<bold>S</bold>) and <italic>H</italic>(<bold>R</bold>|<bold>S</bold>) approximately cancel out, leaving the bias of <italic>I</italic><sub>sh</sub>(<bold>S</bold>; <bold>R</bold>) dominated by that of <italic>H</italic>(<bold>R</bold>)&#x02009;&#x02212;&#x02009;<italic>H</italic><sub>ind</sub>(<bold>R</bold>|<bold>S</bold>) which is much smaller than that of the normal information estimate <italic>I</italic>(<bold>S</bold>; <bold>R</bold>). Using this shuffling technique, combined with entropy bias correction methods as described above, can reduce the number of trials needed for a reliable estimate by a factor of four (Montemurro et al., <xref ref-type="bibr" rid="B22">2007b</xref>; Panzeri et al., <xref ref-type="bibr" rid="B31">2007</xref>).</p></sec><sec><title>James&#x02013;stein shrinkage (&#x0201c;shrink&#x0201d;) estimator</title><p>Another recently proposed technique to compute entropies from limited samples is the so-called &#x0201c;James&#x02013;Stein shrinkage&#x0201d; technique (Hausser and Strimmer, <xref ref-type="bibr" rid="B14">2008</xref>), which works by improving the estimate of the underlying probabilities, rather than the entropy specifically. The James&#x02013;Stein shrinkage technique is based on averaging two models with different properties; a high dimensional model with low bias and high variance and a lower dimensional one with larger bias but smaller variance. The probabilities <italic>p<sub>r</sub></italic> of each response <italic>r</italic> are determined by<disp-formula id="E7"><label>(7)</label><mml:math id="M9"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mtext>Shrink</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mi>&#x003bb;</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>&#x003bb;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mtext>ML</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></disp-formula></p><p>where &#x003bb; &#x02208; [0, 1] is the shrinkage intensity, <inline-formula><mml:math id="M10"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mtext>ML</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> is the normal maximum likelihood estimate from frequency counts and <italic>t<sub>r</sub></italic> is the shrinkage target. The maximum entropy uniform distribution is suggested as a convenient target in Hausser and Strimmer (<xref ref-type="bibr" rid="B14">2008</xref>). The shrinkage intensity &#x003bb; is then given by the following<disp-formula id="E8"><label>(8)</label><mml:math id="M11"><mml:mrow><mml:mi>&#x003bb;</mml:mi><mml:mo>*</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mstyle displaystyle="true"><mml:msub><mml:mo>&#x02211;</mml:mo><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mtext>ML</mml:mtext></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mstyle displaystyle="true"><mml:msub><mml:mo>&#x02211;</mml:mo><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mtext>ML</mml:mtext></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p>This is repeated for all the stimulus conditional distributions, and the entropy is calculated from the corrected probability values using the plug-in method.</p></sec><sec><title>Comparative performance of different estimators</title><p>Figure <xref ref-type="fig" rid="F1">1</xref> reports the results of the performance of bias correction procedures on a set of simulated spike trains from eight simulated neurons. Each of these neurons could emit a spike or not with a probability obtained from a Bernoulli process. The spiking probabilities were exactly equal to those measured, in the 10&#x02013;15&#x02009;ms post-stimulus interval, from eight neurons in rat somatosensory cortex responding to 13 stimuli consisting of whisker vibrations of different amplitude and frequency (Arabzadeh et al., <xref ref-type="bibr" rid="B2">2004</xref>). The 10&#x02013;15&#x02009;ms interval was chosen since it was found to be the interval containing highest information values. Figure <xref ref-type="fig" rid="F1">1</xref>A shows that (with the exception of the James&#x02013;Stein shrinkage) all bias correction procedures generally improve the estimate of <italic>I</italic>(<bold>S</bold>; <bold>R</bold>) with respect to the plug-in estimator, and the NSB correction is especially effective. For the James&#x02013;Stein shrinkage estimator, a uniform target distribution was used, and this may account for the relatively poor performance of that method outside of the asymptotic regime. Figure <xref ref-type="fig" rid="F1">1</xref>B shows that the bias-corrected estimation of information is much improved by using <italic>I</italic><sub>sh</sub>(<bold>S</bold>; <bold>R</bold>) rather than <italic>I</italic>(<bold>S</bold>; <bold>R</bold>). The use of <italic>I</italic><sub>sh</sub>(<bold>S</bold>; <bold>R</bold>) makes the residual errors in the estimation of information much smaller and almost independent from the bias correction method used. Taking into account both bias correction performance and computation time, for this simulated system the best method to use is the shuffled information estimator combined with the Panzeri&#x02013;Treves analytical correction. Using this, an accurate estimate of the information is possible even when the number of samples per stimulus is <inline-formula><mml:math id="M12"><mml:mrow><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mi>R</mml:mi><mml:mn>4</mml:mn></mml:mfrac></mml:mstyle></mml:mrow></mml:math></inline-formula> where <italic>R</italic> is the dimension of the response space.</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>Comparison of the performance of different bias correction methods</bold>. The methods were applied to spike trains of eight simulated somatosensory cortical neurons (see text). The information estimates <italic>I</italic>(<bold>S</bold>; <bold>R</bold>) and <italic>I</italic><sub>sh</sub>(<bold>S</bold>; <bold>R</bold>) are plotted as a function of the available number of trials per stimulus. <bold>(A)</bold> Mean &#x000b1; SD/2 (over 50 simulations) of <italic>I</italic>(<bold>S</bold>; <bold>R</bold>). <bold>(B)</bold> Mean &#x000b1; SD/2 (over 50 simulations) of <italic>I</italic><sub>sh</sub>(<bold>S</bold>; <bold>R</bold>). This calculation is very similar to that in Panzeri et al. (<xref ref-type="bibr" rid="B31">2007</xref>, Figure <xref ref-type="fig" rid="F3">3</xref>), which also used realistic simulations of cortical spike trains (the only difference was that for this figure, the simulated population did not contain any correlations). This figure was produced using the Python library for bias corrections described in Section <xref ref-type="sec" rid="s1">&#x0201c;A Python Library for Information Theoretic Estimates&#x0201d;</xref>, and the code to produce it is available at <uri xlink:type="simple" xlink:href="http://code.google.com/p/pyentropy/">http://code.google.com/p/pyentropy/</uri>.</p></caption><graphic xlink:href="fninf-03-004-g001"/></fig><p>While the basic plug-in entropy calculation is a straightforward sum of logarithms, the correction methods described above add significant complexity to the required calculations. In QE, the underlying entropy calculations have to be run many times, for PT the Bayesian estimate of the number of stimulus responses involves additional calculations and NSB involves a complicated procedure of many numerical integrations. For large data sets, with the large probability spaces that can often arise from modern physiological techniques, performance can be an issue as these computational methods become increasingly CPU and memory intensive. Since the performance of bias correction procedures depends on the statistics of data under analysis, in each data analysis task it is also important to test the accuracy of information estimation methods on simulated data with statistical properties similar to the actual experimental data of interest (Panzeri et al., <xref ref-type="bibr" rid="B31">2007</xref>). It is therefore crucial that these methods be implemented as efficiently as possible. An advantage of Python is that one can benefit both from the improved development time due to the simple syntax and interactive environment, as well as a number of well developed methods for optimising the performance critical portions of the code when necessary. There are tools for automatically converting Python to C inline, inserting your own C code within a Python program, writing full C and FORTRAN extension modules or using Cython, which is a variant of the Python language with a similar syntax but that compiles straight to C code.</p></sec></sec><sec id="s1"><title>A python library for information theoretic estimates</title><p>The study and development of techniques for estimation of information theoretic quantities and associated bias corrections has developed into a field of its own. In order for the results of this work to be useful outside of this small community it must be possible for non-specialists to easily apply these techniques to their data. We have therefore developed a library of tools with the dual purpose of allowing easy application of the most suitable cutting edge bias corrections, while also providing a framework for continued enhancement of existing methods as well as development of new techniques. Although this has been developed for application to investigations of neural coding, the library has been designed to be as general as possible, in the hope that it might also be of use in other areas, and it is publicly available under an open source license<xref ref-type="fn" rid="fn3">3</xref>. There are similar packages available in other languages, such as the <monospace>R entropy</monospace> library<xref ref-type="fn" rid="fn4">4</xref> and the MATLAB Spike Train Analysis Toolbox<xref ref-type="fn" rid="fn5">5</xref>, but the authors are not aware of any similar Python package.</p><p>At the core of the library are two classes, <monospace>DiscreteSystem</monospace> and <monospace>SortedDiscreteSystem</monospace> which sample and store the probability distributions associated with a system and contain methods to compute different entropy quantities. <monospace>DiscreteSystem</monospace> is the most general and can take arbitrarily ordered input. The class is initialised as <monospace>s=DiscreteSystem(X, X_dims, Y, Y_dims)</monospace> where <monospace>X_dims=(Xn,Xm)</monospace> and <monospace>Y_dims=(Yn,Ym)</monospace> are tuples of values describing the parameters of the <monospace>X</monospace> and <monospace>Y</monospace> spaces respectively. <monospace>Xn</monospace> and <monospace>Yn</monospace> are the number of variables in the space, each of which is quantised to take one of <monospace>Xm</monospace> or <monospace>Ym</monospace> possible values, respectively. In total therefore there are <monospace>Xm<sup>Xn</sup></monospace> possible values in the <monospace>X</monospace> space and <monospace>Ym<sup>Yn</sup></monospace> in the <monospace>Y</monospace> space for each trial. <monospace>X</monospace> and <monospace>Y</monospace> are provided as integer arrays with values in <monospace>[0,</monospace> <monospace>Xm &#x02212; 1]</monospace> and <monospace>[0,</monospace> <monospace>Ym &#x02212; 1]</monospace> respectively with <monospace>Xn</monospace>, <monospace>Yn</monospace> rows representing the constituent variables and a column for each trial. It is important the columns match, that is the value of <monospace>X</monospace> in a given column corresponds to the same trial as the value of <monospace>Y</monospace> in the same column, but there are no further requirements on the format of the input. <monospace>SortedDiscreteSystem</monospace> requires the input trials to be grouped in values of the variable <monospace>Y</monospace>. This allows much more efficient sampling of the required probability distributions, since the trials for a given <monospace>Y</monospace> value can be easily isolated without having to search through the whole data set. This requires the space <monospace>Y</monospace> to be a single finite alphabet variable, so it should be decimalised beforehand if necessary. The class is initialised as <monospace>s = SortedDiscreteSystem(X,</monospace> <monospace>X_dims,</monospace> <monospace>Ym,</monospace> <monospace>Ny)</monospace> where <monospace>X,</monospace> <monospace>X_dims</monospace> are as above and <monospace>Ym</monospace> is the number of possible values for the single variable <monospace>Y</monospace> space. <monospace>Ny</monospace> is an array containing the number of trials available for each <monospace>Y</monospace> value. For example, <monospace>Ny[0]</monospace> is the number of trials available with <monospace>Y = 0</monospace>, and the corresponding <monospace>X</monospace> values are found at <monospace>X[0 : Ny[0]]</monospace>. Both of these classes inherit from a base class <monospace>BaseSystem</monospace> which contains the common entropy and information calculations, reducing code duplication and increasing maintainability.</p><p>In neural coding applications such as those described previously, <monospace>Y</monospace> would be the stimulus space <bold>S</bold>, while <monospace>X</monospace> would be the response space <bold>R</bold>. Since the stimuli are usually controlled by the experimenter, the results are often available already sorted by stimulus, allowing use of the more efficient <monospace>SortedDiscreteSystem</monospace> class. Mutual information is symmetric, <italic>I</italic>(<bold>X</bold>; <bold>Y</bold>)&#x02009;=&#x02009;<italic>I</italic>(<bold>Y</bold>; <bold>X</bold>), so in fact the stimulus and response spaces can be provided in any order, but due to the way the conditional probabilities are sampled it is strongly suggested that the smaller of the two spaces be provided as the <monospace>Y</monospace> parameter.</p><p>Once initialised as above, entropy quantities can be calculated using the method <monospace>s.calculate_entropies(method, sampling, calc)</monospace> where <monospace>method</monospace> is one of <monospace>[&#x02018;plugin&#x02019;,&#x02018;pt&#x02019;,&#x02018;qe&#x02019;, &#x02018;nsb&#x02019;]</monospace> and selects the bias correction technique to use, <monospace>sampling</monospace> is one of <monospace>[&#x02018;naive&#x02019;,&#x02018;beta:x&#x02019;,&#x02019;shrink&#x02019;]</monospace> which selects the method for estimating the probability distributions and <monospace>calc</monospace> is a list containing a number of entropies to calculate. The entropies available are <monospace>[&#x02018;HX&#x02019;,&#x02018;HY&#x02019;,&#x02018;HXY&#x02019;,&#x02018;SiHXi&#x02019;,&#x02018;HiX&#x02019;,&#x02018;HiXY&#x02019;, &#x02018;HshXY&#x02019;,&#x02018;ChiX&#x02019;]</monospace>, which in the case where, as described above, the space <monospace>X</monospace> corresponds to the response space <bold>R</bold> and <monospace>Y</monospace> to the stimulus space <bold>S</bold>, denote respectively <italic>H</italic>(<bold>R</bold>), <italic>H</italic>(<bold>S</bold>), <italic>H</italic>(<bold>R</bold>|<bold>S</bold>), <inline-formula><mml:math id="M13"><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi></mml:mstyle><mml:mtext>i</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> <italic>H</italic><sub>ind</sub>(<bold>R</bold>), <italic>H</italic><sub>ind</sub>(<bold>R</bold>|<bold>S</bold>), <italic>H</italic><sub>sh</sub>(<bold>R</bold>|<bold>S</bold>) and &#x003c7;(<bold>R</bold>). &#x003c7;(<bold>R</bold>) is a quantity needed for the information breakdown of (Pola et al., <xref ref-type="bibr" rid="B36">2003</xref>) and is reported in Eq. 25 therein. This function will first decimalise the <monospace>X</monospace> and <monospace>Y</monospace> spaces, if required (if <italic>n</italic> &#x0003e; 1) which involves converting the length-<italic>n</italic> base-<italic>m</italic> words representing the values for each space to a single decimal integer value in [0, <italic>m<sup>n</sup></italic> &#x02212; 1]. The probabilities required for the requested output entropies are then computed using the sampling method specified. &#x0201c; <monospace>naive</monospace>&#x0201d; represents the standard histogram bin counting method which is usually used. The add-constant estimator (Sch&#x000fc;rmann and Grassberger, <xref ref-type="bibr" rid="B41">1996</xref>) is implemented through the &#x0201c; <monospace>beta:x</monospace>&#x0201d; method. The &#x003b2; parameter is provided after the colon in the option, so &#x0201c; <monospace>beta:0.0</monospace> <monospace>1</monospace>&#x0201d; would use the add-constant estimator with &#x003b2; = 0.01. The &#x0201c; <monospace>shrink</monospace>&#x0201d; option selects the James&#x02013;Stein shrinkage estimator (Hausser and Strimmer, <xref ref-type="bibr" rid="B14">2008</xref>). All the entropy estimates are currently implemented in pure Python, except for the NSB estimator. This is implemented using existing publicly available optimised codes<xref ref-type="fn" rid="fn6">6</xref>. We have not yet implemented a direct link to the NSB codes, but instead write the data for analysis to a file, for processing by the standalone external program before reading back results from a file. Python's heritage as a scripting language makes this process of reading and writing formatted files and programmatically calling an external program from the code very easy. The functions <monospace>s.I()</monospace> and <monospace>s.Ish()</monospace> can be used to obtain the mutual information estimate and shuffled mutual information estimate respectively, provided the required entropies have been computed. Similarly <monospace>s.pola_decomp()</monospace> will return the computed values for the decomposition of the mutual information presented in Pola et al. (<xref ref-type="bibr" rid="B36">2003</xref>), again provided the required entropies were computed.</p><p>The module has been designed to be as flexible as possible, allowing comparison of the different methods at every stage. For example, the <monospace>DiscreteSystem</monospace> instance contains the sampled probability distributions, so it is possible to compare the different probability estimation methods directly. It is easy to add additional entropic quantities or new functions of them to the class. The code is documented through use of Python <italic>docstrings</italic>, which are embedded in the source and accessible through the interactive interpreter. Having the code documented in this way makes it easier for others to understand and contribute to.</p><p>There are several properties of Python that make it well suited to this application. Many loops can be vectorised into a single operation acting on arrays which is implemented through the NumPy interface to a highly efficient linear algebra library (ATLAS). When taking slices (extracting a single row or column) of a NumPy array, for example when determining the independent probabilities of the <monospace>X</monospace> variables, a new <italic>view</italic> is created, but points to the same original data. In contrast, in MATLAB, taking such a slice always results in the extracted row being copied in memory to a new array object. As discussed, the object-oriented nature of Python allows code reuse through inheritance. To give an example of the performance of the Pyentropy library, for the preparation of the data for the Plugin, PT and QE methods in Figure <xref ref-type="fig" rid="F1">1</xref>, the time taken using the Pyentropy library on a 2.4GHz Core 2 Duo laptop was 439&#x02009;s. This includes data simulation for 50 trials at each sample size. The same task, using similar MATLAB code on an equivalent laptop was 987&#x02009;s. There is also work in progress to extend the Pyentropy code with a more direct calculation of the core estimates in Cython. Cython is a language for writing C extensions to Python, and it shares a very similar syntax. This provides an easy way to quickly develop fast C modules to speed up the execution of Python code.</p><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>Responses of a VPm neuron to white noise vibrissa stimulation</bold>. <bold>(A)</bold> Vibrissa position as a function of time in units of stimulus SD (1 SD&#x02009;=&#x02009;70&#x02009;&#x003bc;m). <bold>(B)</bold> Spikes fired by the neuron in response to 70 repetitions of the stimulus shown in <bold>(A)</bold>.</p></caption><graphic xlink:href="fninf-03-004-g002"/></fig></sec></sec><sec><title>Finite Alphabet Maximum Entropy Solutions</title><sec><title>Correlations and maximum entropy models</title><p>Simultaneous recordings of the activity of individual neurons placed within local networks in the central nervous system show that most pairs of neurons are weakly correlated: the probability of observing simultaneous spiking is typically sightly &#x02013; but significantly &#x02013; different to the product of the probability of observing the individual spikes (Averbeck et al., <xref ref-type="bibr" rid="B3">2006</xref>; Mastronarde, <xref ref-type="bibr" rid="B19">1983</xref>). These correlations are hypothesized by many investigators to be a fundamental part of the neural population code; they may contribute, for example, by tagging the occurrence of particular salient stimulus combinations (Gray et al., <xref ref-type="bibr" rid="B12">1989</xref>), or by constraining the number of possible network states so that the network may perform error corrections (Schneidman et al., <xref ref-type="bibr" rid="B39">2006</xref>). Whatever the role of correlated firing, an observer of neural activity (either a data analyst or a downstream neural system) trying to assess the importance of correlated activity has to face a hard problem: correlations are difficult to sample because they are described by a number of parameters that increases exponentially with the number of cells considered. Therefore, it is important to establish whether it is possible to describe all correlations between neurons with a small number of parameters that preserve all the relevant features of the joint distribution of simultaneous responses. One way to find compact representations of the correlation structure of response probability can be obtained by using the technique of <italic>maximum entropy</italic> (Montemurro et al., <xref ref-type="bibr" rid="B22">2007b</xref>; Schneidman et al., <xref ref-type="bibr" rid="B40">2003</xref>; Tang et al., <xref ref-type="bibr" rid="B45">2008</xref>; Victor, <xref ref-type="bibr" rid="B49">2006</xref>), as follows.</p><p>The question addressed by maximum entropy models is how well we can describe all interactions between all variables in terms of subsets of interactions between up to <italic>K</italic> variables only, or whether and to what degree higher order interactions are present and important. The maximum entropy technique compares the measured response probability to one that takes into account all the observed interactions of up to <italic>K</italic> elements but does not impose any additional structure on the data. Measuring all interactions of up to <italic>K</italic> variables means measuring all the marginal response probabilities involving up to <italic>K</italic> variables. Therefore any probability matching the observed interactions of up to <italic>K</italic> elements must obey (apart from the usual non negativity and normalization constraints) the following linear constraints. Here we consider a response vector <bold>r</bold>&#x02009;=&#x02009;{<italic>r</italic><sub>1</sub>,&#x02026;, <italic>r</italic><sub>L</sub>} of dimension <italic>L</italic>, with each variable <italic>r<sub>i</sub></italic> taking values from a finite alphabet <bold>A</bold> containing <italic>m</italic> elements.<disp-formula id="E9"><label>(9)</label><mml:math id="M14"><mml:mrow><mml:mtable columnalign="right"><mml:mtr columnalign="right"><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>K</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>&#x02261;</mml:mo><mml:msubsup><mml:mtext>&#x003b7;</mml:mtext><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="right"><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>K</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>&#x02261;</mml:mo><mml:msubsup><mml:mtext>&#x003b7;</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="right"><mml:mtd columnalign="right"><mml:mrow><mml:mo>&#x02026;</mml:mo><mml:mo>&#x02003;</mml:mo><mml:mo>&#x02003;</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>&#x02003;</mml:mo><mml:mo>&#x02026;</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="right"><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>K</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>&#x02261;</mml:mo><mml:msubsup><mml:mtext>&#x003b7;</mml:mtext><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&#x02026;</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02026;</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>Each line above denotes a family of constraints on a model distribution <italic>P<sub>K</sub></italic>(<bold>r</bold>) enforcing equality of the marginal values of a given order to those of the true distribution <italic>P</italic>(<bold>r</bold>). These marginals are denoted by &#x003b7; with subscript indices representing the variables involved in the marginal and superscript indices the corresponding values. The <italic>a</italic><sup>th</sup> order constraint applies for all unique combinations of <italic>a</italic> variables, and every permutation of possible values that those variables can take. Thus the <italic>a</italic><sup>th</sup> line above represents <inline-formula><mml:math id="M15"><mml:mrow><mml:msup><mml:mi>m</mml:mi><mml:mi>a</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>L</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>a</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> constraints, the product of permutations of <italic>a</italic> values with choices of <italic>a</italic> variables.</p><p>The probability distribution <italic>P<sub>K</sub></italic>(<bold>r</bold>) with maximum entropy among those satisfying the above constraints is the one that does not impose the presence of any additional higher order correlations or interactions between the variables. To choose a distribution with lower entropy would correspond to the assumption of some additional structure that we do not know; to choose one with a higher entropy would necessarily violate the constraints that we wish to enforce.</p><p>Following Amari (<xref ref-type="bibr" rid="B1">2001</xref>); Cover and Thomas (<xref ref-type="bibr" rid="B6">2006</xref>) it can be shown that there is a unique solution to the constrained maximum entropy problem, which can be written in the following exponential form:<disp-formula id="E10"><label>(10)</label><mml:math id="M16"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>K</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>r</mml:mi></mml:mstyle><mml:mo>;</mml:mo><mml:mtext>&#x003b8;</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mtext>&#x003b8;</mml:mtext><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>&#x02211;</mml:mo><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&#x0003c;</mml:mo><mml:mo>&#x022ef;</mml:mo><mml:mo>&#x0003c;</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>a</mml:mi></mml:msub><mml:mo>&#x02264;</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02208;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>A</mml:mi></mml:mstyle></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:munder><mml:mrow><mml:msubsup><mml:mi>&#x003b4;</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&#x02026;</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02026;</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mtext>&#x003b8;</mml:mtext><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&#x02026;</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02026;</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:mstyle></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The set of indices <italic>i</italic><sub>1</sub>,&#x02026;,<italic>i<sub>a</sub></italic> label the subsets of a variables among the total <italic>L</italic> considered. The set of indices <inline-formula><mml:math id="M17"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> labels a specific set of values of these variables. The first term in the sum is a finite alphabet Kronecker delta function which takes the value 1 when the variables of the argument specified by the subscript indices take the values specified by the superscript indices, and 0 otherwise. As with the marginal constraints, the second sum for each order is over all unique combinations of <italic>a</italic> variables and all permutations of <italic>a</italic> values that those variables can take; there are <inline-formula><mml:math id="M18"><mml:mrow><mml:msup><mml:mi>m</mml:mi><mml:mi>a</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>L</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>a</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> summands, and the same number of distinct &#x003b8; coefficients of that order.</p><p>In order to compute the maximum entropy distribution <italic>P<sub>K</sub></italic>(<bold>r</bold>;&#x02009;&#x003b8;) compatible with all the known interactions up to <italic>K</italic>-th order, we need to find the &#x003b8; coefficients with up to <italic>K</italic> indices to construct the solution above. These can be determined from the knowledge of the experimental &#x003b7; marginal probabilities of up to K elements through a set of algebraic equations, as detailed in the following section.</p><p>Previous applications of the maximum entropy approach have included temporal sequences of spiking activity, or multi-unit spiking activity across a population, both of which are binary. This simplifies the calculation of the maximum entropy solutions. The extension to a finite alphabet probability space is a significant one, since it greatly increases the scope of possible applications for the method. For example, if larger time bins are used, there will sometimes be more than one spike occurring in each bin. At the moment these values are generally binarized, but using the finite alphabet method allows use of extended time bins, while keeping the effect of all spikes. It can therefore be used to investigate the effect of bursting. Similarly, the finite alphabet extension means the method can be applied to other data, such as LFPs (Belitski et al., <xref ref-type="bibr" rid="B4">2008</xref>) or fMRI, which are inherently continuous but may be meaningfully quantised into a finite alphabet. It also allows investigation of the reverse problem, neural encoding, where one studies the properties of the stimulus, given that a response (such as a spike) as occurred.</p><p>In the following, we describe an implementation of the finite-alphabet maximum entropy computation using Python. In analogy to Schneidman et al. (<xref ref-type="bibr" rid="B40">2003</xref>), we apply the maximum entropy calculation to <italic>P</italic>(<bold>r</bold>). However, the same procedure could be in principle applied to <italic>P</italic>(<bold>r</bold>|<italic>s</italic>).</p></sec><sec><title>An algorithm for finite-alphabet maximum entropy solutions</title><p>The key concept in the algorithm we use to obtain the maximum entropy solution is the idea of identifying a specific probability distribution using different <italic>coordinate systems</italic>. The most obvious way of characterising a discrete probability distribution is by specifying the full list of probabilities for each element of the space. For example, if we have a finite alphabet response vector <bold>r</bold>&#x02009;=&#x02009;{<italic>r</italic><sub>1</sub>,&#x02026;,<italic>r<sub>L</sub></italic>} as above, then there are <italic>m<sup>L</sup></italic> possible values for <bold>r</bold> and so the probability distribution <italic>P</italic>(<bold>r</bold>) can be characterised by <italic>m<sup>L</sup></italic>&#x02009;&#x02212;&#x02009;1 probability values, since one degree of freedom is removed by the normalisation constraint. These are called the <italic>p</italic>-coordinates. An alternative way of uniquely determining a probability distribution is by listing the marginal probability values. As mentioned in the previous section, there are <inline-formula><mml:math id="M19"><mml:mrow><mml:msup><mml:mi>m</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>L</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>k</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> marginals containing of order <italic>k</italic>, so the collection of all marginals has <inline-formula><mml:math id="M20"><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>L</mml:mi></mml:msubsup><mml:msup><mml:mi>m</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>L</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>k</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mi>L</mml:mi></mml:msup><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> elements. This way of describing the probability is called the &#x003b7;-coordinates. For the final characterisation of a probability distribution, we consider the form suggested by Eq. <xref ref-type="disp-formula" rid="E10">10</xref>. Taking <italic>K</italic>&#x02009;=&#x02009;<italic>L</italic>, <italic>P<sub>K</sub></italic>(<bold>r</bold>)&#x02009;=&#x02009;<italic>P</italic>(<bold>r</bold>) and Eq. <xref ref-type="disp-formula" rid="E10">10</xref> shows that any probability can be computed from the set of coefficients, &#x003b8;. Again there are <inline-formula><mml:math id="M21"><mml:mrow><mml:msup><mml:mi>m</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>L</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>k</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> coefficients of each order <italic>k</italic>. &#x003b8;<sub>0</sub> is fixed by the normalisation condition, so again we have <italic>m<sup>L</sup></italic>&#x02009;&#x02212;&#x02009;1 numbers that uniquely identify the probability distribution. Expressing a probability distribution in this way is also known as the <italic>log-linear</italic> form, and the coefficients, &#x003b8; are called the log-linear <italic>effects</italic>. Here we refer to them as the &#x003b8;-coordinates.</p><p>A given probability distribution is represented in any of these coordinate systems by a vector of values. In the following <bold>p</bold> denotes a vector describing a probability distribution in the <italic>p</italic>-coordinates, &#x003b7; denotes a vector of &#x003b7;-coordinate values and &#x003b8; a vector of &#x003b8;-coordinates. The <bold>p</bold> vector is ordered so that the value of the vector at a given index represents the probability of the underlying state which, when interpreted as a length <italic>L</italic> base <italic>m</italic> word, has the decimal value of the index. This ordering was chosen since it is easy to convert between state values and vector indices using existing change of basis functions. The vector &#x003b7;&#x02009;=&#x02009;(&#x003b7;<sub>1</sub>, &#x003b7;<sub>2</sub>,&#x02026;,&#x003b7;<sub><bold>L</bold></sub>) where &#x003b7;<sub><bold>i</bold></sub> is the set of all marginals of order <italic>i</italic>&#x02009;and similarly &#x003b8;&#x02009;=&#x02009;(&#x003b8;<sub>1</sub>, &#x003b8;<sub>2</sub>,&#x02026;,&#x003b8;<sub><bold>L</bold></sub>). The ordering of the vector within the subsets of different orders is arbitrary, however it is important that the subsets &#x003b8;<sub>i</sub> and &#x003b7;<sub>i</sub> share the same ordering for each <italic>i</italic>.</p><p>These notions are rigorously developed in Amari (<xref ref-type="bibr" rid="B1">2001</xref>) using the framework of information geometry, in which the set of probability distributions on a given vector space are treated as a manifold, and the properties of the coordinate systems described above are formalised.</p><sec><title>Coordinate transformations</title><p>An important step in the numerical method for obtaining the maximum entropy solution is the implementation of the transformations between the different coordinate systems described above for representing a probability distribution.</p><sec><title>&#x003b7;&#x02013;<italic>p</italic> transforms</title><p>The key transformation is that from <italic>p</italic>-coordinates to &#x003b7;-coordinates. This is a linear transformation which performs the summation of relevant probabilities for calculating the marginal. With the coordinates arranged in vectors, as described above, it can be expressed as<disp-formula id="E11"><label>(11)</label><mml:math id="M22"><mml:mrow><mml:mtext>&#x003b7;</mml:mtext><mml:mo>=</mml:mo><mml:mtext>A</mml:mtext><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>p</mml:mi></mml:mstyle></mml:mrow></mml:math></disp-formula>where <italic>A</italic> is a square matrix containing binary values. Each row of <italic>A</italic> contains a 1 in the column for each <italic>p</italic> coordinate that contributes to that marginal. The inverse transformation, <italic>p</italic> coordinates from &#x003b7; coordinates is simply<disp-formula id="E12"><label>(12)</label><mml:math id="M23"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>P</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mtext>&#x003b7;</mml:mtext></mml:mrow></mml:math></disp-formula></p><p>The matrix <italic>A</italic> is invertible since it is square and all its constituent rows are linearly independent.</p></sec><sec><title>&#x003b8;&#x02013;<italic>p</italic> transforms</title><p>For the &#x003b8;&#x02013;<italic>p</italic> transformations, first notice from Eq. <xref ref-type="disp-formula" rid="E10">10</xref> that in vector form <inline-formula><mml:math id="M24"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>p</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mtext>&#x003b8;</mml:mtext><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mtext>&#x003b8;</mml:mtext></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. This is because, for a given probability, the &#x003b8; terms required are those corresponding to the non-zero elements of that specific state vector. Similarly, for a given probability, that probability will appear in the sum for the marginals corresponding to the same non-zero elements of the state vector. The marginals that a given probability appears in are given by the columns of the matrix <italic>A</italic>, so provided the &#x003b8; vector is ordered in the same way as the &#x003b7; vector, the sum of &#x003b8; terms required in the exponential of Eq. <xref ref-type="disp-formula" rid="E10">10</xref> for each probability is given by <italic>A<sup>T</sup></italic>&#x003b8;. By evaluating Eq. <xref ref-type="disp-formula" rid="E10">10</xref> for the zero state vector <inline-formula><mml:math id="M25"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>L</mml:mi></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> we see that the constant factor in the log-linear model, <inline-formula><mml:math id="M26"><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mtext>&#x003b8;</mml:mtext><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, is in fact <italic>p</italic><sub>0</sub>. From <inline-formula><mml:math id="M27"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>p</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mtext>&#x003b8;</mml:mtext></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, it is trivial to obtain the following transformation from <italic>p</italic> coordinates to &#x003b8; coordinates.<disp-formula id="E13"><label>(13)</label><mml:math id="M28"><mml:mrow><mml:mtext>&#x003b8;</mml:mtext><mml:mo>=</mml:mo><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">[</mml:mo><mml:mi>ln</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mtext>&#x000a0;</mml:mtext><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>p</mml:mi></mml:mstyle><mml:mo>&#x02212;</mml:mo><mml:mi>ln</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mtext>&#x000a0;</mml:mtext><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p><p>The other direction is slightly more complicated, since for a closed expression for <bold>p</bold> we must compute <italic>p</italic><sub>0</sub> from the theta vector. The normalisation condition requires that <inline-formula><mml:math id="M29"><mml:mrow><mml:mo>&#x02211;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>p</mml:mi></mml:mstyle><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> since the vector <bold>p</bold> does not include the <italic>p</italic><sub>0</sub> value. Substituting the expression above gives <inline-formula><mml:math id="M30"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>&#x02211;</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mtext>&#x003b8;</mml:mtext></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x021d2;</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mo>&#x02211;</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mtext>&#x003b8;</mml:mtext></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> yielding<disp-formula id="E14"><label>(14)</label><mml:math id="M31"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>p</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mtext>&#x003b8;</mml:mtext></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mtext>&#x003b8;</mml:mtext></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p></sec></sec><sec><title>Numerical optimisation</title><p>The advantages of the different coordinate systems described above are that they allow us to easily represent our constraints on the maximum entropy solution. From Eq. <xref ref-type="disp-formula" rid="E9">9</xref> fixing interactions up to order <italic>K</italic> to those of the measured distribution corresponds to setting the low order &#x003b7;-coordinates of the maximum entropy solution equal to those of the measured distribution. From Eq. <xref ref-type="disp-formula" rid="E10">10</xref> the maximum entropy constraint is enforced by setting the high order components of the &#x003b8;-coordinates to zero. By enforcing these constraints simultaneously, we obtain a set of <italic>N</italic> simultaneous equations in <italic>N</italic> unknowns, where <inline-formula><mml:math id="M32"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:msup><mml:mi>m</mml:mi><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>L</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>j</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the number of coordinates up to order <italic>k</italic>. Again <italic>m</italic> is the size of the finite alphabet.</p><p>In the following &#x003b7;<sub><italic>k</italic></sub> represents the <italic>N</italic> low order (up to order <italic>k</italic>) marginals of the sampled distribution. <inline-formula><mml:math id="M33"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>&#x003b8;</mml:mtext><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mover accent="true"><mml:mtext>&#x003b8;</mml:mtext><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> represent the low and high order theta coordinates of the maximum entropy distribution. <inline-formula><mml:math id="M34"><mml:mrow><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>&#x002c7;</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x022c5;</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the coordinate transformation from &#x003b8; to <italic>p</italic> coordinates from Eq. <xref ref-type="disp-formula" rid="E14">14</xref> and <inline-formula><mml:math id="M35"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>&#x003b7;</mml:mtext><mml:mo>&#x002c7;</mml:mo></mml:mover><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x022c5;</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the coordinate transformation in Eq. <xref ref-type="disp-formula" rid="E11">11</xref> but with only the low order marginals returned. Setting the high order theta's, <inline-formula><mml:math id="M36"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>&#x003b8;</mml:mtext><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> to zero ensures that there are no higher order interactions. It is then possible to find the low order theta's that produce the same low order marginals as the sampled distribution, &#x003b7;<sub><italic>k</italic></sub>. These low order theta's, <inline-formula><mml:math id="M37"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>&#x003b8;</mml:mtext><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> completely characterise the maximum entropy distribution. In vector form the equations are:<disp-formula id="E15"><label>(15)</label><mml:math id="M38"><mml:mrow><mml:msub><mml:mtext>&#x003b7;</mml:mtext><mml:mi>k</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mover accent="true"><mml:mtext>&#x003b7;</mml:mtext><mml:mo>&#x002c7;</mml:mo></mml:mover><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>&#x002c7;</mml:mo></mml:mover></mml:mstyle><mml:mtext>&#x02009;</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mover accent="true"><mml:mtext>&#x003b8;</mml:mtext><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mover accent="true"><mml:mtext>&#x003b8;</mml:mtext><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>0</mml:mn></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>Once the <inline-formula><mml:math id="M39"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>&#x003b8;</mml:mtext><mml:mo>&#x000af;</mml:mo></mml:mover><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are determined by numerically solving the equation above, one can convert back to <italic>p</italic>-coordinates to obtain the corresponding maximum entropy distribution and calculate its entropy.</p></sec></sec><sec><title>Python implementation</title><p>Initially the method described above was implemented in MATLAB. Later, the same algorithm was converted to Python with NumPy and SciPy. This was both because we were having performance issues with MATLAB in the finite alphabet case, and partly as a way to evaluate Python as a platform for our work. This gives the opportunity to make comparisons between the two systems. However, as well as moving the code to Python, we continued to develop and improve the algorithms, making it difficult to provide rigorous performance comparisons between the two systems. Instead we hope to provide an overview of our experiences and impressions of using Python in an ongoing research project.</p><p>A major difference in the code between the two systems is the structure of the program. In MATLAB the notion of the global <italic>workspace</italic> was exploited. Here a setup script is used to define the coordinate transformation functions in the global workspace, from where they can be easily called by other scripts or used to interactively investigate data. In Python, an object-oriented approach was taken featuring two main classes. The first of these, <monospace>AmariSolve</monospace>, contains the parameters related to the underlying probability distribution, the required coordinate transformations and the code for performing the numerical solution. This is initialised with two parameters, the number of variables and the finite alphabet of each variable, since this is the only information required to implement the solution. The second class, <monospace>AmariSystem</monospace>, contains the data related to a specific system being studied, and contains the sampled probability distributions, calculated maximum entropy distributions and associated entropies. In this way the data independent analysis code is separated from the system specific code and data &#x02013; the idea being that a single <monospace>AmariSolve</monospace> instance can be used on different data sets, providing the dimensions of the probability space are the same. It was found this approach gave much more flexibility than the global workspace, which could be confusing to manage during development, for example by requiring a full copy of the setup script to be maintained for every change to the algorithm investigated.</p><p>A key step in the implementation of the algorithm is the generation of the matrix <italic>A</italic> which provides the transformation between probabilities (<italic>p</italic>-coordinates) and marginals (&#x003b7;-coordinates). A recursive function is used in a loop over each order, to compute the elements of <italic>A</italic> row by row. The code implements the longhand approach used for manual calculation of smaller matrices. The idea is that each marginal is the sum over all variables not fixed by the specification of the marginal. For each order a vector called <monospace>terms</monospace> is created which contains all base m words of length <italic>L</italic>&#x02009;&#x02212;&#x02009;<italic>o</italic>, where <italic>o</italic> is the order being considered. Then for each marginal, if columns of the appropriate value are inserted into the appropriate position in the <monospace>terms</monospace> array, the result contains a row for each probability state included in that marginal. These are converted to decimal, which directly gives the index in the probability vector, and the corresponding columns in <italic>A</italic> are set to 1. To cover the different marginals, first the alphabet value and then the position is looped over. For orders higher than one, this process is recursive, so the first alphabet value is looped over, then within that the first position, then within that the second alphabet, then the second position and so on. This transformation matrix can be very large since its dimensions are the dimensions of the full probability space. However, it is highly sparse in structure, so in both implementations the provided sparse array construct was used to reduce the amount of memory required. In SciPy, the sparse array module is very flexible, providing a number of formats and datatypes. The advantage of this was that the binary matrix <italic>A</italic> could be stored as a sparse array of 8-bit integers in SciPy, which provided a factor of eight memory saving over the 64-bit double which is the only type the MATLAB sparse matrix supports. Equations 12 and 13 show that some coordinate transformations require inversion of the matrix <italic>A</italic>. Although this is not required directly for the computation of the maximum entropies, it was frequently useful while investigating properties of the system and of the different maximum entropy solutions. SciPy offers a very flexible direct interface to the UMFPACK<xref ref-type="fn" rid="fn7">7</xref> library of sparse solvers (Davis, <xref ref-type="bibr" rid="B8">2004</xref>), that allowed us to easily pre-factor the matrix and store the results allowing rapid calculation of the coordinate transforms when needed.</p><p>The numerical optimisation step is very similar in both implementations, using the <monospace>fsolve</monospace> function of the respective system. In MATLAB a Gauss&#x02013;Newton method was used, while in SciPy <monospace>fsolve</monospace> is a wrapper around the MINPACK (Mor&#x000e9; et al., <xref ref-type="bibr" rid="B24">1999</xref>) <monospace>hybrd</monospace> algorithm which implements a modification of the Powell hybrid method. Both of these methods performed similarly. The function that the optimiser runs is the same in both implementations and this is a direct implementation of the left hand side of Eq. <xref ref-type="disp-formula" rid="E15">15</xref>; the Python version is shown below. Here <monospace>Asmall</monospace> is a subset of the transformation matrix <italic>A</italic> containing only the rows required and <monospace>Bsmall</monospace> is the transpose of this. <monospace>Asmall</monospace> is extracted from <italic>A</italic> using the <italic>slice</italic> operator, for example in Python, <monospace>Asmall = A[:l, :]</monospace>. Python again provides a significant advantage here in terms of memory used. In MATLAB, any such slice results in a <italic>copy</italic> of the data. However, with NumPy, the slice results in a <italic>view</italic> of the original data. Similarly, in NumPy the transpose is also a view, with a different starting point and striding, but the same data buffer as the original array. In MATLAB the transpose operation also produces a copy.<preformat position="float" xml:space="preserve"><monospace>def solvefunc(self, theta_un, Asmall, Bsmall, eta_sampled):   b&#x02009;=&#x02009;np.exp(Bsmall.matvec(theta_un))   y&#x02009;=&#x02009;eta_sampled( Asmall.matvec(b)/(b.sum()&#x02009;+&#x02009;1) )   return y</monospace></preformat></p><p>As the method was developed and applied to increasing large probability spaces, it became clear that the limiting factor for these more challenging parameter sets was the memory usage rather than the computation time. The Python implementation was therefore optimised to reduce the memory usage.</p><p>This enhancement was simplified by using the object-oriented features of Python. New classes were created which inherited from <monospace>AmariSolve</monospace> and <monospace>AmariSystem</monospace> described above. It was then possible to change only the required functions, for example the matrix generation routine, to stop at the required row. This minimised the other changes and duplication of code. Also, developing in this way meant very few changes were required to the analysis scripts to take advantage of this change &#x02013; in most cases a simple substitution of the class name at the top of the script was enough to use the new method. One of the memory optimisations was to produce the matrix <italic>A</italic> in smaller blocks, writing the rows and columns of the non-zero elements directly to files on disk to reduce memory overhead. Once this procedure was completed a sparse matrix in coordinate (COO) format could be generated directly from these files, and then converted to compressed sparse column (CSC) format for efficient matrix-vector multiplication. This is another example of where good results were obtained by using low level features that would not have been available in MATLAB.</p><p>As an example of the relative performance of Python and MATLAB, maximum entropy solutions of up to second order were computed for a system with <italic>n&#x02009;</italic>=&#x02009;4, <italic>m</italic>&#x02009;=&#x02009;9 (four variables each taking 1 of 9 values). The MATLAB code took 17&#x02009;s with a peak resident memory usage of 340&#x02009;MB and the Python code took 12&#x02009;s with a peak resident memory usage of 110&#x02009;MB. These results are typical of our experience across a range of parameter values. The numerical optimisation routine took almost exactly the same time in both systems, with the difference being due to the improved performance of the sampling of the probability distributions in Python. This is likely to be due to the reduced amount of data copying needed with NumPy when using slicing and other array operations.</p><p>In conclusion, for the development of this technique the use of Python with NumPy and SciPy libraries as an alternative to MATLAB was highly successful. The computational speed was very similar, but using NumPy allowed us to reduce the memory requirement by around two-thirds. This is important, because as described above, memory usage was the limiting factor restricting the size of the probability space over which the analysis could be performed. As well as the vectors representing the actual probability distribution, the sparse matrix <italic>A</italic> must be calculated and held in memory. The ability to use an 8-bit integer for this binary matrix with Python provided a factor of 8 memory saving over the MATLAB equivalent. More significantly, the algorithm requires extraction of the submatrix of up to the relevant order, and the transpose of that, which in MATLAB consists of copies (meaning for each order the data is copied in memory three times, once for the full matrix <italic>A</italic>, once for the extracted <monospace>Asmall</monospace> for the given order, and once for the transpose thereof, <monospace>Bsmall</monospace>). As an example, this meant that on a workstation with 2 GB of RAM the largest binary probability space that could be analysed up to order 3 was 12 variables for the MATLAB implementation, but 18 variables for the Python version. It is also worth noting that, while being similar to MATLAB, the Python language is a great pleasure to work with.</p><sec><title>Example of application to thalamic neural recordings</title><p>To illustrate the application of maximum entropy techniques, here we compute maximum entropy models from a neuron in the ventro posterior medial nucleus (VPm), which is the principal whisker-related relay nucleus in the rat thalamus. Using extracellular microelectrodes, we recorded the responses of single VPm units in anaesthetised rats whose whiskers were mechanically stimulated with a piezoelectric wafer driven by a low-pass filtered white noise (see Montemurro et al., <xref ref-type="bibr" rid="B21">2007a</xref>, for details). We used two types of white noise stimulation. The first sequence was identical on every trial (repeated stimulus); the second was independently generated on every trial (non-repeated stimulus). Figure <xref ref-type="fig" rid="F2">2</xref>B shows a raster plot of the spikes fired by a single neuron in response to 70 repetitions of the stimulus in Figure <xref ref-type="fig" rid="F2">2</xref>A. As previously reported (Montemurro et al., <xref ref-type="bibr" rid="B21">2007a</xref>; Petersen et al., <xref ref-type="bibr" rid="B34">2008</xref>), VPm responses to white noise were highly repeatable and temporally precise. An information theoretic analysis of these data revealed that these neurons convey information at sub-ms temporal precision (Montemurro et al., <xref ref-type="bibr" rid="B21">2007a</xref>) and that there are correlations between the times of individual spikes. One source of correlation came from the refractoriness of neurons, and another source of correlation came from their tendency to fire spikes in bursts (Montemurro et al., <xref ref-type="bibr" rid="B21">2007a</xref>). An important question is whether these correlations between the times of spikes emitted by the same neuron have a significant impact on the information and entropy of the neural spike train, and if these correlations can be described by simple pairwise models or if they rather need a complex, high order characterization. Here we will address these questions by using maximum entropy models which, as explained above, provide a natural framework to study the impact of different orders of correlation to spike train entropy and information. Previous studies employing maximum entropy have focussed mainly on correlations across a population of neurons (Schneidman et al., <xref ref-type="bibr" rid="B39">2006</xref>; Shlens et al., <xref ref-type="bibr" rid="B43">2006</xref>). Here, we extend this study to focus on correlations in time between spikes of a single neuron. This is interesting because finding a compact maximum entropy representation of within cell correlations is an important step towards understanding spike timing codes and representing them efficiently (Nirenberg and Victor, <xref ref-type="bibr" rid="B27">2007</xref>; Tang et al., <xref ref-type="bibr" rid="B45">2008</xref>).</p><p>We discretized the time into small bins of size &#x00394;<italic>t</italic> = 4 ms and quantified the response of the considered VPm neuron as a binary sequence of 1's and 0's (spikes or silence in that bin respectively), characterising the neural response <bold>r</bold> as non-overlapping binary words of length <italic>L</italic> extracted from this signal. We then considered the probability of response <italic>P</italic>(<bold>r</bold>) in response to all patterns of whisker stimulation obtained from the non-repeated white noise sequences, and we compared its entropy to that of the maximum entropy probability <italic>P<sub>K</sub></italic>(<bold>r</bold>) at level <italic>K</italic> (<italic>K</italic> = 1,&#x02026;,3) and to the entropy of the true distribution. Results are reported in Figure <xref ref-type="fig" rid="F3">3</xref>. We found that the lowest order model (<italic>K</italic> = 1, which considers spikes in each bin as independent from each other) provides an entropy very close to that carried by higher order probability models. The difference between lower and higher order entropies becomes proportionally larger as the length <italic>L</italic> of the binary word increases. However, differences remain small: for <italic>L</italic> = 14, the difference between the independent-model, <italic>K</italic> = 1 entropy and the true one remain within 3%. This suggests that the spike train could be quantitatively well described even by a simple model that ignores correlations between spikes at different time bins. It should be noted that in the Python implementation of this calculation, the limit on the maximum number of time bins <italic>L</italic> and the order <italic>K</italic> that could be analysed was set by the number of trials available and the effectiveness of the sampling bias corrections implemented, whereas in the corresponding MATLAB implementation the limit was reached when the available memory was consumed. For a binary system as described here that limit was <italic>L</italic> = 12, <italic>K</italic> = 2 on our workstation. This highlights the advantages of Python for these implementations.</p><fig id="F3" position="float"><label>Figure 3</label><caption><p><bold>Response entropy of a VPm neuron to white noise vibrassa stimulation</bold>. The full response entropy [<italic>H</italic>(<bold>R</bold>) denoted <italic>H</italic> in the figure] is shown together with that of maximum entropy models preserving first [<italic>H</italic><sup>(1)</sup>], first and second [<italic>H</italic><sup>(2)</sup>] and up to third order [<italic>H</italic><sup>(3)</sup>] marginal densities. The response is treated as non-overlapping words of length 6 (panel <bold>A</bold>), 10 (panel <bold>B</bold>) and 14 (panel <bold>C</bold>) bins, with each bin of 4&#x02009;ms duration.</p></caption><graphic xlink:href="fninf-03-004-g003"/></fig><p>It should be noted that while we are applying the analysis here to data from a single cell, the computational challenge is determined solely by the dimension of the underlying probability space. In this case, the largest underlying probability space considered has a dimension of 2<sup>14</sup> which is computationally equivalent to the case of the binary response of 14 simultaneously recorded neurons.</p></sec></sec></sec><sec><title>Collaborative Computing</title><p>There is a growing trend in neuroscience towards the development and use of collaborative computing services. These are multi-user systems, accessed over the internet which provide computational resources while facilitating interaction between users. This is a natural evolution for the field, as rapid advances in physiological techniques of many kinds result in data sets of increasing size and with an associated proliferation of analysis tools of increasing complexity. The idea is to provide an environment to foster collaboration, especially between experimentalists and theoreticians, by providing databases of experimental results, and online analytical tools for application to those data.</p><p>The field of bioinformatics has pioneered the development of such systems, which are now well established and playing an important role. However, implementing such systems for neuroscience presents some challenges not faced by the bioinformatics community. The greatest of these is the volume and variety of experimental data. While traditional bioinformatics services tend to process data as strings &#x02013; which is partly why the Perl programming language still underpins much bioinformatics analysis &#x02013; in neuroscience we deal with large sets of binary data in a variety of different formats. This presents difficulties for the decentralised model of separately provided and hosted services that has become popular in the bioinformatics community. This data requires significant contextual detail, or metadata, to be useful and is large enough to make the sharing of terabytes of data between labs a significant issue. It therefore seems that neuroscience requires a stronger organisational structure for these systems, to facilitate easier interoperability of data and provide security and access control.</p><p>The adoption of Python is highly advantageous in this context. The Python language is flexible, extensible and runs on a wide range of platforms. It also has the fast array mathematics crucial for neuroscience work, which are not available in languages such as Perl, which have been traditionally used for bioinformatics services. Like Perl though, it is a dynamic interpreted language, which simplifies the deployment of code on distributed systems. It has a similar syntax to MATLAB, the established standard in the field, and although there are no automated tools, translating code and algorithms from one to the other is relatively straightforward. Unfortunately it is difficult to use MATLAB to provide these kinds of multi-user services due to licensing restrictions. We are working on adapting our information theoretic techniques for use in systems of this type, and this was one of the factors that influenced our decision to investigate Python.</p><p>The Code, Analysis, Repository and Modelling for e-Neuroscience (CARMEN)<xref ref-type="fn" rid="fn8">8</xref> project is a consortium effort to create a virtual laboratory for neurophysiology (Gibson et al., <xref ref-type="bibr" rid="B11">2008</xref>), and is one example of project attempting to provide a centralised organisational structure for collaborative computing in neuroscience, as discussed above. CARMEN is an e-Science Pilot Project funded by the Engineering and Physical Sciences Research Council (UK) and involves investigators from 11 UK universities.</p><p>The goals of the CARMEN project are to create a decentralised computing resource used by experimentalists and theoreticians alike; a repository for both experimental data and analysis code that can be made available to all users of the system. We are working to provide our Python-based information theoretic algorithms as &#x0201c;services&#x0201d; on the CARMEN system. Providing such packaged services as modules that can be used in easy to construct &#x0201c;workflows&#x0201d; has many advantages. It allows easy comparison of different analytical techniques on the same dataset, as well as allowing application of a given technique to a number of different datasets that might otherwise be hard to obtain or convert to a suitable format. It allows application of the techniques of information theory by experimentalists and others who may otherwise lack the mathematical background, programming skills or inclination to implement such techniques by hand from the literature. It should also allow better reproducibility of published results, as well as providing a substantial computational resource allowing calculations that could be too time consuming for a user to perform on a desktop computer.</p><sec><title>Python web services</title><p>A &#x0201c;web service&#x0201d; is &#x0201c;a software system designed to support interoperable machine-to-machine interaction over a network&#x0201d;<xref ref-type="fn" rid="fn9">9</xref>. Web services are well suited to collaborative computing services, and they have been proven as a successful model for e-Science through their use in the bioinformatics community. They are also used as the foundation of the analysis code in the CARMEN project described above. Web services are operating system, location and language neutral. This is exploited in CARMEN to allow dynamic deployment of services to different computational nodes, and also simplifies the use and integration of analysis code written in a range of languages.</p><p>There are a number of standards governing the behaviour of web services, largely provided by the World Wide Web Consortium (W3C), which are required to allow them to interact. The fact that these standards are vendor neutral has enabled them to gain traction where previous attempts to provide interoperable services has failed. Simple Object Access Protocol (SOAP)<xref ref-type="fn" rid="fn10">10</xref> is a standard XML based messaging format used to pass data and parameters to an analysis service, and then receive the results back. All clients and web services are capable of passing and decoding SOAP messages. The other pivotal standard is that of the Web Services Description Language (WSDL)<xref ref-type="fn" rid="fn11">11</xref>, an XML document for the description of a web service; that is the method calls it provides, the arguments they require and the results they return. The WSDL that represents a web service is sufficiently informative to allow automatic generation of clients capable of binding to the service.</p><p>As part of our work we are making the information theoretic techniques that we are developing available as web services, for use in CARMEN and similar systems. Python greatly eases this process. We can create a Python-based service for a specific information theoretic task simply by importing our information theoretic library and calling the appropriate function with the appropriate arguments. This reduces code repetition, and the flexibility and simplicity of the Python module system makes the process easy to manage. For example, if the algorithmic code was actually included in the service programs, this would exist in every service performing an information theoretic calculation with a copy on every node to which the service had been deployed. By having a library with a consistent API, this can be updated in a single place on each computational node without having to change any of the existing services.</p><p>Once there is a Python script to perform the required task, it is necessary to &#x0201c;wrap&#x0201d; it to create a web service. There are a number of toolkits to do this including the Python native Zolera SOAP Infrastructure (ZSI) and SOAPpy. However, the method we have been using is InstantSOAP<xref ref-type="fn" rid="fn12">12</xref> a generic toolkit capable of exposing legacy applications as web services. Initially, we have created Python scripts that run as command line applications. This is straightforward since Python includes an excellent tool for easily parsing command line options. InstantSOAP provides a native command line processor to wrap any command line application into a web service through the creation of a single XML file. Work is currently in progress to extend InstantSOAP to natively support Python services, allowing direct deployment of a Python function as a web service, without requiring the developer to understand the web services stack, a significant barrier to entry in developing web services in any language. Python's licensing model is also important in the deployment of distributed services; MATLAB suffers from licensing restrictions for collaborative deployment. This makes it harder both to provide open services to a large number of users and to employ the dynamic deployment architecture through which code may run on a number of computational nodes. For example, whilst CARMEN is capable of providing MATLAB web services, it is through compiled MATLAB scripts, supported by the MATLAB runtime environment, and has no native interface to MATLAB <italic>per se</italic>, adding additional complexity to the procedure of creating, deploying and managing web services. There are also a number of ongoing technical challenges related to running the compiled MATLAB binaries within the web service environment.</p></sec></sec><sec sec-type="Discussion"><title>Discussion</title><p>In modern neuroscience a growing challenge is handling and interpreting increasingly large volumes of physiological data of many different types. To face this challenge computational techniques are becoming more and more important. We have described information theory, which is one such technique that is particularly suited to the challenges posed by neurophysiological datasets, and can provide valuable insights into neural coding and the function of the nervous system.</p><p>Information theory provides a natural framework to study communication in most systems, and the brain is no exception. An obstacle to a wider spread of its use among sensory neurophysiology laboratories has been the technical difficulties associated with its calculation (mostly the problem of bias corrections) and the lack of well defined, cross-platform packages that can handle generic datasets. The work presented in this paper is an attempt to address this limitation and provide the neuroscience community with open source packages that allow unbiased calculation of information from various types of neural data, from spikes to field potentials. The use of Python helps to develop flexible tools that can easily be applied or extended (because of the flexibility of the Python language) to handle different types of neurophysiological signals (because of the ability to manage memory efficiently) and to different data formats (because of the ability of Python to easily read a variety of data formats commonly used in neuroscience).</p><p>We have also described a current area of intensive research on neural coding; namely a new implementation for computing solutions of maximum entropy given marginal constraints. Although the example presented in Figure <xref ref-type="fig" rid="F3">3</xref> was on a binary data space, the ability of the code to support finite alphabet probability spaces is significant and allows the application of the maximum entropy technique to a wide range of new areas. In our own experience with simulated data (results not shown here, but partly reported in L&#x000fc;dtke et al., <xref ref-type="bibr" rid="B18">2009</xref>), using the Python implementation described here we were able to solve maximum entropy solutions of order 2 on spaces of up to 7 variables quantised to 9 levels (a probability space with dimension &#x0223c;4.7&#x02009;m) on a well-equipped workstation in a reasonable amount of time (&#x0223c;1 day). This was a dramatic improvement over what we were initially able to achieve with the MATLAB version of code; indeed the MATLAB version would have been unable to solve for a system of that size due to memory limitations. Other potential finite alphabet applications include analysis of quantised naturally continuous signals, such as LFP or fMRI as well as opening the possibility of studying the interactions between the stimulus features encoded by spiking responses, where instead of response given stimulus we consider the properties of the stimulus given a response.</p><p>Looking to the future of inter-disciplinary science, we have considered the possibilities offered by collaborative computing services based on grid or cloud architectures. While such systems have been developed for use in other areas, neuroscience poses some unique challenges. We have outlined our work as part of the CARMEN project, which hopes to address these challenges and provide a valuable service for storage, processing and analysis of electrophysiological data. We are developing information theoretic analysis tools as web services, which will make them available to greater range of practitioners, and hopefully increase their use within the neuroscience community.</p><p>The development of analysis tools like the ones discussed here has potentially significant implications for the refinement, reduction and replacement (3R) of animals in research. In our specific case, the opportunity to easily run information analysis on a number of different existing datasets (which as discussed, is facilitated by Python) maximizes the probability of obtaining new insights into neural codes without the need to sacrifice new animals. The free availability of advanced routines for calculation of bias-corrected information estimates offers neurophysiological laboratories the possibility of reliably computing information from a smaller number of trials, thereby maximizing the potential to record from multiple sites in the same animal and thus reducing the total number of animals needed for statistical significance. The ability of the code to adapt to the different types of neural signals that can simultaneously be extracted from the extracellular signal also increases the amount of information that can be obtained without increasing the invasiveness of the recording procedures.</p><p>We have found significant advantages to using Python for all of the work described above. As discussed, we have found it well suited both to reimplementing existing techniques for exposure to a wider audience, as open-source packages and hosted computational services, and to the research and development of new techniques and algorithms. Together with the excellent interactive environment IPython<xref ref-type="fn" rid="fn13">13</xref>, it provides much of the power available from low level C coding with a numerical library, but with greatly reduced complexity and development time. For example, a major advantage for our maximum entropy application was the way we were able to fine tune the use of the sparse matrix structures. The interactive nature, familiar to users of MATLAB, is crucial to aid research, both in terms of investigation of data as well as development of algorithms. Compared to MATLAB, we have seen performance increases in moving our code to Python, particularly related to memory management in the case of our more demanding algorithms. In addition, increased productivity and code manageability, for example from the ability to use object-oriented programming techniques, speed development and ease collaboration with other researchers.</p><p>We have experienced few problems with migrating our code from MATLAB. We have been able to easily access existing data stored in .MAT files and also to smoothly translate code. It is even possible to call MATLAB from Python, through the <monospace>mlabwrap</monospace> module<xref ref-type="fn" rid="fn14">14</xref>, which we have used to run existing MATLAB code provided by colleagues for preprocessing data. Initially the required packages were difficult to install, requiring compilation from source of a range of packages with complicated dependencies. Actually getting the software installed was therefore the greatest challenge when we began using Python. However, since then, the community has done a lot of work in improving this process, and there are now regular binary releases of all the important components, as well as a number of projects that distribute a complete scientific tool chain with all required components through a common installer<xref ref-type="fn" rid="fn15">15</xref>. Another challenge was adapting to the pass by reference semantics of Python rather than the pass by value style of MATLAB, as well as adapting to 0 based indexing. However, once these mental adjustments had been made we found ourselves more productive with Python than we were with MATLAB. Other disadvantages of Python are that the documentation of the included functions, while still available interactively, is not as comprehensive as that provided with MATLAB and the plotting functionality provided by <monospace>matplotlib</monospace>, is not quite as easy to use or well developed as the MATLAB version, especially with regard to 3D plotting.</p><p>We have been able to easily provide our Python code as web services, for integration into collaborative systems such as CARMEN, without requiring a significant time investment to adjust or tune the code for this purpose. In fact, Python is an excellent fit for projects such as CARMEN. It provides the flexibility of dynamic interpreted languages such as Perl, that have traditionally been used to provide services in systems of this type, while including the fast array mathematics that are crucial for the efficient analysis of neurophysiological data. It is difficult to use MATLAB in systems such as this, due to licensing restrictions which pose problems, both for allowing multiple users to access the service, and for running the service on different nodes in a grid infrastructure. Obviously, with Python being open source, there are no such issues. The benefits of open source extend beyond collaborative computing projects however; there is a compelling open-access argument for avoiding expensive proprietary software in published scientific work.</p><p>So far we have only scratched the surface in terms of what is available in the Python ecosystem that could be of benefit for our work. The extensive collection of modules available for Python allow great flexibility, for example making it much easier to develop GUI interfaces and handle a wide variety of data formats. There are also several methods to easily extend Python code with natively compiled C extensions, to increase the performance of critical sections of code, while still allowing the interactive use and rapid development of Python. We are currently focussed on optimising our information theoretic codes through the use of Cython<xref ref-type="fn" rid="fn16">16</xref>, which we are finding significantly easier to use and less error prone than the MATLAB equivalent (the MEX interface). Another area we are actively investigating in the use of parallelism. In many cases our problems are <italic>embarrassingly parallel</italic>, for example calculating information theoretic bias-corrected quantities over a number of data sets or computing maximum entropy solutions of different orders and conditional distributions. A number of open source solutions exist for parallel computing with Python, and we are investigating using these features of IPython to easily distribute these types of jobs to available machines.</p></sec><sec><title>Supplementary Material</title><p>The Python library for information theoretic estimates described in Section <xref ref-type="sec" rid="s1">&#x0201c;A Python Library for Information Theoretic Estimates&#x0201d;</xref>, including code for producing Figure <xref ref-type="fig" rid="F1">1</xref>, can be found at <uri xlink:type="simple" xlink:href="http://code.google.com/p/pyentropy/">http://code.google.com/p/pyentropy/</uri>. The code for obtaining the finite alphabet maximum entropy solutions can also be found on that page. This code is provided as Supplementary Material on the conditions that (1) the authorship of the software shall be acknowledged, (2) the present article shall be correctly cited in any publication that uses results generated by the software, (3) any publication that uses results generated by our software shall correctly cite the original articles (cited in this paper) which developed any bias correction methods used.</p></sec><sec><title>Conflict of Interest Statement</title><p>The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p></sec></body><back><ack><p>This work was supported by the EPSRC &#x0201c;CARMEN&#x0201d; grant and by IIT. We are indebted to C. Magri, R. Senatore, F. Montani, N. Ludtke and M. A. Montemurro for useful discussions on the implementation of entropy methods and for important contributions to the development of the information theoretic algorithms.</p></ack><ref-list><title>References</title><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Amari</surname><given-names>S. I.</given-names></name></person-group> (<year>2001</year>). <article-title>Information geometry on hierarchy of probability distributions</article-title>. <source>IEEE Trans. Inf. Theory</source><volume>47</volume>, <fpage>1701</fpage>&#x02013;<lpage>1711</lpage><pub-id pub-id-type="doi">10.1109/18.930911</pub-id></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Arabzadeh</surname><given-names>E.</given-names></name><name><surname>Panzeri</surname><given-names>S.</given-names></name><name><surname>Diamond</surname><given-names>M. E.</given-names></name></person-group> (<year>2004</year>). <article-title>Whisker vibration information carried by rat barrel cortex neurons</article-title>. <source>J. Neurosci.</source><volume>24</volume>, <fpage>6011</fpage>&#x02013;<lpage>6020</lpage><pub-id pub-id-type="doi">10.1523/JNEUROSCI.1389-04.2004</pub-id><pub-id pub-id-type="pmid">15229248</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Averbeck</surname><given-names>B. B.</given-names></name><name><surname>Latham</surname><given-names>P. E.</given-names></name><name><surname>Pouget</surname><given-names>A.</given-names></name></person-group> (<year>2006</year>). <article-title>Neural correlations, population coding and computation</article-title>. <source>Nat. Rev. Neurosci.</source><volume>7</volume>, <fpage>358</fpage>&#x02013;<lpage>367</lpage><pub-id pub-id-type="doi">10.1038/nrn1888</pub-id><pub-id pub-id-type="pmid">16760916</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Belitski</surname><given-names>A.</given-names></name><name><surname>Gretton</surname><given-names>A.</given-names></name><name><surname>Magri</surname><given-names>C.</given-names></name><name><surname>Marayama</surname><given-names>Y.</given-names></name><name><surname>Montemurro</surname><given-names>M. A.</given-names></name><name><surname>Logothetis</surname><given-names>N. K.</given-names></name><name><surname>Panzeri</surname><given-names>S.</given-names></name></person-group> (<year>2008</year>). <article-title>Low-frequency local field potentials and spikes in primary visual cortex convey independent visual information</article-title>. <source>J. Neurosci.</source><volume>28</volume>, <fpage>5696</fpage>&#x02013;<lpage>5709</lpage><pub-id pub-id-type="doi">10.1523/JNEUROSCI.0009-08.2008</pub-id><pub-id pub-id-type="pmid">18509031</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Borst</surname><given-names>A.</given-names></name><name><surname>Theunissen</surname><given-names>F. E.</given-names></name></person-group> (<year>1999</year>). <article-title>Information theory and neural coding</article-title>. <source>Nat. Neurosci.</source><volume>2</volume>, <fpage>947</fpage>&#x02013;<lpage>957</lpage><pub-id pub-id-type="doi">10.1038/14731</pub-id><pub-id pub-id-type="pmid">10526332</pub-id></citation></ref><ref id="B6"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Cover</surname><given-names>T. M.</given-names></name><name><surname>Thomas</surname><given-names>J. A.</given-names></name></person-group> (<year>2006</year>). <article-title>Elements of Information Theory</article-title>, <edition>2nd Edn.</edition><publisher-loc>Hoboken, NJ</publisher-loc>, <publisher-name>John Wiley &#x00026; Sons</publisher-name></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Dan</surname><given-names>Y.</given-names></name><name><surname>Alonso</surname><given-names>J. M.</given-names></name><name><surname>Usrey</surname><given-names>W. M.</given-names></name><name><surname>Reid</surname><given-names>R. C.</given-names></name></person-group> (<year>1998</year>). <article-title>Coding of visual information by precisely correlated spikes in the lateral geniculate nucleus</article-title>. <source>Nat. Neurosci.</source><volume>1</volume>, <fpage>501</fpage>&#x02013;<lpage>507</lpage><pub-id pub-id-type="doi">10.1038/2217</pub-id><pub-id pub-id-type="pmid">10196548</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Davis</surname><given-names>T. A.</given-names></name></person-group> (<year>2004</year>). <article-title>Algorithm 832: UMFPACK V4. 3 &#x02013; An unsymmetric-pattern multifrontal method</article-title>. <source>ACM Trans. Math. Soft.</source><volume>30</volume>, <fpage>196</fpage>&#x02013;<lpage>199</lpage><pub-id pub-id-type="doi">10.1145/992200.992206</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>de Ruyter van Steveninck</surname><given-names>R.</given-names></name><name><surname>Lewen</surname><given-names>G.</given-names></name><name><surname>Strong</surname><given-names>S.</given-names></name><name><surname>Koberle</surname><given-names>R.</given-names></name><name><surname>Bialek</surname><given-names>W.</given-names></name></person-group> (<year>1997</year>). <article-title>Reproducibility and variability in neural spike trains</article-title>. <source>Science</source><volume>21</volume>, <fpage>1805</fpage>&#x02013;<lpage>1808</lpage><pub-id pub-id-type="pmid">9065407</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Fuhrmann Alpert</surname><given-names>G.</given-names></name><name><surname>Sun</surname><given-names>F.</given-names></name><name><surname>Handwerker</surname><given-names>D.</given-names></name><name><surname>D'Esposito</surname><given-names>M.</given-names></name><name><surname>Knight</surname><given-names>R.</given-names></name></person-group> (<year>2007</year>). <article-title>Spatio-temporal information analysis of event-related BOLD responses</article-title>. <source>Neuroimage</source><volume>34</volume>, <fpage>1545</fpage>&#x02013;<lpage>1561</lpage><pub-id pub-id-type="doi">10.1016/j.neuroimage.2006.10.020</pub-id><pub-id pub-id-type="pmid">17188515</pub-id></citation></ref><ref id="B11"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Gibson</surname><given-names>F.</given-names></name><name><surname>Austin</surname><given-names>J.</given-names></name><name><surname>Ingram</surname><given-names>C.</given-names></name><name><surname>Fletcher</surname><given-names>M.</given-names></name><name><surname>Jackson</surname><given-names>T.</given-names></name><name><surname>Jessop</surname><given-names>M.</given-names></name><name><surname>Knowles</surname><given-names>A.</given-names></name><name><surname>Liang</surname><given-names>B.</given-names></name><name><surname>Lord</surname><given-names>P.</given-names></name><name><surname>Pitsilis</surname><given-names>G.</given-names></name><name><surname>Periorellis</surname><given-names>P.</given-names></name><name><surname>Simonotto</surname><given-names>J.</given-names></name><name><surname>Watson</surname><given-names>P.</given-names></name><name><surname>Smith</surname><given-names>L.</given-names></name></person-group> (<year>2008</year>). <article-title>The CARMEN Virtual Laboratory: Web-Based Paradigms for Collaboration in Neuroscience</article-title>. 6th International Meeting on Substrate-Integrated Microelectrodes. Reutlingen, Germany.</citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gray</surname><given-names>C. M.</given-names></name><name><surname>Konig</surname><given-names>P.</given-names></name><name><surname>Engel</surname><given-names>A. K.</given-names></name><name><surname>Singer</surname><given-names>W.</given-names></name></person-group> (<year>1989</year>). <article-title>Oscillatory responses in cat visual cortex exhibit inter-columnar synchronization which reflects global stimulus properties</article-title>. <source>Nature</source><volume>338</volume>, <fpage>334</fpage>&#x02013;<lpage>337</lpage><pub-id pub-id-type="doi">10.1038/338334a0</pub-id><pub-id pub-id-type="pmid">2922061</pub-id></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hatsopoulos</surname><given-names>N. G.</given-names></name><name><surname>Ojakangas</surname><given-names>C. L.</given-names></name><name><surname>Paninski</surname><given-names>L.</given-names></name><name><surname>Donoghue</surname><given-names>J. P.</given-names></name></person-group> (<year>1998</year>). <article-title>Information about movement direction obtained from synchronous activity of motor cortical neurons</article-title>. <source>Proc. Natl. Acad. Sci.</source><volume>95</volume>, <fpage>15706</fpage>&#x02013;<lpage>15711</lpage><pub-id pub-id-type="doi">10.1073/pnas.95.26.15706</pub-id><pub-id pub-id-type="pmid">9861034</pub-id></citation></ref><ref id="B14"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Hausser</surname><given-names>J.</given-names></name><name><surname>Strimmer</surname><given-names>K.</given-names></name></person-group> (<year>2008</year>). <article-title>Entropy inference and the James&#x02013;Stein estimator</article-title>. Preprint, arXiv:0811.3579v1.</citation></ref><ref id="B15"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Honey</surname><given-names>C. J.</given-names></name><name><surname>Kotter</surname><given-names>R.</given-names></name><name><surname>Breakspear</surname><given-names>M.</given-names></name><name><surname>Sporns</surname><given-names>O.</given-names></name></person-group> (<year>2007</year>). <article-title>Network structure of cerebral cortex shapes functional connectivity on multiple time scales</article-title>. <source>Proc. Natl. Acad. Sci.</source><volume>104</volume>, <fpage>10240</fpage>&#x02013;<lpage>10245</lpage><pub-id pub-id-type="doi">10.1073/pnas.0701519104</pub-id><pub-id pub-id-type="pmid">17548818</pub-id></citation></ref><ref id="B16"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Jones</surname><given-names>E.</given-names></name><name><surname>Oliphant</surname><given-names>T.</given-names></name><name><surname>Peterson</surname><given-names>P.</given-names></name><etal/></person-group> (<year>2001</year>). <article-title>SciPy: Open Source Scientific Tools for Python</article-title>. URL <uri xlink:type="simple" xlink:href="http://www.scipy.org/">http://www.scipy.org/</uri></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Latham</surname><given-names>P. E.</given-names></name><name><surname>Nirenberg</surname><given-names>S.</given-names></name></person-group> (<year>2005</year>). <article-title>Synergy, redundancy, and independence in population codes, revisited</article-title>. <source>J. Neurosci.</source><volume>25</volume>, <fpage>5195</fpage>&#x02013;<lpage>5206</lpage><pub-id pub-id-type="doi">10.1523/JNEUROSCI.5319-04.2005</pub-id><pub-id pub-id-type="pmid">15917459</pub-id></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>L&#x000fc;dtke</surname><given-names>N.</given-names></name><name><surname>Ince</surname><given-names>R. A. A.</given-names></name><name><surname>Brown</surname><given-names>M.</given-names></name><name><surname>Kell</surname><given-names>D. B.</given-names></name><name><surname>Panzeri</surname><given-names>S.</given-names></name></person-group> (<year>2009</year>). <article-title>A comparative evaluation of entropy and variance based methods for sensitivity analysis</article-title>. In <source>Preparation</source></citation></ref><ref id="B19"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Mastronarde</surname><given-names>D. N.</given-names></name></person-group> (<year>1983</year>). <article-title>Correlated firing of cat retinal ganglion cells. I. Spontaneously active inputs to X- and Y-cells</article-title>. <source>J. Neurophysiol.</source><volume>49</volume>, <fpage>303</fpage>&#x02013;<lpage>324</lpage><pub-id pub-id-type="pmid">6300340</pub-id></citation></ref><ref id="B20"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Miller</surname><given-names>G. A.</given-names></name></person-group> (<year>1955</year>). <article-title>Note on the bias of information estimates</article-title>. In <source>Information Theory in Psychology: Problems and Methods</source>, <person-group person-group-type="editor"><name><surname>Quastler</surname><given-names>H.</given-names></name></person-group> ed. (<publisher-loc>Glencoe, Ill</publisher-loc>, <publisher-name>Free Press</publisher-name>), pp. <fpage>95</fpage>&#x02013;<lpage>100</lpage></citation></ref><ref id="B21"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Montemurro</surname><given-names>M. A.</given-names></name><name><surname>Panzeri</surname><given-names>S.</given-names></name><name><surname>Maravall</surname><given-names>M.</given-names></name><name><surname>Alenda</surname><given-names>A.</given-names></name><name><surname>Bale</surname><given-names>M. R.</given-names></name><name><surname>Brambilla</surname><given-names>M.</given-names></name><name><surname>Petersen</surname><given-names>R. S.</given-names></name></person-group> (<year>2007a</year>). <article-title>Role of precise spike timing in coding of dynamic vibrissa stimuli in somatosensory thalamus</article-title>. <source>J. Neurophysiol.</source><volume>98</volume>, <fpage>1871</fpage>&#x02013;<lpage>1882</lpage><pub-id pub-id-type="doi">10.1152/jn.00593.2007</pub-id><pub-id pub-id-type="pmid">17671103</pub-id></citation></ref><ref id="B22"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Montemurro</surname><given-names>M. A.</given-names></name><name><surname>Senatore</surname><given-names>R.</given-names></name><name><surname>Panzeri</surname><given-names>S.</given-names></name></person-group> (<year>2007b</year>). <article-title>Tight data-robust bounds to mutual information combining shuffling and model selection techniques</article-title>. <source>Neural Comput.</source><volume>19</volume>, <fpage>2913</fpage>&#x02013;<lpage>2957</lpage><pub-id pub-id-type="doi">10.1162/neco.2007.19.11.2913</pub-id><pub-id pub-id-type="pmid">17883346</pub-id></citation></ref><ref id="B23"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Montemurro</surname><given-names>M. A.</given-names></name><name><surname>Rasch</surname><given-names>M. J.</given-names></name><name><surname>Murayama</surname><given-names>Y.</given-names></name><name><surname>Logothetis</surname><given-names>N. K.</given-names></name><name><surname>Panzeri</surname><given-names>S.</given-names></name></person-group> (<year>2008</year>). <article-title>Phase-of-firing coding of natural visual stimuli in primary visual cortex</article-title>. <source>Curr. Biol.</source><volume>18</volume>, <fpage>375</fpage>&#x02013;<lpage>380</lpage><pub-id pub-id-type="doi">10.1016/j.cub.2008.02.023</pub-id><pub-id pub-id-type="pmid">18328702</pub-id></citation></ref><ref id="B24"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Mor&#x000e9;</surname><given-names>J.</given-names></name><name><surname>Garbow</surname><given-names>B.</given-names></name><name><surname>Hillstrom</surname><given-names>K.</given-names></name></person-group> (<year>1999</year>). <article-title>Minpack</article-title>. URL <uri xlink:type="simple" xlink:href="http://www.netlib.org/minpack">http://www.netlib.org/minpack</uri></citation></ref><ref id="B25"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Nemenman</surname><given-names>I.</given-names></name><name><surname>Bialek</surname><given-names>W.</given-names></name><name><surname>de Ruyter van Steveninck</surname><given-names>R.</given-names></name></person-group> (<year>2004</year>). <article-title>Entropy and information in neural spike trains: progress on the sampling problem</article-title>. <source>Phys. Rev. E</source><volume>69</volume>, <fpage>56111</fpage><pub-id pub-id-type="doi">10.1103/PhysRevE.69.056111</pub-id></citation></ref><ref id="B26"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Nemenman</surname><given-names>I.</given-names></name><name><surname>Shafee</surname><given-names>F.</given-names></name><name><surname>Bialek</surname><given-names>W.</given-names></name></person-group> (<year>2002</year>). <article-title>Entropy and inference, revisited</article-title>. <source>Adv. Neural. Inf. Process. Syst.</source><volume>14</volume>, <fpage>95</fpage>&#x02013;<lpage>100</lpage></citation></ref><ref id="B27"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Nirenberg</surname><given-names>S.</given-names></name><name><surname>Victor</surname><given-names>J.</given-names></name></person-group> (<year>2007</year>). <article-title>Analyzing the activity of large populations of neurons: how tractable is the problem?</article-title><source>Curr. Opin. Neurobiol.</source><volume>17</volume>, <fpage>397</fpage>&#x02013;<lpage>400</lpage><pub-id pub-id-type="doi">10.1016/j.conb.2007.07.002</pub-id><pub-id pub-id-type="pmid">17709240</pub-id></citation></ref><ref id="B28"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Panzeri</surname><given-names>S.</given-names></name></person-group> (<year>1999</year>). <article-title>Correlations and the encoding of information in the nervous system</article-title>. <source>Proc. R. Soc. B</source><volume>266</volume>, <fpage>1001</fpage>&#x02013;<lpage>1012</lpage><pub-id pub-id-type="doi">10.1098/rspb.1999.0736</pub-id></citation></ref><ref id="B29"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Panzeri</surname><given-names>S.</given-names></name><name><surname>Magri</surname><given-names>C.</given-names></name><name><surname>Logothetis</surname><given-names>N.</given-names></name></person-group> (<year>2008</year>). <article-title>On the use of information theory for the analysis of the relationship between neural and imaging signals</article-title>. <source>Magn. Reson. Imaging</source><volume>26</volume>, <fpage>1015</fpage>&#x02013;<lpage>1025</lpage><pub-id pub-id-type="doi">10.1016/j.mri.2008.02.019</pub-id><pub-id pub-id-type="pmid">18486395</pub-id></citation></ref><ref id="B30"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Panzeri</surname><given-names>S.</given-names></name><name><surname>Petersen</surname><given-names>R.</given-names></name><name><surname>Schultz</surname><given-names>S.</given-names></name><name><surname>Lebedev</surname><given-names>M.</given-names></name><name><surname>Diamond</surname><given-names>M.</given-names></name></person-group> (<year>2001</year>). <article-title>The role of spike timing in the coding of stimulus location in rat somatosensory cortex</article-title>. <source>Neuron</source><volume>29</volume>, <fpage>769</fpage>&#x02013;<lpage>777</lpage><pub-id pub-id-type="doi">10.1016/S0896-6273(01)00251-3</pub-id><pub-id pub-id-type="pmid">11301035</pub-id></citation></ref><ref id="B31"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Panzeri</surname><given-names>S.</given-names></name><name><surname>Senatore</surname><given-names>R.</given-names></name><name><surname>Montemurro</surname><given-names>M.</given-names></name><name><surname>Petersen</surname><given-names>R.</given-names></name></person-group> (<year>2007</year>). <article-title>Correcting for the sampling bias problem in spike train information measures</article-title>. <source>J. Neurophysiol.</source><volume>98</volume>, <fpage>1064</fpage>&#x02013;<lpage>1072</lpage><pub-id pub-id-type="doi">10.1152/jn.00559.2007</pub-id><pub-id pub-id-type="pmid">17615128</pub-id></citation></ref><ref id="B32"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Panzeri</surname><given-names>S.</given-names></name><name><surname>Treves</surname><given-names>A.</given-names></name></person-group> (<year>1996</year>). <article-title>Analytical estimates of limited sampling biases in different information measures</article-title>. <source>Netw. Comput. Neural Syst.</source><volume>7</volume>, <fpage>87</fpage>&#x02013;<lpage>107</lpage><pub-id pub-id-type="doi">10.1088/0954-898X/7/1/006</pub-id></citation></ref><ref id="B33"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Perez</surname><given-names>F.</given-names></name><name><surname>Granger</surname><given-names>B.</given-names></name></person-group> (<year>2007</year>). <article-title>Ipython: a system for interactive scientific computing</article-title>. <source>Comput. Sci. Eng.</source><volume>9</volume>, <fpage>21</fpage>&#x02013;<lpage>29</lpage><pub-id pub-id-type="doi">10.1109/MCSE.2007.53</pub-id></citation></ref><ref id="B34"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Petersen</surname><given-names>R.</given-names></name><name><surname>Brambilla</surname><given-names>M.</given-names></name><name><surname>Bale</surname><given-names>M.</given-names></name><name><surname>Alenda</surname><given-names>A.</given-names></name><name><surname>Panzeri</surname><given-names>S.</given-names></name><name><surname>Montemurro</surname><given-names>M.</given-names></name><name><surname>Maravall</surname><given-names>M.</given-names></name></person-group> (<year>2008</year>). <article-title>Diverse and temporally precise kinetic feature selectivity in the VPm thalamic nucleus</article-title>. <source>Neuron</source><volume>60</volume>, <fpage>890</fpage>&#x02013;<lpage>903</lpage><pub-id pub-id-type="doi">10.1016/j.neuron.2008.09.041</pub-id><pub-id pub-id-type="pmid">19081382</pub-id></citation></ref><ref id="B35"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Petersen</surname><given-names>R.</given-names></name><name><surname>Panzeri</surname><given-names>S.</given-names></name><name><surname>Diamond</surname><given-names>M.</given-names></name></person-group> (<year>2001</year>). <article-title>Population coding of stimulus location in rat somatosensory cortex</article-title>. <source>Neuron</source><volume>32</volume>, <fpage>503</fpage>&#x02013;<lpage>514</lpage><pub-id pub-id-type="doi">10.1016/S0896-6273(01)00481-0</pub-id><pub-id pub-id-type="pmid">11709160</pub-id></citation></ref><ref id="B36"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pola</surname><given-names>G.</given-names></name><name><surname>Thiele</surname><given-names>A.</given-names></name><name><surname>Hoffmann</surname><given-names>K.</given-names></name><name><surname>Panzeri</surname><given-names>S.</given-names></name></person-group> (<year>2003</year>). <article-title>An exact method to quantify the information transmitted by different mechanisms of correlational coding</article-title>. <source>Netw. Comput. Neural Syst.</source><volume>14</volume>, <fpage>35</fpage>&#x02013;<lpage>60</lpage><pub-id pub-id-type="doi">10.1088/0954-898X/14/1/303</pub-id></citation></ref><ref id="B37"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Rieke</surname><given-names>F.</given-names></name><name><surname>Bialek</surname><given-names>W.</given-names></name><name><surname>Warland</surname><given-names>D.</given-names></name><name><surname>Van Steveninck</surname><given-names>R.</given-names></name></person-group> (<year>1999</year>). <article-title>Spikes: Exploring the Neural Code. Bradford Book</article-title>. <publisher-loc>Cambridge, MA</publisher-loc>, <publisher-name>MIT Press</publisher-name></citation></ref><ref id="B38"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Rubino</surname><given-names>D.</given-names></name><name><surname>Robbins</surname><given-names>K.</given-names></name><name><surname>Hatsopoulos</surname><given-names>N.</given-names></name></person-group> (<year>2006</year>). <article-title>Propagating waves mediate information transfer in the motor cortex</article-title>. <source>Nat. Neurosci.</source><volume>9</volume>, <fpage>1549</fpage>&#x02013;<lpage>1557</lpage><pub-id pub-id-type="doi">10.1038/nn1802</pub-id><pub-id pub-id-type="pmid">17115042</pub-id></citation></ref><ref id="B39"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Schneidman</surname><given-names>E.</given-names></name><name><surname>Berry</surname><given-names>M.</given-names><suffix>II</suffix></name><name><surname>Segev</surname><given-names>R.</given-names></name><name><surname>Bialek</surname><given-names>W.</given-names></name></person-group> (<year>2006</year>). <article-title>Weak pairwise correlations imply strongly correlated network states in a neural population</article-title>. <source>Nature</source><volume>440</volume>, <fpage>1007</fpage>&#x02013;<lpage>1012</lpage><pub-id pub-id-type="doi">10.1038/nature04701</pub-id><pub-id pub-id-type="pmid">16625187</pub-id></citation></ref><ref id="B40"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Schneidman</surname><given-names>E.</given-names></name><name><surname>Still</surname><given-names>S.</given-names></name><name><surname>Berry</surname><given-names>M.</given-names></name><name><surname>Bialek</surname><given-names>W.</given-names></name></person-group> (<year>2003</year>). <article-title>Network information and connected correlations</article-title>. <source>Phys. Rev. Lett.</source><volume>91</volume>, <fpage>238701</fpage><pub-id pub-id-type="doi">10.1103/PhysRevLett.91.238701</pub-id><pub-id pub-id-type="pmid">14683220</pub-id></citation></ref><ref id="B41"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sch&#x000fc;rmann</surname><given-names>T.</given-names></name><name><surname>Grassberger</surname><given-names>P.</given-names></name></person-group> (<year>1996</year>). <article-title>Entropy estimation of symbol sequences</article-title>. <source>Chaos.</source><volume>6</volume>, <fpage>414</fpage>&#x02013;<lpage>427</lpage><pub-id pub-id-type="doi">10.1063/1.166191</pub-id><pub-id pub-id-type="pmid">12780271</pub-id></citation></ref><ref id="B42"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Shannon</surname><given-names>C.</given-names></name></person-group> (<year>1948</year>). <article-title>A mathematical theory of communication</article-title>. <source>Bell Syst. Tech. J.</source><volume>27</volume>, <fpage>379</fpage>&#x02013;<lpage>423</lpage></citation></ref><ref id="B43"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Shlens</surname><given-names>J.</given-names></name><name><surname>Field</surname><given-names>G.</given-names></name><name><surname>Gauthier</surname><given-names>J.</given-names></name><name><surname>Grivich</surname><given-names>M.</given-names></name><name><surname>Petrusca</surname><given-names>D.</given-names></name><name><surname>Sher</surname><given-names>A.</given-names></name><name><surname>Litke</surname><given-names>A.</given-names></name><name><surname>Chichilnisky</surname><given-names>E.</given-names></name></person-group> (<year>2006</year>). <article-title>The structure of multi-neuron firing patterns in primate retina</article-title>. <source>J. Neurosci.</source><volume>26</volume>, <fpage>8254</fpage><pub-id pub-id-type="doi">10.1523/JNEUROSCI.1282-06.2006</pub-id><pub-id pub-id-type="pmid">16899720</pub-id></citation></ref><ref id="B44"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Strong</surname><given-names>S.</given-names></name><name><surname>Koberle</surname><given-names>R.</given-names></name><name><surname>de Ruyter van Steveninck</surname><given-names>R.</given-names></name><name><surname>Bialek</surname><given-names>W.</given-names></name></person-group> (<year>1998</year>). <article-title>Entropy and information in neural spike trains</article-title>. <source>Phys. Rev. Lett.</source><volume>80</volume>, <fpage>197</fpage>&#x02013;<lpage>200</lpage><pub-id pub-id-type="doi">10.1103/PhysRevLett.80.197</pub-id></citation></ref><ref id="B45"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Tang</surname><given-names>A.</given-names></name><name><surname>Jackson</surname><given-names>D.</given-names></name><name><surname>Hobbs</surname><given-names>J.</given-names></name><name><surname>Chen</surname><given-names>W.</given-names></name><name><surname>Smith</surname><given-names>J. L.</given-names></name><name><surname>Patel</surname><given-names>H.</given-names></name><name><surname>Prieto</surname><given-names>A.</given-names></name><name><surname>Petrusca</surname><given-names>D.</given-names></name><name><surname>Grivich</surname><given-names>M. I.</given-names></name><name><surname>Sher</surname><given-names>A.</given-names></name><name><surname>Hottowy</surname><given-names>P.</given-names></name><name><surname>Dabrowski</surname><given-names>W.</given-names></name><name><surname>Litke</surname><given-names>A. M.</given-names></name><name><surname>Beggs</surname><given-names>J. M.</given-names></name></person-group> (<year>2008</year>). <article-title>A maximum entropy model applied to spatial and temporal correlations from cortical networks <italic>in vitro</italic></article-title>. <source>J. Neurosci.</source><volume>28</volume>, <fpage>505</fpage>&#x02013;<lpage>518</lpage><pub-id pub-id-type="doi">10.1523/JNEUROSCI.3359-07.2008</pub-id><pub-id pub-id-type="pmid">18184793</pub-id></citation></ref><ref id="B46"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Treves</surname><given-names>A.</given-names></name><name><surname>Panzeri</surname><given-names>S.</given-names></name></person-group> (<year>1995</year>). <article-title>The upward bias in measures of information derived from limited data samples</article-title>. <source>Neural Comput.</source><volume>7</volume>, <fpage>399</fpage>&#x02013;<lpage>407</lpage><pub-id pub-id-type="doi">10.1162/neco.1995.7.2.399</pub-id></citation></ref><ref id="B47"><citation citation-type="other"><person-group person-group-type="author"><name><surname>van Rossum</surname><given-names>G.</given-names></name></person-group> (<year>1995</year>). <article-title>Python Reference Manual</article-title>. CWI Reports CS-R 9525.</citation></ref><ref id="B48"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Victor</surname><given-names>J.</given-names></name></person-group> (<year>1999</year>). <article-title>Temporal aspects of neural coding in the retina and lateral geniculate</article-title>. <source>Netw. Comput. Neural Syst.</source><volume>10</volume>, <fpage>1</fpage>&#x02013;<lpage>66</lpage><pub-id pub-id-type="doi">10.1088/0954-898X/10/4/201</pub-id></citation></ref><ref id="B49"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Victor</surname><given-names>J.</given-names></name></person-group> (<year>2006</year>). <article-title>Approaches to information-theoretic analysis of neural activity</article-title>. <source>Biol. Theory</source><volume>1</volume>, <fpage>302</fpage>&#x02013;<lpage>316</lpage><pub-id pub-id-type="doi">10.1162/biot.2006.1.3.302</pub-id></citation></ref><ref id="B50"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Waldert</surname><given-names>S.</given-names></name><name><surname>Preissl</surname><given-names>H.</given-names></name><name><surname>Demandt</surname><given-names>E.</given-names></name><name><surname>Braun</surname><given-names>C.</given-names></name><name><surname>Birbaumer</surname><given-names>N.</given-names></name><name><surname>Aertsen</surname><given-names>A.</given-names></name><name><surname>Mehring</surname><given-names>C.</given-names></name></person-group> (<year>2008</year>). <article-title>Hand movement direction decoded from MEG and EEG</article-title>. <source>J. Neurosci.</source><volume>28</volume>, <fpage>1000</fpage>&#x02013;<lpage>1008</lpage><pub-id pub-id-type="doi">10.1523/JNEUROSCI.5171-07.2008</pub-id><pub-id pub-id-type="pmid">18216207</pub-id></citation></ref></ref-list><fn-group><fn id="fn1"><p><sup>1</sup>The Mathworks, Inc, Natick, MA. <uri xlink:type="simple" xlink:href="http://www.mathworks.com/">http://www.mathworks.com/</uri></p></fn><fn id="fn2"><p><sup>2</sup>&#x0201c;Open source is a development method for software that harnesses the power of distributed peer review and transparency of process. The promise of open source is better quality, higher reliability, more flexibility, lower cost, and an end to predatory vendor lock-in.&#x0201d; <uri xlink:type="simple" xlink:href="http://www.opensource.org/">http://www.opensource.org/</uri></p></fn><fn id="fn3"><p><sup>3</sup>See <uri xlink:type="simple" xlink:href="http://code.google.com/p/pyentropy/">http://code.google.com/p/pyentropy/</uri></p></fn><fn id="fn4"><p><sup>4</sup>See <uri xlink:type="simple" xlink:href="http://www.strimmerlab.org/software/entropy/index.html">http://www.strimmerlab.org/software/entropy/index.html</uri></p></fn><fn id="fn5"><p><sup>5</sup>See <uri xlink:type="simple" xlink:href="http://neuroanalysis.org/toolkit/">http://neuroanalysis.org/toolkit/</uri></p></fn><fn id="fn6"><p><sup>6</sup>From <uri xlink:type="simple" xlink:href="http://nsb-entropy.sourceforge.net/">http://nsb-entropy.sourceforge.net/</uri></p></fn><fn id="fn7"><p><sup>7</sup><uri xlink:type="simple" xlink:href="http://www.cise.ufl.edu/research/sparse/umfpack/">http://www.cise.ufl.edu/research/sparse/umfpack/</uri></p></fn><fn id="fn8"><p><sup>8</sup><uri xlink:type="simple" xlink:href="http://www.carmen.org.uk/">http://www.carmen.org.uk/</uri></p></fn><fn id="fn9"><p><sup>9</sup><uri xlink:type="simple" xlink:href="http://www.w3.org/TR/ws-gloss/">http://www.w3.org/TR/ws-gloss/</uri></p></fn><fn id="fn10"><p><sup>10</sup><uri xlink:type="simple" xlink:href="http://www.w3.org/TR/soap/">http://www.w3.org/TR/soap/</uri></p></fn><fn id="fn11"><p><sup>11</sup><uri xlink:type="simple" xlink:href="http://www.w3.org/TR/wsdl">http://www.w3.org/TR/wsdl</uri></p></fn><fn id="fn12"><p><sup>12</sup><uri xlink:type="simple" xlink:href="http://instantsoap.sourceforge.net/">http://instantsoap.sourceforge.net/</uri></p></fn><fn id="fn13"><p><sup>13</sup>&#x0201c;An enhanced interactive Python shell and architecture for interactive parallel computing&#x0201d;, <uri xlink:type="simple" xlink:href="http://ipython.scipy.org/">http://ipython.scipy.org/</uri> (Perez and Granger, <xref ref-type="bibr" rid="B33">2007</xref>)</p></fn><fn id="fn14"><p><sup>14</sup>&#x0201c;A high-level Python to MATLAB bridge&#x0201d;, <uri xlink:type="simple" xlink:href="http://mlabwrap.sourceforge.net/">http://mlabwrap.sourceforge.net/</uri></p></fn><fn id="fn15"><p><sup>15</sup>See for example <uri xlink:type="simple" xlink:href="http://www.pythonxy.com/">http://www.pythonxy.com/</uri> and <uri xlink:type="simple" xlink:href="http://www.enthought.com/products/epd.php">http://www.enthought.com/products/epd.php</uri></p></fn><fn id="fn16"><p><sup>16</sup>The Cython language, &#x0201c;C extensions for Python&#x0201d;, <uri xlink:type="simple" xlink:href="http://cython.org/">http://cython.org/</uri></p></fn></fn-group></back></article>