<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208181</article-id><article-id pub-id-type="pmc">2648750</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S8</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S8</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Triplet supertree heuristics for the tree of life</article-title></title-group><contrib-group><contrib id="A1" contrib-type="author"><name><surname>Lin</surname><given-names>Harris T</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>htlin@cs.iastate.edu</email></contrib><contrib id="A2" contrib-type="author"><name><surname>Burleigh</surname><given-names>J Gordon</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>gburleigh@ufl.edu</email></contrib><contrib id="A3" corresp="yes" contrib-type="author"><name><surname>Eulenstein</surname><given-names>Oliver</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>oeulenst@cs.iastate.edu</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Computer Science, Iowa State University, Ames, IA, USA</aff><aff id="I2"><label>2</label>National Evolutionary Synthesis Center, Durham, NC, USA; University of Florida, Gainesville, FL, USA</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S8</fpage><lpage>S8</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S8"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Lin et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Lin et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Lin               T               Harris                              htlin@cs.iastate.edu            </dc:author><dc:title>            Triplet supertree heuristics for the tree of life         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S8-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S8&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>There is much interest in developing fast and accurate supertree methods to infer the tree of life. Supertree methods combine smaller input trees with overlapping sets of taxa to make a comprehensive phylogenetic tree that contains all of the taxa in the input trees. The intrinsically hard triplet supertree problem takes a collection of input species trees and seeks a species tree (supertree) that maximizes the number of triplet subtrees that it shares with the input trees. However, the utility of this supertree problem has been limited by a lack of efficient and effective heuristics.</p></sec><sec><title>Results</title><p>We introduce fast hill-climbing heuristics for the triplet supertree problem that perform a step-wise search of the tree space, where each step is guided by an exact solution to an instance of a local search problem. To realize time efficient heuristics we designed the first nontrivial algorithms for two standard search problems, which greatly improve on the time complexity to the best known (na&#x000ef;ve) solutions by a factor of <italic>n </italic>and <italic>n</italic><sup>2 </sup>(the number of taxa in the supertree). These algorithms enable large-scale supertree analyses based on the triplet supertree problem that were previously not possible. We implemented hill-climbing heuristics that are based on our new algorithms, and in analyses of two published supertree data sets, we demonstrate that our new heuristics outperform other standard supertree methods in maximizing the number of triplets shared with the input trees.</p></sec><sec><title>Conclusion</title><p>With our new heuristics, the triplet supertree problem is now computationally more tractable for large-scale supertree analyses, and it provides a potentially more accurate alternative to existing supertree methods.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>Assembling the tree of life, or the phylogeny of all species, is one of the grand challenges in evolutionary biology. Supertree methods take a collection of species trees with overlapping, but not identical, sets of taxa and return a "supertree" that contains all taxa found in the input trees (e.g., [<xref ref-type="bibr" rid="B1">1</xref>-<xref ref-type="bibr" rid="B4">4</xref>]). Thus, supertrees provide a way to synthesize small trees into a comprehensive phylogeny representing large sections of the tree of life. Recent supertree analyses have produced the first complete family-level phylogeny of flowering plants [<xref ref-type="bibr" rid="B5">5</xref>], and the first phylogeny of nearly all extant mammals [<xref ref-type="bibr" rid="B6">6</xref>]. Since the main objective of most supertree analyses is to build extremely large phylogenetic trees by solving intrinsically hard computational problems, the design of efficient and effective heuristics is a critically important part of developing any useful supertree method.</p><p>Ideal supertree methods must combine speed and accuracy. By far the most commonly used supertree method is matrix representation with parsimony (MRP; [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B8">8</xref>]). MRP converts a collection of input trees into a binary character matrix, and then performs a parsimony analysis on a matrix representation of the input trees. Thus, MRP analyses can use efficient parsimony heuristics implemented in programs such as PAUP* [<xref ref-type="bibr" rid="B9">9</xref>] and TNT [<xref ref-type="bibr" rid="B10">10</xref>], making large-scale MRP supertree analyses computationally more tractable. However, the accuracy and performance of MRP are frequently criticized. For example, there is evidence of input tree size and shape biases [<xref ref-type="bibr" rid="B11">11</xref>,<xref ref-type="bibr" rid="B12">12</xref>], the results can vary depending on the method of matrix representation [<xref ref-type="bibr" rid="B11">11</xref>], and the accuracy of the MRP supertrees are not necessarily correlated with the parsimony score [<xref ref-type="bibr" rid="B13">13</xref>]. Therefore, there is a need to develop alternate methods that share the advantages of MRP but produce more accurate supertrees.</p><p>Since we rarely know the evolutionary history of a group of organisms with certainty, it is usually impossible to assess the accuracy of a supertree based on its similarity to the true species phylogeny. A more practical way to define the accuracy of a supertree is based on the overall similarity of the supertree to the collection of input trees. There are numerous ways to measure the similarity between input trees and the supertree. The intrinsically hard [<xref ref-type="bibr" rid="B14">14</xref>] triplet supertree problem measures this similarity based on the common shared triplets, or rooted, binary, 3-taxon trees that are the irreducible unit of phylogenetic information in rooted trees [<xref ref-type="bibr" rid="B14">14</xref>]. Specifically, the triplet supertree problem seeks a supertree that shares the most triplets with the input trees.</p><p>We introduce hill-climbing heuristics for the triplet supertree problem that make it feasible for truly large-scale phylogenetic analyses. Hill-climbing heuristics have been effectively applied to other intrinsically difficult supertree problems [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B15">15</xref>]. They search the space of all possible supertrees guided by a series of exact solutions to instances of a local search problem. The local search problem is to find an optimal phylogenetic tree that shares the most number of triplets with the input trees in the neighborhood of a given tree. The neighborhood is the set of all phylogenetic trees into which the given tree can be transformed by applying a tree edit operation. A variety of different tree edit operations have been proposed [<xref ref-type="bibr" rid="B16">16</xref>,<xref ref-type="bibr" rid="B17">17</xref>], and two of them, rooted Subtree Pruning and Regrafting (SPR) and Tree Bisection and Reconnection (TBR), have shown much promise for phylogenetic studies [<xref ref-type="bibr" rid="B18">18</xref>,<xref ref-type="bibr" rid="B19">19</xref>]. However, algorithms for local search problems based on SPR and TBR operations, especially on rooted trees, are still in their infancy. To conduct large-scale phylogenetic analyses, there is much need for effective SPR and TBR based local search problems that can be solved efficiently.</p><p>In this work we improve upon the best known (na&#x000ef;ve) solutions for the SPR and TBR local search problems by a factor of <italic>n </italic>and <italic>n</italic><sup>2 </sup>(the number of taxa in the supertree) respectively. This is especially desirable since standard local search heuristics for the triplet supertree problem typically involve solving several thousand instances of the local search problem. We demonstrate the performance of our new triplet heuristics in a comparative analysis with other standard supertree methods.</p><sec><title>Related work</title><sec><title>Triplet supertree problem</title><p>The triplet supertree problem makes use of the fact that every rooted tree can be equivalently represented by a set of triplet trees [<xref ref-type="bibr" rid="B17">17</xref>]. A triplet tree is a rooted fully binary tree over three taxa. Thus, a <italic>triplet-similarity </italic>measure can be defined between two rooted trees that is the cardinality of the intersection of their triplet presentations. This measure can be extended to measure the similarity from a collection of rooted input trees to a rooted supertree, by summing up the triplet-similarities for each input tree and the supertree. The triplet supertree problem is to find a supertree that maximizes the triplet-similarity for a given collection of input trees. Figure <xref ref-type="fig" rid="F1">1</xref> illustrates the triplet supertree problem.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Triplet supertree problem</bold>. Given an input profile of <italic>n </italic>species trees (<italic>T</italic><sub>1</sub>,..., <italic>T</italic><sub><italic>n</italic></sub>), the triplet supertree problem is to find a supertree that maximizes the triplet-similarity score. The score for a supertree is calculated by first decomposing trees into their corresponding triplet presentations, then counting the number of common triplets between the supertree and each input tree (<italic>S</italic><sub>1</sub>,..., <italic>S</italic><sub><italic>n</italic></sub>), and finally aggregating all the counts. The triplet-similarity score for the candidate supertree <italic>T </italic>with respect to the input profile is therefore <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S8-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>.</p></caption><graphic xlink:href="1471-2105-10-S1-S8-1"/></fig></sec><sec><title>Hill-climbing heuristics</title><p>We introduce hill-climbing heuristics to solve the triplet supertree problem. Hill-climbing heuristics have been successfully applied to several intrinsically complex supertree problems. In these heuristics a tree graph is defined for the given set of input trees and some, typically symmetric, tree-edit operation. The nodes in the tree graph are the phylogenetic trees over the overall taxon set of the input trees. An edge adjoins two nodes exactly if the corresponding trees can be transformed into each other by the tree edit operation. The cost of a node in the graph is the measurement from the input trees to the tree represented by the node under the particular supertree problems optimization measurement. For the triplet supertree problem, the cost of a node in the graph is the triplet-similarity from the input trees to the tree represented by the node. Given a starting node in the tree graph, the heuristic's task is to find a maximal-length path of steepest ascent in the cost of its nodes and to return the last node on such a path. This path is found by solving the local search problem for every node along the path. The local search problem is to find a node with the maximum cost in the neighborhood (all adjacent nodes) of a given node. The neighborhood searched depends on the edit operation. Edit operations of interest are SPR and TBR [<xref ref-type="bibr" rid="B17">17</xref>]. We defer the definition of these operations to the next section. The best known run times (na&#x000ef;ve solutions) for the SPR and TBR based local search problems under the triplet-similarity measurement are <italic>O</italic>(<italic>kn</italic><sup>4</sup>) and <italic>O</italic>(<italic>kn</italic><sup>5</sup>) respectively, where <italic>k </italic>is the number of input gene trees and <italic>n </italic>is the number of taxa present in the input gene trees.</p></sec></sec><sec><title>Contribution of the manuscript</title><p>We introduce algorithms that solve the local SPR and TBR based search problems for our triplet supertree heuristics in times <italic>O</italic>(<italic>n</italic><sup>3</sup>) and <italic>O</italic>(<italic>n</italic><sup>3</sup>) respectively, with an initial pre-processing time of <italic>O</italic>(<italic>kn</italic><sup>3</sup>). These algorithms allow true large-scale phylogenetic analyses using hill-climbing heuristics for the triplet supertree problem. Finally, we demonstrate the performance of our SPR and TBR based hill-climbing heuristics in comparative studies on two large published data sets.</p></sec></sec><sec sec-type="methods"><title>Methods</title><p>Initially, for each possible triplet over the set of all taxa we count and store the frequency displayed by all the input trees in <italic>O</italic>(<italic>kn</italic><sup>3</sup>) time. Then, for each local search problem, we use dynamic programming to efficiently pre-process necessary triplet counts in <italic>O</italic>(<italic>n</italic><sup>3</sup>) time. By exploiting the structural properties of SPR and TBR related to triplet-similarity, we are able to use these triplet counts to compute the differences in triplet-similarity for all SPR and TBR neighborhoods, each in <italic>O</italic>(<italic>n</italic><sup>3</sup>) time.</p><sec><title>Basic definitions, notations, and preliminaries</title><p>In this section we introduce basic definitions and notations and then define preliminaries required for this work. For brevity the proofs of Lemmas 2&#x02013;6 are omitted, but available on request.</p><sec><title>Basic definitions and notations</title><p>A <italic>tree T </italic>is a connected graph with no cycles, consisting of a node set <italic>V</italic>(<italic>T</italic>) and an edge set <italic>E</italic>(<italic>T</italic>). <italic>T </italic>is <italic>rooted </italic>if it has exactly one distinguished node called the <italic>root </italic>which we denote by Ro(<italic>T</italic>).</p><p>Let <italic>T </italic>be a rooted tree. We define &#x02264;<sub><italic>T </italic></sub>to be the partial order on <italic>V</italic>(<italic>T</italic>) where <italic>x </italic>&#x02264;<sub><italic>T </italic></sub><italic>y </italic>if <italic>y </italic>is a node on the path between Ro(<italic>T</italic>) and <italic>x</italic>. If <italic>x </italic>&#x02264;<sub><italic>T </italic></sub><italic>y </italic>we call <italic>x </italic>a <italic>descendant </italic>of <italic>y</italic>, and <italic>y </italic>an <italic>ancestor </italic>of <italic>x</italic>. We also define <italic>x </italic>&#x0003c;<sub><italic>T </italic></sub><italic>y </italic>if <italic>x </italic>&#x02264;<sub><italic>T </italic></sub><italic>y </italic>and <italic>x </italic>&#x02260; <italic>y</italic>, in this case we call <italic>x </italic>a <italic>proper descendant </italic>of <italic>y</italic>, and <italic>y </italic>a <italic>proper ancestor </italic>of <italic>x</italic>.</p><p>The set of minima under &#x02264;<sub><italic>T </italic></sub>is denoted by Le(<italic>T</italic>) and its elements are called <italic>leaves</italic>. If {<italic>x</italic>, <italic>y</italic>} &#x02208; <italic>E</italic>(<italic>T</italic>) and <italic>x </italic>&#x02264;<sub><italic>T </italic></sub><italic>y </italic>then we call <italic>y </italic>the <italic>parent </italic>of <italic>x </italic>denoted by Pa<sub><italic>T</italic></sub>(<italic>x</italic>) and we call <italic>x </italic>a <italic>child </italic>of <italic>y</italic>. The set of all children of <italic>y </italic>is denoted by Ch<sub><italic>T</italic></sub>(<italic>y</italic>). If two nodes in <italic>T </italic>have the same parent, they are called <italic>siblings</italic>. The <italic>least common ancestor </italic>of a non-empty subset <italic>L </italic>&#x02286; <italic>V</italic>(<italic>T</italic>), denoted as <italic>lca</italic><sub><italic>T</italic></sub>(<italic>L</italic>), is the unique smallest upper bound of <italic>L </italic>under &#x02264;<sub><italic>T</italic></sub>.</p><p>If <italic>e </italic>&#x02208; <italic>E</italic>(<italic>T</italic>), we define <italic>T</italic>/<italic>e </italic>to be the tree obtained from <italic>T </italic>by identifying the ends of <italic>e </italic>and then deleting <italic>e</italic>. <italic>T</italic>/<italic>e </italic>is said to be obtained from <italic>T </italic>by <italic>contracting e</italic>. If <italic>v </italic>is a vertex of <italic>T </italic>with degree one or two, and <italic>e </italic>is an edge incident with <italic>v</italic>, the tree <italic>T</italic>/<italic>e </italic>is said to be obtained from <italic>T </italic>by <italic>suppressing v</italic>.</p><p>The <italic>restricted subtree </italic>of <italic>T </italic>induced by a non-empty subset <italic>L </italic>&#x02286; <italic>V</italic>(<italic>T</italic>), denoted as <italic>T</italic>|<italic>L</italic>, is the tree induced by <italic>L </italic>where all internal nodes with degree two are suppressed, with the exception of the root node. The <italic>subtree </italic>of <italic>T </italic>rooted at node <italic>y </italic>&#x02208; <italic>V</italic>(<italic>T</italic>), denoted as <italic>T</italic><sub><italic>y</italic></sub>, is the restricted subtree induced by {<italic>x </italic>&#x02208; <italic>V</italic>(<italic>T</italic>): <italic>x </italic>&#x02264;<sub><italic>T </italic></sub><italic>y</italic>}.</p><p><italic>T </italic>is fully <italic>binary </italic>if every node has either zero or two children. Throughout this paper, the term tree refers to a rooted fully binary tree.</p></sec><sec><title>The triplet supertree problem</title><p>We now introduce necessary definitions to state the triplet supertree problem. A <italic>triplet </italic>is a rooted binary tree with three leaves. A triplet <italic>T </italic>with leaves <italic>a</italic>, <italic>b</italic>, and <italic>c </italic>is denoted <italic>ab</italic>|<italic>c </italic>if <italic>lca</italic><sub><italic>T</italic></sub>({<italic>a</italic>, <italic>b</italic>}) is a proper descendant of the root. Note that we do not distinguish between <italic>ab</italic>|<italic>c </italic>and <italic>ba</italic>|<italic>c</italic>. The set of all triplets of a tree <italic>T</italic>, denoted as Tr(<italic>T</italic>), is {<italic>ab</italic>|<italic>c </italic>: <italic>T</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} = <italic>ab</italic>|<italic>c</italic>}. The set of <italic>common triplets </italic>between two trees <italic>T</italic><sub>1 </sub>and <italic>T</italic><sub>2</sub>, denoted as <italic>S</italic>(<italic>T</italic><sub>1</sub>, <italic>T</italic><sub>2</sub>), is Tr(<italic>T</italic><sub>1</sub>) &#x02229; Tr(<italic>T</italic><sub>2</sub>). A <italic>profile P </italic>is a tuple of trees (<italic>T</italic><sub>1</sub>,..., <italic>T</italic><sub><italic>n</italic></sub>), we extend the definition of leaf set to profiles as <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S8-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mtext>Le</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x0222a;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:mtext>Le</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>. Let <italic>P </italic>be a profile, we call <italic>T</italic>* a <italic>supertree </italic>of <italic>P </italic>if Le(<italic>T</italic>*) = Le(<italic>P</italic>).</p><p>We are now ready to define the triplet supertree problem (Fig. <xref ref-type="fig" rid="F1">1</xref>).</p><p><bold>Definition 1 </bold>(Triplet similarity). <italic>Given a profile P </italic>= (<italic>T</italic><sub>1</sub>,..., <italic>T</italic><sub><italic>n</italic></sub>) <italic>and a supertree T</italic>* <italic>of P, we define the </italic>triplet-similarity score <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S8-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>.</p><p><bold>Problem 1 </bold>(The triplet supertree problem). <italic>Given a profile P, find a supertree T</italic>* <italic>that maximizes S</italic>(<italic>P</italic>, <italic>T</italic>*). <italic>We call any such T</italic>* <italic>a </italic>triplet supertree.</p><p><bold>Theorem 1 </bold>([<xref ref-type="bibr" rid="B14">14</xref>]). <italic>The triplet supertree problem is NP-hard</italic>.</p></sec><sec><title>Local search problems</title><p>Here we first provide definitions for the re-root (RR), TBR, and SPR edit operations and then formulate the related local search problems. Figures <xref ref-type="fig" rid="F2">2</xref> and <xref ref-type="fig" rid="F3">3</xref> illustrate the RR and TBR edit operations respectively.</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Example of an RR operation</bold>. Depicted is an example of an RR operation where <italic>T' </italic>= RR<sub><italic>T</italic></sub>(<italic>d</italic>). The original tree <italic>T </italic>is shown in (a). In (b), we first suppress the root node, and then introduce the new root node <italic>r </italic>above <italic>d</italic>. Finally we rearrange the tree so that <italic>r </italic>is at root, as in (c).</p></caption><graphic xlink:href="1471-2105-10-S1-S8-2"/></fig><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>Example of a TBR operation</bold>. Depicted is an example of a TBR operation where <italic>T' </italic>= TBR<sub><italic>T</italic></sub>(<italic>e</italic>, <italic>h</italic>, <italic>b</italic>). The original tree <italic>T </italic>is shown in (a). In (b), we first remove the edge above <italic>e</italic>, that is we prune the subtree <italic>T</italic><sub><italic>e</italic></sub>. Then we introduce a new node above <italic>h </italic>which will be the new root of the pruned subtree. We also introduce a new node above <italic>b </italic>&#x02013; this is where we will reconnect the subtree back to <italic>T</italic>. Finally we rearrange the tree and obtain the resulting tree <italic>T' </italic>as in (c).</p></caption><graphic xlink:href="1471-2105-10-S1-S8-3"/></fig><p><bold>Definition 2 </bold>(RR operation). <italic>Let T be a tree and x </italic>&#x02208; <italic>V</italic>(<italic>T</italic>). RR<sub><italic>T</italic></sub>(<italic>x</italic>) <italic>is defined to be the tree T if x </italic>= Ro(<italic>T</italic>). <italic>Otherwise</italic>, RR<sub><italic>T</italic></sub>(<italic>x</italic>) <italic>is the tree that is obtained from T by (i) suppressing </italic>Ro(<italic>T</italic>), <italic>and (ii) subdividing the edge </italic>{Pa<sub><italic>T</italic></sub>(<italic>x</italic>), <italic>x</italic>} <italic>by a new root node. We define the following extension</italic>:</p><p><disp-formula>RR<sub><italic>T </italic></sub>= &#x0222a;<sub><italic>x</italic>&#x02208;<italic>V</italic>(<italic>T</italic>)</sub>{RR<sub><italic>T</italic></sub>(<italic>x</italic>)}.</disp-formula></p><p><italic>Let x </italic>&#x02264;<sub><italic>T </italic></sub><italic>v, we also define a partial </italic>RR <italic>operation </italic>RR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>x</italic>) <italic>by replacing T</italic><sub><italic>v </italic></sub><italic>with </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S8-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mrow><mml:mtext>RR</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>(<italic>x</italic>).</p><p><bold>Definition 3 </bold>(TBR operation). <italic>For technical reasons we first define for a tree T the </italic>planted tree Pl(<italic>T</italic>) <italic>that is the tree obtained by adding an additional edge, called </italic>root edge, {<italic>r</italic>, Ro(<italic>T</italic>)} <italic>to E</italic>(<italic>T</italic>).</p><p><italic>Let T be a tree, e </italic>= (<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E</italic>(<italic>T</italic>), <italic>and X, Y be the connected components that are obtained by removing edge e from T where v </italic>&#x02208; <italic>X and u </italic>&#x02208; <italic>Y. We define </italic>TBR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>x</italic>, <italic>y</italic>) <italic>for x </italic>&#x02208; <italic>X and y </italic>&#x02208; <italic>Y to be the tree that is obtained from </italic>Pl(<italic>T</italic>) <italic>by first removing edge e, then replacing the component X by </italic>RR<sub><italic>X</italic></sub>(<italic>x</italic>), <italic>and then adjoining a new edge f between x' </italic>= Ro(RR<sub><italic>X</italic></sub>(<italic>x</italic>)) <italic>and Y as follows:</italic></p><p><italic>1. Create a new node y' that subdivides the edge </italic>(Pa<sub><italic>T</italic></sub>(<italic>y</italic>), <italic>y</italic>).</p><p><italic>2. Adjoin the edge f between nodes x' and y'</italic>.</p><p><italic>3. Suppress the node u, and rename x' as v and y' as u</italic>.</p><p><italic>4. Contract the root edge</italic>.</p><p><italic>We say that the tree </italic>TBR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>x</italic>, <italic>y</italic>) <italic>is obtained from T by a </italic>tree bisection and reconnection (TBR) <italic>operation that </italic>bisects <italic>the tree T into the components X</italic>, <italic>Y and reconnects them above the nodes x</italic>, <italic>y</italic>.</p><p><italic>We define the following extensions for the </italic>TBR <italic>operation:</italic></p><p><italic>1</italic>. TBR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>x</italic>) = &#x0222a;<sub><italic>y</italic>&#x02208;<italic>Y </italic></sub>TBR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>x</italic>, <italic>y</italic>)</p><p><italic>2</italic>. TBR<sub><italic>T</italic></sub>(<italic>v</italic>) = &#x0222a;<sub><italic>x</italic>&#x02208;<italic>X </italic></sub>TBR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>x</italic>)</p><p><italic>3</italic>. TBR<sub><italic>T </italic></sub>= &#x0222a;<sub>(<italic>u</italic>, <italic>v</italic>)&#x02208;<italic>E</italic>(<italic>T</italic>) </sub>TBR<sub><italic>T</italic></sub>(<italic>v</italic>)</p><p>An SPR operation for a tree <italic>T </italic>can be briefly described through the following steps: (i) prune some subtree <italic>S </italic>from <italic>T</italic>, (ii) add a root edge to the remaining tree <italic>T'</italic>, (iii) regraft <italic>S </italic>into an edge of the remaining tree <italic>T'</italic>, (iv) contract the root edge. For our purposes we define the SPR operation as a special case of the TBR operation.</p><p><bold>Definition 4 </bold>(SPR operation). <italic>Let T be a tree, e </italic>= (<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E</italic>(<italic>T</italic>), <italic>and X, Y be the connected components that are obtained by removing edge e from T where v </italic>&#x02208; <italic>X and u </italic>&#x02208; <italic>Y. We define </italic>SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>y</italic>) <italic>for y </italic>&#x02208; <italic>Y to be </italic>TBR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>v</italic>, <italic>y</italic>). <italic>We say that the tree </italic>SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>y</italic>) <italic>is obtained from T by a </italic>subtree prune and regraft (SPR) <italic>operation that </italic>prunes <italic>subtree T</italic><sub><italic>v </italic></sub><italic>and </italic>regrafts <italic>it above node y</italic>.</p><p><italic>We define the following extensions of the </italic>SPR <italic>operation:</italic></p><p><italic>1</italic>. SPR<sub><italic>T</italic></sub>(<italic>v</italic>) = &#x0222a;<sub><italic>y</italic>&#x02208;<italic>Y </italic></sub>SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>y</italic>)</p><p><italic>2</italic>. SPR<sub><italic>T </italic></sub>= &#x0222a;<sub>(<italic>u</italic>, <italic>v</italic>)&#x02208;<italic>E</italic>(<italic>T</italic>) </sub>SPR<sub><italic>T</italic></sub>(<italic>v</italic>)</p><p><bold>Problem 2 </bold>(TBR Scoring (TBR-S)). <italic>Given a profile P and a supertree T of P, find a tree T</italic>* &#x02208; TBR<sub><italic>T </italic></sub><italic>such that </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S8-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msub><mml:mrow><mml:mtext>TBR</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula></p><p><bold>Problem 3 </bold>(TBR-Restricted Scoring (TBR-RS)). <italic>Given a profile P, a supertree T of P, and </italic>(<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E</italic>(<italic>T</italic>), <italic>find a tree T</italic>* &#x02208; TBR<sub><italic>T</italic></sub>(<italic>v</italic>) <italic>such that </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S8-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msub><mml:mrow><mml:mtext>TBR</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula></p><p>The problems SPR Scoring (SPR-S) and SPR-Restricted Scoring (SPR-RS) are defined analogously to the problems TBR-S and TBR-RS respectively.</p><p>Further, we observe that to solve any of these four local search problems, it is sufficient to find a tree within the neighborhood that gives the maximum increase on <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S8-i6" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula>(<italic>P</italic>, <italic>T</italic>), without calculating the value of each <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S8-i6" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula>(<italic>P</italic>, <italic>T</italic>) itself. With this observation, it is useful to give the following definition.</p><p><bold>Definition 5</bold>. <italic>Let P be a profile, T</italic><sub>1 </sub><italic>and T</italic><sub>2 </sub><italic>be two supertrees of P, we define the </italic>score difference function, <italic>denoted as </italic>&#x00394;<sub><italic>P</italic></sub>(<italic>T</italic><sub>1</sub>, <italic>T</italic><sub>2</sub>), <italic>to be </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S8-i6" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula>(<italic>P</italic>, <italic>T</italic><sub>2</sub>) - <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S8-i6" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula>(<italic>P</italic>, <italic>T</italic><sub>1</sub>).</p></sec></sec><sec><title>Solving the SPR-RS and SPR-S problems</title><p>We first show how to solve the SPR-RS problem. Extending on this solution we introduce a new algorithm for the SPR-S problem.</p><sec><title>Solving the <italic>SPR</italic>-RS problem</title><p>Given a profile <italic>P</italic>, a supertree <italic>T </italic>of <italic>P</italic>, and (<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E</italic>(<italic>T</italic>), we compute &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic>, <italic>T'</italic>) for each <italic>T' </italic>&#x02208; SPR<sub><italic>T</italic></sub>(<italic>v</italic>) by first pruning and regrafting <italic>T</italic><sub><italic>v </italic></sub>to Ro(<italic>T</italic>) and compute the score differences for each "move-down" operation, then traverse <italic>T </italic>in pre-order to obtain the tree that gives the maximum score difference. We first give a definition that helps us describe a single "move-down".</p><p><bold>Definition 6 </bold>(Immediate Triplet). <italic>Let T be a tree and v </italic>&#x02208; <italic>V</italic>(<italic>T</italic>), <italic>an </italic>immediate triplet <italic>induced by v, denoted as yz </italic>&#x025b7;&#x025c1; <italic>v</italic>, <italic>is a triplet yz</italic>|<italic>v where there exists nodes a, b </italic>&#x02208; <italic>V</italic>(<italic>T</italic>) <italic>such that </italic>Pa<sub><italic>T</italic></sub>(<italic>y</italic>) = Pa<sub><italic>T</italic></sub>(<italic>z</italic>) = <italic>b and </italic>Pa<sub><italic>T</italic></sub>(<italic>b</italic>) = Pa<sub><italic>T</italic></sub>(<italic>v</italic>) = <italic>a</italic>.</p><p><bold>Algorithm 1 </bold>Algorithm for the SPR-RS problem</p><p>1: <bold>procedure </bold>SPR-RS(<italic>P</italic>, <italic>T</italic>, (<italic>u</italic>, <italic>v</italic>))</p><p>Input: A profile <italic>P </italic>= (<italic>T</italic><sub>1</sub>,..., <italic>T</italic><sub><italic>n</italic></sub>), a supertree <italic>T </italic>of <italic>P</italic>, and (<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E</italic>(<italic>T</italic>)</p><p>Output: <italic>T</italic>* &#x02208; SPR<sub><italic>T</italic></sub>(<italic>v</italic>), and &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic>, <italic>T</italic>*)</p><p>2:&#x000a0;&#x000a0;&#x000a0;<italic>r </italic>&#x02190; Ro(<italic>T</italic>)</p><p>3:&#x000a0;&#x000a0;&#x000a0;<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S8-i7" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>T</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> &#x02190; SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>r</italic>)</p><p>4:&#x000a0;&#x000a0;&#x000a0;Call MovedownAndCompute(<italic>P</italic>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S8-i7" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>T</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>, <italic>v</italic>)</p><p>5:&#x000a0;&#x000a0;&#x000a0;Traverse the tree <italic>T</italic><sub><italic>r </italic></sub>in pre-order to compute &#x00394;<sub><italic>P</italic></sub>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-S1-S8-i7" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>T</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>, <italic>T'</italic>) for each <italic>T' </italic>&#x02208; SPR<sub><italic>T</italic></sub>(<italic>v</italic>) using the values computed by MovedownAndCompute</p><p>6:&#x000a0;&#x000a0;&#x000a0;<italic>T</italic>* &#x02190; <italic>T' </italic>&#x02208; SPR<sub><italic>T</italic></sub>(<italic>v</italic>) such that <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-10-S1-S8-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>&#x00394;</mml:mi><mml:mi>P</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02033;</mml:mo></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msub><mml:mrow><mml:mtext>SPR</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mi>&#x00394;</mml:mi><mml:mi>P</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>T</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mo>&#x02033;</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula></p><p>7:&#x000a0;&#x000a0;&#x000a0;<italic>d </italic>&#x02190; &#x00394;<sub><italic>P</italic></sub>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-10-S1-S8-i7" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>T</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>, <italic>T</italic>*) - &#x00394;<sub><italic>P</italic></sub>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1471-2105-10-S1-S8-i7" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>T</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>, <italic>T</italic>)</p><p>8:&#x000a0;&#x000a0;&#x000a0;<bold>return </bold>(<italic>T</italic>*, <italic>d</italic>)</p><p>9: <bold>end procedure</bold></p><p>10: <bold>procedure </bold>M<sc>OVEDOWN</sc>A<sc>ND</sc>C<sc>OMPUTE</sc>(<italic>P</italic>, <italic>T</italic>, <italic>v</italic>)</p><p>Input: A profile <italic>P</italic>, a tree <italic>T</italic>, and <italic>v </italic>&#x02208; <italic>V</italic>(<italic>T</italic>)</p><p>11:&#x000a0;&#x000a0;&#x000a0;<italic>yz </italic>&#x025b7;&#x025c1; <italic>v </italic>&#x02190; The immediate triplet induced by <italic>v </italic>in <italic>T</italic></p><p>12:&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold><italic>t </italic>&#x02208; {<italic>y</italic>, <italic>z</italic>} <bold>do</bold></p><p>13:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>T' </italic>&#x02190; SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>t</italic>)</p><p>14:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Compute and store &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic>, <italic>T'</italic>)</p><p>15:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Call MovedownAndCompute(<italic>P</italic>, <italic>T'</italic>, <italic>v</italic>)</p><p>16:&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>17: <bold>end procedure</bold></p><p>It can be easily seen that Algorithm 1 is correctly solving the SPR-RS problem.</p></sec><sec><title>Solving the <italic>SPR</italic>-S problem</title><p><bold>Algorithm 2 </bold>Algorithm for the SPR-S problem</p><p>1: <bold>procedure </bold>SPR-S(<italic>P</italic>, <italic>T</italic>)</p><p>Input: A profile <italic>P </italic>= (<italic>T</italic><sub>1</sub>,..., <italic>T</italic><sub><italic>n</italic></sub>), a supertree <italic>T </italic>of <italic>P</italic></p><p>Output: <italic>T</italic>* &#x02208; SPR<sub><italic>T</italic></sub>, and &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic>, <italic>T</italic>*)</p><p>2:&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold>(<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>E</italic>(<italic>T</italic>) <bold>do</bold></p><p>3:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Store the value of SPR-RS(<italic>P</italic>, <italic>T</italic>, (<italic>u</italic>, <italic>v</italic>))</p><p>4:&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>5:&#x000a0;&#x000a0;&#x000a0;(<italic>T</italic>*, <italic>d</italic>) &#x02190; the stored value of SPR-RS calls that has the maximum score increase by traversing the tree <italic>T </italic>in post-order</p><p>6:&#x000a0;&#x000a0;&#x000a0;<bold>return </bold>(<italic>T</italic>*, <italic>d</italic>)</p><p>7: <bold>end procedure</bold></p><p>Algorithm 2 gives a trivial extension of Algorithm 1 to solve the SPR-S problem.</p></sec><sec><title>Computing &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic>, <italic>T'</italic>) efficiently</title><p>Algorithm 1 assumed the computation of &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic>, <italic>T'</italic>) for each move-down operation (Line 14). In this section we show how to compute each &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic>, <italic>T'</italic>) efficiently by exploiting structural properties related to the triplet-similarity. We begin with some useful definitions.</p><p><bold>Definition 7</bold>. <italic>Let A, B, C be pairwise mutual exclusive leaf sets, we extend the triplet notation by AB</italic>|<italic>C </italic>= {<italic>ab</italic>|<italic>c </italic>: <italic>a </italic>&#x02208; <italic>A</italic>, <italic>b </italic>&#x02208; <italic>B</italic>, <italic>c </italic>&#x02208; <italic>C</italic>}. <italic>Further, let u, v, w be three nodes in a tree T having no ancestral relationships, define uv</italic>|<sub><italic>T</italic></sub><italic>w </italic>= Le(<italic>T</italic><sub><italic>u</italic></sub>) Le(<italic>T</italic><sub><italic>v</italic></sub>)| Le(<italic>T</italic><sub><italic>w</italic></sub>)</p><p><bold>Definition 8</bold>. <italic>The </italic>Boolean value <italic>of a statement &#x003d5;, denoted as </italic>&#x027e6;<italic>&#x003d5;</italic>&#x027e7;, <italic>is 1 if &#x003d5; is true, 0 otherwise</italic>.</p><p><bold>Definition 9</bold>. <italic>Given a profile P </italic>= (<italic>T</italic><sub>1</sub>,..., <italic>T</italic><sub><italic>n</italic></sub>) <italic>and distinct a, b, c </italic>&#x02208; Le(<italic>P</italic>), <italic>we define the </italic>triplet summation function <italic>by</italic></p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17" name="1471-2105-10-S1-S8-i9" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:msub>                                 <mml:mi>&#x003c3;</mml:mi>                                 <mml:mi>P</mml:mi>                              </mml:msub>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>a</mml:mi>                              <mml:mi>b</mml:mi>                              <mml:mo>|</mml:mo>                              <mml:mi>c</mml:mi>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>=</mml:mo>                              <mml:mstyle displaystyle="true">                                 <mml:munderover>                                    <mml:mo>&#x02211;</mml:mo>                                    <mml:mrow>                                       <mml:mi>i</mml:mi>                                       <mml:mo>=</mml:mo>                                       <mml:mn>1</mml:mn>                                    </mml:mrow>                                    <mml:mi>n</mml:mi>                                 </mml:munderover>                                 <mml:mrow>                                    <mml:mrow>                                       <mml:mo>&#x0301a;</mml:mo>                                       <mml:mrow>                                          <mml:mi>a</mml:mi>                                          <mml:mi>b</mml:mi>                                          <mml:mo>|</mml:mo>                                          <mml:mi>c</mml:mi>                                          <mml:mo>&#x02208;</mml:mo>                                          <mml:mtext>Tr</mml:mtext>                                          <mml:mo stretchy="false">(</mml:mo>                                          <mml:msub>                                             <mml:mi>T</mml:mi>                                             <mml:mi>i</mml:mi>                                          </mml:msub>                                          <mml:mo stretchy="false">)</mml:mo>                                       </mml:mrow>                                       <mml:mo>&#x0301b;</mml:mo>                                    </mml:mrow>                                 </mml:mrow>                              </mml:mstyle>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p><italic>Let A, B, C </italic>&#x02286; Le(<italic>P</italic>) <italic>be pairwise mutual exclusive leaf sets, we extend the triplet summation function by</italic></p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18" name="1471-2105-10-S1-S8-i10" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:msub>                                 <mml:mi>&#x003c3;</mml:mi>                                 <mml:mi>P</mml:mi>                              </mml:msub>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>A</mml:mi>                              <mml:mi>B</mml:mi>                              <mml:mo>|</mml:mo>                              <mml:mi>C</mml:mi>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>=</mml:mo>                              <mml:mstyle displaystyle="true">                                 <mml:munder>                                    <mml:mo>&#x02211;</mml:mo>                                    <mml:mrow>                                       <mml:mi>a</mml:mi>                                       <mml:mo>&#x02208;</mml:mo>                                       <mml:mi>A</mml:mi>                                       <mml:mo>,</mml:mo>                                       <mml:mi>b</mml:mi>                                       <mml:mo>&#x02208;</mml:mo>                                       <mml:mi>B</mml:mi>                                       <mml:mo>,</mml:mo>                                       <mml:mi>c</mml:mi>                                       <mml:mo>&#x02208;</mml:mo>                                       <mml:mi>C</mml:mi>                                    </mml:mrow>                                 </mml:munder>                                 <mml:mrow>                                    <mml:msub>                                       <mml:mi>&#x003c3;</mml:mi>                                       <mml:mi>P</mml:mi>                                    </mml:msub>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>a</mml:mi>                                    <mml:mi>b</mml:mi>                                    <mml:mo>|</mml:mo>                                    <mml:mi>c</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:mstyle>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p><italic>Further</italic>, <italic>let u</italic>, <italic>v</italic>, <italic>w be three nodes in a tree T having no ancestral relationships</italic>, <italic>we define</italic></p><p><disp-formula><italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uv</italic>|<italic>w</italic>) = <italic>&#x003c3;</italic><sub><italic>P</italic></sub>(<italic>uv</italic>|<sub><italic>T</italic></sub><italic>w</italic>)</disp-formula></p><p><bold>Lemma 1</bold>. <italic>Let T be a tree and yz </italic>&#x025b7;&#x025c1; <italic>v be an immediate triplet induced by a node v </italic>&#x02208; <italic>V</italic>(<italic>T</italic>). <italic>If T' </italic>= SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>y</italic>), <italic>then</italic></p><p><disp-formula id="bmcM1"><label>(1)</label>Tr(<italic>T'</italic>) = (Tr(<italic>T</italic>)\<italic>yz</italic>|<sub><italic>T</italic></sub><italic>v</italic>) &#x0222a; <italic>vy</italic>|<sub><italic>T</italic></sub><italic>z</italic></disp-formula></p><p>(1) <italic>Proof</italic>. Let <italic>a</italic>, <italic>b</italic>, <italic>c </italic>&#x02208; Le(<italic>T</italic>), we consider the following cases:</p><p>1. If any one of <italic>a</italic>, <italic>b</italic>, <italic>c </italic>is not in the subtree <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19" name="1471-2105-10-S1-S8-i11" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mtext>Pa</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, then <italic>T'</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} = <italic>T</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>}. Since both <italic>yz</italic>|<sub><italic>T</italic></sub><italic>v </italic>and <italic>vy</italic>|<sub><italic>T</italic></sub><italic>z </italic>only contain triplets formed under the subtree <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20" name="1471-2105-10-S1-S8-i11" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mtext>Pa</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, <italic>T</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} and only this triplet resolution of {<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} is in both sides of equality.</p><p>2. Consider three subtrees <italic>T</italic><sub><italic>v</italic></sub>, <italic>T</italic><sub><italic>y</italic></sub>, <italic>T</italic><sub><italic>z</italic></sub>. If <italic>a</italic>, <italic>b</italic>, <italic>c </italic>are all in one of the subtree, then since the subtrees <italic>T</italic><sub><italic>v</italic></sub>, <italic>T</italic><sub><italic>y</italic></sub>, <italic>T</italic><sub><italic>z </italic></sub>do not change by the SPR operation, <italic>T'</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} = <italic>T</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>}. Since both <italic>yz</italic>|<sub><italic>T</italic></sub><italic>v </italic>and <italic>vy</italic>|<sub><italic>T</italic></sub><italic>z </italic>only contain triplets that are formed by one leaf from each of <italic>T</italic><sub><italic>v</italic></sub>, <italic>T</italic><sub><italic>y</italic></sub>, and <italic>T</italic><sub><italic>z </italic></sub>subtrees, <italic>T</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} and only this triplet resolution of {<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} is in both sides of equality.</p><p>3. Consider three subtrees <italic>T</italic><sub><italic>v</italic></sub>, <italic>T</italic><sub><italic>y</italic></sub>, <italic>T</italic><sub><italic>z</italic></sub>. If two leaves of {<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} are in one subtree and the other leaf is in another subtree, and suppose WLOG that {<italic>a</italic>, <italic>b</italic>} are in one subtree, then we observe that <italic>lca</italic><sub><italic>T</italic></sub>({<italic>a</italic>, <italic>b</italic>}) &#x0003c;<sub><italic>T </italic></sub><italic>lca</italic><sub><italic>T</italic></sub>({<italic>a</italic>, <italic>b</italic>, <italic>c</italic>}) and <italic>lca</italic><sub><italic>T'</italic></sub>({<italic>a</italic>, <italic>b</italic>}) &#x0003c;<sub><italic>T' </italic></sub><italic>lca</italic><sub><italic>T'</italic></sub>({<italic>a</italic>, <italic>b</italic>, <italic>c</italic>}), so <italic>T'</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} = <italic>T</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} = <italic>ab</italic>|<italic>c</italic>.</p><p>Also, as in Case 2, both <italic>yz</italic>|<sub><italic>T</italic></sub><italic>v </italic>and <italic>vy</italic>|<sub><italic>T</italic></sub><italic>z </italic>does not contain triplet formed by {<italic>a</italic>, <italic>b</italic>, <italic>c</italic>}, so <italic>T</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} and only this triplet resolution of {<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} is in both sides of equality.</p><p>4. If each of <italic>T</italic><sub><italic>v</italic></sub>, <italic>T</italic><sub><italic>y</italic></sub>, and <italic>T</italic><sub><italic>z </italic></sub>contains exactly one leaf in {<italic>a</italic>, <italic>b</italic>, <italic>c</italic>}, and suppose WLOG that <italic>a </italic>&#x02208; Le(<italic>T</italic><sub><italic>v</italic></sub>), <italic>b </italic>&#x02208; Le(<italic>T</italic><sub><italic>y</italic></sub>), and <italic>c </italic>&#x02208; Le(<italic>T</italic><sub><italic>z</italic></sub>). Then <italic>T</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} = <italic>bc</italic>|<italic>a </italic>and <italic>T'</italic>|{<italic>a</italic>, <italic>b</italic>, <italic>c</italic>} = <italic>ab</italic>|<italic>c</italic>. Also we observe that <italic>bc</italic>|<italic>a </italic>&#x02208; <italic>yz</italic>|<sub><italic>T</italic></sub><italic>v </italic>and <italic>ab</italic>|<italic>c </italic>&#x02208; <italic>vy</italic>|<sub><italic>T</italic></sub><italic>z</italic>, therefore RHS, and hence both sides contain <italic>ab</italic>|<italic>c </italic>and only this resolution of {<italic>a</italic>, <italic>b</italic>, <italic>c</italic>}.</p><p><bold>Lemma 2</bold>. <italic>Given a profile P and a supertree T of P, let yz </italic>&#x025b7;&#x025c1; <italic>v be an immediate triplet induced by a node v </italic>&#x02208; <italic>V</italic>(<italic>T</italic>). <italic>If T' </italic>= SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>y</italic>), <italic>then</italic></p><p><disp-formula id="bmcM2"><label>(2)</label>&#x00394;<sub><italic>P </italic></sub>(<italic>T</italic>, <italic>T'</italic>) = <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vy</italic>|<italic>z</italic>) - <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>yz</italic>|<italic>v</italic>)</disp-formula></p><p><bold>Lemma 3</bold>. <italic>Given a profile P and a supertree T of P, let distinct v, b </italic>&#x02208; <italic>V</italic>(<italic>T</italic>) <italic>such that v </italic>&#x02270;<sub><italic>T </italic></sub><italic>b</italic>, <italic>b </italic>&#x02270;<sub><italic>T </italic></sub><italic>v</italic>, <italic>and </italic>Ch<sub><italic>T</italic></sub>(<italic>b</italic>) = {<italic>y</italic>, <italic>z</italic>}. <italic>If T</italic><sub>1 </sub>= SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>b</italic>) <italic>and T</italic><sub>2 </sub>= SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>y</italic>), <italic>then</italic></p><p><disp-formula id="bmcM3"><label>(3)</label>&#x00394;<sub><italic>P</italic></sub>(<italic>T</italic><sub>1</sub>, <italic>T</italic><sub>2</sub>) = <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vy</italic>|<italic>z</italic>) - <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>yz</italic>|<italic>v</italic>)</disp-formula></p><p><bold>Lemma 4</bold>. <italic>Given a profile P and a supertree T of P, let v, b </italic>&#x02208; <italic>V</italic>(<italic>T</italic>) <italic>such that </italic>Pa<sub><italic>T </italic></sub>(Pa<sub><italic>T</italic></sub>(<italic>v</italic>)) &#x02264;<sub><italic>T </italic></sub><italic>b</italic>, <italic>and let </italic>&#x0220f; = {<italic>x </italic>&#x02208; <italic>V</italic>(<italic>T</italic>): <italic>v </italic>&#x0003c;<sub><italic>T </italic></sub><italic>x </italic>&#x0003c;<sub><italic>T </italic></sub><italic>b</italic>}. <italic>Define C </italic>= &#x0222a;<sub><italic>x</italic>&#x02208;&#x0220f; </sub>{c&#x02208;Ch<sub><italic>T</italic></sub>(<italic>x</italic>):v&#x02270;<sub>T</sub>c}. <italic>Let </italic>Ch<sub><italic>T</italic></sub>(<italic>b</italic>) = {<italic>y</italic>, <italic>z</italic>}, <italic>and WLOG suppose y </italic>&#x02209; &#x0220f;. <italic>If T</italic><sub>1 </sub>= SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>b</italic>) <italic>and T</italic><sub>2 </sub>= SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>y</italic>), <italic>then</italic></p><p><disp-formula id="bmcM4"><label>(4)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M21" name="1471-2105-10-S1-S8-i12" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:msub>                                 <mml:mi>&#x00394;</mml:mi>                                 <mml:mi>P</mml:mi>                              </mml:msub>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:msub>                                 <mml:mi>T</mml:mi>                                 <mml:mn>1</mml:mn>                              </mml:msub>                              <mml:mo>,</mml:mo>                              <mml:msub>                                 <mml:mi>T</mml:mi>                                 <mml:mn>2</mml:mn>                              </mml:msub>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>=</mml:mo>                              <mml:mstyle displaystyle="true">                                 <mml:munder>                                    <mml:mo>&#x02211;</mml:mo>                                    <mml:mrow>                                       <mml:mi>x</mml:mi>                                       <mml:mo>&#x02208;</mml:mo>                                       <mml:mi>C</mml:mi>                                    </mml:mrow>                                 </mml:munder>                                 <mml:mrow>                                    <mml:mo stretchy="false">[</mml:mo>                                    <mml:msub>                                       <mml:mi>&#x003c3;</mml:mi>                                       <mml:mrow>                                          <mml:mi>P</mml:mi>                                          <mml:mo>,</mml:mo>                                          <mml:mi>T</mml:mi>                                       </mml:mrow>                                    </mml:msub>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>v</mml:mi>                                    <mml:mi>y</mml:mi>                                    <mml:mo>|</mml:mo>                                    <mml:mi>x</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                    <mml:mo>&#x02212;</mml:mo>                                    <mml:msub>                                       <mml:mi>&#x003c3;</mml:mi>                                       <mml:mrow>                                          <mml:mi>P</mml:mi>                                          <mml:mo>,</mml:mo>                                          <mml:mi>T</mml:mi>                                       </mml:mrow>                                    </mml:msub>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>y</mml:mi>                                    <mml:mi>x</mml:mi>                                    <mml:mo>|</mml:mo>                                    <mml:mi>v</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                    <mml:mo>]</mml:mo>                                 </mml:mrow>                              </mml:mstyle>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>Equations (3) and (4) provide computations for all SPR-RS neighborhoods (Line 14 of Algorithm 1). We now show how to compute them efficiently.</p><p><bold>Algorithm 3 </bold>Algorithm to compute triplet summation function</p><p>1: <bold>procedure </bold>P<sc>REPROCESS</sc>T<sc>RIPLET</sc>S<sc>UM</sc>(<italic>P</italic>)</p><p>Input: A profile <italic>P </italic>= (<italic>T</italic><sub>1</sub>,..., <italic>T</italic><sub><italic>n</italic></sub>)</p><p>2:&#x000a0;&#x000a0;&#x000a0;Initialize all values of <italic>&#x003c3;</italic><sub><italic>P </italic></sub>to 0</p><p>3:&#x000a0;&#x000a0;&#x000a0;<bold>for </bold><italic>i </italic>= 1 to <italic>n </italic><bold>do</bold></p><p>4:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold><italic>u </italic>&#x02208; <italic>V</italic>(<italic>T</italic><sub><italic>i</italic></sub>) in post-order, <italic>u </italic>&#x02209; Le(<italic>T</italic><sub><italic>i</italic></sub>) <bold>do</bold></p><p>5:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;{<italic>v</italic>, <italic>w</italic>} &#x02190; Ch<sub><italic>T</italic></sub>(<italic>u</italic>)</p><p>6:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold>{<italic>x</italic>, <italic>y</italic>} &#x02208; Le(<italic>T</italic><sub><italic>v</italic></sub>), <italic>z </italic>&#x02208; Le(<italic>T</italic><sub><italic>w</italic></sub>) <bold>do</bold></p><p>7:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Increment <italic>&#x003c3;</italic><sub><italic>P</italic></sub>(<italic>xy</italic>|<italic>z</italic>)</p><p>8:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>9:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold>{<italic>x</italic>, <italic>y</italic>} &#x02208; Le(<italic>T</italic><sub><italic>w</italic></sub>), <italic>z </italic>&#x02208; Le(<italic>T</italic><sub><italic>v</italic></sub>) <bold>do</bold></p><p>10:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Increment <italic>&#x003c3;</italic><sub><italic>P</italic></sub>(<italic>xy</italic>|<italic>z</italic>)</p><p>11:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>12:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>13:&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>14: <bold>end procedure</bold></p><p>Given a profile <italic>P </italic>= (<italic>T</italic><sub>1</sub>,..., <italic>T</italic><sub><italic>n</italic></sub>), we start by computing the triplet summation function <italic>&#x003c3;</italic><sub><italic>P </italic></sub>for all triplets, as shown by Algorithm 3.</p><p><bold>Algorithm 4 </bold>Algorithm to compute extended triplet summation function</p><p>1: <bold>procedure </bold>P<sc>REPROCESS</sc>E<sc>XTENDED</sc>T<sc>RIPLET</sc>S<sc>UM</sc>(<italic>P</italic>, <italic>T</italic>)</p><p>Input: A profile <italic>P </italic>= (<italic>T</italic><sub>1</sub>,..., <italic>T</italic><sub><italic>n</italic></sub>), a supertree <italic>T </italic>of <italic>P</italic></p><p>2:&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold><italic>u </italic>&#x02208; <italic>V</italic>(<italic>T</italic>) in post-order <bold>do</bold></p><p>3:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold><italic>v </italic>&#x02208; <italic>V</italic>(<italic>T</italic>) in post-order after <italic>u</italic>, <italic>lca</italic><sub><italic>T</italic></sub>({<italic>u</italic>, <italic>v</italic>}) &#x02209; {<italic>u</italic>, <italic>v</italic>} <bold>do</bold></p><p>4:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold><italic>w </italic>&#x02208; <italic>V</italic>(<italic>T</italic>) in post-order after <italic>v</italic>, <italic>lca</italic><sub><italic>T</italic></sub>({<italic>u</italic>, <italic>v</italic>, <italic>w</italic>}) &#x02209; {<italic>u</italic>, <italic>v</italic>, <italic>w</italic>} <bold>do</bold></p><p>5:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>if </bold><italic>w </italic>&#x02208; Le(<italic>T</italic>) <bold>then</bold></p><p>6:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>if </bold><italic>v </italic>&#x02208; Le(<italic>T</italic>) <bold>then</bold></p><p>7:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>if </bold><italic>u </italic>&#x02208; Le(<italic>T</italic>) <bold>then</bold></p><p>8:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uv</italic>|<italic>w</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic></sub>(<italic>uv</italic>|<italic>w</italic>)</p><p>9:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uw</italic>|<italic>v</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic></sub>(<italic>uw</italic>|<italic>v</italic>)</p><p>10:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vw</italic>|<italic>u</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic></sub>(<italic>vw</italic>|<italic>u</italic>)</p><p>11:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>else</bold></p><p>12:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;{<italic>u</italic><sub>1</sub>, <italic>u</italic><sub>2</sub>} &#x02190; Ch<sub><italic>T</italic></sub>(<italic>u</italic>)</p><p>13:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uv</italic>|<italic>w</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>u</italic><sub>1</sub><italic>v</italic>|<italic>w</italic>) + <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>u</italic><sub>2</sub><italic>v</italic>|<italic>w</italic>)</p><p>14:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uw</italic>|<italic>v</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>u</italic><sub>1</sub><italic>w</italic>|<italic>v</italic>) + <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>u</italic><sub>2</sub><italic>w</italic>|<italic>v</italic>)</p><p>15:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vw</italic>|<italic>u</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vw</italic>|<italic>u</italic><sub>1</sub>) + <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vw</italic>|<italic>u</italic><sub>2</sub>)</p><p>16:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end if</bold></p><p>17:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>else</bold></p><p>18:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;{<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>} &#x02190; Ch<sub><italic>T</italic></sub>(<italic>v</italic>)</p><p>19:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uv</italic>|<italic>w</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uv</italic><sub>1</sub>|<italic>w</italic>) + <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uv</italic><sub>2</sub>|<italic>w</italic>)</p><p>20:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uw</italic>|<italic>v</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uw</italic>|<italic>v</italic><sub>1</sub>) + <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uw</italic>|<italic>v</italic><sub>2</sub>)</p><p>21:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vw</italic>|<italic>u</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>v</italic><sub>1</sub><italic>w</italic>|<italic>u</italic>) + <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>v</italic><sub>2</sub><italic>w</italic>|<italic>u</italic>)</p><p>22:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end if</bold></p><p>23:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>else</bold></p><p>24:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;{<italic>w</italic><sub>1</sub>, <italic>w</italic><sub>2</sub>} &#x02190; Ch<sub><italic>T</italic></sub>(<italic>w</italic>)</p><p>25:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uv</italic>|<italic>w</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uv</italic>|<italic>w</italic><sub>1</sub>) + <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uv</italic>|<italic>w</italic><sub>2</sub>)</p><p>26:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uw</italic>|<italic>v</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uw</italic><sub>1</sub><italic>|v</italic>) + <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>uw</italic><sub>2</sub><italic>|v</italic>)</p><p>27:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vw</italic>|<italic>u</italic>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vw</italic><sub>1</sub>|<italic>u</italic>) + <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vw</italic><sub>2</sub>|<italic>u</italic>)</p><p>28:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end if</bold></p><p>29:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>30:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>31:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>32: <bold>end procedure</bold></p><p>Next, we compute the extended triplet summation function <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>, for all nodes <italic>u</italic>, <italic>v</italic>, <italic>w </italic>in <italic>T </italic>having no ancestral relationships, as shown by Algorithm 4.</p><p><bold>Algorithm 5 </bold>Algorithm to compute score difference function</p><p>1: <bold>procedure </bold>P<sc>REPROCESS</sc>S<sc>CORE</sc>D<sc>IFFERENCE</sc>(<italic>P</italic>, <italic>T</italic>)</p><p>Input: A profile <italic>P </italic>= (<italic>T</italic><sub>1</sub>,..., <italic>T</italic><sub><italic>n</italic></sub>), a supertree <italic>T </italic>of <italic>P</italic></p><p>2:&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold><italic>v </italic>&#x02208; <italic>V</italic>(<italic>T</italic>) <bold>do</bold></p><p>3:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold>(<italic>b</italic>, <italic>y</italic>) &#x02208; <italic>E</italic>(<italic>T</italic>): <italic>b </italic>&#x02270;<sub><italic>T </italic></sub>Pa<sub><italic>T</italic></sub>(<italic>v</italic>) <bold>do</bold></p><p>4:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Let Ch<sub><italic>T</italic></sub>(<italic>b</italic>) = {<italic>y</italic>, <italic>z</italic>}</p><p>5:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Let <italic>T</italic><sub>1 </sub>= SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>b</italic>), <italic>T</italic><sub>2 </sub>= SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>y</italic>)</p><p>6:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>if </bold><italic>v </italic>&#x02264;<sub><italic>T </italic></sub><italic>b </italic><bold>then</bold></p><p>7:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>for all </bold><italic>p </italic>&#x02208; <italic>V</italic>(<italic>T</italic>): <italic>v </italic>&#x0003c;<sub><italic>T </italic></sub><italic>p </italic>&#x0003c;<sub><italic>T </italic></sub><italic>b </italic><bold>do</bold></p><p>8:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Let <italic>x </italic>&#x02208; Ch<sub><italic>T </italic></sub>(<italic>p</italic>) where <italic>v </italic>&#x02270;<sub><italic>T </italic></sub><italic>x</italic></p><p>9:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x00394;<sub><italic>P</italic></sub>(<italic>T</italic><sub>1</sub>, <italic>T</italic><sub>2</sub>) &#x02190; &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic><sub>1</sub>, <italic>T</italic><sub>2</sub>) + <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vy</italic>|<italic>x</italic>) - <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>yx</italic>|<italic>v</italic>)</p><p>10:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>11:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>else</bold></p><p>12:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>&#x00394;</italic><sub><italic>P</italic></sub>(<italic>T</italic><sub>1</sub>, <italic>T</italic><sub>2</sub>) &#x02190; <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>vy</italic>|<italic>z</italic>) - <italic>&#x003c3;</italic><sub><italic>P</italic>, <italic>T</italic></sub>(<italic>yz</italic>|<italic>v</italic>)</p><p>13:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end if</bold></p><p>14:&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>15:&#x000a0;&#x000a0;&#x000a0;<bold>end for</bold></p><p>16: <bold>end procedure</bold></p><p>Finally, we compute the score difference function &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic><sub>1</sub>, <italic>T</italic><sub>2</sub>) for all <italic>v </italic>&#x02208; <italic>V</italic>(<italic>T</italic>) and (<italic>b</italic>, <italic>y</italic>) &#x02208; <italic>E</italic>(<italic>T</italic>) where <italic>b </italic>&#x02270;<sub><italic>T </italic></sub>Pa<sub><italic>T</italic></sub>(<italic>v</italic>) such that <italic>T</italic><sub>1 </sub>= SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>b</italic>) and <italic>T</italic><sub>2 </sub>= SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>y</italic>). This is shown by Algorithm 5.</p></sec><sec><title>Time complexity</title><p>We describe the time complexity for our solution for the SPR-S problem. First, we run Algorithm 3 once for the entire heuristic run, which takes <italic>O</italic>(<italic>kn</italic><sup>3</sup>) where <italic>k </italic>is the number of input trees and <italic>n </italic>is the number of taxa present in the input trees. Then, for each SPR-S problem, we begin by pre-processing necessary counts using Algorithm 4 and 5, each takes time <italic>O</italic>(<italic>n</italic><sup>3</sup>). These pre-processed computations allow Algorithm 1 to run in <italic>O</italic>(<italic>n</italic>) time. Finally, Algorithm 2 issues <italic>O</italic>(<italic>n</italic>) calls to Algorithm 1, so overall it takes <italic>O</italic>(<italic>n</italic><sup>2</sup>) time. Including the pre-processing steps, we see that solving the SPR-S problem takes <italic>O</italic>(<italic>n</italic><sup>3</sup>) time, with an expense of <italic>O</italic>(<italic>kn</italic><sup>3</sup>) at the beginning of the entire heuristic run.</p></sec></sec><sec><title>Solving the TBR-RS and TBR-S problems</title><p>We extend our solutions of SPR-RS and SPR-S problems to solve TBR-RS and TBR-S problems.</p><sec><title>Solving the <italic>TBR</italic>-RS problem</title><p>We observe that a TBR operation can be viewed as an SPR operation followed by an RR operation. We exploit this structural property further and establish some lemmas which helps us compute the score differences for all TBR operations in the TBR-RS neighborhood.</p><p><bold>Lemma 5</bold>. <italic>Given a profile P, a supertree T of P, and a valid </italic>TBR <italic>operation on T where T' </italic>= TBR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>x</italic>, <italic>y</italic>), <italic>then</italic></p><p><disp-formula id="bmcM5"><label>(5)</label>&#x00394;<sub><italic>P</italic></sub>(<italic>T</italic>, <italic>T'</italic>) = &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic>, SPR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>y</italic>)) + &#x00394;<sub><italic>P</italic></sub>(<italic>T</italic>, RR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>x</italic>))</disp-formula></p><p>Lemma 5 implies that given a subtree, we can find the best TBR-RS neighborhood by finding the best SPR-RS neighborhood and apply the best re-rooting for the subtree regardless of which SPR operation was chosen. Further, we note that RR is a special case of SPR operation by the following lemma.</p><p><bold>Lemma 6</bold>. <italic>Given a profile P and a supertree T of P, let xy </italic>&#x025b7;&#x025c1; <italic>z be an immediate triplet induced by a node z </italic>&#x02208; <italic>V</italic>(<italic>T</italic>) <italic>and </italic>Pa<sub><italic>T</italic></sub>(<italic>z</italic>) = <italic>v</italic>, <italic>then</italic></p><p><disp-formula id="bmcM6"><label>(6)</label>RR<sub><italic>T</italic></sub>(<italic>v</italic>, <italic>x</italic>) = SPR<sub><italic>T</italic></sub>(<italic>z</italic>, <italic>y</italic>)</disp-formula></p><p>This means that we can reuse Lemmas 2, 3, 4 and their corresponding algorithms to compute the score differences of all move-downs in terms of re-rooting. Hence, given a subtree the algorithm would first compute the best re-rooting and its score difference, then simply join this RR operation with the best SPR operation in the SPR-RS neighborhood.</p></sec><sec><title>Solving the <italic>TBR</italic>-S problem</title><p>Similar to solving the SPR-S problem, we can solve the TBR-S problem given the solution to the TBR-RS problem in the previous section.</p></sec><sec><title>Time complexity</title><p>We perform the same steps to solve the SPR-S problem, and additionally by utilizing Lemmas 5 and 6 we compute and store the best re-rooting for each subtree, which takes <italic>O</italic>(<italic>n</italic><sup>3</sup>) time. Overall, solving the TBR-S problem still takes <italic>O</italic>(<italic>n</italic><sup>3</sup>) time.</p></sec></sec></sec><sec><title>Results and discussion</title><p>We examined the performance of our new triplet heuristics by comparing with two other supertree methods, MRP and modified Min-Cut (MMC; [<xref ref-type="bibr" rid="B20">20</xref>]), using published data sets from marsupials [<xref ref-type="bibr" rid="B21">21</xref>] and Cetartiodactyla [<xref ref-type="bibr" rid="B22">22</xref>]. MRP is the most widely applied supertree method [<xref ref-type="bibr" rid="B3">3</xref>]. However, MRP supertrees, like triplet supertrees, are intrinsically hard to compute. Therefore they are estimated using heuristics, which do not guarantee an optimal solution. In contrast, MMC supertrees can be computed exactly in polynomial time, and therefore, it has been suggested that MMC will be useful for building very large phylogenies [<xref ref-type="bibr" rid="B20">20</xref>]. We evaluated each of the supertree methods using the triplet-similarity and the maximum agreement subtree (MAST) similarity [<xref ref-type="bibr" rid="B23">23</xref>] between the input trees and the supertrees. Furthermore, we measured the parsimony score of each computed supertree based on its binary matrix representation. For the marsupial data set, we also compared our results to published results using the max cut (MXC) supertree algorithm [<xref ref-type="bibr" rid="B24">24</xref>]. MXC is a modification of MMC that provides a heuristic approach based on the triplet supertree problem. There is currently no publicly available implementation of MXC (S. Snir, pers. comm.), and therefore, we were unable to apply it to the other data set.</p><p>Triplet supertrees were constructed using the programs TH(SPR) and TH(TBR) that implement hill-climbing heuristics based on our efficient local search algorithms for SPR and TBR branch swapping respectively. MRP supertrees were constructed using the parsimony hill-climbing heuristic implemented in PAUP* [<xref ref-type="bibr" rid="B9">9</xref>] with TBR branch swapping. We found very little difference in the results of MRP analyses when we collapsed zero-length branches and when we forced all MRP trees to be binary. We report the results from analyses that collapsed zero-length branches. All hill-climbing analyses were executed on 20 initial random addition sequence replicate trees and saving a single best tree per replicate. MMC supertrees were constructed using a program [<xref ref-type="bibr" rid="B20">20</xref>] supplied by Rod Page.</p><p>Our new triplet heuristics seek the supertrees with the maximum number of identical triplets to the collection of input trees, and indeed, we find they both outperform all other methods based on triplet-similarity in all data sets (Table <xref ref-type="table" rid="T1">1</xref>). Furthermore, all the triplet supertree analyses were completed within 15 minutes using a Kensington quad-core 2.66 GHz Linux-based machine, demonstrating that our heuristics make the triplet supertree problem extremely tractable for large-scale analyses. Both triplet heuristics and the MRP heuristic perform much better than the exact MMC algorithm, based on triplet-similarity and MAST-similarity. The MXC algorithm suffers from the lack of an available implementation; however, in our single comparison with the published results, this algorithm does not perform as well as either the MRP heuristic or our triplet heuristics.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Results of supertree analyses of two empirical data sets. Note that a bolded number represents the best found score for each measurement in a data set.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center"><bold>Data Set</bold></td><td align="center"><bold>Method</bold></td><td align="center"><bold>Triplet-similarity</bold></td><td align="center"><bold>MAST-similarity</bold></td><td align="center"><bold>Pars. Score</bold></td></tr></thead><tbody><tr><td align="center"><bold>Marsupial </bold>[<xref ref-type="bibr" rid="B21">21</xref>]<break/>158 input trees<break/>267 taxa</td><td align="center">MMC</td><td align="center">51.73 %</td><td align="center">54.20 %</td><td align="center">3901</td></tr><tr><td></td><td colspan="4"><hr></hr></td></tr><tr><td></td><td align="center">MXC</td><td align="center">&#x02248; 96 %</td><td align="center">&#x02248; 66 %</td><td align="center">N/A</td></tr><tr><td></td><td colspan="4"><hr></hr></td></tr><tr><td></td><td align="center">MRP</td><td align="center">98.29 %</td><td align="center"><bold>71.70 </bold>%</td><td align="center"><bold>2274</bold></td></tr><tr><td></td><td colspan="4"><hr></hr></td></tr><tr><td></td><td align="center">TH(SPR)</td><td align="center"><bold>98.99 </bold>%</td><td align="center">70.50 %</td><td align="center">2317</td></tr><tr><td></td><td colspan="4"><hr></hr></td></tr><tr><td></td><td align="center">TH(TBR)</td><td align="center"><bold>98.99 </bold>%</td><td align="center">70.70 %</td><td align="center">2317</td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="center"><bold>Cetartiodactyla </bold>[<xref ref-type="bibr" rid="B22">22</xref>]<break/>201 input trees<break/>290 taxa</td><td align="center">MMC</td><td align="center">70.03 %</td><td align="center">54.20 %</td><td align="center">4929</td></tr><tr><td></td><td colspan="4"><hr></hr></td></tr><tr><td></td><td align="center">MRP</td><td align="center">95.84 %</td><td align="center"><bold>65.40 </bold>%</td><td align="center"><bold>2603</bold></td></tr><tr><td></td><td colspan="4"><hr></hr></td></tr><tr><td></td><td align="center">TH(SPR)</td><td align="center"><bold>97.28 </bold>%</td><td align="center">63.40 %</td><td align="center">2754</td></tr><tr><td></td><td colspan="4"><hr></hr></td></tr><tr><td></td><td align="center">TH(TBR)</td><td align="center"><bold>97.28 </bold>%</td><td align="center">63.50 %</td><td align="center">2754</td></tr></tbody></table></table-wrap><p>Although the difference in the triplet-similarity score between the triplet heuristics and the MRP heuristic is always less than 2% (Table <xref ref-type="table" rid="T1">1</xref>), due to the extremely large-number of triplets, even these apparently small differences represent large differences in tree topologies. For example, in the marsupial data set, the 0.7% difference in triplet-similarity represents over 17,400 triplets. The comparison of the triplet heuristics and the MRP heuristic also demonstrates that optimizing the parsimony score of the matrix representation of input trees is not directly correlated with optimizing the triplet-similarity of input trees and the supertree; supertrees with smaller (better) parsimony scores have lower (worse) triplet-similarity (Table <xref ref-type="table" rid="T1">1</xref>).</p><p>Our experiments also demonstrate that the supertree with the best triplet-similarity is not necessarily best in terms of MAST-similarity. In fact, MRP outperforms the triplet heuristics in terms of the MAST-similarity to the input trees (Table <xref ref-type="table" rid="T1">1</xref>). It is not intuitive that a parsimony analysis on a matrix representation of the input trees (MRP) is a valid or useful approach to infer the most accurate supertrees (but see [<xref ref-type="bibr" rid="B25">25</xref>]). The popularity of MRP is probably based more on the availability of programs that implement fast heuristics rather than a belief that parsimony on a matrix representation of input trees is the ideal supertree optimality criterion. However, MRP performs well in simple simulation experiments [<xref ref-type="bibr" rid="B26">26</xref>,<xref ref-type="bibr" rid="B27">27</xref>] and in analyses of empirical data (e.g., [<xref ref-type="bibr" rid="B13">13</xref>]), and it clearly can be an effective supertree method. Since it is not obvious whether it is better to find supertrees that maximize accuracy in terms of triplet-similarity, MAST-similarity, or some other tree similarity measure like the Robinson-Foulds distance, we suggest that the triplet heuristics are an informative complement to the MRP method. Both approaches can provide supertrees that represent different, and equally valid, perspectives on accuracy.</p></sec><sec><title>Conclusion</title><p>Despite the inherent complexity of the triplet supertree problem, we have shown that it can be addressed effectively by using hill-climbing heuristics. We introduced efficient algorithms for standard local search problems that are solved by these heuristics. Our algorithms greatly improve on the best known (na&#x000ef;ve) solutions for these search problems. This in turn makes hill-climbing heuristics for the triplet supertree problem applicable for large-scale phylogenetic studies.</p><p>We demonstrate the performance of an implementation of our hill-climbing heuristics. In analyses of two empirical data sets, our triplet heuristics quickly found supertrees that contained more triplets in common with the input trees than supertrees found by MRP, MMC, or MXC. These results demonstrate not only that our heuristics for the triplet supertree problem make it a valuable alternative to standard supertree methods. They also demonstrate that developing new supertree heuristics that directly seek to optimize the accuracy of the supertree with respect to the input trees can enhance our ability to infer with accuracy large sections of the tree of life.</p><p>The algorithmic ideas developed in this work might set base for theoretical properties that identifies a much broader class of local search objectives, which can be solved more efficiently. This could lead to other powerful supertree heuristics. However, it remains an open problem if our solutions for the SPR and TBR based local search problems for the triplet supertree problem can be improved further.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>HTL designed the triplet heuristics, implemented programs TH(SPR) and TH(TBR), and carried out the experiments. JGB led the analysis of the experimental results. OE inspired the triplet heuristics and supervised the project. All authors contributed to the writing of this manuscript, and have read and approved the final manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>This research is supported in part by National Science Foundation AToL grant EF-0334832 and NESCent (NSF EF-0423641).</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gordon</surname><given-names>AD</given-names></name></person-group><article-title>Consensus supertrees: The synthesis of rooted trees containing overlapping sets of labeled leaves</article-title><source>Journal of Classification</source><year>1986</year><volume>3</volume><fpage>335</fpage><lpage>348</lpage></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sanderson</surname><given-names>MJ</given-names></name><name><surname>Purvis</surname><given-names>A</given-names></name><name><surname>Henze</surname><given-names>C</given-names></name></person-group><article-title>Phylogenetic supertrees: assembling the trees of life</article-title><source>Trends in Ecology &#x00026; Evolution</source><year>1998</year><volume>13</volume><fpage>105</fpage><lpage>109</lpage></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bininda-Emonds</surname><given-names>ORP</given-names></name><name><surname>Gittleman</surname><given-names>JL</given-names></name><name><surname>Steel</surname><given-names>MA</given-names></name></person-group><article-title>The (super) tree of life: procedures, problems, and prospects</article-title><source>Annual Review of Ecology and Systematics</source><year>2002</year><volume>33</volume><fpage>265</fpage><lpage>289</lpage></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bininda-Emonds</surname><given-names>ORP</given-names></name></person-group><article-title>The evolution of supertrees</article-title><source>Trends in Ecology and Evolution</source><year>2004</year><volume>19</volume><fpage>315</fpage><lpage>22</lpage><pub-id pub-id-type="pmid">16701277</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Davies</surname><given-names>JT</given-names></name><name><surname>Barraclough</surname><given-names>TG</given-names></name><name><surname>Chase</surname><given-names>MW</given-names></name><name><surname>Soltis</surname><given-names>PS</given-names></name><name><surname>Soltis</surname><given-names>DE</given-names></name><name><surname>Savolainen</surname><given-names>V</given-names></name></person-group><article-title>Darwin's abominable mystery: Insights from a supertree of the angiosperms</article-title><source>PNAS</source><year>2004</year><volume>101</volume><fpage>1904</fpage><lpage>1909</lpage><pub-id pub-id-type="pmid">14766971</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bininda-Emonds</surname><given-names>ORP</given-names></name><name><surname>Cardillo</surname><given-names>M</given-names></name><name><surname>Jones</surname><given-names>KE</given-names></name><name><surname>MacPhee</surname><given-names>RDE</given-names></name><name><surname>Beck</surname><given-names>RMD</given-names></name><name><surname>Grenyer</surname><given-names>R</given-names></name><name><surname>Price</surname><given-names>SA</given-names></name><name><surname>Vos</surname><given-names>RA</given-names></name><name><surname>Gittleman</surname><given-names>JL</given-names></name><name><surname>Purvis</surname><given-names>A</given-names></name></person-group><article-title>The delayed rise of present-day mammals</article-title><source>Nature</source><year>2007</year><volume>446</volume><fpage>507</fpage><lpage>512</lpage><pub-id pub-id-type="pmid">17392779</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Baum</surname><given-names>BR</given-names></name></person-group><article-title>Combining trees as a way of combining data sets for phylogenetic inference, and the desirability of combining gene trees</article-title><source>Taxon</source><year>1992</year><volume>41</volume><fpage>3</fpage><lpage>10</lpage></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ragan</surname><given-names>MA</given-names></name></person-group><article-title>Phylogenetic inference based on matrix representation of trees</article-title><source>Molecular Phylogenetics and Evolution</source><year>1992</year><volume>1</volume><fpage>53</fpage><lpage>58</lpage><pub-id pub-id-type="pmid">1342924</pub-id></citation></ref><ref id="B9"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Swofford</surname><given-names>DL</given-names></name></person-group><source>PAUP*: Phylogenetic Analysis Using Parsimony (*and Other Methods) Version 40 beta</source><year>2002</year><publisher-name>Sunderland, Massachusetts, USA: Sinauer Assoc</publisher-name></citation></ref><ref id="B10"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Goloboff</surname><given-names>PA</given-names></name></person-group><person-group person-group-type="editor"><name><surname>DeSalle R, Wheeler W, Giribet Ge</surname></name></person-group><article-title>Techniques for analysis of large data sets</article-title><source>Techniques in Molecular Systematics and Evolution</source><year>2000</year><publisher-name>Birkhauser-Verlag, Basel</publisher-name><fpage>70</fpage><lpage>9</lpage></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Purvis</surname><given-names>A</given-names></name></person-group><article-title>A modification to Baum and Ragan's method for combining phylogenetic trees</article-title><source>Systematic Biology</source><year>1995</year><volume>44</volume><fpage>251</fpage><lpage>5</lpage></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Wilkinson</surname><given-names>M</given-names></name><name><surname>Cotton</surname><given-names>JA</given-names></name><name><surname>Creevey</surname><given-names>C</given-names></name><etal></etal></person-group><article-title>The shape of supertrees to come: tree shape related properties of fourteen supertree methods</article-title><source>Systematic Biology</source><year>2005</year><volume>54</volume><fpage>419</fpage><lpage>31</lpage><pub-id pub-id-type="pmid">16012108</pub-id></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>D</given-names></name><name><surname>Eulenstein</surname><given-names>O</given-names></name><name><surname>Fernandez-Baca</surname><given-names>D</given-names></name><name><surname>Burleigh</surname><given-names>JG</given-names></name></person-group><article-title>Improved heuristics for minimum-flip supertree construction</article-title><source>Evolutionary Bioinformatics</source><year>2006</year><volume>2</volume><fpage>401</fpage><lpage>410</lpage></citation></ref><ref id="B14"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Bryant</surname><given-names>D</given-names></name></person-group><article-title>Building Trees, Hunting for Trees, and Comparing Trees &#x02013; Theory and Methods in Phylogenetic Analysis</article-title><source>PhD thesis</source><year>1997</year><publisher-name>University of Canterbury</publisher-name></citation></ref><ref id="B15"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Bansal</surname><given-names>M</given-names></name><name><surname>Eulenstein</surname><given-names>O</given-names></name></person-group><article-title>The Gene-Duplication Problem: Near-Linear Time Algorithms for NNI Based Local Searches</article-title><source>Bioinformatics Research and Applications</source><year>2008</year><fpage>14</fpage><lpage>25</lpage></citation></ref><ref id="B16"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Page</surname><given-names>RDM</given-names></name><name><surname>Holmes</surname><given-names>EC</given-names></name></person-group><source>Molecular evolution: a phylogenetic approach</source><year>1998</year><publisher-name>Blackwell Science</publisher-name></citation></ref><ref id="B17"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Semple</surname><given-names>C</given-names></name><name><surname>Steel</surname><given-names>M</given-names></name></person-group><source>Phylogenetics</source><year>2003</year><publisher-name>Oxford University Press</publisher-name></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Guigo</surname><given-names>R</given-names></name><name><surname>Muchnik</surname><given-names>I</given-names></name><name><surname>Smith</surname><given-names>TF</given-names></name></person-group><article-title>Reconstruction of ancient molecular phylogeny</article-title><source>Mol Phylogenet Evol</source><year>1996</year><volume>6</volume><fpage>189</fpage><lpage>213</lpage><pub-id pub-id-type="pmid">8899723</pub-id></citation></ref><ref id="B19"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Page</surname><given-names>RDM</given-names></name><name><surname>Charleston</surname><given-names>M</given-names></name></person-group><article-title>From Gene to organismal phylogeny: reconciled trees and the gene tree/species tree problem</article-title><source>Mol Phylogenet Evol</source><year>1997</year><volume>7</volume><fpage>231</fpage><lpage>240</lpage><pub-id pub-id-type="pmid">9126565</pub-id></citation></ref><ref id="B20"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Page</surname><given-names>RDM</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Gusfield D, Guig&#x000f3; R</surname></name></person-group><article-title>Modified mincut supertrees</article-title><source>International Workshop, Algorithms in Bioinformatics (WABI)</source><year>2002</year><volume>2452</volume><publisher-name>Lecture Notes in Computer Science, Springer Verlag</publisher-name><fpage>300</fpage><lpage>315</lpage></citation></ref><ref id="B21"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Cardillo</surname><given-names>M</given-names></name><name><surname>Bininda-Emonds</surname><given-names>ORP</given-names></name><name><surname>Boakes</surname><given-names>E</given-names></name><name><surname>Purvis</surname><given-names>A</given-names></name></person-group><article-title>A species-level phylogenetic supertree of marsupials</article-title><source>Journal of Zoology</source><year>2004</year><volume>264</volume><fpage>11</fpage><lpage>31</lpage></citation></ref><ref id="B22"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Price</surname><given-names>SA</given-names></name><name><surname>Bininda-Emonds</surname><given-names>ORP</given-names></name><name><surname>Gittleman</surname><given-names>JL</given-names></name></person-group><article-title>A complete phylogeny of the whales, dolphins and even-toed hoofed mammals (Cetartiodactyla)</article-title><source>Biological Reviews</source><year>2005</year><volume>80</volume><fpage>445</fpage><lpage>473</lpage><pub-id pub-id-type="pmid">16094808</pub-id></citation></ref><ref id="B23"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Burleigh</surname><given-names>JG</given-names></name><name><surname>Eulenstein</surname><given-names>O</given-names></name><name><surname>Fernandez-Baca</surname><given-names>D</given-names></name><name><surname>Sanderson</surname><given-names>MJ</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Bininda-Emonds ORP</surname></name></person-group><article-title>MRF supertrees</article-title><source>Phylogenetic supertrees: Combining Information to Reveal the Tree of Life</source><year>2004</year><publisher-name>Dordrecht: Kluwer Academic</publisher-name><fpage>65</fpage><lpage>85</lpage></citation></ref><ref id="B24"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Snir</surname><given-names>S</given-names></name><name><surname>Rao</surname><given-names>S</given-names></name></person-group><article-title>Using Max Cut to Enhance Rooted Trees Consistency</article-title><source>IEEE/ACM Trans Comput Biol Bioinformatics</source><year>2006</year><volume>3</volume><fpage>323</fpage><lpage>333</lpage></citation></ref><ref id="B25"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bruen</surname><given-names>TC</given-names></name><name><surname>Bryant</surname><given-names>D</given-names></name></person-group><article-title>Parsimony via Consensus</article-title><source>Systematic Biology</source><year>2008</year><volume>57</volume><fpage>251</fpage><lpage>256</lpage><pub-id pub-id-type="pmid">18425715</pub-id></citation></ref><ref id="B26"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bininda-Emonds</surname><given-names>ORP</given-names></name><name><surname>Sanderson</surname><given-names>MJ</given-names></name></person-group><article-title>Assessment of the Accuracy of Matrix Representation with Parsimony Analysis Supertree Construction</article-title><source>Systematic Biology</source><year>2001</year><volume>50</volume><fpage>565</fpage><lpage>579</lpage><pub-id pub-id-type="pmid">12116654</pub-id></citation></ref><ref id="B27"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Eulenstein</surname><given-names>O</given-names></name><name><surname>Chen</surname><given-names>D</given-names></name><name><surname>Burleigh</surname><given-names>JG</given-names></name><name><surname>Fernandez-Baca</surname><given-names>D</given-names></name><name><surname>Sanderson</surname><given-names>M</given-names></name></person-group><article-title>Performance of flip supertrees with a heuristic algorithm</article-title><source>Systematic Biology</source><year>2004</year><volume>53</volume><fpage>299</fpage><lpage>308</lpage><pub-id pub-id-type="pmid">15205054</pub-id></citation></ref></ref-list></back></article>