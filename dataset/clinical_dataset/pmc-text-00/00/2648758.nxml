<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208119</article-id><article-id pub-id-type="pmc">2648758</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S2</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S2</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Genome aliquoting with double cut and join</article-title></title-group><contrib-group><contrib id="A1" corresp="yes" contrib-type="author"><name><surname>Warren</surname><given-names>Robert</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>rwarr059@uottawa.ca</email></contrib><contrib id="A2" corresp="yes" contrib-type="author"><name><surname>Sankoff</surname><given-names>David</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>sankoff@uottawa.ca</email></contrib></contrib-group><aff id="I1"><label>1</label>School of Information Technology and Engineering, University of Ottawa, 800 King Edward Avenue, Ottawa, Canada</aff><aff id="I2"><label>2</label>Department of Mathematics and Statistics, University of Ottawa, 585 King Edward Avenue, Ottawa, Canada</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S2</fpage><lpage>S2</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S2"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Warren and Sankoff; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Warren and Sankoff; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Warren               Robert                              rwarr059@uottawa.ca            </dc:author><dc:title>            Genome aliquoting with double cut and join         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S2-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S2&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>The <italic>genome aliquoting probem </italic>is, given an observed genome <italic>A </italic>with <italic>n </italic>copies of each gene, presumed to descend from an <italic>n</italic>-way polyploidization event from an ordinary diploid genome <italic>B</italic>, followed by a history of chromosomal rearrangements, to reconstruct the identity of the original genome <italic>B'</italic>. The idea is to construct <italic>B'</italic>, containing exactly one copy of each gene, so as to minimize the number of rearrangements <italic>d</italic>(<italic>A, B' </italic>&#x02295; <italic>B' </italic>&#x02295; ... &#x02295; <italic>B'</italic>) necessary to convert the observed genome <italic>B' </italic>&#x02295; <italic>B' </italic>&#x02295; ... &#x02295; <italic>B' </italic>into <italic>A</italic>.</p></sec><sec><title>Results</title><p>In this paper we make the first attempt to define and solve the genome aliquoting problem. We present a heuristic algorithm for the problem as well the data from our experiments demonstrating its validity.</p></sec><sec><title>Conclusion</title><p>The heuristic performs well, consistently giving a non-trivial result. The question as to the existence or non-existence of an exact solution to this problem remains open.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>Occasionally, during evolution, a genome <italic>B </italic>will convert into an <italic>n</italic>-fold replicate of itself, creating a <italic>polyploid B </italic>&#x02295; <italic>B </italic>&#x02295; ... &#x02295; <italic>B</italic>, containing <italic>n </italic>identical copies of every gene and every chromosome. Over time, through genome rearrangements, the sets of chromosomes are intermingled and the identity of the original genome is lost. Thus, brewers' yeast descends from an ancient tetraploid and wheat from an ancient hexaploid. Then the <italic>genome aliquoting probem </italic>is, given an observed genome <italic>A </italic>with <italic>n </italic>copies of each gene, to reconstruct the identity of the original genome <italic>B'</italic>.</p><p>The aliquoting problem is a generalization from the <italic>genome halving problem </italic>[<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>], just as polyploidization is a more general process than tetraploidization. High-order polyploids are particularly prevalent in plants. We will illustrate with a data set on hexaploid wheat <italic>n </italic>= 3.</p><p>The <italic>genome halving problem </italic>has been solved several times. The first solution to this problem was published in [<xref ref-type="bibr" rid="B1">1</xref>], which solved this problem with respect to inversion and translocation distance. [<xref ref-type="bibr" rid="B3">3</xref>] corrected a small problem in [<xref ref-type="bibr" rid="B1">1</xref>] with respect to unichromosomal genomes. In [<xref ref-type="bibr" rid="B2">2</xref>] the problem was solved with respect to the inversion, translocation and block interchange distance; an approach that was later refined in [<xref ref-type="bibr" rid="B4">4</xref>]. All of these algorithms are linear time and very efficient and proven to return the most parsimonious solution.</p><p>Until now, there have not been any algorithms to solve the more general genome aliquoting problem. Our algorithm for the genome aliquoting problem is an extension of the genome halving algorithms, primarily the algorithm from [<xref ref-type="bibr" rid="B2">2</xref>], to handle polyploids with three or more copies of every gene.</p><sec><title>Notation</title><p>In this section we introduce our notation for genomes. A gene <italic>a </italic>represents an oriented sequence of DNA whose two <italic>extremities </italic>are its <italic>tail </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S2-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:mover><mml:mi>a</mml:mi><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula> and its <italic>head </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S2-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mover><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula>. The <italic>adjacency </italic>of two consecutive genes <italic>a </italic>and <italic>b </italic>is denoted by an unordered set, either <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S2-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:mo>{</mml:mo><mml:mover><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mi>b</mml:mi><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mi>a</mml:mi><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mi>b</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mi>a</mml:mi><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mi>b</mml:mi><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mi>a</mml:mi><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mi>b</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>, depending on the order and orientation of <italic>a </italic>and <italic>b</italic>.</p><p>An extremity that is not adjacent to any other extremity is called a <italic>telomere </italic>and is represented by a singleton set {<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S2-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mover><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula>} or {<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S2-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:mover><mml:mi>a</mml:mi><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula>}. A <italic>genome </italic>is represented by an unordered set of adjacencies and telomeres such that the head and tail of each gene appear exactly once.</p><p>A <italic>duplicated genome </italic>is a genome with two or more copies of each gene such that the head and the tail of every gene appear exactly <italic>p </italic>&#x02265; 2 times. To differentiate the genes we arbitrarily assign each gene a subscript. Thus, we say that gene <italic>a </italic>is a <italic>unique gene </italic>with <italic>paralogs a</italic><sub>1,</sub><italic>a</italic><sub>2</sub>, ... <italic>a</italic><sub><italic>p </italic></sub>with corresponding <italic>paralogous extremities </italic><inline-formula><inline-graphic xlink:href="1471-2105-10-S1-S2-i4.gif"/></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S2-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula>.</p><p>Without a loss of generality, we say that two adjacencies {<italic>a</italic>, <italic>b</italic>} and {<italic>c</italic>, <italic>d</italic>} are <italic>compatible </italic>if both <italic>a </italic>is paralogous with <italic>c </italic>and <italic>b </italic>is paralogous with <italic>d </italic>or if neither <italic>a </italic>nor <italic>b </italic>is paralogous with either of <italic>c </italic>or <italic>d</italic>. For example, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S2-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S2-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> are compatible but neither is compatible with <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S2-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>4</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> but all three are compatible with <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S2-i9" overflow="scroll"><mml:semantics><mml:mrow><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>4</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. Any two telomeres are always compatible. A telomere and an adjacency are compatible if the telomere's extremity is not paralogous with either of the extremities in the adjacency. We say that a set of adjacencies and telomeres is compatible if no two elements of the set are incompatible.</p><p><bold>Definition 1 </bold><italic>Let A be a duplicated genome. A is </italic>valid <italic>if and only if:</italic></p><p>&#x02022; <italic>If there exists an x and there exists a y such that </italic>{<italic>u</italic><sub><italic>x</italic></sub>, <italic>v</italic><sub><italic>y</italic></sub>} &#x02208; <italic>A and u</italic><sub><italic>x</italic></sub><italic>is not paralogous with v</italic><sub><italic>y</italic></sub><italic>then for all </italic>1 &#x02264; <italic>x </italic>&#x02264; <italic>p there exists a y such that</italic>{<italic>u</italic><sub><italic>x</italic></sub>, <italic>v</italic><sub><italic>y</italic></sub>} &#x02208; <italic>A</italic></p><p>&#x02022; <italic>If there exists an x such that </italic>{<italic>u</italic><sub><italic>x</italic></sub>} &#x02208; <italic>A then for all </italic>1 &#x02264; <italic>x </italic>&#x02264; <italic>p </italic>{<italic>u</italic><sub><italic>x</italic></sub>} &#x02208; <italic>A</italic>.</p><p>A duplicated genome that is valid is a <italic>perfectly duplicated genome </italic>(see Figure <xref ref-type="fig" rid="F1">1b</xref> for an example). Similarly, an invalid duplicated genome is called a <italic>rearranged duplicated genome </italic>(see Figure <xref ref-type="fig" rid="F1">1a</xref> for an example).</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Duplicated genomes</bold>. Two different genomes both with three chromosomes, four unique genes each with three paralogs. (a) The rearranged duplicated genome represented by the unordered set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S2-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:mo>{</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. (b) The perfectly duplicated genome represented by the unordered set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S2-i11" overflow="scroll"><mml:semantics><mml:mrow><mml:mo>{</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x0003e;</mml:mo><mml:mo>&#x02212;</mml:mo></mml:mrow></mml:mover><mml:mo>}</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>.</p></caption><graphic xlink:href="1471-2105-10-S1-S2-1"/></fig><p>We can now define the problem:</p><p><bold>Definition 2 </bold><italic>The </italic>genome aliquoting problem <italic>is defined as follows: given a rearranged duplicated genome A find a perfectly duplicated genome B such that the distance between A and B is minimal with respect to some distance metric</italic>.</p><p>In this paper, the distance metric we will use is the <italic>double cut and join distance</italic>. The <italic>distance </italic>between two genomes is the shortest sequence of rearrangement operations needed to transform a genome <italic>A </italic>into a genome <italic>B</italic>. With double cut and join, the set of rearrangement operations used to compute the distance includes translocations, fusions, fissions, inversions and block interchanges (an approximation of a transposition). Double cut and join was introduced in [<xref ref-type="bibr" rid="B5">5</xref>] and refined later in [<xref ref-type="bibr" rid="B6">6</xref>]. It is the later paper from which we draw the following formal definition of double cut and join:</p><p><bold>Definition 3 </bold><italic>The </italic>double cut and join <italic>operation acts on two adjacencies or telomeres u and v of a genome in one of the following three ways:</italic></p><p>&#x02022; <italic>If both u </italic>= {<italic>p</italic>, <italic>q</italic>}<italic>and v </italic>= {<italic>r</italic>, <italic>s</italic>}<italic>are adjacencies, these are replaced by the two adjacencies </italic>{<italic>p, r</italic>}<italic>and </italic>{<italic>s, q</italic>}<italic>or by the two adjacencies </italic>{<italic>p, s</italic>}<italic>and </italic>{<italic>q, r</italic>}.</p><p>&#x02022; <italic>If u </italic>= {<italic>p</italic>, <italic>q</italic>}<italic>is an adjacency and v </italic>= {<italic>r</italic>}<italic>is a telomere, these are replaced by </italic>{<italic>p, r</italic>}<italic>and </italic>{<italic>q</italic>}<italic>or by </italic>{<italic>q, r</italic>}<italic>and </italic>{<italic>p</italic>}.</p><p>&#x02022; <italic>If both u </italic>= {<italic>q</italic>}<italic>and v </italic>= {<italic>r</italic>}<italic>are telomeres, these are replaced by </italic>{<italic>q, r</italic>}.</p><p><italic>In addition, as an inverse of the last case, a single adjacency </italic>{<italic>q, r</italic>}<italic>can be replaced by two telomeres </italic>{<italic>q</italic>}<italic>and </italic>{<italic>r</italic>}.</p></sec></sec><sec sec-type="methods"><title>Methods</title><p>The pseudocode for the algorithm is given in Figure <xref ref-type="fig" rid="F2">2</xref>. In following sections we breakdown and explain the various steps of the algorithm in detail as well as our implementation of the algorithm.</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Algorthim</bold>. A pseudocode description of the genome aliquoting algorithm.</p></caption><graphic xlink:href="1471-2105-10-S1-S2-2"/></fig><sec><title>Generate natural graphs</title><p>Like when solving the genome halving problem, the first step for the genome aliquoting heuristic is construct a natural graph according to the definition below.</p><p><bold>Definition 4 </bold><italic>Let A be a duplicated genome. A </italic>natural graph <italic>NG</italic>(<italic>V, E</italic>) <italic>is a graph whose vertices V are the adjacencies and telomeres of A and each extremity is connected to all of its paralogous extremties by an edge in the set E</italic>.</p><p>Observe that, with this definition, the vertices have a degree of either <italic>p </italic>- 1 or 2 (<italic>p </italic>- 1) where <italic>p </italic>is the ploidy of the genome. Thus, for the interesting case of <italic>p </italic>&#x02265; 3, every vertex has a degree of at least two (see Figure <xref ref-type="fig" rid="F3">3</xref> for an example). However, essential to genome halving is that every vertex in the natural graph have a degree of at most two.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>Natural graph</bold>. A natural graph describing the genome depicted in Figure 1a. Observe that the genome has a ploidy of 3 and every vertex in the natural graph has a degree of either 2 or 4.</p></caption><graphic xlink:href="1471-2105-10-S1-S2-3"/></fig><p>A graph with a degree of at most two is important for two reasons. Firstly, it allows for the maximum cardinality set of compatible adjacencies and telomeres of the natural graph to be easily computed, as in [<xref ref-type="bibr" rid="B2">2</xref>], or for the double cut and join operation to be applied directly on the graph, as in [<xref ref-type="bibr" rid="B4">4</xref>]. Secondly, it allows for the cycles and paths of the natural graph to be trivially computed.</p><p>Since the heuristic must handle graphs with vertices of degree three or more, it must find this information through some other means. Hence, while the natural graph is still the base of the solution, a great deal of additional work is needed to extract the relevant information from it.</p></sec><sec><title>Generate modified clique graphs</title><p>While many useful properties of the natural graph are obfuscated when the ploidy of the graph is increased to three or more, one property is still very clear: the graph's cliques. Every extremity of the genome corresponds to one clique in the natural graph. Thus, to capitalize on this, we create a clique graph from the natural graph according to the following definition.</p><p><bold>Definition 5 </bold><italic>Let NG</italic>(<italic>V, E</italic>) <italic>be a natural graph constructed from a genome A. A </italic>clique graph <italic>CG</italic>(<italic>V', E'</italic>) <italic>is a graph whose vertices V' are the extremities of A and there exists an edge </italic>{<italic>u, v</italic>} <italic>in the set E' if there exists an adjacency </italic>{<italic>u</italic><sub><italic>x</italic></sub>, <italic>v</italic><sub><italic>y</italic></sub>} <italic>in A where </italic>1 &#x02264; <italic>x, y </italic>&#x02264; <italic>p and p is the ploidy of A</italic>.</p><p>Observant readers may notice that, in order to compute the clique graph, the natural graph is not needed. It is included in the pseudocode and the above section to help stress the link between the genome aliquoting heuristic and genome halving algorithm and to better explain the origin of the clique graphs, but it is not necessary in an actual implementation.</p><p>The clique graph as defined above is not sufficient for our purposes. It is missing the data concerning the telomeres contained in the natural graph. To solve this problem, the algorithm must modify the clique graph by creating null vertices, one for each vertex of the clique graph, and connecting each null vertex to its corresponding non-null vertex by an edge (see Figure <xref ref-type="fig" rid="F4">4</xref>).</p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>Modified clique graph</bold>. A modified clique graph describing the natural graph depicted in Figure 3. The five bold edges represent all the edges that belong to the maximum weight matching of this graph.</p></caption><graphic xlink:href="1471-2105-10-S1-S2-4"/></fig><p>Now, after modifying the clique graph, each edge corresponds to either an adjacency or telomere in the genome. However, it would be useful to know how many adjacencies and telomeres correspond to each edge. The solution is to weight the edges. If the edge corresponds to an adjacency, assign it a weight equal to the number of adjacencies to which it corresponds. If the edge corresponds to a telomere, assign it a weight equal to <italic>half </italic>the number of telomeres to which it corresponds (see Figure <xref ref-type="fig" rid="F4">4</xref>). The reason why telomeres are weighted half as much as adjacencies is because telomeres are weighted half as much as adjacencies when computing the double cut and join distance. Since the objective is compute double cut and join distance directly from the clique graph, it is important to capture this detail.</p><p>Even with all the additional information added to the clique graph some information is still missing. In particular, adjacencies of the form {<italic>u</italic>, <italic>u</italic>} are not considered in this graph. This is intentional. Such information doesn't help in the aliquoting of the graph so the algorithm simply ignores it.</p></sec><sec><title>Compute maximum weight matching</title><p>The process of aliquoting a genome is in theory quite simple. For each extremity simply select one adjacency or telomere from the rearranged duplicated genome and add it to the perfectly duplicated genome, copying it as many times as needed to get the necessary ploidy. The difficulty of finding a parsimonious perfectly duplicated genome lies in the copies. If the copies are not compatible with the selected adjacency or telomere then the distance between the original genome and the constructed genome increases. Thus, any algorithm that endeavors to construct the most parsimonious perfectly duplicated genome must maximize the number of compatible adjacencies and telomeres. Thus, as in the genome halving problem, one important objective of the genome aliquoting problem is to find the maximum cardinality set of compatible adjacencies and telomeres. Using the modified clique graph, it is now possible to do just that.</p><p>Observe that a pair of adjacencies and/or telomeres is compatible if their corresponding edges in the modified clique graph do not share a vertex in common (we say the edges are <italic>independent</italic>) or if they are represented by the same edge. Thus, to find the maximum cardinality set of compatible adjacencies and telomeres the algorithm must find a set of independent edges with maximum weight. Consider the following well-known graph problem:</p><p><bold>Definition 6 </bold><italic>The </italic>maximum weighted matching problem <italic>is defined as follows: find a set of independent edges such that the sum of the weights of the edges is maximum</italic>.</p><p>The maximum weighted matching problems was famously solved by Edmonds in polynomial time [<xref ref-type="bibr" rid="B7">7</xref>]. Thus, it is possible to compute the maximum set of compatible adjacencies and telomeres in polynomial time. Hence, the algorithm has recovered the first piece of data that was obfuscated when the transition to genome with ploidy of three or greater was made (see Figure <xref ref-type="fig" rid="F4">4</xref> for an example).</p></sec><sec><title>Find cycle and paths</title><p>Typically, a single double cut and join operation reduces the distance by one. However, occasionally a double cut and join operation reduces the distance by two instead. In the genome halving problem, it was possible to detect the double cut and join operations that would reduce the distance by two by detecting the <italic>even </italic>cycles (even in terms of number of edges) and <italic>odd </italic>paths in the natural graph. Since the vertices of the clique graph are the edges of the natural graph and the edges of the clique graph are the vertices of the natural graph, an even length cycle in the clique graph corresponds to an even length cycle in the natural graph but an <italic>even </italic>length path in the clique graph corresponds to an <italic>odd </italic>length path in the natural graph. Thus, the genome aliquoting heuristic must find even length cycles and even length paths in the clique graph in order to detect the double cut and join operations that reduce the distance by two.</p><p>When detecting cycles and paths for the genome aliquoting problem there is are two additional details that must be considered over the detecting cycles and path for the genome halving problem. First, unlike the genome halving problem, not every cycle and path is a component of the natural graph. For cycles, this doesn't change anything. But for paths, this means that there is an additional detail that must be considered. For the purposes of the genome aliquoting problem, a path is any path between two telomeres in the natural graph meaning that it is between two null vertices in the modified clique graph (see Figure <xref ref-type="fig" rid="F5">5</xref>).</p><fig position="float" id="F5"><label>Figure 5</label><caption><p><bold>Re-weighted modified clique graph</bold>. A modified clique graph depicted in Figure 4, after it has been re-weighted for cycle and path detection. Red edges and vertices represent the edges and vertices along an even length alternating path. Blue edges and vertices represent the edges and vertices along an even length alternating cycle. As can be seen from the figure, this graph has exactly one even alternating cycle and exactly one even alternating path each with a flow of 1.</p></caption><graphic xlink:href="1471-2105-10-S1-S2-5"/></fig><p>Secondly, an edge in the clique graph may correspond to several edges in the natural graph. In the clique graph this is represented by the weights of the edges. Thus, it is important to account for the weights when detecting cycles and paths.</p><p>Because the task has changed from finding the matching to finding the cycles and paths the weights of the clique graph need to be modified slightly as well. In order to understand why and how to modify the edges, it is important to understand what both the matching and the cycles and paths represent.</p><p>In the genome aliquoting problem, the goal is to <italic>construct </italic>another genome that minimizes the distance. Thus, the algorithm must build a genome in such a way that the fewest number of double cut and join operations need to be performed. Another way of looking at it is that we are "pre-performing" double cut and join operations; any double cut and join operation that the algorithm can legally perform at this stage is one fewer double cut and join operation that it must perform later. The edges of the matching, and their corresponding edge weights, indicate the double cut and join operations that can be legally performed during the creation of the genome, <italic>i.e. </italic>they indicate the double cut and join operations that need <italic>not </italic>be performed when computing the distance.</p><p>When computing the cycles and paths, the algorithm is no longer "pre-performing" double cut and join operations. Rather, the algorithm is attempting to predict the double cut and join operations that will be performed when computing the distance between the original genome and the constructed genome. Thus, while the weights of unmatched edges are still correct as the extremities represented by those edge will need to be moved when the distance is computed, the weights of the matched edges are not correct as the double cut and join operation indicated by those weights will have already have been performed.</p><p>Therefore, the algorithm must change the weights of the matched edges to reflect the situation during the calculation of the distance.</p><p>So what, if anything, do the matched edges represent while the distance is being computed? The matched edges represent the final state of two extremities; the extremities that correspond to the vertices that the edge connects. The current weight of the matched edge indicates how many of the pairs of extremities have reached that final state. Therefore, the complement of that weight indicates how many pairs of extremities have not yet reached that final state. Hence, if <italic>p </italic>is the ploidy of the graph and <italic>w</italic>(<italic>e</italic>) is the weight of a matched edge <italic>e</italic>, then <italic>w</italic>(<italic>e</italic>) = <italic>p </italic>- <italic>w</italic>(<italic>e</italic>).</p><p>Unfortunately, there is a complication when it comes to re-weighting the graph. In the original weighting scheme, the weights of edges connected to a null vertex where weighted half as much as those connect to two non-null vertices. The algorithm needs to re-weight the edges to be on par with the others. Hence, if <italic>e </italic>is a matched edge connected to a null vertex then its weight should be <italic>w</italic>(<italic>e</italic>) = <italic>p </italic>- 2&#x000b7;<italic>w</italic>(<italic>e</italic>) and if <italic>e </italic>is an <italic>unmatched </italic>edge connected to a null vertex then its weight should be <italic>w</italic>(<italic>e</italic>) = 2&#x000b7;<italic>w</italic>(<italic>e</italic>). See Figure <xref ref-type="fig" rid="F5">5</xref> for an example on how to re-weight the graph.</p><p>Once the algorithm has updated the weights to reflect the change in objective how do the weights factor into the detection of cycles and paths? It is easy to see that each weight represents an upper bound on some kind of resource. The matched edges represent an upper bound on the double cut and join operations used in computing the distance and the unmatched edges represent an upper bound on the resources available to the double cut and join operations, <italic>i.e. </italic>the extremities. Thus, matched and unmatched edges, each in a different way, represent an upper bound on the number of double cut and join operations.</p><p>In the genome halving problem, any sequence of double cut and join operations that form an even cycle or an even path produces an extra double cut and join operation. It is the same for the genome aliquoting problem except that a cycle or path may represent multiple sequence of double cut and join operations and, hence, multiple extra double cut and join operations. As each edge represents an upper bound on the number of double cut and join operations that can act on that edge, the number of sequences of double cut and join operations is the smallest edge weight on the even cycle or even path. Therefore, it is the <italic>flow </italic>of the even cycle or even path that the algorithm must compute.</p><p>There is another factor that the algorithm must account for when choosing cycles and paths: they must <italic>alternate </italic>between matched and unmatched edges. As mentioned before, matched edges represent the double cut and join operations and unmatched edges represent the extremities used in those double cut and join operations, thus, both are needed. By alternating between matched and unmatched edges, we learn which extremities must be matched to which double cut and join operations in order to produce an extra double cut and join operation.</p><p>The authors of this paper make no assertion about the best method to determine the cycles and paths other than that any implementation of this algorithm should make an effort to maximize the number of cycles, and their flow, and the number of paths and their flow. Ideally this should be done in one step, but, as this is a heuristic, doing it in two steps (finding cycles followed by path or <italic>visa versa</italic>) is possible but with a potential lose in accuracy. Unfortunately, because of the simplicity of the later method, it is the method that we use in our implementation (see section Implementation below).</p><p>Create genome</p><p>At this stage it is now possible to construct a perfectly duplicated genome. As both the genome and the maximum cardinality set of compatible adjacencies and telomeres are sets of adjacencies and telomeres, the maximum cardinality set of compatible adjacencies and telomeres can be used to immediately create part of the perfectly duplicated genome as depicted in Figure <xref ref-type="fig" rid="F6">6</xref>.</p><fig position="float" id="F6"><label>Figure 6</label><caption><p><bold>Compatible set</bold>. A partially aliquoted genome derive from the maximum cardinality set of compatible adjacencies and telomeres that was derived from the matching depicted in Figure 4.</p></caption><graphic xlink:href="1471-2105-10-S1-S2-6"/></fig><p>For the remaining adjacencies and telomeres of the perfectly duplicated genome, the matched edges that are connected to two non-null vertices indicate the adjacencies and those that are connected to only one non-null vertex indicate the telomeres. However, pairing these extremities alone does not guarantee a good aliquoting. In some cases it is important to know the subscripts of the extremities to be paired.</p><p>To get this additional information, the algorithm must <italic>join along </italic>the cycles and paths that it detected (see Figure <xref ref-type="fig" rid="F7">7</xref>). To do this, take the two adjacencies represented by two unmatched edges along a cycle or path (one adjacency from each unmatched edge) and use their adjacent matched edge as a template to join them. For example, assume without a loss of generality let {<italic>a</italic>, <italic>b</italic>} be a matched edge along one of the detected cycles. This edge will be adjacent to two unmatched edges. Each unmatched edge will represent some adjacencies in the original genome, say {<italic>c</italic><sub><italic>x</italic></sub>, <italic>a</italic><sub><italic>y</italic></sub>} and {<italic>b</italic><sub><italic>z</italic></sub>, <italic>d</italic><sub><italic>w</italic></sub>}. To join along the cycle the algorithm adds the overlap between the matched edge and its adjacent unmatched edges to the constructed genome, hence it adds {<italic>a</italic><sub><italic>y</italic></sub>, <italic>b</italic><sub><italic>z</italic></sub>}.</p><fig position="float" id="F7"><label>Figure 7</label><caption><p><bold>Joining along the paths and cycles</bold>. A partially aliquoted genome derived from the path and cycle depicted in Figure 5.</p></caption><graphic xlink:href="1471-2105-10-S1-S2-7"/></fig><p>When it comes to paths there are two exceptions to the above rule as there will be two edges in the path that are connected to a null vertex, one matched edge and one unmatched edge. Recall that null vertices correspond to telomeres. Consider the unmatched edge a telomere for the purpose of joining along the path. Since it will overlap with its neighboring matched genome, there is no other difference. As for the matched edge, the algorithm should simply ignore it.</p><p>After joining along the cycles and paths, it is possible to combine that result with the maximum cardinality set of adjacencies and telomeres to create the genome. Figure <xref ref-type="fig" rid="F8">8</xref> is an example of this. However, while creating the genome there may be some ambiguity. For example, if a cycle or path has a flow of two then there will be two possible extremities that could be joined at each edge. Another common occurrence of ambiguity is the case where some extremities are neither part of the maximum cardinality set of adjacencies and telomeres nor are they identified while joining along the cycles and paths.</p><fig position="float" id="F8"><label>Figure 8</label><caption><p><bold>A perfectly duplicated genome</bold>. A perfectly duplicated genome created by combining the partially aliquoted genomes in Figures 6 and 7. In this particular case, no random joinings were needed to complete the genome.</p></caption><graphic xlink:href="1471-2105-10-S1-S2-8"/></fig><p>All cases of ambiguity are resolved in the same manner: arbitrarily combining the extremities. In experiments arbitrarily combining the ambiguous extremities never increased or decreased the distance. In fact, we conjecture that it can be proven that it never will.</p></sec><sec><title>Implementation</title><p>Our implementation of the heuristic follows the pseudo-code above fairly closely. Detecting the cycles and paths are performed independently, with the cycles being detected first since they are usually a greater contributer to reducing the distance.</p><p>We use an implementation of the Edmonds algorithm to exactly compute the maximum weight matching problem [<xref ref-type="bibr" rid="B7">7</xref>] as well as a slightly modified implementation of the Edmonds-Karp maximum flow algorithm [<xref ref-type="bibr" rid="B8">8</xref>] to find the flow of the alternating even paths.</p><p>For the alternating even cycles, we use a greedy heuristic that simply tries to find the smallest cycles (in terms of number of edges) in hopes that this will produce the least conflict and therefore the maximum flow. Detecting the cycles is the only heuristic used in our heuristic but even if we had used an exact algorithm for this step our algorithm would still only be a heuristic.</p><p>Our implementation of the heuristic runs in time polynomial to the number of genes in the genome. It performs extremely quickly requiring very large genomes to produce any kind of noticeable slowdown.</p></sec></sec><sec><title>Results and Discussion</title><p>To test the heuristic, we ran it on some simulated data. Unfortunately, it is impossible to generate a genome with a known rearrangement distance. Thus, we generated genomes that were small enough that we could retrieve the exact result using a brute force algorithm. We performed tests on seven types of genomes: hexaploids (three copies of each gene) with two, three and four genes and octoploids (four copies of each gene) with two and three genes. We randomly generated 25 examples of each of the seven types of genomes and ran both our heuristic and a brute force algorithm and compared the solutions.</p><p>We divide the results from our experiment into four categories: exact, minor inexact, major inexact and error. The category exact means that our algorithm got the same result (in terms of distance) as the brute force algorithm.</p><p>We can trivially assume that the distance must be less than or equal to <italic>n</italic>&#x000b7;(1 - <italic>p</italic>) where <italic>p </italic>is the ploidy of the genome and <italic>n </italic>is the number of genes. Thus, a minor inexact result means that our algorithm did better than the trivial case but worse than the brute force algorithm.</p><p>There are two types of major inexact results. The first is the case where the heuristic produced a distance that was <italic>lower </italic>than the lowest possible result (the result of the brute force algorithm). In Table <xref ref-type="table" rid="T1">1</xref>, this type of major inexact result is indicated by the number before the slash. The second is the case where the heuristic produced a distance that was equal to the trivial case and this was not the best result (<italic>i.e. </italic>the brute force algorithm returned a lower result). In Table <xref ref-type="table" rid="T1">1</xref>, this is indicated by the number after the slash. The heuristic never returned a result that was worse than the trivial result.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Heuristic/brute force comparison. The results of our experiment comparing our heuristic to a brute force algorithm.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Test Case</td><td align="center">Exact</td><td align="center">Minor Inexact</td><td align="center">Major Inexact</td><td align="center">Error</td></tr></thead><tbody><tr><td align="left" colspan="5"><bold>Hexaploid</bold></td></tr><tr><td align="left">2 genes</td><td align="center">19(16)</td><td align="center">2</td><td align="center">3(0)/1</td><td align="center">6</td></tr><tr><td align="left">3 genes</td><td align="center">9(6)</td><td align="center">11(9)</td><td align="center">1(0)/4</td><td align="center">6</td></tr><tr><td align="left">4 genes</td><td align="center">5(3)</td><td align="center">17(14)</td><td align="center">2(0)/1</td><td align="center">7</td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="left" colspan="5"><bold>Octaploid</bold></td></tr><tr><td align="left">2 genes</td><td align="center">14(12)</td><td align="center">9(7)</td><td align="center">1(0)/1</td><td align="center">5</td></tr><tr><td align="left">3 genes</td><td align="center">6(4)</td><td align="center">16(12)</td><td align="center">2(0)/1(0)</td><td align="center">9</td></tr><tr><td align="left">TOTAL</td><td align="center">53(41)</td><td align="center">55(44)</td><td align="center">9(0)/8(7)</td><td align="center">33</td></tr></tbody></table></table-wrap><p>The final category, error, indicates the number of times that the algorithm returned a genome that was not properly aliquoted. Any result in this category always occurs in conjunction with a result from another category. Thus, if we consider all the error results to be "contaminated" and unusable, we indicate what the actual result for each of the other categories would be in parenthesizes.</p><p>Since the first test of the heuristic could only be conducted on smaller genomes, we conducted a second test of the heuristic on larger genomes but without the brute force algorithm. We compared the results of this second test with the trivial case to indicate that our heuristic returns a non-trivial result. This time, not only did we aliquote hexaploids and octaploids, but also larger polyploids, specifically decaploids (five copies of every gene) and icosaploids (10 copies of every gene). We also studied our algorithm on genomes with more genes, starting at 40 genes in the smallest case and 100 genes in the largest. Again we attempted our algorithm on 25 randomly generated examples of each genome.</p><p>For this set of experiments we simple checked to see if the heuristic returned a distance less than, equal to, or greater than the trivial case. Additionally, we checked to make sure that the genome was properly aliquoted. The results of this experiment are listed in Table <xref ref-type="table" rid="T2">2</xref>.</p><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Heuristic on large genomes. The results of our experiment testing the performance of the heuristic on large genomes.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Test Case</td><td align="center">Less Than</td><td align="center">Equal To</td><td align="center">Greater Than</td><td align="center">Error</td></tr></thead><tbody><tr><td align="left" colspan="5"><bold>Hexaploid</bold></td></tr><tr><td align="left">40 genes</td><td align="center">25(19)</td><td align="center">0</td><td align="center">0</td><td align="center">6</td></tr><tr><td align="left">60 genes</td><td align="center">25(18)</td><td align="center">0</td><td align="center">0</td><td align="center">7</td></tr><tr><td align="left">80 genes</td><td align="center">25(19)</td><td align="center">0</td><td align="center">0</td><td align="center">6</td></tr><tr><td align="left">100 genes</td><td align="center">25(19)</td><td align="center">0</td><td align="center">0</td><td align="center">6</td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="left" colspan="5"><bold>Octaploid</bold></td></tr><tr><td align="left">40 genes</td><td align="center">25(19)</td><td align="center">0</td><td align="center">0</td><td align="center">6</td></tr><tr><td align="left">60 genes</td><td align="center">25(19)</td><td align="center">0</td><td align="center">0</td><td align="center">6</td></tr><tr><td align="left">80 genes</td><td align="center">25(20)</td><td align="center">0</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="left">100 genes</td><td align="center">25(22)</td><td align="center">0</td><td align="center">0</td><td align="center">3</td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="left" colspan="5"><bold>Decaploid</bold></td></tr><tr><td align="left">40 genes</td><td align="center">25(17)</td><td align="center">0</td><td align="center">0</td><td align="center">8</td></tr><tr><td align="left">60 genes</td><td align="center">25(22)</td><td align="center">0</td><td align="center">0</td><td align="center">3</td></tr><tr><td align="left">80 genes</td><td align="center">25(20)</td><td align="center">0</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="left">100 genes</td><td align="center">25(19)</td><td align="center">0</td><td align="center">0</td><td align="center">6</td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="left" colspan="5"><bold>Icosaploid</bold></td></tr><tr><td align="left">40 genes</td><td align="center">25(22)</td><td align="center">0</td><td align="center">0</td><td align="center">3</td></tr><tr><td align="left">60 genes</td><td align="center">25(23)</td><td align="center">0</td><td align="center">0</td><td align="center">2</td></tr><tr><td align="left">80 genes</td><td align="center">25(24)</td><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="left">100 genes</td><td align="center">25(23)</td><td align="center">0</td><td align="center">0</td><td align="center">2</td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="left">TOTAL</td><td align="center">400(325)</td><td align="center">0</td><td align="center">0</td><td align="center">75</td></tr></tbody></table></table-wrap><p>Finally, we decided to test our algorithm on real, rather than simulated, data. We applied our heuristic to the hexaploid wheat that we retrieved from the Gramene database [<xref ref-type="bibr" rid="B9">9</xref>]. Note that after <italic>p</italic>-ploidization, many of the gene families thus created are reduced by the various processes of gene loss. Eventually, after a long time has elapsed, very few of the genes will have retained <italic>p </italic>copies. Thus, in the wheat data we could only identify 92 gene families with three members. On this input, our heuristic returned an aliquoted genome with a distance of 138 but with one incorrectly aliquoted chromosome. Correcting that chromosome would produce an aliquoted genome with a distance of 139, well below the trivial distance of 184. The corrected result had a total of 45 chromosomes of which 3 were circular.</p><p>There are several interesting results from the experiments. Let's begin by examine the negatives.</p><p>21% of the time, the heuristic returned an improperly aliquoted genome. On the smaller genomes this was higher (26%) whereas on the larger genomes this was lower (19%). The reason why the algorithm gives improperly aliquoted genomes goes back the genome halving papers.</p><p>In [<xref ref-type="bibr" rid="B1">1</xref>], it was stated that, if <italic>C</italic><sub>1 </sub>and <italic>C</italic><sub>2 </sub>were two identical chromosomes, then a circular unichromosomal genome where <italic>C</italic><sub>1 </sub>and <italic>C</italic><sub>2 </sub>are concatenated together at both end points can be considered an acceptable halving. When double cut and join was introduced, it was considered desirable to allow circular chromosomes so an effort was made to generalize this statement. In the first attempt, in [<xref ref-type="bibr" rid="B2">2</xref>], any concatenation of two halved chromosomes, with one or both endpoints, in either a unichromosomal or multi-chromosomal setting was considered acceptable. [<xref ref-type="bibr" rid="B4">4</xref>] modified this definition by adding the restriction that both endpoints needed to be joined.</p><p>In our genome aliquoting heuristic, we used the definition from [<xref ref-type="bibr" rid="B4">4</xref>]. However, even though this definition is more restrictive than [<xref ref-type="bibr" rid="B2">2</xref>], it creates a problem in the generalized aliquoting case (not in the halving case). To see the problem consider a hexaploid with three aliquoted chromosomes <italic>C</italic><sub>1</sub>, <italic>C</italic><sub>2 </sub>and <italic>C</italic><sub>3</sub>. The problem is that, because we have more than two parts, it might occur that <italic>C</italic><sub>1 </sub>and <italic>C</italic><sub>2 </sub>concatenate to form <italic>C</italic><sub>1</sub><italic>C</italic><sub>2 </sub>but <italic>C</italic><sub>3 </sub>does not join that concatenation. This is an improperly aliquoted genome, but, so long as all the chromosomes are circular, it is a proper aliquoting according the definition of valid. Hence, the heurisitic accepts it. All the errors listed above are genomes of this form.</p><p>However, this error is not particularly severe as it is easy to detect and it is easy to correct. For each problem case that occurs it will take at most two double cut and join operations to correct so we can simply increase the distance by that amount. This becomes particularly important when we consider the second major problem with our algorithm, the "better than optimal" results that where produced in some cases.</p><p>As we can see from Table <xref ref-type="table" rid="T1">1</xref>, the "better than optimal" results only occur in conjunction with an invalid aliquoting. The increase in distance that comes from correcting such an aliquoting will invariably also correct the distance, although it may not yield the exactly optimal distance (it might be slightly worse).</p><p>However, perhaps the most serious problem is that indicated on Table <xref ref-type="table" rid="T1">1</xref>, in the row "Octoploid with 3 genes" and the column "Major Inexact". The result after the slash indicates a case where the heuristic produces a trivial result and an incorrectly aliquoted genome at the same time. This means that it is possible for the heuristic to produce an incorrectly aliquoted genome that cannot be fixed. Fortunately, this seems to be an unlikely occurrence, especially on larger genomes.</p><p>There are, however, many positive attributes of the heuristics as well. As seems to be indicated by the case of icosaploids, the number of incorrect aliquotings seem to go down on very large genes. This is likely because the heuristic has a bias towards selecting adjacencies in the original genome that tend to produce circular chromosomes. But, with a larger genome the heuristic will select more telomeres and, thus, produce more linear chromosomes. Even selecting few telomeres in proportion to the number adjacencies seems to dramatically reduce the number of circular chromosomes. And, since the improper aliquoting only occurs with circular chromosomes, the chance of an improper aliquoting occuring is reduced.</p><p>Additionally, we can see that, on larger genomes, the heuristic performs better than the trivial case. In these cases the heuristic tended to give a distance that was about 15% lower than the trivial case. Finally, at least on the smaller genomes, we can clearly see that most of the time the heuristic gave a good result. 33% of the results are the correct answer without any error and another 35% of the results have a better than trivial answer without any error. We can also see that in most of the cases where there was an error it could be corrected for and the result would still be better than trivial.</p></sec><sec><title>Conclusion</title><p>From the results we can conclude that the algorithm seems to perform very well as a heuristic for the genome aliquoting problem. We have shown that in small cases, the algorithm performs very close to optimal and, while it is easy to imagine that the error ratio increases as the genome gets larger the algorithm never-the-less continues to perform significantly better than any trivial case.</p><p>While the heuristic has been known to occasionally produce a genome with a "better than optimal" distance, this is always the product of an improperly aliquoted genome, and, thus, it is easy to detect and fix. Furthermore, fixing such a genome will also correct the distance. Thus, users concerned about such a result can easily implement a post-processing step that tests for this problem and corrects it when found.</p><p>Thus, we conclude that the algorithm produces a reasonably parsimonious solution for any instance of the genome aliquoting problem.</p><p>There are a number of improvements that can be done on this heuristic. A better method for detecting cycles and paths and maximizing their flow is needed. Ideally, such a method should be able to detect both cycles and paths simultaneously and it should produce an exact result.</p><p>Additionally, a better definition of validity is needed. Because we wanted to include circular chromosomes, the definiton from [<xref ref-type="bibr" rid="B4">4</xref>] was used. However, by allowing certain types of circular chromosomes the problem of "better than optimal" solutions was introduced. The El-Mabrouk and Sankoff definition [<xref ref-type="bibr" rid="B1">1</xref>] would eliminate circular chromosomes and, therefore, this problem.</p><p>Finally, perhaps the most important objective for future work is to examine the possible existence of an exact algorithm. Given how close this problem is to the median problem [<xref ref-type="bibr" rid="B10">10</xref>], it may be that his problem is NP-complete [<xref ref-type="bibr" rid="B11">11</xref>]. On the other hand, given how well this heuristic performs it may be that a polynomial time algorithm exists. We conjecture that if the above improvements to the heuristic can be made and that an algorithm can be found that finds the maximum weight matching and the cycle flow and path flow all at the same time then the algorithm will return an exact solution.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>RW devised the algorithms and did the mathematical analysis. He also drafted the paper. DS contributed to the research strategy, participated in discussions throughout the research and revised the manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>We thank Qian Zhu for providing us with the wheat data as well as Wei Xu and Maryam Haghighi for their helpful discussion. Research supported in part by a grant to David Sankoff from the Natural Sciences and Engineering Research Council of Canada (NSERC). David Sankoff holds the Canada Research Chair in Mathematical Genomics and is a Fellow of the Royal Society of Canada.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>El-Mabrouk</surname><given-names>N</given-names></name><name><surname>Sankoff</surname><given-names>D</given-names></name></person-group><article-title>The reconstruction of doubled genomes</article-title><source>SIAM Journal on Computing</source><year>2003</year><volume>32</volume><fpage>754</fpage><lpage>792</lpage></citation></ref><ref id="B2"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Warren</surname><given-names>R</given-names></name><name><surname>Sankoff</surname><given-names>D</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Brazma A, Miyano S, Akutsu T</surname></name></person-group><article-title>Genome halving with double cut and join</article-title><source>Proceedings of the 6th Asia-Pacific Bioinformatics Conference, of Advances in Bioinformatics and Computational Biology</source><year>2008</year><volume>6</volume><publisher-name>Imperial College Press</publisher-name><fpage>231</fpage><lpage>240</lpage></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Alekseyev</surname><given-names>MA</given-names></name><name><surname>Pevzner</surname><given-names>PA</given-names></name></person-group><article-title>Whole genome duplications and contracted breakpoint graphs</article-title><source>SIAM Journal on Computing</source><year>2007</year><volume>36</volume><fpage>1748</fpage><lpage>1763</lpage></citation></ref><ref id="B4"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Mixtacki</surname><given-names>J</given-names></name></person-group><article-title>Genome halving under DCJ revisited</article-title><source>Proceedings of the 14th Annual International Computing and Combinatorics Conference</source><year>2008</year></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Yancopoulos</surname><given-names>S</given-names></name><name><surname>Attie</surname><given-names>O</given-names></name><name><surname>Friedberg</surname><given-names>R</given-names></name></person-group><article-title>Efficient sorting of genomic permutations by translocation, inversion, and block interchange</article-title><source>Bioinformatics</source><year>2005</year><volume>21</volume><fpage>3340</fpage><lpage>3346</lpage><pub-id pub-id-type="pmid">15951307</pub-id></citation></ref><ref id="B6"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Bergeron</surname><given-names>A</given-names></name><name><surname>Mixtacki</surname><given-names>J</given-names></name><name><surname>Stoye</surname><given-names>J</given-names></name></person-group><person-group person-group-type="editor"><name><surname>B&#x000fc;cher P, Moret BM</surname></name></person-group><article-title>A unifying view of genome rearrangements</article-title><source>Algorithms in Bioinformatics: 6th International Workshop, of Lecture Notes in Computer Science</source><year>2006</year><volume>4175</volume><publisher-name>Berlin, Heidelberg: Springer-Verlag</publisher-name><fpage>163</fpage><lpage>173</lpage></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Edmonds</surname><given-names>J</given-names></name></person-group><article-title>Paths, trees and flowers</article-title><source>Canadian Journal of Mathematics</source><year>1965</year><volume>17</volume><fpage>449</fpage><lpage>467</lpage></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Edmonds</surname><given-names>J</given-names></name><name><surname>Karp</surname><given-names>RM</given-names></name></person-group><article-title>Theoretical improvements in algorithmic efficiency for network flow problems</article-title><source>Journal of the ACM</source><year>1972</year><volume>19</volume><fpage>248</fpage><lpage>264</lpage></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ware</surname><given-names>D</given-names></name><name><surname>Jaiswal</surname><given-names>P</given-names></name><name><surname>Ni</surname><given-names>J</given-names></name><name><surname>Pan</surname><given-names>X</given-names></name><name><surname>Chang</surname><given-names>K</given-names></name><name><surname>Clark</surname><given-names>K</given-names></name><name><surname>Teytelman</surname><given-names>L</given-names></name><name><surname>Schmidt</surname><given-names>S</given-names></name><name><surname>Zhao</surname><given-names>W</given-names></name><name><surname>Cartinhour</surname><given-names>S</given-names></name><name><surname>McCouch</surname><given-names>S</given-names></name><name><surname>Stein</surname><given-names>L</given-names></name></person-group><article-title>Gramene: a resource for comparative grass genomics</article-title><source>Nucleic Acids Research</source><year>2002</year><volume>30</volume><fpage>103</fpage><lpage>105</lpage><pub-id pub-id-type="pmid">11752266</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sankoff</surname><given-names>D</given-names></name><name><surname>Blanchette</surname><given-names>M</given-names></name></person-group><article-title>Multiple genome rearrangement and breakpoint phylogeny</article-title><source>Journal of Computational Biology</source><year>1998</year><volume>5</volume><fpage>555</fpage><lpage>570</lpage><pub-id pub-id-type="pmid">9773350</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Caprara</surname><given-names>A</given-names></name></person-group><article-title>The reversal median problem</article-title><source>INFORMS Journal on Computing</source><year>2003</year><volume>15</volume></citation></ref></ref-list></back></article>