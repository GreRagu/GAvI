<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article" xml:lang="EN"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Front Neuroinformatics</journal-id><journal-id journal-id-type="publisher-id">Front. Neuroinform.</journal-id><journal-title>Frontiers in Neuroinformatics</journal-title><issn pub-type="epub">1662-5196</issn><publisher><publisher-name>Frontiers Research Foundation</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19198661</article-id><article-id pub-id-type="pmc">2636686</article-id><article-id pub-id-type="doi">10.3389/neuro.11.001.2009</article-id><article-categories><subj-group subj-group-type="heading"><subject>Neuroscience</subject><subj-group><subject>Original Research</subject></subj-group></subj-group></article-categories><title-group><article-title>NEURON and Python</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Hines</surname><given-names>Michael L.</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author"><name><surname>Davison</surname><given-names>Andrew P.</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="author-notes" rid="fn001">*</xref></contrib><contrib contrib-type="author"><name><surname>Muller</surname><given-names>Eilif</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref></contrib></contrib-group><aff id="aff1"><sup>1</sup><institution>Computer Science, Yale University</institution><country>New Haven, CT, USA</country></aff><aff id="aff2"><sup>2</sup><institution>Unit&#x000e9; de Neurosciences Int&#x000e9;gratives et Computationelles, CNRS</institution><country>Gif sur Yvette, France</country></aff><aff id="aff3"><sup>3</sup><institution>Laboratory for Computational Neuroscience, Ecole Polytechnique F&#x000e9;d&#x000e9;rale de Lausanne</institution><country>Switzerland</country></aff><author-notes><fn fn-type="edited-by"><p>Edited by: Rolf K&#x000f6;tter, Radboud University, Nijmegen, The Netherlands</p></fn><fn fn-type="edited-by"><p>Reviewed by: Felix Sch&#x000fc;rmann, Ecole Polytechnique F&#x000e9;d&#x000e9;rale de Lausanne, Switzerland; Volker Steuber, University of Hertfordshire, UK; Arnd Roth, University College London, UK</p></fn><corresp id="fn001">*Correspondence: Andrew Davison, UNIC, B&#x000e2;t. 32/33, CNRS, 1 Avenue de la Terrasse, 91198 Gif sur Yvette, France. e-mail: <email>andrew.davison@unic.cnrs-gif.fr</email></corresp></author-notes><pub-date pub-type="epreprint"><day>21</day><month>10</month><year>2008</year></pub-date><pub-date pub-type="epub"><day>28</day><month>1</month><year>2009</year></pub-date><pub-date pub-type="collection"><year>2009</year></pub-date><volume>3</volume><elocation-id>1</elocation-id><history><date date-type="received"><day>24</day><month>9</month><year>2008</year></date><date date-type="accepted"><day>05</day><month>1</month><year>2009</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2009 Hines, Davison and Muller.</copyright-statement><copyright-year>2009</copyright-year><license license-type="open-access" xlink:href="http://www.frontiersin.org/licenseagreement"><p>This is an open-access article subject to an exclusive license agreement between the authors and the Frontiers Research Foundation, which permits unrestricted use, distribution, and reproduction in any medium, provided the original authors and source are credited.</p></license></permissions><abstract><p>The NEURON simulation program now allows Python to be used, alone or in combination with NEURON's traditional Hoc interpreter. Adding Python to NEURON has the immediate benefit of making available a very extensive suite of analysis tools written for engineering and science. It also catalyzes NEURON software development by offering users a modern programming tool that is recognized for its flexibility and power to create and maintain complex programs. At the same time, nothing is lost because all existing models written in Hoc, including graphical user interface tools, continue to work without change and are also available within the Python context. An example of the benefits of Python availability is the use of the <monospace>xml</monospace> module in implementing NEURON's Import3D and CellBuild tools to read MorphML and NeuroML model specifications.</p></abstract><kwd-group><kwd>Python</kwd><kwd>simulation environment</kwd><kwd>computational neuroscience</kwd></kwd-group><counts><fig-count count="3"/><table-count count="1"/><equation-count count="0"/><ref-count count="18"/><page-count count="12"/><word-count count="7111"/></counts></article-meta></front><body><sec sec-type="introduction"><title>Introduction</title><p>The NEURON simulation environment has become widely used in the field of computational neuroscience, with more than 700 papers reporting work employing it as of April, 2008. In large part this is because of its flexibility and the fact that it is continually being extended to meet the evolving research needs of its user community. Experience shows that most of these needs have a software solution that has already been implemented elsewhere in the domain of scientific computing. The problem is one of interfacing an existing package with NEURON's interpreter. Some cases demand intimate knowledge of NEURON's internals and considerable effort; examples include network parallelization with MPI, and adoption of Sundials for adaptive integration. There are many more cases in which existing packages could potentially be employed by NEURON users. Few people, however, have the specialized expertise required to manually interface an existing software package and the creation of such interfaces is tedious. Instead of laborious piecemeal adoption of individual packages that requires intervention by a handful of experts, a better approach is to offer Python as an alternative interpreter so that a huge number of resources becomes available at the cost of only minimal interface code that most users can write for themselves.</p><p>Since 1984, the NEURON simulation environment has used the Hoc interpreter (Kernighan and Pike, <xref ref-type="bibr" rid="B15">1984</xref>) for setup and control of neural simulations. Hoc has a syntax for expressions and control flow vaguely similar to the C language. Hoc is not exactly an interpreted language since, analogous to Pascal, Java, or Python, Hoc statements are first dynamically compiled to an internal stack machine representation using a <monospace>yacc</monospace> parser and then the stack machine statements are executed. A fundamental extension to Hoc syntax was made in the late 80's in order to represent the notion of continuous cables, called sections. Sections are connected to form a tree shaped structure and their principle purpose is to allow the user to specify the physical properties of a neuron without regard for the purely numerical issue of how many compartments are used to represent each of the cable sections. In the early 90's, Hoc syntax was again extended to provide some limited support for classes and objects, that is, data encapsulation and polymorphism, but not inheritance.</p><p>Though Hoc has served well, continuing development and maintenance of a general programming language steals significant time and effort from neurobiology domain-specific improvements. Furthermore, Hoc has turned out to be an orphan language limited to NEURON users. What is desirable is a modern programming language such as Python, which provides expressive syntax, powerful debugging capabilities, and support for modularity, facilitating the construction and maintenance of complex programs. Python has proved its utility by giving rise to a large and diverse community of software developers who are making reusable tools that are easy to plug-in to the user's code, the so-called &#x0201c;batteries included&#x0201d; (Dubois, <xref ref-type="bibr" rid="B6">2007</xref>). In the domain of scientific computing, some examples include Numpy (Oliphant, <xref ref-type="bibr" rid="B17">2007</xref>) and Scipy (Jones et al., <xref ref-type="bibr" rid="B14">2001</xref>) for core scientific functionality, Matplotlib (Hunter, <xref ref-type="bibr" rid="B13">2007</xref>) for 2-D plotting, and IPython (Prez and Granger, <xref ref-type="bibr" rid="B18">2007</xref>) for a convenient interactive environment.</p><p>There are three distinct ways to use NEURON with Python. One is to run the NEURON program with Python as the interpreter accepting interactive commands in the terminal window. Another is to run NEURON with Hoc as the interactive interpreter and access Python functionality through Hoc objects and function calls. These first two cases we will refer to as embedded Python. The third way is to dynamically import NEURON in a running Python or IPython instance, which we will refer to as using NEURON as an extension module for Python.</p><p>In the sections to follow, we describe the steps required to use NEURON with Python, from a user's point of view, and the techniques employed to enable NEURON and Python to work together, from a developer's point of view. We begin in Section <xref ref-type="sec" rid="s1">&#x0201c;Getting Started Using NEURON with Python&#x0201d;</xref> by describing how to install and run NEURON with Python. We then demonstrate how modelling is carried out using Python by comparing it side-by-side with Hoc syntax in Section <xref ref-type="sec" rid="s2">&#x0201c;Writing NEURON Models in Python&#x0201d;</xref>. In Section <xref ref-type="sec" rid="s3">&#x0201c;Using Python Code from Hoc&#x0201d;</xref>, we describe how Python can be accessed from the Hoc interpreter. In Section <xref ref-type="sec" rid="s4">&#x0201c;Technical Aspects&#x0201d;</xref>, we discuss some technical aspects of the implementation of the Python-NEURON interaction. Finally, in Section <xref ref-type="sec" rid="s5">&#x0201c;Importing MorphML Files &#x02014; A Practical Example&#x0201d;</xref> we give a detailed, practical example, from the current NEURON distribution, of combining Python and Hoc.</p><p>The code listings in Figures <xref ref-type="fig" rid="F1 F2 F3">1&#x02013;3</xref> are available for public download from the ModelDB model repository of the Senselab database, <monospace><uri xlink:type="simple" xlink:href="http://senselab.med.yale.edu">http://senselab.med.yale.edu</uri></monospace> (accession number 116491).</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>Code listing for a simple model neuron: building the neuron</bold>. The Python code is on the left and the equivalent Hoc code on the right.</p></caption><graphic xlink:href="fninf-03-001-g001"/></fig><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>Code listing for a simple model neuron (continued from Figure <xref ref-type="fig" rid="F1">1</xref>): instrumenting and running the model</bold>. The Python code is on the left and the equivalent Hoc code on the right.</p></caption><graphic xlink:href="fninf-03-001-g002"/></fig><fig id="F3" position="float"><label>Figure 3</label><caption><p><bold>Code listing demonstrating the use of ref and plotting</bold>.</p></caption><graphic xlink:href="fninf-03-001-g003"/></fig></sec><sec id="s1"><title>Getting Started Using Neuron with Python</title><sec><title>Installation</title><p>NEURON works with Python on Windows, Mac OS X, Linux, andmany other platforms such as the IBM Blue Gene/L/P and Cray XT3 supercomputers. Detailed installation information can be found at <monospace><uri xlink:type="simple" xlink:href="http://www.neuron. yale.edu">http://www.neuron. yale.edu</uri></monospace> by following the &#x0201c;Download and Install&#x0201d; link.</p><p>Binary installers are available for Windows, OS X and RPM-based Linux systems. The Windows installer contains a large portion of Cygwin Python 2.5. On OS X and Linux, the latest version of Python 2.3&#x02013;2.5 previously or subsequently installed is dynamically loaded when NEURON is launched. The binary installers provide Python embedded in NEURON, but do not support using NEURON as an extension module for Python or IPython.</p><p>If you would like to use NEURON as an extension module for Python or IPython, if no installer for your platform exists, or if you need to customize the installation (e.g. enable parallel/MPI support, or change the location of binaries), you should instead get the source code for the standard distribution, also available from the above &#x0201c;Download and Install&#x0201d; link, and compile it for your machine. Further instructions for this are given in the Appendix.</p></sec><sec><title>Basic use</title><p>NEURON may be started without the graphical user interface (GUI) using <monospace>nrniv</monospace> or with the GUI using <monospace>nrngui</monospace>. To use Python as the interpreter, rather than Hoc, use the <monospace>-python</monospace> option:<preformat position="float" xml:space="preserve"><monospace>$ nrniv -pythonNEURON -- VERSION 7.0 (228: fbb244f333a9)    2008-11-25Duke, Yale, and the BlueBrain Project --     Copyright 1984-2008See http://www.neuron.yale.edu/credits.html&#x0003e;&#x0003e;&#x0003e; from neuron import h</monospace></preformat></p><p>If there are any NEURON NMODL extension mechanisms (Hines and Carnevale, <xref ref-type="bibr" rid="B11">2000</xref>) in the working directory, and they have been compiled with <monospace>nrnivmodl</monospace>, they will be loaded automatically.</p><p>Alternatively, you may wish to use NEURON as an extension to the normal Python interpreter, or to IPython (Prez and Granger, <xref ref-type="bibr" rid="B18">2007</xref>), a more interactive variant. To do so, you must build NEURON from source and install the NEURON shared library for Python, as described in the Appendix. In Python (or IPython) then, NEURON is started (and any NMODL mechanisms loaded) when you <monospace>import neuron</monospace>:<preformat position="float" xml:space="preserve"><monospace>$ ipython[&#x02026;]In [1]: from neuron import hNEURON -- VERSION 7.0 (228: fbb244f333a9)     2008-11-25Duke, Yale, and the BlueBrain Project --     Copyright 1984-2008See http://www.neuron.yale.edu/credits.html</monospace></preformat></p><p>and the NEURON GUI is started by importing the <monospace>neuron.gui</monospace> module:<preformat position="float" xml:space="preserve"><monospace>In [2]: from neuron import gui</monospace></preformat></p><p>The <monospace>h</monospace> object that we import from the <monospace>neuron</monospace> module is the principal interface to NEURON's functionality. <monospace>h</monospace> is a <monospace>HocObject</monospace> instance, and has two main functions. First, it gives access to the top-level of the Hoc interpreter, e.g.:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; h('create soma')&#x0003e;&#x0003e;&#x0003e; h.soma&#x0003c;&#x02005;nrn.Section object at 0x8194080&#x0003e;</monospace></preformat></p><p>Second, it makes any of the classes defined in Hoc available to Python:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; stim = h.IClamp(0.5, sec=h.soma)</monospace></preformat></p><p>Note that the <monospace>soma</monospace> section created through the Hoc interpreter appears in Python as a <monospace>Section</monospace> object. We can also create <monospace>Sections</monospace> directly in Python, e.g.<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; dend = h.Section()</monospace></preformat></p><p>These two section objects are entirely equivalent, the only difference being that the name &#x0201c;dend&#x0201d; is not accessible within the Hoc interpreter. In addition to the <monospace>HocObject</monospace> class (and through it, any class defined in Hoc) and the <monospace>Section</monospace> class, the Python <monospace>neuron</monospace> module also provides the <monospace>Segment, Mechanism</monospace> and <monospace>RangeVariable</monospace> classes. More in-depth examples of using NEURON from Python are given in Section <xref ref-type="sec" rid="s2">&#x0201c;Writing NEURON Models in Python&#x0201d;</xref>, while using Python code from Hoc is introduced in Section <xref ref-type="sec" rid="s3">&#x0201c;Using Python Code from Hoc&#x0201d;</xref>.</p></sec><sec><title>Starting parallel neuron</title><p>Assuming NEURON was built with parallel support as discussed in the Appendix, suitably parallelized Hoc scripts are started using the MPI job execution command, typically <monospace>mpiexec</monospace> (Hines and Carnevale, <xref ref-type="bibr" rid="B10">2008</xref>) or the equivalent for your MPI implementation. When Python is used rather than Hoc, the same parallelism features are supported, with only slight changes in the execution model. Both embedded Python (<monospace>nrniv -python</monospace>) and NEURON as an extension module to Python are supported. MPI job execution for embedded Python is the same as standard NEURON/Hoc, except that an extra -<monospace>python</monospace> command line option must be passed to <monospace>nrniv</monospace>:<preformat position="float" xml:space="preserve"><monospace>$ mpiexec -np 4 nrniv -python -mpi nrn-7.0/\src/nrnpython/examples/test1.pynumprocs=4NEURON -- VERSION 7.0 (228: fbb244f333a9)     2008-11-25Duke, Yale, and the BlueBrain Project --     Copyright 1984-2008See http://www.neuron.yale.edu/credits.htmlNEURON thinks I am 0 of 4NEURON thinks I am 2 of 4NEURON thinks I am 3 of 4NEURON thinks I am 1 of 4</monospace></preformat></p><p>For users who prefer to use NEURON as an extension module to Python or IPython, execution is as follows:<preformat position="float" xml:space="preserve"><monospace>$ mpiexec -np 4 python nrn-7.0/src/nrnpython/\examples/test0.pyMPI_Initialized==true, enabling MPI     functionality.numprocs=4NEURON -- VERSION 7.0 (228: fbb244f333a9)     2008-11-25Duke, Yale, and the BlueBrain Project --     Copyright 1984-2008See http://www.neuron.yale.edu/credits.htmlmpi4py thinks I am 2 of 4, NEURON thinks I am     2 of 4mpi4py thinks I am 1 of 4, NEURON thinks I am     1 of 4mpi4py thinks I am 3 of 4, NEURON thinks I am    3 of 4mpi4py thinks I am 0 of 4, NEURON thinks I am    0 of 4</monospace></preformat></p><p>However, there is one important caveat: The NEURON extension module does not initialize MPI itself, but rather delegates this job to Python. To initialize MPI in Python, one must import a Python MPI module, such as &#x0201c;MPI for Python&#x0201d; (<monospace>mpi4py</monospace>) (Dalc&#x000ed;n et al., <xref ref-type="bibr" rid="B5">2008</xref>), prior to importing <monospace>neuron</monospace>:<preformat position="float" xml:space="preserve"><monospace>from mpi4py import MPIfrom neuron import hpc = h.ParallelContext()s = "mpi4py thinks I am %d of %d,\ NEURON thinks I am %d of %d\n" cw = MPI.COMM_WORLDprint s % (cw.rank, cw.size, \           pc.id(),pc.nhost())pc.done()</monospace></preformat></p><p>The module <monospace>mpi4py</monospace> is available from the Python Package Index (<monospace><uri xlink:type="simple" xlink:href="http://pypi.python.org">http://pypi.python.org</uri></monospace>).</p></sec><sec><title>Online help</title><p>For new users of NEURON with Python, a convenient starting place for help is Python online help, provided through the global function <monospace>help</monospace>, which takes one argument, the object on which you would like help:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; import neuron&#x0003e;&#x0003e;&#x0003e; help(neuron)Help on package neuron:NAME     neuronFILE     /usr/lib/python2.5/site-packages/neuron/         __init__.pyDESCRIPTION    neuron    ======    For empirically-based simulations of         neurons and networks of neurons in         Python.    This is the top-level module of the official         python interface to the NEURON simulation         environment (http://www.neuron.yale.        edu/neuron/).    For a list of available names, try         dir(neuron).[&#x02026;]</monospace></preformat></p><p>For commonly used Hoc classes, such as <monospace>Vector, APCount, NetCon</monospace>, etc., helpful reminders of constructor arguments, attributes and units with Python syntax examples are available at the Python prompt:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; from neuron import h&#x0003e;&#x0003e;&#x0003e; help(h.APCount)NEURON+Python Online Help System================================class APCountpointprocessapc = APCount(segment)apc.thresh --- mVapc.n --apc.time --- msapc.record(vector)Description:Counts the number of times the voltage at itslocation crosses a threshold voltage in thepositive direction. n contains the count and timecontains the time of last crossing.[&#x02026;]</monospace></preformat></p><p>In IPython, the <monospace>?</monospace> symbol is a quick shorthand roughly equivalent to online help:<preformat position="float" xml:space="preserve"><monospace>In [3]: ? h.APCountType:            HocObjectBase Class:      &#x0003c;type 'hoc.HocObject'&#x0003e;String Form:     &#x0003c;hoc.HocObject object at 0    xb79022f0&#x0003e;Namespace:       InteractiveLength:          0Docstring:    class APCount    pointprocess[&#x02026;]</monospace></preformat></p></sec></sec><sec id="s2"><title>Writing Neuron Models in Python</title><p>To show how a model neuron is implemented using Python, we repeat the example described in Chapter 6 of the NEURON Book (Carnevale and Hines, <xref ref-type="bibr" rid="B3">2006</xref>), but using Python rather than Hoc. The code listing is given in Figures <xref ref-type="fig" rid="F1">1</xref> and <xref ref-type="fig" rid="F2">2</xref>, and has Python code on the left and the equivalent Hoc code on the right.</p><p>There are only a few syntax and conceptual differences between the Python and Hoc versions, and we expect that Hoc users will have little difficulty transitioning to Python, should they wish to do so (Hoc will continue to be supported, of course). We now comment on the most significant differences.</p><p>First are the <monospace>import</monospace> statements, absent from the Hoc listing, although Hoc does have the <monospace>xopen()</monospace> function that has similar functionality. Since NEURON is now only one of potentially many modules living within the Python interpreter, it must live in its own namespace, so that the names of NEURON-specific classes and variables do not interfere with those from other modules. Of particular importance is the object <monospace>h</monospace>, which is the top-level Hoc interpreter, and gives access to Hoc classes, functions and variables.</p><p>While sections are created using the <monospace>create</monospace> keyword in Hoc, in Python we instantiate a <monospace>Section</monospace> object. Hence the important distinction in Hoc between sections and objects is removed: Everything in Python is an object. Similarly, the <monospace>connect</monospace> keyword in Hoc is replaced by a method call of the child section object in Python.</p><p>In NEURON, each cable section is made up one or more segments, and the diameter is a property of each segment. Hoc's shorthand, allowing the <monospace>diam</monospace> attribute to be set on all segments by setting it on the section is also available in Python. Inhomogeneous values for range variables such as <monospace>diam</monospace> can also be set on the specific <monospace>Segment</monospace> object, returned by calling the <monospace>Section</monospace> object as a function.</p><p>The <monospace>forall</monospace> keyword in Hoc, which iterates over all sections, is replaced by the <monospace>allsec()</monospace> method of the top-level Hoc interpreter object <monospace>h</monospace>. Here again we see, in setting the membrane capacitance <monospace>cm</monospace>, the Hoc and Python shorthands to set the value for all segments at once, without having to explicitly iterate over all <monospace>Segments</monospace>.</p><p>In instrumenting the model, we see that Python and Hoc objects have very similar behaviours. In general, all Hoc classes (<monospace>Vector, List, NetCon</monospace>, etc) are accessible within Python via the <monospace>h</monospace> object. Hoc object references must be declared using the <monospace>objref</monospace> keyword, and objects created using <monospace>new</monospace>, but once created, attribute access and method calls have near-identical syntax in Python and Hoc. There are three major exceptions to this rule. First, many functions and methods act in the context of the &#x02018;currently-accessed section&#x02019;. To support this in Python, these functions take a keyword argument <monospace>sec</monospace>. Second, certain method calls take Hoc expressions as arguments, so, for example, in adding the membrane potential of the soma section to the list of variables to plot, in Hoc we use <monospace>g.addvar(</monospace>&#x0201c;<monospace>soma.v(0.5)</monospace>&#x0201d;), but in the Python version the variable <monospace>soma</monospace> does not exist on the Hoc side, and so we have to pass the <monospace>soma</monospace> Section object as the <monospace>sec</monospace> keyword argument so that the Hoc expression is evaluated in the context of that section. Third, a number of functions/methods take Hoc variable references (indicated by preceding the variable name with the &#x02018;<monospace>&#x00026;</monospace>&#x02019; character) as arguments, the most important being <monospace>Vector.record(&#x00026;var)</monospace> and <monospace>NetCon(&#x00026;var, target)</monospace>. The equivalent syntax in Python is to precede the variable name with <monospace>_ref_</monospace>, e.g.: <monospace>Vector.record(_ref_var)</monospace>. For example, given &#x02018;pre&#x02019; and &#x02018;post&#x02019; Section objects and a dictionary of Hoc Vector objects addressed by a mnemonic string, recording the voltage at the centres of those sections is activated by the statements:<preformat position="float" xml:space="preserve"><monospace># record the membrane potentials and# synaptic currentsvec['v_pre'].record(pre(0.5)._ref_v)vec['v_post'].record(post(0.5)._ref_v)vec['i_syn'].record(syn._ref_i)vec['t'].record(h._ref_t)</monospace></preformat></p><p>Figure <xref ref-type="fig" rid="F3">3</xref> shows the complete listing with the above fragment in context and also illustrates the ease with which NEURON code can be mixed with third-party code such as the powerful Pylab/Matplotlib plotting package (<monospace><uri xlink:type="simple" xlink:href="http://matplotlib.sourceforge.net/">http://matplotlib.sourceforge.net/</uri></monospace>): NEURON <monospace>Vector</monospace> objects work just as well as Python lists or arrays as arguments to the <monospace>plot()</monospace> function.</p><sec><title>Using user-defined mechanisms</title><p>One of NEURON's most powerful features is the ability to write new mechanisms using the NMODL language, and then compile these mechanisms into the executable or into dynamic libraries (DLLs). The standard behaviour of NEURON is to load any mechanisms that have been compiled in the working directory. It is also possible to load DLLs from elsewhere in the filesystem using the Hoc function <monospace>nrn_load_dll()</monospace>. This has the disadvantage that the full path to the shared library file must be provided, which can be hard to determine, since the file is within a hidden folder which itself is within a folder with a platform-specific name. To simplify this, the <monospace>neuron</monospace> Python module adds a function <monospace>load_mechanisms()</monospace>, which takes as an argument the path to the directory containing the NMODL source files, and searches for shared library files below this directory. Furthermore, in analogy to the <monospace>PYTHONPATH</monospace> environment variable which contains a list of paths to search for importable Python modules, if you have defined a <monospace>NRN_NMODL_PATH</monospace> environment variable, NEURON will search these paths for shared libraries and load them at import time.</p></sec><sec><title>Using user-defined classes</title><p>One of the principal advantages of writing NEURON programs in Python rather than Hoc, especially for large, complex programs, is that Python is a fully object-oriented language, supporting encapsulation, polymorphism and inheritance, whereas Hoc supports only encapsulation and a limited form of polymorphism.</p><p>Just as with built-in Hoc classes, access to attributes and methods of user-defined Hoc classes (using the <monospace>begintemplate/endtemplate</monospace> keywords) uses the same syntax in Python as in Hoc. For example, if we have the following user-defined Hoc class in the file <monospace>string.hoc</monospace>:<preformat position="float" xml:space="preserve"><monospace>begintemplate String  public s  strdef s  proc init() {     s = $s1  }endtemplate String</monospace></preformat></p><p>then we can use it as follows:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; from neuron import h&#x0003e;&#x0003e;&#x0003e; h.xopen("string.hoc")&#x0003e;&#x0003e;&#x0003e; my_string = h.String("Hello")&#x0003e;&#x0003e;&#x0003e; my_string.s'Hello'</monospace></preformat></p><p>It is also possible to subclass both built-in and user-defined Hoc classes in Python, although with the restriction that multiple inheritance from Hoc-derived classes is not possible. Subclassing requires the use of the <monospace>hclass</monospace> class factory:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; from neuron import h, hclass&#x0003e;&#x0003e;&#x0003e; class MyNetStim(hclass(h.NetStim)):&#x02026;      """NetStim that allows setting&#x02026;         parameters on creation."""&#x02026;&#x02026;      def __init__(self, start=50, noise=0,&#x02026;                   interval=10, number=10):&#x02026;          self.start = start&#x02026;          self.interval = interval&#x02026;          self.noise = noise&#x02026;          self.number = number&#x02026;&#x0003e;&#x0003e;&#x0003e; stim = MyNetStim(start=0, noise=1)&#x0003e;&#x0003e;&#x0003e; stim.noise1.0&#x0003e;&#x0003e;&#x0003e; class MyString(hclass(h.String)):&#x02026;     def repeat(self, n):&#x02026;       return self.s*n&#x02026;&#x0003e;&#x0003e;&#x0003e; my_string = MyString("Hello")&#x0003e;&#x0003e;&#x0003e; my_string.repeat(3)'HelloHelloHello'</monospace></preformat></p></sec><sec><title>Numerical data transfer between hoc and python</title><p>The Hoc <monospace>Vector</monospace> object provides NEURON with a convenient and efficient container for storing and manipulating collections of numerical values, such as membrane potential traces or spike-times.</p><p>In Python, Hoc <monospace>Vector</monospace> objects expose iterator and indexing methods, such that they can be used in most cases where Numpy (Oliphant, <xref ref-type="bibr" rid="B17">2007</xref>), Scipy (Jones et al., <xref ref-type="bibr" rid="B14">2001</xref>), and Matplotlib (Hunter, <xref ref-type="bibr" rid="B13">2007</xref>), the most important scientific modules, accept lists.</p><p>To benefit from the elegant and expressive notation of Numpy for N-dimensional array manipulation, and from results computed using the large and growing repertoire of scientific packages available for Python, which largely return Numpy arrays, several optimized methods are available for the conversion of Hoc <monospace>Vectors</monospace> to and from Numpy arrays.</p><p>Transferring one-dimensional Numpy arrays and non-nested lists with float or integer items to Hoc <monospace>Vectors</monospace> is straightforward, as the Hoc <monospace>Vector</monospace> constructor accepts an array or list as an argument:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; v1 = h.Vector(a)&#x0003e;&#x0003e;&#x0003e; v2 = h.Vector(l)</monospace></preformat></p><p>Transferring a Hoc <monospace>Vector</monospace> to an array or list is equally straight forward:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; a = array(v1)&#x0003e;&#x0003e;&#x0003e; print a[ 3. 2. 3. 2.]&#x0003e;&#x0003e;&#x0003e; l = list(v2)&#x0003e;&#x0003e;&#x0003e; print l[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]</monospace></preformat></p><p>If you would like to transfer between an existing Numpy array and a Hoc Vector, there are the Hoc <monospace>Vector</monospace> &#x0201c;in-place&#x0201d; member functions <monospace>to_python</monospace> and <monospace>from_python</monospace>:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; v3 = h.Vector(len(a))&#x0003e;&#x0003e;&#x0003e; v3.from_python(a)&#x0003e;&#x0003e;&#x0003e; print list(v3)[3.0, 2.0, 3.0, 2.0]&#x0003e;&#x0003e;&#x0003e; b = zeros_like(a)&#x0003e;&#x0003e;&#x0003e; v3.to_python(b)&#x0003e;&#x0003e;&#x0003e; print b[ 3. 2. 3. 2.]</monospace></preformat></p></sec></sec><sec id="s3"><title>Using Python Code from Hoc</title><p>For interacting with Python, Hoc provides the <monospace>nrnpython()</monospace> function and the <monospace>PythonObject</monospace> class. <monospace>nrnpython()</monospace> takes as its one argument a string that can be any Python statement, e.g.:<preformat position="float" xml:space="preserve"><monospace>oc&#x0003e; nrnpython("a = 3.14159")oc&#x0003e; nrnpython("print a")3.14159</monospace></preformat></p><p><monospace>PythonObject</monospace> has two main uses. Creating an instance using <monospace>new</monospace> returns an object that encapsulates the top-level Python interpreter, e.g.<preformat position="float" xml:space="preserve"><monospace>oc&#x0003e; objref pyoc&#x0003e; py = new PythonObject()oc&#x0003e; py.b = "hello" oc&#x0003e; nrnpython("print b")hello</monospace></preformat></p><p>Strings and float/double values move back and forth between Python and Hoc (although Python integers become double values in Hoc and remain doubles if they are passed back to Python). All other Python objects become instances of the <monospace>PythonObject</monospace> class:<preformat position="float" xml:space="preserve"><monospace>oc&#x0003e; objref dictoc&#x0003e; nrnpython("d = {'a':1, 'b':2, 'c':3}")oc&#x0003e; dict = py.doc&#x0003e; print dictPythonObject [12]oc&#x0003e; print dict.__getitem__("c")3.0</monospace></preformat></p><p>For objects (such as lists and tuples) that take integer indices or are callable as functions, there is a special method named &#x02018;_&#x02019; (underscore):<preformat position="float" xml:space="preserve"><monospace>oc&#x0003e; objref lstoc&#x0003e; nrnpython("c = [7, 8.0, 'nine']")oc&#x0003e; lst = py.coc&#x0003e; for i = 0, lst.__len__() -1 { print lst._[i] }7.08.0nine</monospace></preformat></p><p>The only other trap for the unwary is that both single and double quotes are valid for string definitions in Python, but only double quotes are accepted by Hoc!</p><p>A detailed example of using Python from Hoc, and of the value of being able to access its large standard library, is given in Section <xref ref-type="sec" rid="s5">&#x0201c;Importing MorphML Files &#x02014; A Practical Example&#x0201d;</xref> for the case of importing 3D morphology from a MorphML file.</p></sec><sec id="s4"><title>Technical Aspects</title><p>Tools for building Python extensions, such as BOOST.Python (Abrahams and Grosse-Kunstleve, <xref ref-type="bibr" rid="B1">2003</xref>) or SWIG (Beazley, <xref ref-type="bibr" rid="B2">1996</xref>) might have been useful in more expert hands. However, the ability of users to declare variables, objects, and classes in Hoc, the fact that many existing C++ classes and class methods were not generally meant to be directly visible to the user except through the intermediation of Hoc syntax, and the fact that the Hoc connection to the internal NEURON code was already reasonably uniform, of reasonable size, and understood by us in depth, suggested to us that a Python interface written using the Python C-API (<monospace><uri xlink:type="simple" xlink:href="http://docs.python.org/c-api/">http://docs.python.org/c-api/</uri></monospace>) that reused as much as possible the existing Hoc connection to internal data and functions would give us the general control we needed, and allow us to accomplish the project in reasonable time. It should be emphasized that this design decision to reuse a few of the C functions that manipulate the Hoc runtime stack neither hinders nor assists any future work on development of APIs for major NEURON components, such as the numerical solvers, which may be useful to other simulators. However, our interface implementation does provide a compact example of how an application can communicate with NEURON within a shared address space and therefore makes the the process of dynamically linking NEURON into a user application much simpler.</p><p>Since double precision variables, arrays, constant strings, functions, and objects have very similar syntax and semantics in Hoc and Python, a single <monospace>PyTypeObject</monospace> structure called <monospace>HocObjectType</monospace> associated with a <monospace>PyHocObject</monospace> structure for a Python object instance containing Hoc Symbol and Object fields was sufficient to allow Python access to all these Hoc data-types. When a name is given to an attribute method of the <monospace>HocObjectType</monospace> (the reflexive self <monospace>PyHocObject</monospace> is also an argument to the method), the name is looked up in Hoc's symbol table for the <monospace>PyHocObject</monospace> Hoc Object field, and the symbol along with the Hoc object calls the same function that the Hoc interpreter would call to resolve the attribute at runtime. The attribute, which is typically a number, string, or <monospace>HocObject</monospace>, is then wrapped in a Python object of the proper type and returned. Function calls from Python into Hoc consist of pushing the function arguments onto the Hoc runtime stack and, again, calling the same function the Hoc interpreter would call at runtime. Thus, Python statements involving <monospace>PyHocObject</monospace> objects end up generating and executing the same Hoc stack machine code at runtime that would be accomplished by the corresponding Hoc statement. It should be noted that a great deal of interpreter efficiency can be gained in loop body statements by factoring out as much as possible the precursor objects. For example:<preformat position="float" xml:space="preserve"><monospace>from neuron import hvec = h.Vector (1000000)a = 0for i in xrange (1000000):    a += vec.x[i]</monospace></preformat></p><p>can be optimized by avoiding the repeated search for the attribute <monospace>x</monospace>:<preformat position="float" xml:space="preserve"><monospace>vx = vec.xfor i in xrange (1000000):    a += vx[i]</monospace></preformat></p><p>The former takes 1.3&#x02009;s on a 3&#x02009;GHz machine, while the latter takes 1.0&#x02009;s.</p><p>A critical requirement was to have as natural a correspondence as possible in Python for the special Hoc syntax for Sections, position along a Section, membrane mechanisms, and Range Variables. This was achieved through the C++ definition of corresponding types in Python to create instances for: <monospace>NPySecObj, NPySegObj, NPyMechObj,</monospace> and <monospace>NPyRangeVar</monospace>. For example, the <monospace>NPySegObj</monospace> segment (compartment) object points to the <monospace>NPySecObj</monospace> of which it is a part, specifies its location, x, and also contains a field to help in iterating over the mechanisms that exist at that location. An <monospace>NPyRangeVar</monospace> has, in practice, required only a pointer to the compartment (<monospace>NPySegObj</monospace>) where it exists and a pointer to its Hoc Symbol. A Section represents a continuous cable and evaluation of or assignment to a variable associated with a particular location always involves specifying both which Section and the relative arc length location (0 &#x02264; <italic>x</italic> &#x02264;1) along the Section. Internally, NEURON employs a Section stack to determine the working Section and Hoc syntax provided three ways to specify the top of the Section stack. The Hoc <monospace>Section.variable(x)</monospace> syntax has a direct correspondence to the Python <monospace>Section(x).variable</monospace> syntax and the latter perhaps has more clarity. The Hoc <monospace>Section { Hoc statements }</monospace> syntax is unique to NEURON and for the Python side we were reduced to explicit management of the Section stack with <monospace>Section.push()</monospace> with an explicit <monospace>h.pop_section()</monospace> as the final statement. This gets tedious for single function calls and so in Python we allow the keyword argument, <monospace>sec=Section</monospace>, to push and pop the Section during the scope of the Hoc function call. The Hoc <monospace>access Section</monospace> statement does not require a Python counterpart. However, the Python statement, <monospace>sec = h.cas()</monospace>, returns the top of the Section stack.</p><p>There were several cases of syntax mismatch which could only be overcome by the addition of new idioms. Hoc syntax does not allow an object to be treated as a function, so in Hoc we use <monospace>po._( &#x02026;)</monospace>. Python does not allow call by reference arguments. Therefore, when a Hoc function called from Python requires a reference argument, the variable name must be prefixed by <monospace>&#x02018;_ref_&#x02019;</monospace>. Of course, such variables can only be Hoc variables but that is not a difficulty in practice since either the need is to pass a Hoc RangeVariable or the Python program can construct a Hoc variable for use in these cases. Since all numbers in Hoc are double precision, type errors are raised when Python expects an integer. For the case of array arguments, the Hoc-to-Python interface converts the doubles to integers automatically. Unfortunately, one cannot in general call the <monospace>__getitem__(int)</monospace> method explicitly but must use the <monospace>[expr]</monospace> Hoc syntax. If this becomes a problem in practice, it will be necessary to supply a set of cast functions that can be explicitly invoked by the user.</p><p>We have encountered only one problem with freeing object memory that has proved resistant to a solution. In some cases there is an ambiguity in regard to whether the Hoc or the Python side owns a reference to an object. When this situation occurs, a reference to the object is kept in a list for a deferred call to <monospace>Py_DECREF</monospace> when it is guaranteed that it is safe to do so.</p><p>Assignment of a constant value to a range variable in a Section is far more common than assignment of different values within the segments of a Section and Hoc provides a simple syntax for that case which avoids writing an explicit loop. The latest extension of the NEURON Python interface mimics that behavior in Python by interpreting Section.RangeVariableName in that fashion instead of raising an &#x0201c;AttributeError&#x0201d;. We are also considering extending the implicit iteration idea to SectionLists and Cells to allow not only assignment of constants but also application of inhomogeneous functions.</p><p>A list of the principal differences in syntax between Hoc and Python is given in Table <xref ref-type="table" rid="T1">1</xref>.</p><table-wrap id="T1" position="float"><label>Table 1</label><caption><p><bold>The principal differences in syntax between Hoc and Python</bold>.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" rowspan="1" colspan="1">Python</th><th align="left" rowspan="1" colspan="1">Hoc</th><th align="left" rowspan="1" colspan="1">Notes</th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1"><monospace>obj()</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>obj._()</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>obj[int]</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>obj._[int]</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>obj[double]</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>obj.__getitem__(double)</monospace></td><td align="left" rowspan="1" colspan="1">or <monospace>__setitem__</monospace></td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>obj['string']</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>obj.__getitem__("string")</monospace></td><td align="left" rowspan="1" colspan="1">or <monospace>__setitem__</monospace></td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>f(_ref_var)</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>f(&#x00026;var)</monospace></td><td align="left" rowspan="1" colspan="1">when storing a persistent pointer</td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>f(h.ref(strvar))</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>f(strvar)</monospace></td><td align="left" rowspan="1" colspan="1">when <monospace>f</monospace> changes the string</td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>f(h.ref(obj))</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>f(obj)</monospace></td><td align="left" rowspan="1" colspan="1">when <monospace>f</monospace> changes the reference</td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>f(h.ref(var))</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>f(&#x00026;var)</monospace></td><td align="left" rowspan="1" colspan="1">when <monospace>f</monospace> changes <monospace>var</monospace> (via <monospace>$&#x02005;&#x00026;1</monospace>)</td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>sec = Section()</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>create sec</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>sec.push() stmt h.pop_section()</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>sec { stmt }</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>f(&#x02026;, sec = section)</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>section { f(&#x02026;) }</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>child.connect(parent, px, cx)</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>connect child(cx), parent(px)</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>sec.insert('mechname')</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>sec { insert mechname }</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>sec(x).rangevar</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>sec.rangevar(x)</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>for sec in h.allsec():</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>forall { }</monospace></td><td align="left" rowspan="1" colspan="1">includes <monospace>sec.push()</monospace> and <monospace>h.pop_section() </monospace>of currently accessed section.</td></tr><tr><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>for sec in h.seclist:</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>forsec seclist { }</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>for seg in sec:</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>for (x, 0)</monospace></td><td align="left" rowspan="1" colspan="1">the value of <monospace>x</monospace> is <monospace>seg.x</monospace></td></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>for seg in sec.allseg():</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>for (x)</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>seg.hh.gnabar or seg.gnabar_hh</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>gnabar_hh(x)</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>pp = PointProcess(x, sec=section)</monospace></td><td align="left" rowspan="1" colspan="1"><monospace>sec { pp = new PointProcess(x) }</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><monospace>for mech in seg:</monospace></td><td align="left" rowspan="1" colspan="1">No direct equivalent. Use</td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1"><monospace>MechanismType</monospace></td><td align="left" rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1"><italic>iteration</italic></td><td align="left" rowspan="1" colspan="1"><monospace>for iterator</monospace></td><td align="left" rowspan="1" colspan="1">Python supplies several styles of iteration and Hoc supplies an iterator idiom. Conversion from one to the other is done via explicit programming but Python cannot use a Hoc iterator directly. Nor can Hoc use generators except by calling the underlying <monospace>__next__()</monospace> method.</td></tr></tbody></table></table-wrap></sec><sec id="s5"><title>Importing Morphml Files &#x02014; a Practical Example</title><p>Our first serious use of the NEURON Python interface was to extend the Import3D GUI tool to read MorphML specification files. Import3D is structured around a graphical view of a list of <monospace>Import3d_Section</monospace> objects defined in Hoc. Among many method and field attributes, the principle data field of the <monospace>Import3d_Section</monospace> object is the raw x, y, z, diam information along an unbranched cable and a list index indicating the parent <monospace>Import3d_Section</monospace>. The list of <monospace>Import3d_Section</monospace> objects is constructed by various file reader objects that understand a specific file format such as Eutectic, SWC, or NeuroLucida versions 1 or 3. Since MorphML is an XML format, it was opportune to employ the XML reader module in the standard Python distribution.</p><p>The problem of parsing and analyzing the MorphML format is similar in difficulty to that for NeuroLucida V3 files. We divided the problem into Hoc and Python code portions. In contrast to a file size of 1180 lines for the NeuroLucida V3 file reader, the <monospace>read_morphml.hoc</monospace> file size is 78 lines and the Python portion of the problem is carried out by <monospace>rdxml.py</monospace> with a file size of 370 lines. Since these files are located in the NEURON package default search path &#x02013; <monospace>&#x02026;/nrn/lib/hoc</monospace> for the <monospace>read_morphml.hoc</monospace> file and <monospace>&#x02026;/nrn/lib/python</monospace> for the <monospace>rdxml.py</monospace> file &#x02013; the MorphML reader extension works wherever the NEURON Python interface is installed.</p><p>The <monospace>read_morphml.hoc</monospace> file defines an <monospace>Import3d_MorphML</monospace> Hoc template (class) which interacts with <monospace>Import3d_GUI</monospace> in exactly the same manner as the other format readers.</p><p>When an <monospace>Import3d_MorphML</monospace> instance is created, the Python helper module we wrote to parse the input file is imported with <monospace>nrnpython</monospace>(<monospace>&#x0201c;import rdxml&#x0201d;</monospace>) and <monospace>p = new PythonObject()</monospace> is defined in order to allow access to Python functions.</p><p>The <monospace>proc input() {&#x02026;}</monospace> procedure defines a <monospace>sections</monospace> list and populates it with <monospace>Import3dSection</monospace> objects indirectly via <monospace>p.rdxml.rdxml($s1, this)</monospace> which passes the filename selected earlier by the user along with a reference to the <monospace>Import3dMorphML</monospace> instance to allow callback from the Python code.</p><p>The<preformat position="float" xml:space="preserve"><monospace>def rdxml(fname, ho) :  xml.sax.parse(fname, MyContentHandler(ho))</monospace></preformat></p><p>module function calls the xml parser with the filename and a new instance of<preformat position="float" xml:space="preserve"><monospace>class MyContentHandler(xml.sax.ContentHandler):  def __init__(self, ho):    self.i3d = ho    &#x02026;</monospace></preformat></p><p>The reference to the <monospace>Import3d_MorphML</monospace> instance is stored by the initializer for later use at the end of parsing. During file reading there is no interaction between Hoc and Python, so let it suffice that the xml parsing style is, at the beginning and end of every xml element, to call the <monospace>MyContentHandler</monospace> methods<preformat position="float" xml:space="preserve"><monospace>def startElement(self, name, attrs):  if self.elements.has_key(name):    if debug: print "startElement:", name    self.elements[name](self, attrs)  else :    if debug:      print "startElement unknown", name  def endElement(self, name):    if self.elements.has_key('end'+name):      self.elements['end' +name](self)</monospace></preformat></p><p>where the <monospace>elements</monospace> literal map associates all possible element names with a <monospace>MyContentHandler</monospace> method. E.g.<preformat position="float" xml:space="preserve"><monospace>elements = {  'neuroml':nothing,  'morphml':nothing,  &#x02026;  'segments':segments,  'endsegments':endsegments,  'segment':segment,  'proximal':proximal,  &#x02026;  }</monospace></preformat></p><p>The methods construct Python lists of <monospace>Point, Cable</monospace>, etc, as well as maps associating identifiers with list indices. At the end of parsing, the <monospace>MyContentHandler</monospace> method<preformat position="float" xml:space="preserve"><monospace>def endDocument(self):  self.i3d.parsed(self)</monospace></preformat></p><p>is called by the xml parser.</p><p>At this point we find ourselves back in the Hoc world with an argument that references the <monospace>MyContentHandler</monospace>. Through that we can obtain the information saved by the <monospace>MyContentHandler</monospace> in various maps and lists and copy it into new <monospace>Import3d_Section</monospace> instances.<preformat position="float" xml:space="preserve"><monospace>proc parsed() {&#x02026;  cables = $o1.cables_  points = $o1.points_  cableid2index = $o1.cableid2index_  for i=0, cables.__len__() - 1 {    cab = cables._[i]    sec = new Import3d_Section(cab.first_,\       cab.pcnt_)    sections.append(sec)    if (cab.parent_cable_id_ &#x0003e;= 0) {      ip = cableid2index_[cab.parent_cable_id_]      sec.parentsec = sections.object(ip)      sec.parentx = cab.px_    }    &#x02026;</monospace></preformat></p><p>Note the &#x02018;._&#x02019; idiom for accessing a Python list element since, in Hoc, <monospace>cables[i]</monospace> is syntax implying an object reference array created with <monospace>objref cables[n]</monospace>. Also, <monospace>cableid2index</monospace> is a Python map which associates the cable identifier read from the xml input file, with the proper element in the Python <monospace>cables</monospace> list.</p></sec><sec sec-type="discussion"><title>Discussion</title><p>Python makes available within NEURON a very extensive suite of analysis tools written for the general science and engineering communities. All existing models written in Hoc, including GUI tools, continue to work without change. All NEURON objects are accessible to Python via an instance of the HocObject. Within the Hoc interpreter, all Python objects are accessible via the PythonObject. Binary installation remains straightforward for the usage case of launching NEURON with Python embedded: The MS Windows installer contains a large subset of the 2.5 version of Python, and the Linux RPM and Mac OS X dmg installations will use the latest version of Python, if any, that is already present or subsequently installed. The usage case of launching Python, e.g. using IPython, and dynamically importing NEURON also works but presently requires the extra installation steps described in the Appendix. Numpy is not a prerequisite but, if present, copying of vectors between Numpy and NEURON is very efficient. The Python <monospace>xml</monospace> module is used in the present standard distribution to extend NEURON's Import3D and CellBuild tools to allow reading of MorphML (Crook et al., <xref ref-type="bibr" rid="B4">2007</xref>) and NeuroML (Goddard et al., <xref ref-type="bibr" rid="B8">2001</xref>) model specifications. The Hoc portion of the <monospace>xml</monospace> readers makes heavy use of Python maps and lists.</p><p>With the release of NEURON version 7.0, the Python interface has largely stabilized, and is ready for general use. We recommend that new users of NEURON and those already familiar with Python should use Python rather than Hoc to develop new models. Those with considerable expertise in Hoc but without Python knowledge are likely to be more productive by continuing to develop models with Hoc, but accessing Python's powerful data structures, large standard library and external numerical/plotting packages through <monospace>nrnpython()</monospace> and the <monospace>PythonObject</monospace> class. There is no need to rewrite legacy code in Python, as it will continue to work using the Hoc interpreter or mixed in with new Python code and accessed via the <monospace>h</monospace> object.</p><p>Users are encouraged to submit bug reports and feature requests at the NEURON forum (<monospace><uri xlink:type="simple" xlink:href="http://www.neuron.yale.edu/phpBB">http://www.neuron.yale.edu/phpBB</uri></monospace>) in the &#x0201c;NEURON+Python&#x0201d; sub-section, so that we can continue to improve the Python interface in response to users' experiences.</p></sec><sec><title>Conflict of Interest Statement</title><p>The authors declare that the research presented in this paper was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p></sec></body><back><sec><title>Appendix</title><p>Here we give detailed instructions for building and installing NEURON as a Python extension. Note that, as mentioned earlier, to use NEURON with Python embedded you can use one of the binary installers.</p><p>The following assumes a standard GNU build environment, and a bash shell. You will need both NEURON (<monospace>nrn-VERSION.tar.gz</monospace>) and InterViews (<monospace>iv-VERSION.tar.gz</monospace>) sources, available through the &#x0201c;Download and Install&#x0201d; link at <monospace><uri xlink:type="simple" xlink:href="http://www.neuron.yale.edu">http://www.neuron.yale.edu</uri></monospace>.</p><p>First, build and install Interviews:<preformat position="float" xml:space="preserve"><monospace>$ N=&#x02005;&#x02005;&#x02035;pwd&#x02005;&#x02005;&#x02035;$ tar xzf iv-17.tar.gz$ cd iv-17$ ./configure --prefix=&#x02005;&#x02005;&#x02035;pwd&#x02005;&#x02005;&#x02035;$ make$ make install</monospace></preformat></p><p>Then build and install NEURON:<preformat position="float" xml:space="preserve"><monospace>$ cd..$ tar xzf nrn-7.0.tar.gz$ cd nrn-7.0$ ./configure --prefix=&#x02005;&#x02005;&#x02035;pwd&#x02005;&#x02005;&#x02035;\ --with-iv=$N/iv-17 --with-nrnpython$ make$ make install</monospace></preformat></p><p>Here, the &#x0201c;<monospace>\</monospace>&#x0201d; at the end of the fourth line, indicates it is continued on the fifth. If you want to run parallel NEURON (Hines et al., <xref ref-type="bibr" rid="B12">2008</xref>; Migliore et al., <xref ref-type="bibr" rid="B16">2006</xref>), add <monospace>--with-paranrn</monospace> to the <monospace>configure</monospace> options. This requires a version of MPI to be installed, for example MPICH2 (Gropp, <xref ref-type="bibr" rid="B9">2002</xref>) or openMPI (Gabriel et al., <xref ref-type="bibr" rid="B7">2004</xref>).</p><p>Now add the NEURON <monospace>bin</monospace> directory to your PATH:<preformat position="float" xml:space="preserve"><monospace>$ export PATH=$N/nrn-7.0/i686/bin:$PATH</monospace></preformat></p><p>(Here <monospace>i686</monospace> will be different for different CPU architectures).</p><p>Now build and install the NEURON shared library for Python:<preformat position="float" xml:space="preserve"><monospace>$ cd src/nrnpython# python setup.py install</monospace></preformat></p><p>This command installs the neuron package to the Python site-packages directory, which usually requires root access. If you don't have root access, you can install it locally using <monospace>--prefix</monospace> to specify a location under your home directory:<preformat position="float" xml:space="preserve"><monospace>$ python setup.py install\ --prefix=$HOME/local</monospace></preformat></p><p>This will install the <monospace>neuron</monospace> package to <monospace>$HOME/local/lib/python/site-packages</monospace> under your home directory. You will then have to add this directory to the PYTHONPATH environment variable:<preformat position="float" xml:space="preserve"><monospace>$ export PYTHONPATH=$PYTHONPATH:\$HOME/local/lib/python/site-packages</monospace></preformat></p></sec><ack><p>This work was supported by NIH grant NS11613, by the European Union under the Bio-inspired Intelligent Information Systems program, project reference IST-2004-15879 (FACETS), and by a grant from the Swiss National Science Foundation.</p></ack><ref-list><title>References</title><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Abrahams</surname><given-names>D.</given-names></name><name><surname>Grosse-Kunstleve</surname><given-names>R. W.</given-names></name></person-group> (<year>2003</year>). <article-title>Building hybrid systems with Boost.Python</article-title>. <source>C/C++ Users J.</source><volume>21</volume> <uri xlink:type="simple" xlink:href="http://www.ddj.com/cpp/184401666">http://www.ddj.com/cpp/184401666</uri></citation></ref><ref id="B2"><citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Beazley</surname><given-names>D. M.</given-names></name></person-group> (<year>1996</year>). <article-title>SWIG: an easy to use tool for integrating scripting languages with C and C++</article-title>. In <conf-name>TCLTK'96: Proceedings of the 4th Conference on USENIX Tcl/Tk Workshop, 1996</conf-name>, (<conf-loc>Monterey, CA</conf-loc>, <conf-sponsor>USENIX Association</conf-sponsor>), pp. <fpage>129</fpage>&#x02013;<lpage>139</lpage></citation></ref><ref id="B3"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Carnevale</surname><given-names>N. T.</given-names></name><name><surname>Hines</surname><given-names>M. L.</given-names></name></person-group> (<year>2006</year>). <article-title>The NEURON Book</article-title>. <publisher-loc>Cambridge</publisher-loc>, <publisher-name>Cambridge University Press</publisher-name></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Crook</surname><given-names>S.</given-names></name><name><surname>Gleeson</surname><given-names>P.</given-names></name><name><surname>Howell</surname><given-names>F.</given-names></name><name><surname>Svitak</surname><given-names>J.</given-names></name><name><surname>Silver</surname><given-names>R.</given-names></name></person-group> (<year>2007</year>). <article-title>MorphML: level 1 of the NeuroML standards for neuronal morphology data and model specification</article-title>. <source>Neuroinformatics</source><volume>5</volume>, <fpage>96</fpage>&#x02013;<lpage>104</lpage><pub-id pub-id-type="doi">10.1007/s12021-007-0003-6</pub-id><pub-id pub-id-type="pmid">17873371</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Dalc&#x000ed;n</surname><given-names>L.</given-names></name><name><surname>Paza</surname><given-names>R.</given-names></name><name><surname>Stortia</surname><given-names>M.</given-names></name><name><surname>D'El&#x000ed;aa</surname><given-names>J.</given-names></name></person-group> (<year>2008</year>). <article-title>MPI for Python: performance improvements and MPI-2 extensions</article-title>. <source>J. Parallel Distrib. Comput.</source><volume>68</volume>, <fpage>655</fpage>&#x02013;<lpage>662</lpage><pub-id pub-id-type="doi">10.1016/j.jpdc.2007.09.005</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Dubois</surname><given-names>P. F.</given-names></name></person-group> (<year>2007</year>). <article-title>Python: batteries included</article-title>. <source>IEEE Comput. Sci. Eng.</source><volume>9</volume>, <fpage>7</fpage>&#x02013;<lpage>9</lpage></citation></ref><ref id="B7"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Gabriel</surname><given-names>E.</given-names></name><name><surname>Fagg</surname><given-names>G. E.</given-names></name><name><surname>Bosilca</surname><given-names>G.</given-names></name><name><surname>Angskun</surname><given-names>T.</given-names></name><name><surname>Dongarra</surname><given-names>J. J.</given-names></name><name><surname>Squyres</surname><given-names>J M.</given-names></name><name><surname>Sahay</surname><given-names>V.</given-names></name><name><surname>Kambadur</surname><given-names>P.</given-names></name><name><surname>Barrett</surname><given-names>B.</given-names></name><name><surname>Lumsdaine</surname><given-names>A.</given-names></name><name><surname>Castain</surname><given-names>R. H.</given-names></name><name><surname>Daniel</surname><given-names>D. J.</given-names></name><name><surname>Graham</surname><given-names>R. L.</given-names></name><name><surname>Woodall</surname><given-names>T. S.</given-names></name></person-group> (<year>2004</year>). <article-title>Open MPI: goals, concept, and design of a next generation MPI implementation</article-title>. In Proceedings, 11th European PVM/MPI Users' Group Meeting, <person-group person-group-type="editor"><name><surname>Kranzlm&#x000fc;ller</surname><given-names>D.</given-names></name><name><surname>Kacsuk</surname><given-names>P.</given-names></name><name><surname>Dongara</surname><given-names>J.</given-names></name></person-group> eds (<publisher-loc>Budapest</publisher-loc>, <publisher-name>Springer</publisher-name>), pp. <fpage>97</fpage>&#x02013;<lpage>104</lpage></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Goddard</surname><given-names>N.</given-names></name><name><surname>Hucka</surname><given-names>M.</given-names></name><name><surname>Howell</surname><given-names>F.</given-names></name><name><surname>Cornelis</surname><given-names>H.</given-names></name><name><surname>Shankar</surname><given-names>K.</given-names></name><name><surname>Beeman</surname><given-names>D.</given-names></name></person-group> (<year>2001</year>). <article-title>Towards NeuroML: model description methods for collaborative modeling in neuroscience</article-title>. <source>Philos. Trans. R. Soc. B</source><volume>356</volume>, <fpage>1209</fpage>&#x02013;<lpage>1228</lpage><pub-id pub-id-type="doi">10.1098/rstb.2001.0910</pub-id></citation></ref><ref id="B9"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Gropp</surname><given-names>W.</given-names></name></person-group> (<year>2002</year>). <article-title>MPICH2: a new start for MPI implementations</article-title>. In Proceedings of the 9th European PVM/MPI Users' Group Meeting on Recent Advances in Parallel Virtual Machine and Message Passing Interface, <person-group person-group-type="editor"><name><surname>Kranzlm&#x000fc;ller</surname><given-names>D.</given-names></name><name><surname>Kacsuk</surname><given-names>P.</given-names></name><name><surname>Dongara</surname><given-names>J.</given-names></name><name><surname>Volkert</surname><given-names>J.</given-names></name></person-group> eds (<publisher-loc>London</publisher-loc>, <publisher-name>Springer-Verlag</publisher-name>), p. <fpage>7</fpage></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hines</surname><given-names>M.</given-names></name><name><surname>Carnevale</surname><given-names>N.</given-names></name></person-group> (<year>2008</year>). <article-title>Translating network models to parallel hardware in NEURON</article-title>. <source>J. Neurosci. Methods</source><volume>169</volume>, <fpage>425</fpage>&#x02013;<lpage>455</lpage><pub-id pub-id-type="doi">10.1016/j.jneumeth.2007.09.010</pub-id><pub-id pub-id-type="pmid">17997162</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hines</surname><given-names>M. L.</given-names></name><name><surname>Carnevale</surname><given-names>N. T.</given-names></name></person-group> (<year>2000</year>). <article-title>Expanding NEURON's repertoire of mechanisms with NMODL</article-title>. <source>Neural Comput.</source><volume>12</volume>, <fpage>995</fpage>&#x02013;<lpage>1007</lpage><pub-id pub-id-type="doi">10.1162/089976600300015475</pub-id><pub-id pub-id-type="pmid">10905805</pub-id></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hines</surname><given-names>M. L.</given-names></name><name><surname>Markram</surname><given-names>H.</given-names></name><name><surname>Schuermann</surname><given-names>F.</given-names></name></person-group> (<year>2008</year>). <article-title>Fully implicit parallel simulation of single neurons</article-title>. <source>J. Comput. Neurosci.</source><volume>25</volume>, <fpage>439</fpage>&#x02013;<lpage>448</lpage><pub-id pub-id-type="doi">10.1007/s10827-008-0087-5</pub-id><pub-id pub-id-type="pmid">18379867</pub-id></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hunter</surname><given-names>J. D.</given-names></name></person-group> (<year>2007</year>). <article-title>Matplotlib: a 2D graphics environment</article-title>. <source>IEEE Comput. Sci. Eng.</source><volume>9</volume>, <fpage>90</fpage>&#x02013;<lpage>95</lpage></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jones</surname><given-names>E.</given-names></name><name><surname>Oliphant</surname><given-names>T.</given-names></name><name><surname>Peterson</surname><given-names>P.</given-names></name><etal/></person-group> (<year>2001</year>). <article-title>SciPy: open source scientific tools for Python</article-title>. URL <monospace><uri xlink:type="simple" xlink:href="http://www.scipy.org/">http://www.scipy.org/</uri></monospace></citation></ref><ref id="B15"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Kernighan</surname><given-names>B.</given-names></name><name><surname>Pike</surname><given-names>R.</given-names></name></person-group> (<year>1984</year>). <article-title>The Unix Programming Environment</article-title>. <publisher-loc>Englewood Cliffs, NJ</publisher-loc>, <publisher-name>Prentice Hall</publisher-name></citation></ref><ref id="B16"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Migliore</surname><given-names>M.</given-names></name><name><surname>Cannia</surname><given-names>C.</given-names></name><name><surname>Lytton</surname><given-names>W. W.</given-names></name><name><surname>Markram</surname><given-names>H.</given-names></name><name><surname>Hines</surname><given-names>M. L.</given-names></name></person-group> (<year>2006</year>). <article-title>Parallel network simulations with NEURON</article-title>. <source>J. Comput. Neurosci.</source><volume>21</volume>, <fpage>119</fpage>&#x02013;<lpage>129</lpage><pub-id pub-id-type="doi">10.1007/s10827-006-7949-5</pub-id><pub-id pub-id-type="pmid">16732488</pub-id></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Oliphant</surname><given-names>T. E.</given-names></name></person-group> (<year>2007</year>). <article-title>Python for scientific computing</article-title>. <source>IEEE Comput. Sci. Eng.</source><volume>9</volume>, <fpage>10</fpage>&#x02013;<lpage>20</lpage></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Prez</surname><given-names>F.</given-names></name><name><surname>Granger</surname><given-names>B. E.</given-names></name></person-group> (<year>2007</year>). <article-title>IPython: a system for interactive scientific computing</article-title>. <source>IEEE Comput. Sci. Eng.</source><volume>9</volume>, <fpage>21</fpage>&#x02013;<lpage>29</lpage></citation></ref></ref-list></back></article>