<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Retrovirology</journal-id><journal-title>Retrovirology</journal-title><issn pub-type="epub">1742-4690</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19055831</article-id><article-id pub-id-type="pmc">2637298</article-id><article-id pub-id-type="publisher-id">1742-4690-5-110</article-id><article-id pub-id-type="doi">10.1186/1742-4690-5-110</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>HIV-1 coreceptor usage prediction without multiple alignments: an application of string kernels</article-title></title-group><contrib-group><contrib id="A1" contrib-type="author"><name><surname>Boisvert</surname><given-names>S&#x000e9;bastien</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>Sebastien.Boisvert.3@ulaval.ca</email></contrib><contrib id="A2" contrib-type="author"><name><surname>Marchand</surname><given-names>Mario</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>Mario.Marchand@ift.ulaval.ca</email></contrib><contrib id="A3" contrib-type="author"><name><surname>Laviolette</surname><given-names>Fran&#x000e7;ois</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>Francois.Laviolette@ift.ulaval.ca</email></contrib><contrib id="A4" corresp="yes" contrib-type="author"><name><surname>Corbeil</surname><given-names>Jacques</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>Jacques.Corbeil@crchul.ulaval.ca</email></contrib></contrib-group><aff id="I1"><label>1</label>Centre de recherche du centre hospitalier de l'Universit&#x000e9; Laval, Qu&#x000e9;bec (QC), Canada</aff><aff id="I2"><label>2</label>D&#x000e9;partement d'informatique et de g&#x000e9;nie logiciel, Universit&#x000e9; Laval, Qu&#x000e9;bec (QC), Canada</aff><pub-date pub-type="collection"><year>2008</year></pub-date><pub-date pub-type="epub"><day>4</day><month>12</month><year>2008</year></pub-date><volume>5</volume><fpage>110</fpage><lpage>110</lpage><ext-link ext-link-type="uri" xlink:href="http://www.retrovirology.com/content/5/1/110"/><history><date date-type="received"><day>14</day><month>7</month><year>2008</year></date><date date-type="accepted"><day>4</day><month>12</month><year>2008</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2008 Boisvert et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2008</copyright-year><copyright-holder>Boisvert et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Boisvert               S&#x000e9;bastien                              Sebastien.Boisvert.3@ulaval.ca            </dc:author><dc:title>            HIV-1 coreceptor usage prediction without multiple alignments: an application of string kernels         </dc:title><dc:date>2008</dc:date><dcterms:bibliographicCitation>Retrovirology 5(1): 110-. (2008)</dcterms:bibliographicCitation><dc:identifier type="sici">1742-4690(2008)5:1&#x0003c;110&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1742-4690</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>Human immunodeficiency virus type 1 (HIV-1) infects cells by means of ligand-receptor interactions. This lentivirus uses the CD4 receptor in conjunction with a chemokine coreceptor, either CXCR4 or CCR5, to enter a target cell. HIV-1 is characterized by high sequence variability. Nonetheless, within this extensive variability, certain features must be conserved to define functions and phenotypes. The determination of coreceptor usage of HIV-1, from its protein envelope sequence, falls into a well-studied machine learning problem known as <italic>classification</italic>. The support vector machine (SVM), with string kernels, has proven to be very efficient for dealing with a wide class of classification problems ranging from text categorization to protein homology detection. In this paper, we investigate how the SVM can predict HIV-1 coreceptor usage when it is equipped with an appropriate string kernel.</p></sec><sec><title>Results</title><p>Three string kernels were compared. Accuracies of 96.35% (CCR5) 94.80% (CXCR4) and 95.15% (CCR5 and CXCR4) were achieved with the SVM equipped with the <italic>distant segments kernel </italic>on a test set of 1425 examples with a classifier built on a training set of 1425 examples. Our datasets are built with Los Alamos National Laboratory HIV Databases sequences. A web server is available at <ext-link ext-link-type="uri" xlink:href="http://genome.ulaval.ca/hiv-dskernel"/>.</p></sec><sec><title>Conclusion</title><p>We examined string kernels that have been used successfully for protein homology detection and propose a new one that we call the <italic>distant segments kernel</italic>. We also show how to extract the most relevant features for HIV-1 coreceptor usage. The SVM with the <italic>distant segments kernel </italic>is currently the best method described.</p></sec></abstract></article-meta></front><body><sec><title>Background</title><p>The HIV-1 genome contains 9 genes. One of the genes, the <italic>env </italic>gene, codes for 2 envelope proteins named gp41 and gp120. The gp120 envelope protein must bind to a CD4 receptor and a coreceptor prior to cell infection by HIV-1. Two coreceptors can be used by HIV-1: the CCR5 (chemokine receptor 5) and the CXCR4 (chemokine receptor 4). Some viruses are only capable of using the CCR5 coreceptor. Other viruses can only use the CXCR4 coreceptor. Finally, some HIV-1 viruses are capable of using both of these coreceptors. The pathology of a strain of HIV-1 is partly a function of the coreceptor usage [<xref ref-type="bibr" rid="B1">1</xref>]. The faster CD4+ cell depletion caused by CXCR4-using viruses [<xref ref-type="bibr" rid="B2">2</xref>] makes the accurate prediction of coreceptor usage medically warranted. Specific regions of the HIV-1 external envelope protein, named hypervariable regions, contribute to the turnover of variants from a phenotype to another [<xref ref-type="bibr" rid="B3">3</xref>]. HIV-1 tropisms (R5, X4, R5X4) are often (but not always) defined in the following way. R5 viruses are those that can use only the CCR5 coreceptor and X4 viruses are those that can use only the CXCR4 coreceptor. R5X4 viruses, called dual-tropic viruses, can use both coreceptors. Tropism switch occurs during progression towards AIDS. Recently, it has been shown that R5 and X4 viruses modulate differentially host gene expression [<xref ref-type="bibr" rid="B4">4</xref>].</p><sec><title>Computer-aided prediction</title><p>The simplest method used for HIV-1 coreceptor usage prediction is known as the <italic>charge rule </italic>[<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>]. It relies only on the charge of residues at positions 11 and 25 within the V3 loop aligned against a consensus. The V3 loop is the third highly variable loop in the retroviral envelope protein gp120. Nonetheless, other positions are also important since the removal of these positions gave predictors with comparable (but weaker) performance to those that were trained with these positions present [<xref ref-type="bibr" rid="B1">1</xref>]. Other studies [<xref ref-type="bibr" rid="B7">7</xref>-<xref ref-type="bibr" rid="B12">12</xref>] also outlined the importance of other positions and proposed machine learning algorithms, such as the random forest [<xref ref-type="bibr" rid="B11">11</xref>] and the support vector machine (SVM) with structural descriptors [<xref ref-type="bibr" rid="B10">10</xref>], to built better predictors (than the charge rule). Available predictors (through webservers) of HIV-1 coreceptor usage are enumerated in [<xref ref-type="bibr" rid="B13">13</xref>].</p><p>An accuracy of 91.56% for the task of predicting the CXCR4 usage was obtained by [<xref ref-type="bibr" rid="B10">10</xref>]. Their method, based on structural descriptors of the V3 loop, employed a single dataset containing 432 sequences without indels and required the multiple alignment of all V3 sequences. However, such a prior alignment before learning might remove information present in the sequences which is relevant to the coreceptor usage task. Furthermore, a prior multiple alignment done on all the data invalidates the cross-validation method since the testing set in each fold has been used for the construction of the tested classifier. Another drawback of having an alignment-based method is that sequences having too many indels (when compared to a consensus sequence) are discarded to prevent the multiple alignment from yielding an unacceptable amount of gaps. In this paper, we present a method for predicting the coreceptor usage of HIV-1 which does not perform any multiple alignment prior to learning.</p><p>The SVM [<xref ref-type="bibr" rid="B14">14</xref>] has proven to be very effective at generating classifiers having good generalization (i.e., having high predicting accuracy). In particular, [<xref ref-type="bibr" rid="B1">1</xref>] have obtained a significantly improved predictor (in comparison with the charge rule) with an SVM equipped with a linear kernel. However, the linear kernel is not suited for sequence classification since it does not provide a natural measure of dissimilarity between sequences. Moreover, a SVM with a linear kernel can only use sequences that are exactly of the same length. Consequently, [<xref ref-type="bibr" rid="B1">1</xref>] aligned all HIV-1 V3 loop sequences with respect to a consensus. No such alignment was performed in our experiments. In contrast, string kernels [<xref ref-type="bibr" rid="B15">15</xref>] do not suffer from these deficiencies and have been explicitly designed to deal with strings and sequences of varying lengths. Furthermore, they have been successfully used for protein homology detection [<xref ref-type="bibr" rid="B16">16</xref>] &#x02013; a classification problem which is closely related to the one treated in this paper.</p><p>Consequently, we have investigated the performance of the SVM, equipped with the appropriate string kernel, at predicting the coreceptor used by HIV-1 as a function of its protein envelope sequence (the V3 loop). We have compared two string kernels used for protein homology detection, namely the blended spectrum kernel [<xref ref-type="bibr" rid="B15">15</xref>,<xref ref-type="bibr" rid="B17">17</xref>] and the local alignment kernel [<xref ref-type="bibr" rid="B16">16</xref>], to a newly proposed string kernel, that we called the <italic>distant segments </italic>(DS) kernel.</p></sec><sec><title>Applications</title><p>Bioinformatic methods for predicting HIV phenotypes have been tested in different situations and the concordance is high [<xref ref-type="bibr" rid="B18">18</xref>-<xref ref-type="bibr" rid="B21">21</xref>].</p><p>As described in [<xref ref-type="bibr" rid="B18">18</xref>], current bioinformatics programs are underestimating the use of CXCR4 by dual-tropic viruses in the brain. In [<xref ref-type="bibr" rid="B19">19</xref>], a concordance rate of 91% was obtained between genotypic and phenotypic assays in a clinical setting of 103 patients. In [<xref ref-type="bibr" rid="B20">20</xref>], the authors showed that the SVM with a linear kernel achieves a concordance of 86.5% with the Trofile assay and a concordance of 79.7% with the TRT assay. Recombinant assays (Trofile and TRT) are described in [<xref ref-type="bibr" rid="B20">20</xref>].</p><p>Further improvements in available HIV classifiers could presumably allow the replacement of in vitro phenotypic assays by a combination of sequencing and machine learning to determine the coreceptor usage. DNA sequencing is cheap, machine learning technologies are very accurate whereas phenotypic assays are labor-intensive and take weeks to produce readouts [<xref ref-type="bibr" rid="B13">13</xref>]. Thus, the next generation of bioinformatics programs for the prediction of coreceptor usage promises major improvements in clinical settings.</p></sec></sec><sec sec-type="methods"><title>Methods</title><p>We used the SVM to predict the coreceptor usage of HIV-1 as a function of its protein envelope sequence. The SVM is a discriminative learning algorithm used for binary classification problems. For these problems, we are given a <italic>training set </italic>of <italic>examples</italic>, where each example is labelled as being either <italic>positive </italic>or <italic>negative</italic>. In our case, each example is a string <italic>s </italic>of amino acids. When the binary classification task consists of predicting the usage of CCR5, the label of string <italic>s </italic>is +1 if <italic>s </italic>is the V3 loop of the protein envelope sequence of a HIV-1 virion that uses the CCR5 coreceptor, and -1 otherwise. The same method applies for the prediction of the CXCR4 coreceptor usage. When the binary classification task consists of predicting the capability of utilizing CCR5 and CXCR4 coreceptors, the label of string <italic>s </italic>is +1 if <italic>s </italic>is the V3 loop of the protein envelope sequence of a HIV-1 virion that uses both the CCR5 and CXCR4 coreceptors, and -1 if it is a virion that does not use CCR5 or does not use CXCR4.</p><p>Given a training set of binary labelled examples, each generated according to a fixed (but unknown) distribution <italic>D</italic>, the task of the learning algorithm is to produce a classifier <italic>f </italic>which will be as accurate as possible at predicting the correct class <italic>y </italic>of a test string <italic>s </italic>generated according to <italic>D </italic>(<italic>i.e</italic>., the same distribution that generated the training set). More precisely, if <italic>f </italic>(<italic>s</italic>) denotes the output of classifier <italic>f </italic>on input string <italic>s</italic>, then the task of the learner is to find <italic>f </italic>that minimizes the probability of error <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1742-4690-5-110-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:munder><mml:mrow><mml:mi>Pr</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>~</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:munder><mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02260;</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. A classifier <italic>f </italic>achieving a low probability of error is said to <italic>generalize </italic>well (on examples that are not in the training set).</p><p>To achieve its task, the learning algorithm (or learner) does not have access to the unknown distribution <italic>D</italic>, but only to a limited set of training examples, each generated according to <italic>D</italic>. It is still unknown exactly what is best for the learner to optimize on the training set, but the learning strategy used by the SVM currently provides the best empirical results for many practical binary classification tasks. Given a training set of labelled examples, the learning strategy used by the SVM consists at finding a soft-margin hyperplane [<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B22">22</xref>], in a feature space of high dimensionality, that achieves the appropriate trade-off between the number of training errors and the magnitude of the separating margin realized on the training examples that are correctly classified (see, for example, [<xref ref-type="bibr" rid="B15">15</xref>]).</p><p>In our case, the SVM is used to classify strings of amino acids. The feature space, upon which the separating hyperplane is built, is defined by a mapping from each possible string <italic>s </italic>to a high-dimensional vector <italic>&#x003d5; </italic>(<italic>s</italic>). For example, in the case of the <italic>blended spectrum kernel </italic>[<xref ref-type="bibr" rid="B15">15</xref>], each component <italic>&#x003d5;</italic><sub><italic>&#x003b1; </italic></sub>(<italic>s</italic>) is the frequency of occurrence in <italic>s </italic>of a specific substring <italic>&#x003b1; </italic>that we call a <italic>segment</italic>. The whole vector <italic>&#x003d5; </italic>(<italic>s</italic>) is the collection of all these frequencies for each possible segment of at most <italic>p </italic>symbols. Consequently, vector <italic>&#x003d5; </italic>(<italic>s</italic>) has <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1742-4690-5-110-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:msubsup><mml:mrow><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:msup><mml:mo>|</mml:mo><mml:mi>i</mml:mi></mml:msup></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula> components for an alphabet &#x003a3; containing |&#x003a3;| symbols. If <italic>w </italic>denotes the normal vector of the separating hyperplane, and <italic>b </italic>its bias (which is related to the distance that the hyperplane has from the origin), then the output <italic>f </italic>(<italic>s</italic>) of the SVM classifier, on input string <italic>s</italic>, is given by</p><p><disp-formula><italic>f </italic>(<italic>s</italic>) = sgn (&#x027e8;<italic>w</italic>, <italic>&#x003d5; </italic>(<italic>s</italic>)&#x027e9; + <italic>b</italic>),</disp-formula></p><p>where sgn(<italic>a</italic>) = +1 if <italic>a </italic>&#x0003e; 0 and -1 otherwise, and where &#x027e8;<italic>w</italic>, <italic>&#x003d5; </italic>(<italic>s</italic>)&#x027e9; denotes the inner product between vectors <italic>w </italic>and <italic>&#x003d5; </italic>(<italic>s</italic>). We have &#x027e8;<italic>w</italic>, <italic>&#x003d5; </italic>(<italic>s</italic>)&#x027e9; = <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1742-4690-5-110-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:mo>&#x02329;</mml:mo><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003d5;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x0232a;</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula> for <italic>d</italic>-dimensional vectors. The normal vector <italic>w </italic>is often called the <italic>discriminant </italic>or the <italic>weight vector</italic>.</p><sec><title>Learning in spaces of large dimensionality</title><p>Constructing a separating hyperplane in spaces of very large dimensionality has potentially two serious drawbacks. The first drawback concerns the obvious danger of <italic>overfitting</italic>. Indeed, with so many degrees of freedom for a vector <italic>w </italic>having more components than the number of training examples, there may exist many different <italic>w </italic>having a high probability of error while making very few training errors. However, several theoretical results [<xref ref-type="bibr" rid="B15">15</xref>,<xref ref-type="bibr" rid="B22">22</xref>] indicate that overfitting is unlikely to occur when a large separating margin is found on the (numerous) correctly classified examples &#x02013; thus giving theoretical support to the learning strategy used by the SVM.</p><p>The second potential drawback concerns the computational cost of using very high dimensional feature vectors <italic>&#x003d5; </italic>(<italic>s</italic><sub>1</sub>), <italic>&#x003d5; </italic>(<italic>s</italic><sub>2</sub>),..., <italic>&#x003d5;</italic>(<italic>s</italic><sub><italic>m</italic></sub>) of training examples. As we now demonstrate, this drawback can elegantly be avoided by using <italic>kernels </italic>instead of feature vectors. The basic idea consists of representing the discriminant <italic>w </italic>as a linear combination of the feature vectors of the training examples. More precisely, given a training set {(<italic>s</italic><sub>1</sub>, <italic>y</italic><sub>1</sub>), (<italic>s</italic><sub>2</sub>, <italic>y</italic><sub>2</sub>),..., (<italic>s</italic><sub><italic>m</italic></sub>, <italic>y</italic><sub><italic>m</italic></sub>)} and a mapping <italic>&#x003d5; </italic>(&#x000b7;), we write <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1742-4690-5-110-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>&#x003b1;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>. The set {<italic>&#x003b1;</italic><sub>1</sub>,..., <italic>&#x003b1;</italic><sub><italic>m</italic></sub>} is called the <italic>dual representation </italic>of the (primal) weight vector <italic>w</italic>. Consequently, the inner product &#x027e8;<italic>w</italic>, <italic>&#x003d5; </italic>(<italic>s</italic>)&#x027e9;, used for computing the output of an SVM classifier, becomes</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1742-4690-5-110-i5" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mo>&#x02329;</mml:mo>                           <mml:mi>w</mml:mi>                           <mml:mo>,</mml:mo>                           <mml:mi>&#x003d5;</mml:mi>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>s</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>&#x0232a;</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>i</mml:mi>                                    <mml:mo>=</mml:mo>                                    <mml:mn>1</mml:mn>                                 </mml:mrow>                                 <mml:mi>m</mml:mi>                              </mml:munderover>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>&#x003b1;</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                                 <mml:msub>                                    <mml:mi>y</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                                 <mml:mo>&#x02329;</mml:mo>                                 <mml:mi>&#x003d5;</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:msub>                                    <mml:mi>s</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mo>,</mml:mo>                                 <mml:mi>&#x003d5;</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>s</mml:mi>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mo>&#x0232a;</mml:mo>                              </mml:mrow>                           </mml:mstyle>                           <mml:mo>=</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>i</mml:mi>                                    <mml:mo>=</mml:mo>                                    <mml:mn>1</mml:mn>                                 </mml:mrow>                                 <mml:mi>m</mml:mi>                              </mml:munderover>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>&#x003b1;</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                                 <mml:msub>                                    <mml:mi>y</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                                 <mml:mi>k</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:msub>                                    <mml:mi>s</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                                 <mml:mo>,</mml:mo>                                 <mml:mi>s</mml:mi>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mrow>                           </mml:mstyle>                           <mml:mo>,</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1742-4690-5-110-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:munderover><mml:mo>=</mml:mo><mml:mrow/><mml:mrow><mml:mtext>def</mml:mtext></mml:mrow></mml:munderover><mml:mo>&#x02329;</mml:mo><mml:mi>&#x003d5;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>&#x003d5;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x0232a;</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> defines the <italic>kernel function </italic>associated with the feature map <italic>&#x003d5; </italic>(&#x000b7;). With the dual representation, the SVM classifier is entirely described in terms of the training examples <italic>s</italic><sub><italic>i </italic></sub>having a non-zero value for <italic>&#x003b1;</italic><sub><italic>i</italic></sub>. These examples are called <italic>support vectors</italic>. The so-called "kernel trick" consists of using <italic>k </italic>(<italic>s</italic>, <italic>t</italic>) without explicitly computing &#x027e8;<italic>&#x003d5; </italic>(<italic>s</italic>), <italic>&#x003d5; </italic>(<italic>t</italic>)&#x027e9; &#x02013; a computationally prohibitive task for feature vectors of very large dimensionality. This is possible for many feature maps <italic>&#x003d5; </italic>(&#x000b7;). Consider again, for example, the <italic>blended spectrum </italic>(BS) kernel where each component <italic>&#x003d5;</italic><sub><italic>&#x003b1; </italic></sub>(<italic>s</italic>) is the frequency of occurrence of a segment <italic>&#x003b1; </italic>in string <italic>s </italic>(for all words of at most <italic>p </italic>characters of an alphabet &#x003a3;). In this case, instead of performing <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1742-4690-5-110-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:msubsup><mml:mrow><mml:mo>|</mml:mo><mml:mi>&#x003a3;</mml:mi><mml:msup><mml:mo>|</mml:mo><mml:mi>i</mml:mi></mml:msup></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula> multiplications to compute explicitly &#x027e8;<italic>&#x003d5; </italic>(<italic>s</italic>), <italic>&#x003d5; </italic>(<italic>t</italic>)&#x027e9;, we can compute, for each position <italic>i </italic>in string <italic>s </italic>and each position <italic>j </italic>in string <italic>t</italic>, the number of consecutive symbols that matches in <italic>s </italic>and <italic>t</italic>. We use the big-Oh notation to provide an upper bound to the running time of algorithms. Let <italic>T </italic>(<italic>n</italic>) denote the execution time of an algorithm on an input of size <italic>n</italic>. We say that <italic>T </italic>(<italic>n</italic>) is in <italic>O </italic>(<italic>g </italic>(<italic>n</italic>)) if and only if there exists a constant <italic>c </italic>and a critical <italic>n</italic><sub>0 </sub>such that <italic>T </italic>(<italic>n</italic>) &#x02264; <italic>cg </italic>(<italic>n</italic>) for all <italic>n </italic>&#x02265; <italic>n</italic><sub>0</sub>. The blended spectrum kernel requires at most <italic>O </italic>(<italic>p</italic>&#x000b7;|<italic>s</italic>|&#x000b7;|<italic>t</italic>|) time for each string pair (<italic>s</italic>, <italic>t</italic>) &#x02013; an enormous improvement over the &#x003a9; (|&#x003a3;|<sup><italic>p</italic></sup>) time required for the explicit computation of the inner product between a pair of feature vectors. In fact, there exists an algorithm [<xref ref-type="bibr" rid="B15">15</xref>] for computing the blended spectrum kernel in <italic>O </italic>(<italic>p</italic>&#x000b7;max (|<italic>s</italic>|, |<italic>t</italic>|)) time.</p></sec><sec><title>The distant segments kernel</title><p>The blended spectrum kernel is interesting because it contains all the information concerning the population of segments that are present in a string of symbols without considering their relative positions. Here, we propose the <italic>distant segments </italic>(DS) kernel that, in some sense, extends the BS kernel to include (relative) positional information of segments in a string of symbols.</p><p>If one considers the frequencies of all possible segment distances inside a string as its features, then a precise comparison can be done between any pair of strings. Remote protein homology can be detected using distances between polypeptide segments [<xref ref-type="bibr" rid="B23">23</xref>]. For any string <italic>s </italic>of amino acids, these authors used explicitly a feature vector <italic>&#x003d5; </italic>(<italic>s</italic>) where each component <italic>&#x003d5;</italic><sub><italic>d</italic>, <italic>&#x003b1;</italic>, <italic>&#x003b1;' </italic></sub>(<italic>s</italic>) denotes the number of times the (polypeptide) segment <italic>&#x003b1;' </italic>is located at distance <italic>d </italic>(in units of symbols) following the (polypeptide) segment <italic>&#x003b1;</italic>. They have restricted themselves to the case where <italic>&#x003b1; </italic>and <italic>&#x003b1;' </italic>have the same length <italic>p</italic>, with <italic>p </italic>&#x02264; 3. Since the distance <italic>d </italic>is measured from the first symbol in <italic>&#x003b1; </italic>to the first symbol in <italic>&#x003b1;'</italic>, the <italic>d </italic>= 0 components of <italic>&#x003d5; </italic>(<italic>s</italic>), <italic>i.e</italic>., <italic>&#x003d5;</italic><sub>0,<italic>&#x003b1;</italic>,<italic>&#x003b1;' </italic></sub>(<italic>s</italic>), are non-zero only for <italic>&#x003b1; </italic>= <italic>&#x003b1;' </italic>and represent the number of occurrences of segment <italic>&#x003b1; </italic>in string <italic>s</italic>. Consequently, this feature vector strictly includes all the components of the feature vector associated with the BS kernel but is limited to segments of size <italic>p </italic>(for <italic>p </italic>&#x02264; 3). By working with the explicit feature vectors, these authors were able to obtain easily the components of the discriminant vector <italic>w </italic>that are largest in magnitude and, consequently, are the most relevant for the binary classification task. However, the memory requirement of their algorithm increases exponentialy in <italic>p</italic>. Not surprisingly, only the results for <italic>p </italic>&#x02264; 3 were reported by [<xref ref-type="bibr" rid="B23">23</xref>].</p><p>Despite these limitations, the results of [<xref ref-type="bibr" rid="B23">23</xref>] clearly show the relevance of having features representing the frequency of occurrences of pairs of segments that are separated by some distance for protein remote homology detection. Hence, we propose in this section the <italic>distance segments </italic>(DS) kernel that potentially includes all the features considered by [<xref ref-type="bibr" rid="B23">23</xref>] without limiting ourselves to <italic>p </italic>&#x02264; 3 and to the case where the words (or segments) have to be of the same length. Indeed, we find no obvious biological motivation for these restrictions. Also, as we will show, there is no loss of interpretability of the results by using a kernel instead of the feature vectors. In particular, we can easily obtain the most significant components of the discriminant <italic>w </italic>by using a kernel. We will show that the time and space required for computing the kernel matrix and obtaining the most significant components of the discriminant <italic>w </italic>are bounded polynomially in terms of all the relevant parameters.</p><p>Consider a protein as a string of symbols from the alphabet &#x003a3; of amino acids. &#x003a3;* represents the set of all finite strings (including the empty string). For <italic>&#x003bc; </italic>&#x02208; &#x003a3;*, |<italic>&#x003bc;</italic>| denotes the length of the string <italic>&#x003bc;</italic>. Throughout the paper, <italic>s</italic>, <italic>t</italic>, <italic>&#x003b1;</italic>, <italic>&#x003bc; </italic>and <italic>&#x003bd; </italic>will denote strings of &#x003a3;*, whereas <italic>&#x003b8; </italic>and <italic>&#x003b4; </italic>will be lengths of such strings. Moreover, <italic>&#x003bc; &#x003bd; </italic>will denote the concatenation of <italic>&#x003bc; </italic>and <italic>&#x003bd;</italic>. The DS kernel is based on the following set. Given a string <italic>s</italic>, let <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1742-4690-5-110-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mi>&#x003b1;</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>&#x003b1;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup></mml:mrow><mml:mi>&#x003b4;</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> be the set of all the occurrences of substrings of length <italic>&#x003b4; </italic>that are beginning by segment <italic>&#x003b1; </italic>and ending by segment <italic>&#x003b1;'</italic>. More precisely,</p><p><disp-formula id="bmcM1"><label>(1)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1742-4690-5-110-i8" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msubsup>                              <mml:mi mathvariant="script">S</mml:mi>                              <mml:mrow>                                 <mml:mi>&#x003b1;</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:msup>                                    <mml:mi>&#x003b1;</mml:mi>                                    <mml:mo>&#x02032;</mml:mo>                                 </mml:msup>                              </mml:mrow>                              <mml:mi>&#x003b4;</mml:mi>                           </mml:msubsup>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>s</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:munderover>                              <mml:mo>=</mml:mo>                              <mml:mrow/>                              <mml:mrow>                                 <mml:mtext>def</mml:mtext>                              </mml:mrow>                           </mml:munderover>                           <mml:mo>{</mml:mo>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>&#x003bc;</mml:mi>                           <mml:mo>,</mml:mo>                           <mml:mi>&#x003b1;</mml:mi>                           <mml:mo>,</mml:mo>                           <mml:mi>&#x003bd;</mml:mi>                           <mml:mo>,</mml:mo>                           <mml:msup>                              <mml:mi>&#x003b1;</mml:mi>                              <mml:mo>&#x02032;</mml:mo>                           </mml:msup>                           <mml:mo>,</mml:mo>                           <mml:msup>                              <mml:mi>&#x003bc;</mml:mi>                              <mml:mo>&#x02032;</mml:mo>                           </mml:msup>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>:</mml:mo>                           <mml:mi>s</mml:mi>                           <mml:mo>=</mml:mo>                           <mml:mi>&#x003bc;</mml:mi>                           <mml:mi>&#x003b1;</mml:mi>                           <mml:mi>&#x003bd;</mml:mi>                           <mml:msup>                              <mml:mi>&#x003b1;</mml:mi>                              <mml:mo>&#x02032;</mml:mo>                           </mml:msup>                           <mml:msup>                              <mml:mi>&#x003bc;</mml:mi>                              <mml:mo>&#x02032;</mml:mo>                           </mml:msup>                           <mml:mo>&#x02227;</mml:mo>                           <mml:mn>1</mml:mn>                           <mml:mo>&#x02264;</mml:mo>                           <mml:mo>|</mml:mo>                           <mml:mi>&#x003b1;</mml:mi>                           <mml:mo>|</mml:mo>                           <mml:mo>&#x02227;</mml:mo>                           <mml:mn>1</mml:mn>                           <mml:mo>&#x02264;</mml:mo>                           <mml:mo>|</mml:mo>                           <mml:msup>                              <mml:mi>&#x003b1;</mml:mi>                              <mml:mo>&#x02032;</mml:mo>                           </mml:msup>                           <mml:mo>|</mml:mo>                           <mml:mo>&#x02227;</mml:mo>                           <mml:mn>0</mml:mn>                           <mml:mo>&#x02264;</mml:mo>                           <mml:mo>|</mml:mo>                           <mml:mi>&#x003bd;</mml:mi>                           <mml:mo>|</mml:mo>                           <mml:mo>&#x02227;</mml:mo>                           <mml:mi>&#x003b4;</mml:mi>                           <mml:mo>=</mml:mo>                           <mml:mo>|</mml:mo>                           <mml:mi>s</mml:mi>                           <mml:mo>|</mml:mo>                           <mml:mo>&#x02212;</mml:mo>                           <mml:mo>|</mml:mo>                           <mml:mi>&#x003bc;</mml:mi>                           <mml:mo>|</mml:mo>                           <mml:mo>&#x02212;</mml:mo>                           <mml:mo>|</mml:mo>                           <mml:msup>                              <mml:mi>&#x003bc;</mml:mi>                              <mml:mo>&#x02032;</mml:mo>                           </mml:msup>                           <mml:mo>|</mml:mo>                           <mml:mo>}</mml:mo>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>Note that the substring length <italic>&#x003b4; </italic>is related to the distance <italic>d </italic>of [<xref ref-type="bibr" rid="B23">23</xref>] by <italic>&#x003b4; </italic>= <italic>d </italic>+ |<italic>&#x003b1;'</italic>| where <italic>d </italic>= |<italic>&#x003b1;</italic>| + |<italic>&#x003bd;</italic>| when |<italic>&#x003b1;</italic>| and |<italic>&#x003b1;'</italic>| do not overlap. Note also that, in contrast with [<xref ref-type="bibr" rid="B23">23</xref>], we may have |<italic>&#x003b1;</italic>| &#x02260; |<italic>&#x003b1;'</italic>|. Moreover, the segments <italic>&#x003b1; </italic>and <italic>&#x003b1;' </italic>never overlap since <italic>&#x003bc;&#x003b1;&#x003bd;&#x003b1;' &#x003bc;' </italic>equals to the whole string <italic>s </italic>and 0 &#x02264; |<italic>&#x003bd;</italic>|. We have made this choice because it appeared biologically more plausible to have a distance ranging from the end of the first segment to the beginning of the second segment. Nevertheless, we will see shortly that we can include the possibility of overlap between segments with a very minor modification of the kernel.</p><p>The DS kernel is defined by the following inner product</p><p><disp-formula id="bmcM2"><label>(2)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1742-4690-5-110-i9" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msubsup>                              <mml:mi>k</mml:mi>                              <mml:mrow>                                 <mml:mi>D</mml:mi>                                 <mml:mi>S</mml:mi>                              </mml:mrow>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>&#x003b4;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                                 <mml:mo>,</mml:mo>                                 <mml:msub>                                    <mml:mi>&#x003b8;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                              </mml:mrow>                           </mml:msubsup>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>s</mml:mi>                           <mml:mo>,</mml:mo>                           <mml:mi>t</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:munderover>                              <mml:mo>=</mml:mo>                              <mml:mrow/>                              <mml:mrow>                                 <mml:mtext>def</mml:mtext>                              </mml:mrow>                           </mml:munderover>                           <mml:mo>&#x02329;</mml:mo>                           <mml:msubsup>                              <mml:mi>&#x003d5;</mml:mi>                              <mml:mrow>                                 <mml:mi>D</mml:mi>                                 <mml:mi>S</mml:mi>                              </mml:mrow>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>&#x003b4;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                                 <mml:mo>,</mml:mo>                                 <mml:msub>                                    <mml:mi>&#x003b8;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                              </mml:mrow>                           </mml:msubsup>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>s</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>,</mml:mo>                           <mml:msubsup>                              <mml:mi>&#x003d5;</mml:mi>                              <mml:mrow>                                 <mml:mi>D</mml:mi>                                 <mml:mi>S</mml:mi>                              </mml:mrow>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>&#x003b4;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                                 <mml:mo>,</mml:mo>                                 <mml:msub>                                    <mml:mi>&#x003b8;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                              </mml:mrow>                           </mml:msubsup>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>t</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>&#x0232a;</mml:mo>                           <mml:mo>,</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1742-4690-5-110-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>&#x003d5;</mml:mi><mml:mrow><mml:mi>D</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> is the feature vector</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1742-4690-5-110-i11" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msubsup>                              <mml:mi>&#x003d5;</mml:mi>                              <mml:mrow>                                 <mml:mi>D</mml:mi>                                 <mml:mi>S</mml:mi>                              </mml:mrow>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>&#x003b4;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                                 <mml:mo>,</mml:mo>                                 <mml:msub>                                    <mml:mi>&#x003b8;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                              </mml:mrow>                           </mml:msubsup>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>s</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:munderover>                              <mml:mo>=</mml:mo>                              <mml:mrow/>                              <mml:mrow>                                 <mml:mtext>def</mml:mtext>                              </mml:mrow>                           </mml:munderover>                           <mml:msub>                              <mml:mrow>                                 <mml:mrow>                                    <mml:mo>(</mml:mo>                                    <mml:mrow>                                       <mml:mrow>                                          <mml:mo>|</mml:mo>                                          <mml:mrow>                                             <mml:msubsup>                                                <mml:mi mathvariant="script">S</mml:mi>                                                <mml:mrow>                                                   <mml:mi>&#x003b1;</mml:mi>                                                   <mml:mo>,</mml:mo>                                                   <mml:msup>                                                      <mml:mi>&#x003b1;</mml:mi>                                                      <mml:mo>&#x02032;</mml:mo>                                                   </mml:msup>                                                </mml:mrow>                                                <mml:mi>&#x003b4;</mml:mi>                                             </mml:msubsup>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mi>s</mml:mi>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                          <mml:mo>|</mml:mo>                                       </mml:mrow>                                    </mml:mrow>                                    <mml:mo>)</mml:mo>                                 </mml:mrow>                              </mml:mrow>                              <mml:mrow>                                 <mml:mo>{</mml:mo>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>&#x003b4;</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>&#x003b1;</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:msup>                                    <mml:mi>&#x003b1;</mml:mi>                                    <mml:mo>&#x02032;</mml:mo>                                 </mml:msup>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mo>:</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo>&#x02264;</mml:mo>                                 <mml:mo>|</mml:mo>                                 <mml:mi>&#x003b1;</mml:mi>                                 <mml:mo>|</mml:mo>                                 <mml:mo>&#x02264;</mml:mo>                                 <mml:msub>                                    <mml:mi>&#x003b8;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                                 <mml:mo>&#x02227;</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo>&#x02264;</mml:mo>                                 <mml:mo>|</mml:mo>                                 <mml:msup>                                    <mml:mi>&#x003b1;</mml:mi>                                    <mml:mo>&#x02032;</mml:mo>                                 </mml:msup>                                 <mml:mo>|</mml:mo>                                 <mml:mo>&#x02264;</mml:mo>                                 <mml:msub>                                    <mml:mi>&#x003b8;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                                 <mml:mo>&#x02227;</mml:mo>                                 <mml:mo>|</mml:mo>                                 <mml:mi>&#x003b1;</mml:mi>                                 <mml:mo>|</mml:mo>                                 <mml:mo>+</mml:mo>                                 <mml:mo>|</mml:mo>                                 <mml:msup>                                    <mml:mi>&#x003b1;</mml:mi>                                    <mml:mo>&#x02032;</mml:mo>                                 </mml:msup>                                 <mml:mo>|</mml:mo>                                 <mml:mo>&#x02264;</mml:mo>                                 <mml:mi>&#x003b4;</mml:mi>                                 <mml:mo>&#x02264;</mml:mo>                                 <mml:msub>                                    <mml:mi>&#x003b4;</mml:mi>                                    <mml:mi>m</mml:mi>                                 </mml:msub>                                 <mml:mo>}</mml:mo>                              </mml:mrow>                           </mml:msub>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>Hence, the kernel is computed for a fixed maximum value <italic>&#x003b8;</italic><sub><italic>m </italic></sub>of segment sizes and a fixed maximum value <italic>&#x003b4;</italic><sub><italic>m </italic></sub>of substring length. Note that, the number of strings of size <italic>&#x003b8; </italic>of &#x003a3;* grows exponentially with respect to <italic>&#x003b8;</italic>. Fortunately, we are able to avoid this potentially devastating combinatorial explosion in our computation of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1742-4690-5-110-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>k</mml:mi><mml:mrow><mml:mi>D</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. Figure <xref ref-type="fig" rid="F1">1</xref> shows the pseudo-code of the algorithm. In the pseudo-code, <italic>s </italic>[<italic>i</italic>] denotes the symbol located at position <italic>i </italic>in the string <italic>s </italic>(with <italic>i </italic>&#x02208; {1, 2,..., |<italic>s</italic>|}). Moreover, for any integers <italic>i</italic>, <italic>j</italic>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1742-4690-5-110-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>j</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>i</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> denotes <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1742-4690-5-110-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mrow><mml:mi>j</mml:mi><mml:mo>!</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>!</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>!</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula> if 0 &#x02264; <italic>i </italic>&#x02264; <italic>j</italic>, and 0 otherwise. Admittedly, it is certainly not clear that the algorithm of Figure <xref ref-type="fig" rid="F1">1</xref> actually computes the value of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1742-4690-5-110-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>k</mml:mi><mml:mrow><mml:mi>D</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> given by Equation 2. Hence, a proof of correctness of this algorithm is presented at the appendix (located after the conclusion). The worst-case running time is easy to obtain because the algorithm is essentially composed of three imbricated loops: one for <italic>j</italic><sub><italic>s </italic></sub>&#x02208; {0,..., |<italic>s</italic>|-1}, one for <italic>j</italic><sub><italic>t </italic></sub>&#x02208; {0,..., |<italic>t</italic>|-1}, and one for <italic>i </italic>&#x02208; {1,..., min(|<italic>s</italic>|, |<italic>t</italic>|, <italic>&#x003b4;</italic><sub><italic>m</italic></sub>)}. The time complexity is therefore in <italic>O </italic>(|<italic>s</italic>|&#x000b7;|<italic>t</italic>|&#x000b7;min(|<italic>s</italic>|, |<italic>t</italic>|, <italic>&#x003b4;</italic><sub><italic>m</italic></sub>)).</p><fig position="float" id="F1"><label>Figure 1</label><caption><p>The algorithm for computing <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17" name="1742-4690-5-110-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>k</mml:mi><mml:mrow><mml:mi>D</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>.</p></caption><graphic xlink:href="1742-4690-5-110-1"/></fig><p>Note that the definition of the DS-kernel can be easily modified in order to accept overlaps between <italic>&#x003b1; </italic>and <italic>&#x003b1;'</italic>. Indeed, when overlaps are permitted, they can only occur when both <italic>&#x003b1; </italic>and <italic>&#x003b1;' </italic>start and end in {<italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>0</sub>,..., <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>1</sub>-1}. The number of elements of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18" name="1742-4690-5-110-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> for which <italic>i</italic><sub>2<italic>r </italic></sub>&#x02264; <italic>&#x003b4; </italic>&#x0003c;<italic>i</italic><sub>2<italic>r</italic>+1 </sub>is thus the same for all values of <italic>r</italic>, including <italic>r </italic>= 0. Consequently, the algorithm to compute the DS kernel, when overlaps are permitted, is the same as the one in Figure <xref ref-type="fig" rid="F1">1</xref> except that we need the replace the last two lines of the FOR loop, involved in the computation of <italic>c</italic>, by the single line:</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19" name="1742-4690-5-110-i16" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>c</mml:mi>                           <mml:mo>&#x02190;</mml:mo>                           <mml:mi>c</mml:mi>                           <mml:mo>+</mml:mo>                           <mml:mi>min</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:msub>                              <mml:mi>&#x003b8;</mml:mi>                              <mml:mi>m</mml:mi>                           </mml:msub>                           <mml:mo>,</mml:mo>                           <mml:msub>                              <mml:mi>i</mml:mi>                              <mml:mn>1</mml:mn>                           </mml:msub>                           <mml:mo>&#x02212;</mml:mo>                           <mml:msub>                              <mml:mi>i</mml:mi>                              <mml:mn>0</mml:mn>                           </mml:msub>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>&#x022c5;</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>r</mml:mi>                                    <mml:mo>=</mml:mo>                                    <mml:mn>0</mml:mn>                                 </mml:mrow>                                 <mml:mi>k</mml:mi>                              </mml:munderover>                              <mml:mrow>                                 <mml:mrow>                                    <mml:mo>(</mml:mo>                                    <mml:mrow>                                       <mml:mrow>                                          <mml:mo>(</mml:mo>                                          <mml:mrow>                                             <mml:mtable>                                                <mml:mtr>                                                   <mml:mtd>                                                      <mml:mrow>                                                         <mml:msub>                                                            <mml:mi>l</mml:mi>                                                            <mml:mi>r</mml:mi>                                                         </mml:msub>                                                      </mml:mrow>                                                   </mml:mtd>                                                </mml:mtr>                                                <mml:mtr>                                                   <mml:mtd>                                                      <mml:mn>2</mml:mn>                                                   </mml:mtd>                                                </mml:mtr>                                             </mml:mtable>                                          </mml:mrow>                                          <mml:mo>)</mml:mo>                                       </mml:mrow>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mrow>                                          <mml:mo>(</mml:mo>                                          <mml:mrow>                                             <mml:mtable>                                                <mml:mtr>                                                   <mml:mtd>                                                      <mml:mrow>                                                         <mml:msub>                                                            <mml:mi>l</mml:mi>                                                            <mml:mi>r</mml:mi>                                                         </mml:msub>                                                         <mml:mo>&#x02212;</mml:mo>                                                         <mml:msub>                                                            <mml:mi>&#x003b8;</mml:mi>                                                            <mml:mi>m</mml:mi>                                                         </mml:msub>                                                      </mml:mrow>                                                   </mml:mtd>                                                </mml:mtr>                                                <mml:mtr>                                                   <mml:mtd>                                                      <mml:mn>2</mml:mn>                                                   </mml:mtd>                                                </mml:mtr>                                             </mml:mtable>                                          </mml:mrow>                                          <mml:mo>)</mml:mo>                                       </mml:mrow>                                    </mml:mrow>                                    <mml:mo>)</mml:mo>                                 </mml:mrow>                              </mml:mrow>                           </mml:mstyle>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>Similar simple modifications can be performed for the more restrictive case of |<italic>&#x003b1;</italic>| = |<italic>&#x003b1;'</italic>|.</p></sec><sec><title>Extracting the discriminant vector with the distant segments kernel</title><p>We now show how to extract (with reasonable time and space resources) the components of the discriminant <italic>w </italic>that are non-zero. Recall that <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20" name="1742-4690-5-110-i17" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>l</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>&#x003b1;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula> when the SVM contains <italic>l </italic>support vectors {(<italic>s</italic><sub>1</sub>, <italic>y</italic><sub>1</sub>),..., (<italic>s</italic><sub><italic>l</italic></sub>, <italic>y</italic><sub><italic>l</italic></sub>)}. Recall also that each feature <italic>&#x003d5;</italic><sub><italic>&#x003b4;</italic>, <italic>&#x003b1;</italic>, <italic>&#x003b1;' </italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>) is identified by a triplet (<italic>&#x003b4;</italic>, <italic>&#x003b1;</italic>, <italic>&#x003b1;'</italic>), with <italic>&#x003b4; </italic>&#x02265; |<italic>&#x003b1;</italic>| + |<italic>&#x003b1;'</italic>|. Hence, to obtain the non-zero valued components of <italic>w</italic>, we first obtain the non-zero valued features <italic>&#x003d5;</italic><sub><italic>&#x003b4;</italic>, <italic>&#x003b1;</italic>, <italic>&#x003b1;' </italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>) from each support vector (with Algorithm EXTRACT-FEATURES of Figure <xref ref-type="fig" rid="F2">2</xref>) and then collect and merge every feature of each support vector by multiplying each of them by <italic>&#x003b1;</italic><sub><italic>i</italic></sub><italic>y</italic><sub><italic>i </italic></sub>(with Algorithm EXTRACT-DISCRIMINANT of Figure <xref ref-type="fig" rid="F3">3</xref>).</p><fig position="float" id="F2"><label>Figure 2</label><caption><p>The algorithm for extracting the features of a string <italic>s </italic>into a Map. Here, <italic>s </italic>(<italic>i </italic>: <italic>j</italic>) denotes the substring of <italic>s </italic>starting at position <italic>i </italic>and ending at position <italic>j</italic>.</p></caption><graphic xlink:href="1742-4690-5-110-2"/></fig><fig position="float" id="F3"><label>Figure 3</label><caption><p>The algorithm for merging every feature from the set <italic>S </italic>= {(<italic>s</italic><sub>1</sub>, <italic>y</italic><sub>1</sub>), (<italic>s</italic><sub>2</sub>, <italic>y</italic><sub>2</sub>), ..., (<italic>s</italic><sub><italic>l</italic></sub>, <italic>y</italic><sub><italic>l</italic></sub>)} of all support vectors into a Map representing the discriminant <italic>w</italic>.</p></caption><graphic xlink:href="1742-4690-5-110-3"/></fig><p>We transform each support vector <italic>&#x003d5; </italic>(<italic>s</italic><sub><italic>i</italic></sub>) into a <italic>Map </italic>of features. Each <italic>Map key </italic>is an identifier for a (<italic>&#x003b4;</italic>, <italic>&#x003b1;</italic>, <italic>&#x003b1;'</italic>) having <italic>&#x003d5;</italic><sub><italic>&#x003b4;</italic>, <italic>&#x003b1;</italic>, <italic>&#x003b1;' </italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>) &#x0003e; 0. The <italic>Map value </italic>is given by <italic>&#x003d5;</italic><sub><italic>&#x003b4;</italic>, <italic>&#x003b1;</italic>, <italic>&#x003b1;'</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>) for each key.</p><p>The worst-case access time for an AVL-tree-Map of <italic>n </italic>elements is <italic>O </italic>(log <italic>n</italic>). Hence, from Figure <xref ref-type="fig" rid="F2">2</xref>, the time complexity of extracting all the (non-zero valued) features of a support vector is in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M21" name="1742-4690-5-110-i18" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. Moreover, since the total number of features inserted to the Map by the algorithm EXTRACT-DISCRIMINANT is at most <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M22" name="1742-4690-5-110-i19" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>l</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo>&#x022c5;</mml:mo><mml:msubsup><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, the time complexity of extracting all the non-zero valued components of <italic>w </italic>is in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M23" name="1742-4690-5-110-i20" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>.</p></sec><sec><title>SVM</title><p>We have used a publicly available SVM software, named SVM<sup>light </sup>[<xref ref-type="bibr" rid="B24">24</xref>], for predicting the coreceptor usage. Learning SVM classifier requires to choose the right trade-off between training accuracy and the magnitude of the separating margin on the correctly classified examples. This trade-off is generally captured by a so-called soft-margin hyperparameter <italic>C</italic>.</p><p>The learner must choose the value of <italic>C </italic>from the training set only &#x02013; the testing set must be used only for estimating the performance of the final classifier. We have used the (well-known) 10-fold cross-validation method (on the training set) to determine the best value of <italic>C </italic>and the best values of the kernel hyperparameters (that we describe below). Once the values of all the hyperparameters were found, we used these values to train the final SVM classifier on the whole training set.</p></sec><sec><title>Selected metrics</title><p>The testing of the final SVM classifier was done according to several metrics. Let P and N denote, respectively, the number of positive examples and the number of negative examples in the test set. Let TP, the number of "true positives", denote the number of positive testing examples that are classified (by the SVM) as positive. A similar definition applies to TN, the number of "true negatives". Let FP, the number of "false positives", denote the number of negative testing examples that are classified as positive. A similar definition applied to FN, the number of "false negatives". To quantify the "fitness" of the final SVM classifier, we have computed the <italic>accuracy</italic>, which is (TP+TN)/(P+T), the <italic>sensitivity</italic>, which is TP/P, and the specificity, which is TN/N. Finally, for those who cannot decide how much to weight the cost of a false positive, in comparison with a false negative, we have computed the "area under the ROC curve" as described by [<xref ref-type="bibr" rid="B25">25</xref>].</p><p>Unlike the other metrics, the accuracy (which is 1 &#x02013; the testing error) has the advantage of having very tight confidence intervals that can be computed straightforwardly from the binomial tail inversion, as described by [<xref ref-type="bibr" rid="B26">26</xref>]. We have used this method to find if whether or not the observed difference of testing accuracy (between two classifiers) was statistically significant. We have reported the results only when a statistically significant difference was observed with a 90% confidence level.</p></sec><sec><title>Selected string kernels</title><p>One of the kernel used was the blended spectrum (BS) kernel that we have described above. Recall that the feature space, for this kernel, is the count of all <italic>k</italic>-mers with 1 &#x02264; <italic>k </italic>&#x02264; <italic>p</italic>. Hence <italic>p </italic>is the sole hyperparameter of this kernel.</p><p>We have also used the local alignment (LA) kernel [<xref ref-type="bibr" rid="B16">16</xref>] which can be thought of as a soft-max version of the Smith-Waterman local alignment algorithm for pair of sequences. Indeed, instead of considering the alignment that maximizes the Smith-Waterman (SW) score, the LA kernel considers every local alignment with a Gibbs distribution that depends on its SW score. Unfortunately, the LA kernel has too many hyperparameters precluding their optimization by cross-validation. Hence, a number of choices were made based on the results of [<xref ref-type="bibr" rid="B16">16</xref>]. Namely, the alignment parameters were set to (BLOSUM 62, <italic>e </italic>= 11, <italic>d </italic>= 1) and the empirical kernel map of the LA kernel was used. The hyperparameter <italic>&#x003b2; </italic>was the only one that was adjusted by cross-validation.</p><p>Of course, the proposed distant segments (DS) kernel was also tested. The <italic>&#x003b8;</italic><sub><italic>m </italic></sub>hyperparameter was set to <italic>&#x003b4;</italic><sub><italic>m </italic></sub>to avoid the limitation of segment length. Hence, <italic>&#x003b4;</italic><sub><italic>m </italic></sub>was the sole hyperparameter for this kernel that was optimized by cross-validation.</p><p>Other interesting kernels, not considered here because they yielded inferior results (according to [<xref ref-type="bibr" rid="B16">16</xref>], and [<xref ref-type="bibr" rid="B23">23</xref>]) on the remote protein homology detection problem, include the mismatch kernel [<xref ref-type="bibr" rid="B27">27</xref>] and the pairwise kernel [<xref ref-type="bibr" rid="B28">28</xref>].</p></sec><sec><title>Datasets</title><p>The V3 loop sequence and coreceptor usage of HIV-1 samples were retrieved from Los Alamos National Laboratory HIV Databases <ext-link ext-link-type="uri" xlink:href="http://www.hiv.lanl.gov/"/> through available online forms.</p><p>Every sample had a unique GENBANK identifier. Sequences containing #, $ or * were eliminated from the dataset. The signification of these symbols was reported by Brian Foley of Los Alamos National Laboratory (personal communication). The # character indicates that the codon could not be translated, either because it had a gap character in it (a frame-shifting deletion in the virus RNA), or an ambiguity code (such as R for purine). The $ and * symbols represent a stop codon in the RNA sequence. TAA, TGA or TAG are stop codons. The dataset was first shuffled and then splitted half-half, yielding a training and a testing set. The decision to shuffle the dataset was made to increase the probability that both the training and testing examples are obtained from the same distribution. The decision to use half of the dataset for testing was made in order to obtain tight confidence intervals for accuracy.</p><p>Samples having the same V3 loop sequence and a different coreceptor usage label are called <italic>contradictions</italic>. Contradictions were kept in the datasets to have prediction performances that take into account the biological reality of dual tropism for which frontiers are not well defined.</p><p>Statistics were compiled for the coreceptor usage distribution, the count of contradictions, the amount of samples in each clades and the distribution of the V3 loop length.</p></sec></sec><sec><title>Results</title><p>Here we report statistics on our datasets, namely the distribution, contradictions, subtypes and the varying lengths. We also show the results of our classifiers on the HIV-1 coreceptor usage prediction task, a brief summary of existing methods and an analysis of the discriminant vector with the distant segments kernel.</p><sec><title>Statistics</title><p>In Table <xref ref-type="table" rid="T1">1</xref> is reported the distribution of coreceptor usages in the datasets created from Los Alamos National Laboratory HIV Databases data. In the training set, there are 1225 CCR5-utilizing samples (85.9%), 375 CXCR4-utilizing samples (26.3%) and 175 CCR5-and-CXCR4-utilizing samples (12.2%). The distribution is approximatly the same in the test set. There are contradictions (entries with the same V3 sequence and a different coreceptor usage) in all classes of our datasets. A majority of viruses can use CCR5 in our datasets.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Datasets. Contradictions are in parenthesis.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Coreceptor usage</td><td align="center" colspan="3">Training set</td><td align="center" colspan="3">Test set</td></tr><tr><td></td><td align="left">Negative examples</td><td align="left">Positive examples</td><td align="left">Total</td><td align="left">Negative examples</td><td align="left">Positive examples</td><td align="left">Total</td></tr></thead><tbody><tr><td align="left">CCR5</td><td align="left">200 (13)</td><td align="left">1225 (12)</td><td align="left">1425 (25)</td><td align="left">225 (22)</td><td align="left">1200 (16)</td><td align="left">1425 (38)</td></tr><tr><td align="left">CXCR4</td><td align="left">1050 (44)</td><td align="left">375 (18)</td><td align="left">1425 (62)</td><td align="left">1027 (28)</td><td align="left">398 (21)</td><td align="left">1425 (38)</td></tr><tr><td align="left">CCR5 and CXCR4</td><td align="left">1250 (57)</td><td align="left">175 (30)</td><td align="left">1425 (87)</td><td align="left">1252 (48)</td><td align="left">173 (35)</td><td align="left">1425 (83)</td></tr></tbody></table></table-wrap><p>In Table <xref ref-type="table" rid="T2">2</xref>, the count is reported regarding HIV-1 subtypes, also known as genetic clades. HIV-1 subtype B is the most numerous in our datasets. The clade information is not an attribute that we provided to our classifiers, we only built our method on the primary structure of the V3 loop. Therefore, our method is independant of the clades.</p><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>HIV-1 subtypes.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Subtype</td><td align="left">Training set</td><td align="left">Test set</td><td align="left">Total</td></tr></thead><tbody><tr><td align="left">A</td><td align="left">39</td><td align="left">46</td><td align="left">85</td></tr><tr><td align="left">B</td><td align="left">955</td><td align="left">943</td><td align="left">1898</td></tr><tr><td align="left">C</td><td align="left">168</td><td align="left">149</td><td align="left">317</td></tr><tr><td align="left">02_AG</td><td align="left">12</td><td align="left">15</td><td align="left">27</td></tr><tr><td align="left">O</td><td align="left">11</td><td align="left">11</td><td align="left">22</td></tr><tr><td align="left">D</td><td align="left">69</td><td align="left">95</td><td align="left">164</td></tr><tr><td align="left">A1</td><td align="left">25</td><td align="left">18</td><td align="left">43</td></tr><tr><td align="left">AG</td><td align="left">5</td><td align="left">5</td><td align="left">10</td></tr><tr><td align="left">01_AE</td><td align="left">97</td><td align="left">106</td><td align="left">203</td></tr><tr><td align="left">G</td><td align="left">7</td><td align="left">7</td><td align="left">14</td></tr><tr><td align="left">Others</td><td align="left">37</td><td align="left">30</td><td align="left">67</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="left">Total</td><td align="left">1425</td><td align="left">1425</td><td align="left">2850</td></tr></tbody></table></table-wrap><p>The V3 loops have variable lengths among the virions of a population. In our dataset (Table <xref ref-type="table" rid="T3">3</xref>), the majority of sequences has exactly 36 residues, although the length ranges from 31 to 40.</p><table-wrap position="float" id="T3"><label>Table 3</label><caption><p>Sequence length distribution. The minimum length is 31 residues and the maximum length is 40 residues.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Residues</td><td align="left">Training set</td><td align="left">Test set</td><td align="left">Total</td></tr></thead><tbody><tr><td align="left">31</td><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">32</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">33</td><td align="left">2</td><td align="left">2</td><td align="left">4</td></tr><tr><td align="left">34</td><td align="left">18</td><td align="left">22</td><td align="left">40</td></tr><tr><td align="left">35</td><td align="left">210</td><td align="left">189</td><td align="left">399</td></tr><tr><td align="left">36</td><td align="left">1142</td><td align="left">1162</td><td align="left">2304</td></tr><tr><td align="left">37</td><td align="left">30</td><td align="left">31</td><td align="left">61</td></tr><tr><td align="left">38</td><td align="left">11</td><td align="left">10</td><td align="left">21</td></tr><tr><td align="left">39</td><td align="left">11</td><td align="left">8</td><td align="left">19</td></tr><tr><td align="left">40</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="left">Total</td><td align="left">1425</td><td align="left">1425</td><td align="left">2850</td></tr></tbody></table></table-wrap></sec><sec><title>Coreceptor usage predictions</title><p>Classification results on the three different tasks (CCR5, CXCR4, CCR5-and-CXCR4) are presented in Table <xref ref-type="table" rid="T4">4</xref> for three different kernels.</p><table-wrap position="float" id="T4"><label>Table 4</label><caption><p>Classification results on the test sets. Accuracy, specificity and sensitivity are defined in Methods. See [<xref ref-type="bibr" rid="B25">25</xref>] for a description of the ROC area.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Coreceptor usage</td><td align="left">SVM parameter C</td><td align="left">Kernel parameter</td><td align="left">Support vectors</td><td align="left">Accuracy</td><td align="left">Specificity</td><td align="left">Sensitivity</td><td align="left">ROC area</td></tr></thead><tbody><tr><td align="left"><bold>Blended spectrum kernel</bold></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">CCR5</td><td align="left">0.04</td><td align="left">3</td><td align="left">204</td><td align="left">96.63%</td><td align="left">85.33%</td><td align="left">98.75%</td><td align="left">98.68%</td></tr><tr><td align="left">CXCR4</td><td align="left">0.7</td><td align="left">9</td><td align="left">392</td><td align="left">93.68%</td><td align="left">96.00%</td><td align="left">87.68%</td><td align="left">96.59%</td></tr><tr><td align="left">CCR5 and CXCR4</td><td align="left">2</td><td align="left">15</td><td align="left">430</td><td align="left">94.38%</td><td align="left">98.16%</td><td align="left">67.05%</td><td align="left">90.16%</td></tr><tr><td colspan="8"><hr></hr></td></tr><tr><td align="left"><bold>Local alignment kernel</bold></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">CCR5</td><td align="left">9</td><td align="left">1</td><td align="left">200</td><td align="left">96.42%</td><td align="left">87.55%</td><td align="left">98.08%</td><td align="left">98.12%</td></tr><tr><td align="left">CXCR4</td><td align="left">0.02</td><td align="left">0.05</td><td align="left">321</td><td align="left">92.21%</td><td align="left">97.56%</td><td align="left">78.39%</td><td align="left">95.11%</td></tr><tr><td align="left">CCR5 and CXCR4</td><td align="left">0.5</td><td align="left">0.1</td><td align="left">399</td><td align="left">92.28%</td><td align="left">97.20%</td><td align="left">56.64%</td><td align="left">87.49%</td></tr><tr><td colspan="8"><hr></hr></td></tr><tr><td align="left"><bold>Distant segments kernel</bold></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">CCR5</td><td align="left">0.4</td><td align="left">30</td><td align="left">533</td><td align="left">96.35%</td><td align="left">83.55%</td><td align="left">98.75%</td><td align="left">98.95%</td></tr><tr><td align="left">CXCR4</td><td align="left">0.0001</td><td align="left">30</td><td align="left">577</td><td align="left">94.80%</td><td align="left">97.56%</td><td align="left">87.68%</td><td align="left">96.25%</td></tr><tr><td align="left">CCR5 and CXCR4</td><td align="left">0.2</td><td align="left">35</td><td align="left">698</td><td align="left">95.15%</td><td align="left">99.20%</td><td align="left">65.89%</td><td align="left">90.97%</td></tr><tr><td colspan="8"><hr></hr></td></tr><tr><td align="left"><bold>Perfect deterministic classifier</bold></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">CCR5</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">99.15%</td><td align="left">99.55%</td><td align="left">99.08%</td><td align="left">-</td></tr><tr><td align="left">CXCR4</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">98.66%</td><td align="left">99.70%</td><td align="left">95.97%</td><td align="left">-</td></tr><tr><td align="left">CCR5 and CXCR4</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">97.96%</td><td align="left">99.68%</td><td align="left">85.54%</td><td align="left">-</td></tr><tr><td colspan="8"><hr></hr></td></tr><tr><td align="left"><bold>Distant segments kernel trained on test set</bold></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">CCR5</td><td align="left">0.3</td><td align="left">40</td><td align="left">425</td><td align="left">98.45%</td><td align="left">92.88%</td><td align="left">99.5%</td><td align="left">99.17%</td></tr><tr><td align="left">CXCR4</td><td align="left">0.0001</td><td align="left">35</td><td align="left">611</td><td align="left">98.66%</td><td align="left">99.70%</td><td align="left">95.97%</td><td align="left">98.29%</td></tr><tr><td align="left">CCR5 and CXCR4</td><td align="left">0.0001</td><td align="left">40</td><td align="left">618</td><td align="left">97.96%</td><td align="left">99.68%</td><td align="left">85.54%</td><td align="left">96.27%</td></tr></tbody></table></table-wrap><p>For the CCR5-usage prediction task, the SVM classifier achieved a testing accuracy of 96.63%, 96.42%, and 96.35%, respectively, for the BS, LA, and DS kernels. By using the binomial tail inversion method of [<xref ref-type="bibr" rid="B26">26</xref>], we find no statistically significant difference, with 90% confidence, between kernels.</p><p>For the CXCR4-usage prediction task, the SVM classifier achieved a testing accuracy of 93.68%, 92.21%, and 94.80%, respectively, for the BS, LA, and DS kernels. By using the binomial tail inversion method of [<xref ref-type="bibr" rid="B26">26</xref>], we find that the difference is statistically significant, with 90% confidence, for the DS versus the LA kernel.</p><p>For the CCR5-and-CXCR4-usage task, the SVM classifier achieved a testing accuracy of 94.38%, 92.28 %, and 95.15%, respectively, for the BS, LA, and DS kernels. Again, we find that the difference is statistically significant, with 90% confidence, for the DS versus the LA kernel.</p><p>Overall, all the tested string kernels perform well on the CCR5 task, but the DS kernel is significantly better than the LA kernel (with 90% confidence) for the CXCR4 and CCR5-and-CXCR4 tasks. For these two prediction tasks, the performance of the BS kernel was closer to the one obtained for the DS kernel than the one obtained for the LA kernel.</p></sec><sec><title>Classification with the perfect deterministic classifier</title><p>Also present in Table <xref ref-type="table" rid="T4">4</xref> are the results of the <italic>perfect deterministic classifier</italic>. This classifier is the deterministic classifier achieving the highest possible accuracy on the test set. For any input string <italic>s </italic>in a testing set <italic>T</italic>, the perfect determinist classifier (<italic>h</italic>*) returns the most frequently encountered class label for string <italic>s </italic>in <italic>T</italic>. Hence, the accuracy on <italic>T </italic>of <italic>h</italic>* is an overall measure of the amount of contradictions that are present in <italic>T</italic>. There are no contradictions in <italic>T </italic>if and only if the testing accuracy of <italic>h</italic>* is 100%. As shown in Table <xref ref-type="table" rid="T4">4</xref>, there is a significant amount of contradictions in the test set <italic>T</italic>. These results indicate that any deterministic classifier cannot achieve an accuracy greater than 99.15%, 98.66% and 97.96%, respectively for the CCR5, CXCR4, and CCR5-and-CXCR4 coreceptor usage tasks.</p></sec><sec><title>Discriminative power</title><p>To determine if a SVM classifier equipped with the distant segments (DS) kernel had enough discriminative power to achieve the accuracy of perfect determinist classifier, we trained the SVM, equipped with the DS kernel, <italic>on the testing set</italic>. From the results of Table <xref ref-type="table" rid="T4">4</xref>, we conclude that the SVM equipped with the DS kernel possess sufficient discriminative power since it achieved (almost) the same accuracy as the perfect deterministic classifier for all three tasks. Hence, the fact that the SVM with the DS kernel does not achieve the same accuracy as the perfect determinist classifier when it is obtained from the training set (as indicated in Table <xref ref-type="table" rid="T4">4</xref>) is not due to a lack of discriminative power from the part of the learner.</p></sec><sec><title>Discriminant vectors</title><p>The discriminant vector that maximizes the soft-margin has (almost always) many non-zero valued components which can be extracted by the algorithm of Figure <xref ref-type="fig" rid="F3">3</xref>. We examine which components of the discriminant vector have the largest absolute magnitude. These components give weight to the most relevant features for a given classification task. In Figure <xref ref-type="fig" rid="F4">4</xref>, we describe the most relevant features for each tasks. Only the 20 most significant features are shown.</p><fig position="float" id="F4"><label>Figure 4</label><caption><p>Features (20 are shown) with highest and lowest weights for each coreceptor usage prediction task.</p></caption><graphic xlink:href="1742-4690-5-110-4"/></fig><p>A subset of positive-weighted features shown for CCR5-utilizing viruses are also in the negative-weighted features shown for CXCR4-utilizing viruses. Furthermore, a subset of positive-weighted features shown for CXCR4-utilizing viruses are also in the negative-weighted features reported for CCR5-utilizing viruses. Thus, CCR5 and CXCR4 discriminant models are complementary. However, since 3 tropisms exist (R5, X4 and R5X4), features contributing to CCR5-and-CXCR4 should also include some of the features contributing to CCR5 and some of the features contributing to CXCR4. Among shown positive-weighted features for CCR5-and-CXCR4, there are features that also contribute to CXCR4 ([8, R, R], [13, R, T], [9, R, R]). On another hand, this is not the case for CCR5. However, only the twenty most relevant features have been shown and there are many more features, with similar weights, that contribute to the discriminant vector. In fact, the classifiers that we have obtained depend on a very large number of features (instead of a very small subset of relevant features).</p></sec></sec><sec><title>Discussion</title><p>The proposed HIV-1 coreceptor-usage prediction tool achieved very high accuracy in comparison with other existing prediction methods. In view of the results of Pillai et al, we have shown that the SVM classification accuracy can be greatly improved with the usage of a string kernel. Surprisingly, the local alignment (LA) kernel, which makes an explicit use of biologically-motivated scoring matrices (such as BLOSUM 62), turns out to be outperformed by the blended spectrum (BS) and the distant segments (DS) kernels which do not try to exploit any concept of similarity between residues but rely, instead, on a very large set of easily-interpretable features. Thus, a weighted-majority vote over a very high number of simple features constitutes a very productive approach, that is both sensitive and specific to what it is trained for, and applies well in the field of viral phenotype prediction.</p><sec><title>Comparison with available bioinformatic methods</title><p>In Table <xref ref-type="table" rid="T5">5</xref>, we show a summary of the available methods. The simplest method (the charge rule) has an accuracy of 87.45%. Thus, the charge rule is the worst method presented in table <xref ref-type="table" rid="T5">5</xref>. The SVM with string kernels is the only approach without multiple alignments. Therefore, V3 sequences with many indels can be used with our method, but not with the other. These other methods were not directly tested here with our datasets because they all rely on multiple alignments. The purpose of those alignments is to produce a consensus and to yield transformed sequences having all the same length. As indicated by the size of the training set in those methods, sequences having larger indels were discarded, thus making these datasets smaller. Most of the methods rely on cross-validation to perform quality assessment but, as we have mentioned, this is problematic when multiple alignments are performed prior to learning, since, in these cases, the testing set in each fold is used for the construction of the tested classifier. It is also important to mention that the various methods presented in Table <xref ref-type="table" rid="T5">5</xref> do not produce predictors for the same coreceptor usage task. Indeed, the definition of X4 viruses is not always the same: some authors refer to it as CXCR4-only while other use it as CXCR4-utilizing. It is thus unfeasible to assess the fitness of these approaches, which are twisted by cross-validation, multiple alignments and heterogeneous dataset composition.</p><table-wrap position="float" id="T5"><label>Table 5</label><caption><p>Available methods. The results column contains the metric and what the classifier is predicting.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Reference</td><td align="left">Learning method</td><td align="left">Training set</td><td align="left">Testing set</td><td align="left">Multiple alignments</td><td align="left">Results</td></tr></thead><tbody><tr><td align="left">Pillai et al. 2003</td><td align="left">Charge rule [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>]</td><td align="left">271</td><td align="left">-</td><td align="left">yes</td><td align="left">Accuracy (CXCR4): 87.45%</td></tr><tr><td align="left">Resch et al. 2001</td><td align="left">Neural networks</td><td align="left">181</td><td align="left">-</td><td align="left">yes</td><td align="left">Specificity (X4): 90.00%</td></tr><tr><td align="left">Pillai et al. 2003</td><td align="left">SVM</td><td align="left">271</td><td align="left">-</td><td align="left">yes</td><td align="left">Accuracy (CXCR4): 90.86%</td></tr><tr><td align="left">Jensen et al. 2003</td><td align="left">PSSM<sup>1</sup></td><td align="left">213</td><td align="left">175</td><td align="left">yes</td><td align="left">Specificity (CXCR4): 96.00%</td></tr><tr><td align="left">Jensen et al. 2006</td><td align="left">PSSM</td><td align="left">279</td><td align="left">-</td><td align="left">yes</td><td align="left">Specificity (CXCR4): 94.00%<sup>2</sup></td></tr><tr><td align="left">Sander et al. 2007</td><td align="left">SVM</td><td align="left">432</td><td align="left">-</td><td align="left">yes</td><td align="left">Accuracy (CXCR4): 91.56%</td></tr><tr><td align="left">Xu et al. 2007</td><td align="left">Random forests</td><td align="left">651</td><td align="left">-</td><td align="left">yes</td><td align="left">Accuracy (R5): 95.10%</td></tr><tr><td align="left">Lamers et al. 2008</td><td align="left">Neural networks</td><td align="left">149</td><td align="left">-</td><td align="left">yes</td><td align="left">Accuracy (R5X4): 75.50%</td></tr><tr><td align="left">This manuscript</td><td align="left">SVM</td><td align="left">1425</td><td align="left">1425</td><td align="left"><bold>no</bold></td><td align="left">Accuracy (CXCR4): <bold>94.80%</bold></td></tr></tbody></table><table-wrap-foot><p><sup>1</sup>Position-specific scoring matrices</p><p><sup>2</sup>Subtype C</p></table-wrap-foot></table-wrap><p>The work by Lamers and colleagues [<xref ref-type="bibr" rid="B12">12</xref>] is the first development in HIV-1 coreceptor usage prediction regarding dual-tropic viruses. Using evolved neural networks, an accuracy of 75.50% was achieved on a training set of 149 sequences with the cross-validation method. However, the SVM equipped with the distant segments kernel reached an accuracy of 95.15% on a large test set (1425 sequences) in our experiments. Thus, our SVM outperforms the neural network described by Lamers and colleagues [<xref ref-type="bibr" rid="B12">12</xref>] for the prediction of dual-tropic viruses.</p></sec><sec><title>Los Alamos National Laboratory HIV Databases</title><p>Although we used only the Los Alamos National Laboratory HIV Databases as our source of sequence information, it is notable that this data provider represents a meta-resource, fetching bioinformation from databases around the planet, namely GenBank (USA, <ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/Genbank/"/>), EMBL (Europe, <ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/embl/"/>) and DDBJ (Japan, <ext-link ext-link-type="uri" xlink:href="http://www.ddbj.nig.ac.jp/"/>). Researchers cannot directly send their HIV sequences to LANL, but it is clear that this approach makes this database less likely to contain errors.</p></sec><sec><title>Noise</title><p>The primary cause of contradictions (e.g. a sequence having two or more phenotypes) remains uncharacterized. It may be due to a particular mix, to some extent, of virion envelope attributes (regions other than the V3) and of the host cell receptor counterparts. As genotypic assays, based on bioinformatics prediction software, rely on sequencing technologies, they are likely to play a more important role in clinical settings as sequencing cost drops. Next-generation sequencing platforms promise a radical improvement on the throughput and more affordable prices. Meanwhile, effective algorithmic methods with proven statistical significance must be developed. Bioinformatics practitioners have to innovate by creating new algorithms to deal with large datasets and need to take into consideration sequencing errors and noise in phenotypic assay readouts. Consequently, we investigated the use of statistical machine learning algorithms, such as the SVM, whose robustness against noise has been observed in many classification tasks. The high accuracy results we have obtained here indicate that this is also the case for the task of predicting the coreceptor usage of HIV-1. While it remains uncertain whether or not other components of the HIV-1 envelope contribute to the predictability of the viral phenotype, we have shown that the V3 loop alone produces very acceptable outputs despite the presence of a small amount of noise.</p></sec><sec><title>Web server</title><p>To allow HIV researchers to test our method on the web, we have implemented a web server for the HIV-1 coreceptor usage prediction. The address of this web server is <ext-link ext-link-type="uri" xlink:href="http://genome.ulaval.ca/hiv-dskernel"/>. In this setting, one has to submit fasta-formatted V3 sequences in a web form. Then, using the dual representation of the SVM with the distant segments kernel, the software predicts the coreceptor usage of each submitted viral sequence. Those predictions are characterized by high accuracy (according to results in Table <xref ref-type="table" rid="T4">4</xref>). Source codes for the web server and for a command-line back-end are available in additional file <xref ref-type="supplementary-material" rid="S1">1</xref>.</p></sec></sec><sec><title>Conclusion</title><p>To our knowledge, this is the first paper that investigates the use of string kernels for predicting the coreceptor usage of HIV-1. Our contributions include a novel string kernel (the distant segments kernel), a SVM predictor for HIV-1 coreceptor usage with the identification of the most relevant features and state-of-the-art results on accuracy, specificity, sensitivity and receiver operating characteristic. As suggested, string kernels outperform all published algorithms for HIV-1 coreceptor usage prediction. Large margin classifiers and string kernels promise improvements in drug selection, namely CCR5 coreceptor inhibitors and CXCR4 coreceptor inhibitors, in clinical settings. Since the binding of an envelope protein to a receptor/coreceptor prior to infection is not specific to HIV-1, one could extend this work to other diseases. Furthermore, most ligand interactions could be analyzed in such a fashion. Detailed features in primary structures (DNA or protein sequences) can be elucidated with the proposed bioinformatic method. Although we have exposed that even the perfect algorithm (entitled "Perfect determinist classifier") can not reach faultless outcomes, we have also empirically demonstrated that our algorithms are very competitive (more than 96% with distant segments for CCR5). It is thus feasible to apply kernel methods based on features in primary structures to compare sequence information in the perspective of predicting a phenotype. The distant segments kernel has broad applicability in HIV research such as drug resistance, coreceptor usage (as shown in this paper), immune escape, and other viral phenotypes.</p></sec><sec><title>Appendix</title><sec><title>Proof of the correctness of the distant segments kernel</title><p>We now prove that the algorithm DISTANT-SEGMENTS-KERNEL (<italic>s</italic>, <italic>t</italic>, <italic>&#x003b4;</italic><sub><italic>m</italic></sub>, <italic>&#x003b8; </italic><sub><italic>m</italic></sub>) does, indeed, compute <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M24" name="1742-4690-5-110-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>k</mml:mi><mml:mrow><mml:mi>D</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> as defined by Equation 2.</p><p><italic>Proof</italic>. For each pair (<italic>j</italic><sub><italic>s</italic></sub>, <italic>j</italic><sub><italic>t</italic></sub>) such that <italic>s </italic>[<italic>j</italic><sub><italic>s </italic></sub>+ 1] = <italic>t </italic>[<italic>j</italic><sub><italic>t </italic></sub>+ 1] and each <italic>&#x003b4; </italic>&#x02265; 2, let us define <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M25" name="1742-4690-5-110-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> to be the set of all triples (<italic>&#x003b4;</italic>, (<italic>&#x003bc;</italic><sub><italic>s</italic></sub>, <italic>&#x003b1;</italic>, <italic>&#x003bd;</italic><sub><italic>s</italic></sub>, <italic>&#x003b1;'</italic>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M26" name="1742-4690-5-110-i21" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003bc;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>), (<italic>&#x003bc;</italic><sub><italic>t</italic></sub>, <italic>&#x003b1;</italic>, <italic>&#x003bd;</italic><sub><italic>t</italic></sub>, <italic>&#x003b1;'</italic>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M27" name="1742-4690-5-110-i22" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>&#x003bc;</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>)) such that</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M28" name="1742-4690-5-110-i23" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mtable columnalign="left">                              <mml:mtr columnalign="left">                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mi>&#x003b4;</mml:mi>                                       <mml:mo>&#x02264;</mml:mo>                                       <mml:msub>                                          <mml:mi>&#x003b4;</mml:mi>                                          <mml:mi>m</mml:mi>                                       </mml:msub>                                       <mml:mo>;</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow/>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr columnalign="left">                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mo>|</mml:mo>                                       <mml:mi>&#x003b1;</mml:mi>                                       <mml:mo>|</mml:mo>                                       <mml:mo>&#x02264;</mml:mo>                                       <mml:msub>                                          <mml:mi>&#x003b8;</mml:mi>                                          <mml:mi>m</mml:mi>                                       </mml:msub>                                       <mml:mtext>&#x000a0;and&#x000a0;</mml:mtext>                                       <mml:mo>|</mml:mo>                                       <mml:msup>                                          <mml:mi>&#x003b1;</mml:mi>                                          <mml:mo>&#x02032;</mml:mo>                                       </mml:msup>                                       <mml:mo>|</mml:mo>                                       <mml:mo>&#x02264;</mml:mo>                                       <mml:msub>                                          <mml:mi>&#x003b8;</mml:mi>                                          <mml:mi>m</mml:mi>                                       </mml:msub>                                       <mml:mo>;</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow/>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr columnalign="left">                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msub>                                          <mml:mi>&#x003bc;</mml:mi>                                          <mml:mi>u</mml:mi>                                       </mml:msub>                                       <mml:mo>,</mml:mo>                                       <mml:mi>&#x003b1;</mml:mi>                                       <mml:mo>,</mml:mo>                                       <mml:msub>                                          <mml:mi>&#x003bd;</mml:mi>                                          <mml:mi>u</mml:mi>                                       </mml:msub>                                       <mml:mo>,</mml:mo>                                       <mml:msup>                                          <mml:mi>&#x003b1;</mml:mi>                                          <mml:mo>&#x02032;</mml:mo>                                       </mml:msup>                                       <mml:mo>,</mml:mo>                                       <mml:msub>                                          <mml:msup>                                             <mml:mi>&#x003bc;</mml:mi>                                             <mml:mo>&#x02032;</mml:mo>                                          </mml:msup>                                          <mml:mi>u</mml:mi>                                       </mml:msub>                                       <mml:mo stretchy="false">)</mml:mo>                                       <mml:mo>&#x02208;</mml:mo>                                       <mml:msubsup>                                          <mml:mi mathvariant="script">S</mml:mi>                                          <mml:mrow>                                             <mml:mi>&#x003b1;</mml:mi>                                             <mml:mo>,</mml:mo>                                             <mml:msup>                                                <mml:mi>&#x003b1;</mml:mi>                                                <mml:mo>&#x02032;</mml:mo>                                             </mml:msup>                                          </mml:mrow>                                          <mml:mi>&#x003b4;</mml:mi>                                       </mml:msubsup>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>u</mml:mi>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:mtext>for&#x000a0;</mml:mtext>                                       <mml:mi>u</mml:mi>                                       <mml:mo>=</mml:mo>                                       <mml:mi>s</mml:mi>                                       <mml:mtext>&#x000a0;and&#x000a0;for&#x000a0;</mml:mtext>                                       <mml:mi>u</mml:mi>                                       <mml:mo>=</mml:mo>                                       <mml:mi>t</mml:mi>                                       <mml:mo>;</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr columnalign="left">                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mo>|</mml:mo>                                       <mml:msub>                                          <mml:mi>&#x003bc;</mml:mi>                                          <mml:mi>s</mml:mi>                                       </mml:msub>                                       <mml:mo>|</mml:mo>                                       <mml:mo>=</mml:mo>                                       <mml:msub>                                          <mml:mi>j</mml:mi>                                          <mml:mi>s</mml:mi>                                       </mml:msub>                                       <mml:mtext>&#x000a0;and&#x000a0;</mml:mtext>                                       <mml:mo>|</mml:mo>                                       <mml:msub>                                          <mml:mi>&#x003bc;</mml:mi>                                          <mml:mi>t</mml:mi>                                       </mml:msub>                                       <mml:mo>|</mml:mo>                                       <mml:mo>=</mml:mo>                                       <mml:msub>                                          <mml:mi>j</mml:mi>                                          <mml:mi>t</mml:mi>                                       </mml:msub>                                       <mml:mo>.</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow/>                                 </mml:mtd>                              </mml:mtr>                           </mml:mtable>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>Clearly, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M29" name="1742-4690-5-110-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>k</mml:mi><mml:mrow><mml:mi>D</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> is the sum of all the values of |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M30" name="1742-4690-5-110-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| over all the possible pairs (<italic>j</italic><sub><italic>s</italic></sub>, <italic>j</italic><sub><italic>t</italic></sub>). Moreover, it is easy to see that |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M31" name="1742-4690-5-110-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| can be computed only from the knowledge of the set of indices <italic>i </italic>&#x02208; {1,..., <italic>n</italic>} satisfying property <italic>P </italic>(<italic>i</italic>) : = <italic>s </italic>[<italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic>] = <italic>t </italic>[<italic>j</italic><sub><italic>t </italic></sub>+ <italic>i</italic>]. Note that when the test of the first WHILE loop is performed, the value of <italic>i </italic>is such that <italic>P </italic>(<italic>i</italic>) is valid but not <italic>P </italic>(<italic>i </italic>- 1). Moreover, in the second WHILE loop, <italic>P </italic>(<italic>i</italic>) remains valid, except for the last test. Thus, <italic>s </italic>[<italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic>] = <italic>t </italic>[<italic>j</italic><sub><italic>t </italic></sub>+ <italic>i</italic>] if and only if <italic>i</italic><sub>2<italic>r </italic></sub>&#x02264; <italic>i </italic>&#x0003c;<italic>i</italic><sub>2<italic>r</italic>+1 </sub>for some <italic>r </italic>&#x02208; {0,..., <italic>k</italic>}. This, in turn, implies that each element of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M32" name="1742-4690-5-110-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> must be such that <italic>i</italic><sub>2<italic>r </italic></sub>&#x02264; <italic>&#x003b4; </italic>&#x0003c;<italic>i</italic><sub>2<italic>r</italic>+1 </sub>for some <italic>r</italic>. To obtain the result, it is therefore sufficient to prove that both of theses properties hold.</p><p><bold>P1 </bold>The number of elements of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M33" name="1742-4690-5-110-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, for which <italic>i</italic><sub>0 </sub>&#x0003c;<italic>&#x003b4; </italic>&#x0003c;<italic>i</italic><sub>1</sub>, is given by</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M34" name="1742-4690-5-110-i24" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mtable>                                    <mml:mtr>                                       <mml:mtd>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>l</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                          </mml:mrow>                                       </mml:mtd>                                    </mml:mtr>                                    <mml:mtr>                                       <mml:mtd>                                          <mml:mn>3</mml:mn>                                       </mml:mtd>                                    </mml:mtr>                                 </mml:mtable>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                           <mml:mo>&#x02212;</mml:mo>                           <mml:mn>2</mml:mn>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mtable>                                    <mml:mtr>                                       <mml:mtd>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>l</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:msub>                                                <mml:mi>&#x003b8;</mml:mi>                                                <mml:mi>m</mml:mi>                                             </mml:msub>                                          </mml:mrow>                                       </mml:mtd>                                    </mml:mtr>                                    <mml:mtr>                                       <mml:mtd>                                          <mml:mn>3</mml:mn>                                       </mml:mtd>                                    </mml:mtr>                                 </mml:mtable>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                           <mml:mo>+</mml:mo>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mtable>                                    <mml:mtr>                                       <mml:mtd>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>l</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mn>2</mml:mn>                                             <mml:msub>                                                <mml:mi>&#x003b8;</mml:mi>                                                <mml:mi>m</mml:mi>                                             </mml:msub>                                          </mml:mrow>                                       </mml:mtd>                                    </mml:mtr>                                    <mml:mtr>                                       <mml:mtd>                                          <mml:mn>3</mml:mn>                                       </mml:mtd>                                    </mml:mtr>                                 </mml:mtable>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p><bold>P2 </bold>For <italic>r </italic>&#x02208; {1,..., <italic>k</italic>}, the number of elements of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M35" name="1742-4690-5-110-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, for which <italic>i</italic><sub>2<italic>r </italic></sub>&#x02264; <italic>&#x003b4; </italic>&#x0003c;<italic>i</italic><sub>2<italic>r</italic>+1</sub>, is given by</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M36" name="1742-4690-5-110-i25" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>min</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:msub>                              <mml:mi>&#x003b8;</mml:mi>                              <mml:mi>m</mml:mi>                           </mml:msub>                           <mml:mo>,</mml:mo>                           <mml:msub>                              <mml:mi>i</mml:mi>                              <mml:mn>1</mml:mn>                           </mml:msub>                           <mml:mo>&#x02212;</mml:mo>                           <mml:msub>                              <mml:mi>i</mml:mi>                              <mml:mn>0</mml:mn>                           </mml:msub>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>&#x022c5;</mml:mo>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mrow>                                    <mml:mo>(</mml:mo>                                    <mml:mrow>                                       <mml:mtable>                                          <mml:mtr>                                             <mml:mtd>                                                <mml:mrow>                                                   <mml:msub>                                                      <mml:mi>l</mml:mi>                                                      <mml:mi>r</mml:mi>                                                   </mml:msub>                                                </mml:mrow>                                             </mml:mtd>                                          </mml:mtr>                                          <mml:mtr>                                             <mml:mtd>                                                <mml:mn>2</mml:mn>                                             </mml:mtd>                                          </mml:mtr>                                       </mml:mtable>                                    </mml:mrow>                                    <mml:mo>)</mml:mo>                                 </mml:mrow>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:mrow>                                    <mml:mo>(</mml:mo>                                    <mml:mrow>                                       <mml:mtable>                                          <mml:mtr>                                             <mml:mtd>                                                <mml:mrow>                                                   <mml:msub>                                                      <mml:mi>l</mml:mi>                                                      <mml:mn>0</mml:mn>                                                   </mml:msub>                                                   <mml:mo>&#x02212;</mml:mo>                                                   <mml:msub>                                                      <mml:mi>&#x003b8;</mml:mi>                                                      <mml:mi>m</mml:mi>                                                   </mml:msub>                                                </mml:mrow>                                             </mml:mtd>                                          </mml:mtr>                                          <mml:mtr>                                             <mml:mtd>                                                <mml:mn>2</mml:mn>                                             </mml:mtd>                                          </mml:mtr>                                       </mml:mtable>                                    </mml:mrow>                                    <mml:mo>)</mml:mo>                                 </mml:mrow>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>To prove these properties, we will use the fact that, if 1 &#x02264; <italic>i </italic>&#x02264; <italic>k</italic>, then <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M37" name="1742-4690-5-110-i26" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>k</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>i</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> counts the number of sequences &#x027e8;<italic>a</italic><sub>1</sub>,..., <italic>a</italic><sub><italic>i</italic></sub>&#x027e9; satisfying 1 &#x02264; <italic>a</italic><sub>1 </sub>&#x0003c;<italic>a</italic><sub>2 </sub>&#x0003c; &#x022ef; &#x0003c;<italic>a</italic><sub><italic>i </italic></sub>&#x02264; <italic>k </italic>where {<italic>a</italic><sub>1</sub>, <italic>a</italic><sub>2</sub>, ..., <italic>a</italic><sub><italic>i</italic></sub>} are <italic>i </italic>string positions. Moreover, for any substring <italic>u </italic>of <italic>s</italic>, let us denote by <italic>b</italic><sub><italic>u </italic></sub>the starting position of <italic>u </italic>in <italic>s</italic>, and by <italic>e</italic><sub><italic>u </italic></sub>the first position of <italic>s </italic>after the substring <italic>u </italic>(if <italic>s </italic>ends with <italic>u</italic>, choose <italic>e</italic><sub><italic>u </italic></sub>= |<italic>s</italic>| + 1).</p><p>We first prove <bold>P2</bold>. Fix an <italic>r</italic>. Since <italic>i</italic><sub>0 </sub>= 1, we have that any <italic>s</italic>-substring <italic>&#x003b1; </italic>of length &#x02264; <italic>&#x003b8;</italic><sub><italic>m </italic></sub>with <italic>b</italic><sub><italic>&#x003b1; </italic></sub>= <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>0 </sub>and <italic>e</italic><sub><italic>&#x003b1; </italic></sub>&#x02264; <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>1 </sub>together with any <italic>s</italic>-substring <italic>&#x003b1;' </italic>of length &#x02264; <italic>&#x003b8;</italic><sub><italic>m </italic></sub>such that</p><p><disp-formula><italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>2<italic>r </italic></sub>&#x02264; <italic>b</italic><sub><italic>&#x003b1;' </italic></sub>&#x0003c;<italic>e</italic><sub><italic>&#x003b1;' </italic></sub>&#x02264; <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>2<italic>r</italic>+1</sub>,</disp-formula></p><p>will give rise to exactly one element of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M38" name="1742-4690-5-110-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> with <italic>i</italic><sub>2<italic>r </italic></sub>&#x02264; <italic>&#x003b4; </italic>&#x0003c;<italic>i</italic><sub>2<italic>r</italic>+1</sub>. Conversely, each element <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M39" name="1742-4690-5-110-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> such that <italic>i</italic><sub>2<italic>r </italic></sub>&#x02264; <italic>&#x003b4; </italic>&#x0003c;<italic>i</italic><sub>2<italic>r</italic>+1 </sub>will have an <italic>&#x003b1; </italic>and an <italic>&#x003b1;' </italic>with these properties. Since <italic>&#x003b1; </italic>has to start at <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>0</sub>, it is easy to see that the number of such possible <italic>&#x003b1; </italic>is exactly min(<italic>&#x003b8;</italic><sub><italic>m</italic></sub>, <italic>i</italic><sub>1 </sub>- <italic>i</italic><sub>0</sub>). Thus let us show that the number of possible <italic>&#x003b1;' </italic>is exactly <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M40" name="1742-4690-5-110-i27" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula>.</p><p>Since <italic>l</italic><sub><italic>r </italic></sub>gives the number of positions from <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>2<italic>r </italic></sub>to <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>2<italic>r</italic>+1 </sub>inclusively, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M41" name="1742-4690-5-110-i28" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> counts all the possible, choices of <italic>b</italic><sub><italic>&#x003b1;' </italic></sub>and <italic>e</italic><sub><italic>&#x003b1;' </italic></sub>with <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>2<italic>r </italic></sub>&#x02264; <italic>b</italic><sub><italic>&#x003b1;' </italic></sub>&#x0003c;<italic>e</italic><sub><italic>&#x003b1;' </italic></sub>&#x02264; <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>2<italic>r</italic>+1</sub>. Thus <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M42" name="1742-4690-5-110-i28" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> counts the number of possible strings <italic>&#x003b1;' </italic>of all possible lengths (including lengths &#x0003e; <italic>&#x003b8;</italic><sub><italic>m</italic></sub>). On another hand, the number of <italic>&#x003b1;' </italic>having a length &#x0003e; <italic>&#x003b8;</italic><sub><italic>m</italic></sub>. is equal to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M43" name="1742-4690-5-110-i29" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula>. Indeed, if <italic>l</italic><sub><italic>r </italic></sub>- <italic>&#x003b8;</italic><sub><italic>m </italic></sub>&#x0003c; 2, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M44" name="1742-4690-5-110-i29" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> = 0 as wanted, and otherwise, there is a one-to-one correspondence between the set of all sequences &#x027e8;<italic>a</italic><sub>1</sub>, <italic>a</italic><sub>2</sub>&#x027e9; such that 1 &#x02264; <italic>a</italic><sub>1 </sub>&#x0003c;<italic>a</italic><sub>2 </sub>&#x02264; <italic>l</italic><sub><italic>r </italic></sub>- <italic>&#x003b8;</italic><sub><italic>m </italic></sub>and the set of all <italic>&#x003b1;' </italic>of length &#x0003e; <italic>&#x003b8;</italic><sub><italic>m</italic></sub>. The correspondence is obtained by putting <italic>b</italic><sub><italic>&#x003b1;' </italic></sub>= <italic>i</italic><sub>2<italic>r </italic></sub>+ <italic>a</italic><sub>1 </sub>- 1 and <italic>e</italic><sub><italic>&#x003b1;' </italic></sub>= <italic>i</italic><sub>2<italic>r </italic></sub>+ <italic>&#x003b8;</italic><sub><italic>m </italic></sub>+ <italic>a</italic><sub>2 </sub>- 1.</p><p>The proof for <bold>P1 </bold>is similar to the one for <bold>P2 </bold>except that we have to consider the fact that both <italic>&#x003b1; </italic>and <italic>&#x003b1;' </italic>start and end in {<italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>0</sub>,..., <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>1 </sub>- 1}. Since no overlap is allowed and <italic>b</italic><sub><italic>&#x003b1; </italic></sub>= <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>0</sub>, we must have</p><p><disp-formula><italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>0 </sub>&#x02264; <italic>e</italic><sub><italic>&#x003b1; </italic></sub>- 1 &#x0003c;<italic>b</italic><sub><italic>&#x003b1;' </italic></sub>&#x0003c;<italic>e</italic><sub><italic>&#x003b1;' </italic></sub>&#x02264; <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>1</sub>.</disp-formula></p><p>Since <italic>l</italic><sub>0 </sub>gives the number of positions from <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>0 </sub>to <italic>j</italic><sub><italic>s </italic></sub>+ <italic>i</italic><sub>1 </sub>inclusively, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M45" name="1742-4690-5-110-i30" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> counts all the possible choices of <italic>&#x003b1; </italic>and <italic>&#x003b1;' </italic>for all possible lengths. Recall that if <italic>l</italic><sub>0 </sub>&#x0003c; 3, which can only occur if <italic>i</italic><sub>1 </sub>= <italic>i</italic><sub>0 </sub>+ 1, we have that <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M46" name="1742-4690-5-110-i30" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula>, as wanted.</p><p>On another hand, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M47" name="1742-4690-5-110-i31" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> counts all the possible choices of <italic>&#x003b1; </italic>of length &#x0003e; <italic>&#x003b8;</italic><sub><italic>m </italic></sub>and of <italic>&#x003b1;' </italic>of arbitrary length. This set of possible choices is non empty only if <italic>l</italic><sub>0 </sub>- <italic>&#x003b8;</italic><sub><italic>m </italic></sub>&#x02265; 3 and, then, the one-to-one correspondence between a sequence &#x027e8;<italic>a</italic><sub>1</sub>, <italic>a</italic><sub>2</sub>, <italic>a</italic><sub>3</sub>&#x027e9; such that 1 &#x02264; <italic>a</italic><sub>1 </sub>&#x0003c;<italic>a</italic><sub>2 </sub>&#x0003c;<italic>a</italic><sub>3 </sub>&#x02264; <italic>l</italic><sub>0 </sub>- <italic>&#x003b8;</italic><sub><italic>m </italic></sub>and the values of &#x027e8;<italic>e</italic><sub><italic>&#x003b1;</italic></sub>, <italic>b</italic><sub><italic>&#x003b1;'</italic></sub>, <italic>e</italic><sub><italic>&#x003b1;'</italic></sub>&#x027e9; is</p><p><disp-formula><italic>e</italic><sub><italic>&#x003b1; </italic></sub>- 1 = <italic>j</italic><sub><italic>s </italic></sub>+ <italic>&#x003b8;</italic><sub><italic>m </italic></sub>+ <italic>a</italic><sub>1</sub>,&#x000a0;&#x000a0;&#x000a0;<italic>b</italic><sub><italic>&#x003b1;' </italic></sub>= <italic>j</italic><sub><italic>s </italic></sub>+ <italic>&#x003b8;</italic><sub><italic>m </italic></sub>+ <italic>a</italic><sub>2</sub>&#x000a0;&#x000a0;&#x000a0;and&#x000a0;&#x000a0;&#x000a0;<italic>e</italic><sub><italic>&#x003b1;' </italic></sub>= <italic>j</italic><sub><italic>s </italic></sub>+ <italic>&#x003b8;</italic><sub><italic>m </italic></sub>+ <italic>a</italic><sub>3</sub>.</disp-formula></p><p>Similarly, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M48" name="1742-4690-5-110-i31" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> counts all the possible choices of <italic>&#x003b1;' </italic>of length &#x0003e; <italic>&#x003b8;</italic><sub><italic>m </italic></sub>and of <italic>&#x003b1; </italic>of arbitrary length, the correspondence being <italic>e</italic><sub><italic>&#x003b1; </italic></sub>- 1 = <italic>j</italic><sub><italic>s </italic></sub>+ <italic>a</italic><sub>1</sub>, <italic>b</italic><sub><italic>&#x003b1;' </italic></sub>= <italic>j</italic><sub><italic>s </italic></sub>+ <italic>a</italic><sub>2 </sub>and <italic>e</italic><sub><italic>&#x003b1;' </italic></sub>= <italic>j</italic><sub><italic>s </italic></sub>+ <italic>&#x003b8;</italic><sub><italic>m </italic></sub>+ <italic>a</italic><sub>3</sub>. Finally, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M49" name="1742-4690-5-110-i32" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>&#x003b8;</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> counts all the possible choices of <italic>&#x003b1; </italic>and <italic>&#x003b1;'</italic>, both of length &#x0003e; <italic>&#x003b8;</italic><sub><italic>m</italic></sub>. In the cases where such possible choices exist (i.e., if <italic>l</italic><sub>0 </sub>- 2<italic>&#x003b8;</italic><sub><italic>m </italic></sub>&#x02265; 3), the correspondence is <italic>e</italic><sub><italic>&#x003b1; </italic></sub>- 1 = <italic>j</italic><sub><italic>s </italic></sub>+ <italic>&#x003b8;</italic><sub><italic>m </italic></sub>+ <italic>a</italic><sub>1</sub>, <italic>b</italic><sub><italic>&#x003b1;' </italic></sub>= <italic>j</italic><sub><italic>s </italic></sub>+ <italic>&#x003b8;</italic><sub><italic>m </italic></sub>+ <italic>a</italic><sub>2 </sub>and <italic>e</italic><sub><italic>&#x003b1;' </italic></sub>= <italic>j</italic><sub><italic>s </italic></sub>+ 2<italic>&#x003b8;</italic><sub><italic>m </italic></sub>+ <italic>a</italic><sub>3</sub>. Then, property <bold>P1 </bold>immediately follows from the inclusion-exclusion argument.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p></sec></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>SB, MM, FL and JC drafted the manuscript. FL wrote the proof for the distant segments kernel. SB performed experiments. SB, MM, FL and JC approved the manuscript.</p></sec><sec sec-type="supplementary-material"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="S1"><caption><title>Additional file 1</title><p>Source code and data. Web server, classifiers, discriminant vectors and data sets.</p></caption><media xlink:href="1742-4690-5-110-S1.zip" mimetype="application" mime-subtype="x-zip-compressed"><caption><p>Click here for file</p></caption></media></supplementary-material></sec></body><back><ack><sec><title>Acknowledgements</title><p>This project was funded by the Canadian Institutes of Health Research and by the Natural Sciences and Engineering Research Council of Canada (MM, 122405 and FL, 262067). JC is the holder of Canada Research Chair in Medical Genomics.</p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pillai</surname><given-names>S</given-names></name><name><surname>Good</surname><given-names>B</given-names></name><name><surname>Richman</surname><given-names>D</given-names></name><name><surname>Corbeil</surname><given-names>J</given-names></name></person-group><article-title>A new perspective on V3 phenotype prediction</article-title><source>AIDS Res Hum Retroviruses</source><year>2003</year><volume>19</volume><fpage>145</fpage><lpage>149</lpage><pub-id pub-id-type="pmid">12643277</pub-id></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Richman</surname><given-names>D</given-names></name><name><surname>Bozzette</surname><given-names>S</given-names></name></person-group><article-title>The impact of the syncytium-inducing phenotype of human immunodeficiency virus on disease progression</article-title><source>J Infect Dis</source><year>1994</year><volume>169</volume><fpage>968</fpage><lpage>974</lpage><pub-id pub-id-type="pmid">7909549</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Zhang</surname><given-names>L</given-names></name><name><surname>Robertson</surname><given-names>P</given-names></name><name><surname>Holmes</surname><given-names>EC</given-names></name><name><surname>Cleland</surname><given-names>A</given-names></name><name><surname>Leigh</surname><given-names>Brown A</given-names></name><name><surname>Simmonds</surname><given-names>P</given-names></name></person-group><article-title>Selection for specific V3 sequences on transmission of human immunodeficiency virus</article-title><source>J Virol</source><year>1993</year><volume>67</volume><fpage>3345</fpage><lpage>56</lpage><pub-id pub-id-type="pmid">8497055</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sirois</surname><given-names>M</given-names></name><name><surname>Robitaille</surname><given-names>L</given-names></name><name><surname>Sasik</surname><given-names>R</given-names></name><name><surname>Estaquier</surname><given-names>J</given-names></name><name><surname>Fortin</surname><given-names>J</given-names></name><name><surname>Corbeil</surname><given-names>J</given-names></name></person-group><article-title>R5 and X4 HIV viruses differentially modulate host gene expression in resting CD4+ T cells</article-title><source>AIDS Res Hum Retroviruses</source><year>2008</year><volume>24</volume><fpage>485</fpage><lpage>493</lpage><pub-id pub-id-type="pmid">18327980</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Milich</surname><given-names>L</given-names></name><name><surname>Margolin</surname><given-names>B</given-names></name><name><surname>Swanstrom</surname><given-names>R</given-names></name></person-group><article-title>V3 loop of the human immunodeficiency virus type 1 Env protein: interpreting sequence variability</article-title><source>J Virol</source><year>1993</year><volume>67</volume><fpage>5623</fpage><lpage>5634</lpage><pub-id pub-id-type="pmid">8350415</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Fouchier</surname><given-names>R</given-names></name><name><surname>Groenink</surname><given-names>M</given-names></name><name><surname>Kootstra</surname><given-names>N</given-names></name><name><surname>Tersmette</surname><given-names>M</given-names></name><name><surname>Huisman</surname><given-names>H</given-names></name><name><surname>Miedema</surname><given-names>F</given-names></name><name><surname>Schuitemaker</surname><given-names>H</given-names></name></person-group><article-title>Phenotype-associated sequence variation in the third variable domain of the human immunodeficiency virus type 1 gp120 molecule</article-title><source>J Virol</source><year>1992</year><volume>66</volume><fpage>3183</fpage><lpage>3187</lpage><pub-id pub-id-type="pmid">1560543</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Resch</surname><given-names>W</given-names></name><name><surname>Hoffman</surname><given-names>N</given-names></name><name><surname>Swanstrom</surname><given-names>R</given-names></name></person-group><article-title>Improved success of phenotype prediction of the human immunodeficiency virus type 1 from envelope variable loop 3 sequence using neural networks</article-title><source>Virology</source><year>2001</year><volume>288</volume><fpage>51</fpage><lpage>62</lpage><pub-id pub-id-type="pmid">11543657</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jensen</surname><given-names>M</given-names></name><name><surname>Li</surname><given-names>F</given-names></name><name><surname>van 't Wout</surname><given-names>A</given-names></name><name><surname>Nickle</surname><given-names>D</given-names></name><name><surname>Shriner</surname><given-names>D</given-names></name><name><surname>He</surname><given-names>H</given-names></name><name><surname>McLaughlin</surname><given-names>S</given-names></name><name><surname>Shankarappa</surname><given-names>R</given-names></name><name><surname>Margolick</surname><given-names>J</given-names></name><name><surname>Mullins</surname><given-names>J</given-names></name></person-group><article-title>Improved coreceptor usage prediction and genotypic monitoring of R5-to-X4 transition by motif analysis of human immunodeficiency virus type 1 env V3 loop sequences</article-title><source>J Virol</source><year>2003</year><volume>77</volume><fpage>13376</fpage><lpage>13388</lpage><pub-id pub-id-type="pmid">14645592</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jensen</surname><given-names>M</given-names></name><name><surname>Coetzer</surname><given-names>M</given-names></name><name><surname>van 't Wout</surname><given-names>A</given-names></name><name><surname>Morris</surname><given-names>L</given-names></name><name><surname>Mullins</surname><given-names>J</given-names></name></person-group><article-title>A reliable phenotype predictor for human immunodeficiency virus type 1 subtype C based on envelope V3 sequences</article-title><source>J Virol</source><year>2006</year><volume>80</volume><fpage>4698</fpage><lpage>4704</lpage><pub-id pub-id-type="pmid">16641263</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sander</surname><given-names>O</given-names></name><name><surname>Sing</surname><given-names>T</given-names></name><name><surname>Sommer</surname><given-names>I</given-names></name><name><surname>Low</surname><given-names>A</given-names></name><name><surname>Cheung</surname><given-names>P</given-names></name><name><surname>Harrigan</surname><given-names>P</given-names></name><name><surname>Lengauer</surname><given-names>T</given-names></name><name><surname>Domingues</surname><given-names>F</given-names></name></person-group><article-title>Structural descriptors of gp120 V3 loop for the prediction of HIV-1 coreceptor usage</article-title><source>PLoS Comput Biol</source><year>2007</year><volume>3</volume><fpage>e58</fpage><pub-id pub-id-type="pmid">17397254</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Xu</surname><given-names>S</given-names></name><name><surname>Huang</surname><given-names>X</given-names></name><name><surname>Xu</surname><given-names>H</given-names></name><name><surname>Zhang</surname><given-names>C</given-names></name></person-group><article-title>Improved prediction of coreceptor usage and phenotype of HIV-1 based on combined features of V3 loop sequence using random forest</article-title><source>J Microbiol</source><year>2007</year><volume>45</volume><fpage>441</fpage><lpage>446</lpage><pub-id pub-id-type="pmid">17978804</pub-id></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lamers</surname><given-names>S</given-names></name><name><surname>Salemi</surname><given-names>M</given-names></name><name><surname>McGrath</surname><given-names>M</given-names></name><name><surname>Fogel</surname><given-names>G</given-names></name></person-group><article-title>Prediction of R5, X4, and R5X4 HIV-1 coreceptor usage with evolved neural networks</article-title><source>IEEE/ACM Trans Comput Biol Bioinform</source><year>2008</year><volume>5</volume><fpage>291</fpage><lpage>300</lpage><pub-id pub-id-type="pmid">18451438</pub-id></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lengauer</surname><given-names>T</given-names></name><name><surname>Sander</surname><given-names>O</given-names></name><name><surname>Sierra</surname><given-names>S</given-names></name><name><surname>Thielen</surname><given-names>A</given-names></name><name><surname>Kaiser</surname><given-names>R</given-names></name></person-group><article-title>Bioinformatics prediction of HIV coreceptor usage</article-title><source>Nat Biotechnol</source><year>2007</year><volume>25</volume><fpage>1407</fpage><lpage>1410</lpage><pub-id pub-id-type="pmid">18066037</pub-id></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Cortes</surname><given-names>C</given-names></name><name><surname>Vapnik</surname><given-names>V</given-names></name></person-group><article-title>Support-Vector Networks</article-title><source>Machine Learning</source><year>1995</year><volume>20</volume><fpage>273</fpage><lpage>297</lpage></citation></ref><ref id="B15"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Shawe-Taylor</surname><given-names>J</given-names></name><name><surname>Cristianini</surname><given-names>N</given-names></name></person-group><source>Kernel Methods for Pattern Analysis</source><year>2004</year><publisher-name>Cambridge University Press</publisher-name></citation></ref><ref id="B16"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Saigo</surname><given-names>H</given-names></name><name><surname>Vert</surname><given-names>J</given-names></name><name><surname>Ueda</surname><given-names>N</given-names></name><name><surname>Akutsu</surname><given-names>T</given-names></name></person-group><article-title>Protein homology detection using string alignment kernels</article-title><source>Bioinformatics</source><year>2004</year><volume>20</volume><fpage>1682</fpage><lpage>1689</lpage><pub-id pub-id-type="pmid">14988126</pub-id></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Leslie</surname><given-names>C</given-names></name><name><surname>Eskin</surname><given-names>E</given-names></name><name><surname>Noble</surname><given-names>W</given-names></name></person-group><article-title>The spectrum kernel: a string kernel for SVM protein classification</article-title><source>Pac Symp Biocomput</source><year>2002</year><fpage>564</fpage><lpage>575</lpage><pub-id pub-id-type="pmid">11928508</pub-id></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Mefford</surname><given-names>M</given-names></name><name><surname>Gorry</surname><given-names>P</given-names></name><name><surname>Kunstman</surname><given-names>K</given-names></name><name><surname>Wolinsky</surname><given-names>S</given-names></name><name><surname>Gabuzda</surname><given-names>D</given-names></name></person-group><article-title>Bioinformatic prediction programs underestimate the frequency of CXCR4 usage by R5X4 HIV type 1 in brain and other tissues</article-title><source>AIDS Res Hum Retroviruses</source><year>2008</year><volume>24</volume><fpage>1215</fpage><lpage>1220</lpage><pub-id pub-id-type="pmid">18788913</pub-id></citation></ref><ref id="B19"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Raymond</surname><given-names>S</given-names></name><name><surname>Delobel</surname><given-names>P</given-names></name><name><surname>Mavigner</surname><given-names>M</given-names></name><name><surname>Cazabat</surname><given-names>M</given-names></name><name><surname>Souyris</surname><given-names>C</given-names></name><name><surname>Sandres-Saun&#x000e9;</surname><given-names>K</given-names></name><name><surname>Cuzin</surname><given-names>L</given-names></name><name><surname>Marchou</surname><given-names>B</given-names></name><name><surname>Massip</surname><given-names>P</given-names></name><name><surname>Izopet</surname><given-names>J</given-names></name></person-group><article-title>Correlation between genotypic predictions based on V3 sequences and phenotypic determination of HIV-1 tropism</article-title><source>AIDS</source><year>2008</year><volume>22</volume><fpage>F11</fpage><lpage>16</lpage><pub-id pub-id-type="pmid">18753930</pub-id></citation></ref><ref id="B20"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Skrabal</surname><given-names>K</given-names></name><name><surname>Low</surname><given-names>A</given-names></name><name><surname>Dong</surname><given-names>W</given-names></name><name><surname>Sing</surname><given-names>T</given-names></name><name><surname>Cheung</surname><given-names>P</given-names></name><name><surname>Mammano</surname><given-names>F</given-names></name><name><surname>Harrigan</surname><given-names>P</given-names></name></person-group><article-title>Determining human immunodeficiency virus coreceptor use in a clinical setting: degree of correlation between two phenotypic assays and a bioinformatic model</article-title><source>J Clin Microbiol</source><year>2007</year><volume>45</volume><fpage>279</fpage><lpage>284</lpage><pub-id pub-id-type="pmid">17122004</pub-id></citation></ref><ref id="B21"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sing</surname><given-names>T</given-names></name><name><surname>Low</surname><given-names>A</given-names></name><name><surname>Beerenwinkel</surname><given-names>N</given-names></name><name><surname>Sander</surname><given-names>O</given-names></name><name><surname>Cheung</surname><given-names>P</given-names></name><name><surname>Domingues</surname><given-names>F</given-names></name><name><surname>B&#x000fc;ch</surname><given-names>J</given-names></name><name><surname>D&#x000e4;umer</surname><given-names>M</given-names></name><name><surname>Kaiser</surname><given-names>R</given-names></name><name><surname>Lengauer</surname><given-names>T</given-names></name><name><surname>Harrigan</surname><given-names>P</given-names></name></person-group><article-title>Predicting HIV coreceptor usage on the basis of genetic and clinical covariates</article-title><source>Antivir Ther (Lond)</source><year>2007</year><volume>12</volume><fpage>1097</fpage><lpage>1106</lpage><pub-id pub-id-type="pmid">18018768</pub-id></citation></ref><ref id="B22"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Vapnik</surname><given-names>V</given-names></name></person-group><source>Statistical learning Theory</source><year>1998</year><publisher-name>New York: Wiley</publisher-name></citation></ref><ref id="B23"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lingner</surname><given-names>T</given-names></name><name><surname>Meinicke</surname><given-names>P</given-names></name></person-group><article-title>Remote homology detection based on oligomer distances</article-title><source>Bioinformatics</source><year>2006</year><volume>22</volume><fpage>2224</fpage><lpage>2231</lpage><pub-id pub-id-type="pmid">16837522</pub-id></citation></ref><ref id="B24"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Joachims</surname><given-names>T</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Scholkopf B, Burges C, Smola A</surname></name></person-group><article-title>Making large-Scale SVM Learning Practical</article-title><source>Advances in Kernel Methods &#x02013; Support Vector Learning</source><year>1999</year><publisher-name>MIT Press</publisher-name></citation></ref><ref id="B25"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gribskov</surname><given-names>M</given-names></name><name><surname>Robinson</surname><given-names>N</given-names></name></person-group><article-title>Use of receiver operating characteristic (ROC) analysis to evaluate sequence matching</article-title><source>Comput Chem</source><year>1996</year><volume>20</volume><fpage>25</fpage><lpage>33</lpage><pub-id pub-id-type="pmid">16718863</pub-id></citation></ref><ref id="B26"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Langford</surname><given-names>J</given-names></name></person-group><article-title>Tutorial on practical prediction theory for classification</article-title><source>Journal of Machine Learning Research</source><year>2005</year><volume>6</volume><fpage>273</fpage><lpage>306</lpage></citation></ref><ref id="B27"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Leslie</surname><given-names>C</given-names></name><name><surname>Eskin</surname><given-names>E</given-names></name><name><surname>Cohen</surname><given-names>A</given-names></name><name><surname>Weston</surname><given-names>J</given-names></name><name><surname>Noble</surname><given-names>W</given-names></name></person-group><article-title>Mismatch string kernels for discriminative protein classification</article-title><source>Bioinformatics</source><year>2004</year><volume>20</volume><fpage>467</fpage><lpage>476</lpage><pub-id pub-id-type="pmid">14990442</pub-id></citation></ref><ref id="B28"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Liao</surname><given-names>L</given-names></name><name><surname>Noble</surname><given-names>W</given-names></name></person-group><article-title>Combining pairwise sequence similarity and support vector machines for remote protein homology detection</article-title><source>Proceedings of the Sixth Annual Conference on Research in Computational Molecular Biology</source><year>2002</year><fpage>225</fpage><lpage>232</lpage></citation></ref></ref-list></back></article>