<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208109</article-id><article-id pub-id-type="pmc">2648743</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S10</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S10</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Improved algorithms for approximate string matching (extended abstract)</article-title></title-group><contrib-group><contrib id="A1" corresp="yes" contrib-type="author"><name><surname>Papamichail</surname><given-names>Dimitris</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>dimitris@cs.miami.edu</email></contrib><contrib id="A2" contrib-type="author"><name><surname>Papamichail</surname><given-names>Georgios</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>pmichael@ekdd.gr</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Computer Science, University of Miami, Coral Gables, Miami, USA</aff><aff id="I2"><label>2</label>National Center of Public Administration, Athens, Greece</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S10</fpage><lpage>S10</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S10"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Papamichail and Papamichail; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Papamichail and Papamichail; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Papamichail               Dimitris                              dimitris@cs.miami.edu            </dc:author><dc:title>            Improved algorithms for approximate string matching (extended abstract)         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S10-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S10&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>The problem of approximate string matching is important in many different areas such as computational biology, text processing and pattern recognition. A great effort has been made to design efficient algorithms addressing several variants of the problem, including comparison of two strings, approximate pattern identification in a string or calculation of the longest common subsequence that two strings share.</p></sec><sec><title>Results</title><p>We designed an output sensitive algorithm solving the edit distance problem between two strings of lengths <italic>n </italic>and <italic>m </italic>respectively in time O((<italic>s </italic>- |<italic>n </italic>- <italic>m</italic>|)&#x000b7;min(<italic>m</italic>, <italic>n</italic>, <italic>s</italic>) + <italic>m </italic>+ <italic>n</italic>) and linear space, where s is the edit distance between the two strings. This worst-case time bound sets the quadratic factor of the algorithm independent of the longest string length and improves existing theoretical bounds for this problem. The implementation of our algorithm also excels in practice, especially in cases where the two strings compared differ significantly in length.</p></sec><sec><title>Conclusion</title><p>We have provided the design, analysis and implementation of a new algorithm for calculating the edit distance of two strings with both theoretical and practical implications. Source code of our algorithm is available online.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>Approximate string matching is a fundamental, challenging problem in Computer Science, often requiring a large amount of computational resources. It finds applications in different areas such as computational biology, text processing, pattern recognition and signal processing. For these reasons, fast practical algorithms for approximate string matching are in high demand. There are several variants of the approximate string matching problem, including the problem of finding a pattern in a text allowing a limited number of errors and the problem of finding the number of edit operations that can transform one string to another. We are interested in the latter form in this paper.</p><p>The edit distance <italic>D</italic>(<italic>A, B</italic>) between two strings <italic>A </italic>and <italic>B </italic>is defined in general as the minimum cost of any sequence of edit operations that edits <italic>A </italic>into <italic>B </italic>or vice versa. In this work we will focus on the Levenshtein edit distance [<xref ref-type="bibr" rid="B1">1</xref>], where the allowed edit operations are insertion, deletion or substitution of a single character, with each operation carrying a cost of 1. The distance measure which uses this type of operation is often called the unit-cost edit distance and is considered the most common form. The weighted edit distance allows the same operations as the Levenshtein edit distance, but each operation may have an arbitrary cost.</p><p>In the literature there exist a number of algorithms dealing with the calculation of the edit distance between two strings. The basic dynamic programming algorithm that solves the problem in <italic>O</italic>(<italic>mn</italic>) time and linear space has been invented and analyzed several times in different contexts [<xref ref-type="bibr" rid="B2">2</xref>-<xref ref-type="bibr" rid="B7">7</xref>], published between 1968 and 1975. Early on there was an algorithm by Masek and Paterson [<xref ref-type="bibr" rid="B8">8</xref>], building on a technique called the "Four-Russian paradigm" [<xref ref-type="bibr" rid="B9">9</xref>], which computes the edit distance of two strings over a finite alphabet in time <italic>O</italic>(<italic>mn</italic>/log<sup>2 </sup><italic>n</italic>). This algorithm is not applicable in practice, since it can outperform the basic algorithm only then the input size is exceeding 40 GB. All these algorithms can also be used to calculate the <italic>alignment </italic>of two strings, in addition to their edit distance. A modification of the basic algorithm by Hirschberg [<xref ref-type="bibr" rid="B10">10</xref>] allows the alignment calculation to be performed using linear space as well.</p><p>A few years later in 1985, Ukkonen arrived at an <italic>O</italic>(<italic>s</italic>&#x000b7;min(<italic>m</italic>, <italic>n</italic>)) time algorithm, using space <italic>O</italic>(min(<italic>m</italic>, <italic>n</italic>, <italic>s</italic>)) [<xref ref-type="bibr" rid="B11">11</xref>], where s is the edit distance of the two strings compared, creating a very efficient output sensitive algorithm for this problem. The following year, Myers published an algorithm for the Longest Common Substring (<italic>LCS</italic>) problem, which is similar to the edit distance problem, which has <italic>O</italic>(<italic>s</italic><sup>2 </sup>+ (<italic>m </italic>+ <italic>n</italic>) log(<italic>m </italic>+ <italic>n</italic>)) time and linear space complexity [<xref ref-type="bibr" rid="B12">12</xref>]. In achieving this result, a generalized suffix tree of the input strings, supplemented by <italic>Lowest Common Ancestor </italic>(<italic>LCA</italic>) information, has to be used, which renders the solution impractical and only of theoretical value. The practical version of that algorithm needs <italic>O</italic>(<italic>s</italic>(<italic>m </italic>+ <italic>n</italic>)) time. On the other hand, a variation of Ukkonen's algorithm using <italic>O</italic>(<italic>s</italic>&#x000b7;min(<italic>s</italic>, <italic>m, n</italic>)) space leads to an efficient, straightforward implementation, using recursion. Lastly, the basic algorithm, although theoretically inferior, is the most commonly used, owing to its adaptability, ease of implementation, instruction value, and speed, the latter being a result of small constant factors.</p><p>In this paper we will present an O((<italic>s </italic>- |<italic>n </italic>- <italic>m</italic>|)&#x000b7;min(<italic>m</italic>, <italic>n</italic>, <italic>s</italic>) + <italic>m </italic>+ <italic>n</italic>) time and linear space algorithm to calculate the edit distance of two strings, which improves on all previous results, the implementation of which is practical and competitive to the fastest algorithms available. The quadratic factor in the time complexity now becomes independent of the longest string, with the algorithm performing its best when the two strings compared differ significantly in size.</p></sec><sec sec-type="methods"><title>Methods</title><sec><title>Definitions</title><p>In this section we closely follow the notation and definitions in [<xref ref-type="bibr" rid="B11">11</xref>]. Let <italic>A </italic>= <italic>a</italic><sub>1</sub><italic>a</italic><sub>2</sub>...<italic>a</italic><sub><italic>n </italic></sub>and B = <italic>b</italic><sub>1</sub><italic>b</italic><sub>2</sub>...<italic>b</italic><sub><italic>m </italic></sub>be two strings of lengths <italic>n </italic>and <italic>m </italic>respectively, over a finite alphabet &#x003a3;. Without loss of generality, let <italic>n </italic>= <italic>m</italic>.</p><p>The edit operations defined in the previous section can be generalized to have non-negative costs, but for the sake of simplicity in the analysis of our algorithm we will concern ourselves only with the Levenshtein edit distance. We also assume that there is always an editing sequence with cost <italic>D</italic>(<italic>A</italic>, <italic>B</italic>) converting <italic>A </italic>into <italic>B </italic>such that if a cell is deleted, inserted or changed, it is not modified again. Under these assumptions the edit distance is symmetric and it holds 0 &#x02264; <italic>s </italic>&#x02264; <italic>max</italic>(<italic>n</italic>, <italic>m</italic>). Since <italic>n </italic>&#x02265; <italic>m </italic>and there is a minimum number of <italic>n </italic>- <italic>m </italic>insertions that need to be applied in transforming <italic>A </italic>into <italic>B</italic>, the last equation becomes <italic>n </italic>- <italic>m </italic>&#x02264; <italic>s </italic>&#x02264; <italic>n</italic>. The insertion and deletion operations are symmetric, since an insertion, when transforming <italic>A </italic>to <italic>B</italic>, is equivalent to a deletion in the opposite transformation, and vice versa. Both operations will be referred to as indels.</p><p>The basic dynamic programming algorithm employed to solve the edit distance problem, invented in a number of different contexts [<xref ref-type="bibr" rid="B2">2</xref>-<xref ref-type="bibr" rid="B7">7</xref>], makes use of the edit graph, an (<italic>n </italic>+ 1) &#x000d7; (<italic>m </italic>+ 1) matrix (<italic>d</italic><sub><italic>ij</italic></sub>) that is computed from the recurrence:</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S10-i1" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mtable columnalign="left">                              <mml:mtr columnalign="left">                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>d</mml:mi>                                          <mml:mrow>                                             <mml:mn>00</mml:mn>                                          </mml:mrow>                                       </mml:msub>                                    </mml:mrow>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mo>=</mml:mo>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mn>0</mml:mn>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow/>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr columnalign="left">                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>d</mml:mi>                                          <mml:mrow>                                             <mml:mi>i</mml:mi>                                             <mml:mi>j</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                    </mml:mrow>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mo>=</mml:mo>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:mi>min</mml:mi>                                       <mml:mo>&#x02061;</mml:mo>                                       <mml:mo stretchy="false">(</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>d</mml:mi>                                          <mml:mrow>                                             <mml:mi>i</mml:mi>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mn>1</mml:mn>                                             <mml:mo>,</mml:mo>                                             <mml:mi>j</mml:mi>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mn>1</mml:mn>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo>+</mml:mo>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mtext>if&#x000a0;</mml:mtext>                                       <mml:msub>                                          <mml:mi>a</mml:mi>                                          <mml:mi>i</mml:mi>                                       </mml:msub>                                       <mml:mo>=</mml:mo>                                       <mml:msub>                                          <mml:mi>b</mml:mi>                                          <mml:mi>j</mml:mi>                                       </mml:msub>                                       <mml:mtext>&#x000a0;then&#x000a0;</mml:mtext>                                       <mml:mn>0</mml:mn>                                       <mml:mtext>&#x000a0;else&#x000a0;</mml:mtext>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                       <mml:mo>,</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr columnalign="left">                                 <mml:mtd columnalign="left">                                    <mml:mrow/>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow/>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow/>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>d</mml:mi>                                          <mml:mrow>                                             <mml:mi>i</mml:mi>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mn>1</mml:mn>                                             <mml:mo>,</mml:mo>                                             <mml:mi>j</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo>,</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr columnalign="left">                                 <mml:mtd columnalign="left">                                    <mml:mrow/>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow/>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow/>                                 </mml:mtd>                                 <mml:mtd columnalign="left">                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>d</mml:mi>                                          <mml:mrow>                                             <mml:mi>i</mml:mi>                                             <mml:mo>,</mml:mo>                                             <mml:mi>j</mml:mi>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mn>1</mml:mn>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                       <mml:mo>,</mml:mo>                                       <mml:mi>i</mml:mi>                                       <mml:mo>&#x0003e;</mml:mo>                                       <mml:mn>0</mml:mn>                                       <mml:mtext>&#x000a0;or&#x000a0;</mml:mtext>                                       <mml:mi>j</mml:mi>                                       <mml:mo>&#x0003e;</mml:mo>                                       <mml:mn>0.</mml:mn>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                           </mml:mtable>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>This matrix can be evaluated starting from <italic>d</italic><sub>00 </sub>and proceeding row-by-row or column-by-column. This process takes time and space <italic>O</italic>(<italic>mn</italic>) and produces the edit distance of the strings in position <italic>d</italic><sub><italic>mn</italic></sub>. The cells of the matrix (nodes of the graph) have dependencies based on this recurrence, forming the <italic>dependency </italic>or <italic>edit graph</italic>, a directed acyclic graph that is shown in Fig. <xref ref-type="fig" rid="F1">1</xref>. All edit graph nodes will be referred to as cells and all graph edges (edit operations) will be referred to as <italic>transitions</italic>.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Dependency graph</bold>. </p></caption><graphic xlink:href="1471-2105-10-S1-S10-1"/></fig><p>To refer to the diagonals of (<italic>d</italic><sub><italic>ij</italic></sub>) we number them with integers -<italic>m</italic>, -<italic>m </italic>+ 1, ..., 0, 1, ..., <italic>n </italic>such that the diagonal denoted by <italic>k </italic>consists of those <italic>d</italic><sub><italic>ij </italic></sub>cells for which <italic>j </italic>- <italic>i </italic>= <italic>k</italic>. The diagonal <italic>n </italic>- <italic>m</italic>, where the final value <italic>d</italic><sub><italic>mn </italic></sub>resides, is special for our purposes and we will call it main diagonal. The matrix cells between diagonals 0 and <italic>n </italic>- <italic>m </italic>(inclusive) consist the center of the edit graph/matrix, the lower left triangle between diagonals -1 to -<italic>m </italic>will be called the left <italic>corner </italic>of the graph and upper right triangle between diagonals <italic>n </italic>- <italic>m </italic>+ 1 and <italic>n </italic>will be called the <italic>right corner </italic>of the graph.</p><p>A <italic>path </italic>in the edit graph is a series of transitions connecting cells, similar to a path in a directed graph. Whenever we generally refer to a path, we will assume that the final cell it reaches is <italic>d</italic><sub><italic>mn</italic></sub>. The optimal path will be a path originating at <italic>d</italic><sub>00</sub>, and for which the sum of the costs of its transitions is minimal among all paths from <italic>d</italic><sub>00</sub>.</p></sec><sec><title>The concept</title><p>The basic dynamic programming algorithm evaluates unnecessary values of (<italic>d</italic><sub><italic>ij</italic></sub>). This fact led Ukkonen [<xref ref-type="bibr" rid="B11">11</xref>] design an algorithm that is diagonal-based and computes cell values only between the diagonals -<italic> s </italic>and <italic>n </italic>- <italic>m </italic>+ <italic>s</italic>. He also observed that <italic>d</italic><sub><italic>i </italic>+ 1, <italic>j</italic>+1 </sub>&#x02208; {<italic>d</italic><sub><italic>i</italic>, <italic>j</italic></sub>, <italic>d</italic><sub><italic>i</italic>.<italic>j </italic></sub>+ 1} and therefore the values along a diagonal are non-decreasing.</p><p>Both Ukkonen [<xref ref-type="bibr" rid="B11">11</xref>], for calculating the edit distance, and Myers [<xref ref-type="bibr" rid="B12">12</xref>], for calculating the length of the <italic>Longest Common Substring </italic>of two strings, designed their algorithms with a common feature: The iterations in evaluating the edit graph cells were score based, as opposed to column or row based in the basic algorithm. In each step they would increase the edit distance D by 1, starting at 0, and evaluate all cells with values <italic>d</italic><sub><italic>ij </italic></sub>&#x02264; <italic>D</italic>, meaning cells reachable with edit distance D, often omitting cells not contributing to the next iteration, by considering transitions between cells where the values are incremented.</p><p>The algorithm we present here builds on all previous observations and the main iteration is score based as well. But we also make use of the following facts:</p><p>1. <italic>n </italic>- <italic>m </italic>indels are unavoidable.</p><p>2. Additional indels are unavoidable when the optimal path strays away from the main diagonal.</p><p>3. Certain cells do not contribute to the optimal path or their contribution is redundant.</p><p>Points 1 and 2 follow from the fact that an indel is required to move to the next diagonal. At least <italic>n </italic>- <italic>m </italic>indels are required on any path that first reaches the main diagonal, and every time the path strays from the main diagonal, it must return to it.</p><p>In order to address the third fact, we will introduce the concept of <italic>dominance</italic>. We will say that cell <italic>d</italic><sub><italic>ij </italic></sub>dominates cell <italic>d</italic><sub><italic>kl </italic></sub>if no path through <italic>d</italic><sub><italic>kl </italic></sub>defines a better edit distance than the optimal path through <italic>d</italic><sub><italic>ij</italic></sub>. This implies that <italic>d</italic><sub><italic>ij </italic></sub>has an equal or better potential to belong to the optimal path (which defines <italic>s</italic>) than <italic>d</italic><sub><italic>kl</italic></sub>, and thus the latter and its paths do not need to be considered further.</p><p>Some dominance relations between cells can be spotted easily. Let us consider all possible paths starting from d<sub>00</sub>. If a match exists between characters <italic>a</italic><sub>1 </sub>and <italic>b</italic><sub>1 </sub>(<italic>a</italic><sub>1 </sub>= <italic>b</italic><sub>1</sub>), then we do not need to consider indel transitions from <italic>d</italic><sub>00 </sub>to <italic>d</italic><sub>10 </sub>and <italic>d</italic><sub>01</sub>. In that case actually, all cells <italic>d</italic><sub>0<italic>k </italic></sub>for 1 &#x02264; <italic>k </italic>&#x02264; <italic>n </italic>and <italic>d</italic><sub><italic>k</italic>0 </sub>for 1 &#x02264; <italic>k </italic>&#x02264; <italic>m </italic>are dominated by <italic>d</italic><sub>11</sub>. Since <italic>a</italic><sub>1 </sub>matches <italic>b</italic><sub>1</sub>, cell <italic>d</italic><sub>11 </sub>obtains the value of 0. Then all cells d1k, 2 &#x02264; <italic>k </italic>&#x02264; <italic>n </italic>can obtain a value of <italic>k </italic>- 1 through a path traversing <italic>d</italic><sub>11</sub>. Any path through <italic>d</italic><sub>01 </sub>cannot result in a smaller value for cells <italic>d</italic><sub>1<italic>k</italic></sub>, 2 &#x02264; <italic>k </italic>&#x02264; <italic>n</italic>, since cells <italic>d</italic><sub>0,<italic>k</italic>-1 </sub>have the same value. In a similar manner, cells in the second column starting at the third line are dominated by d<sub>11</sub>. These arguments apply not only to d<sub>00 </sub>but to all <italic>d</italic><sub><italic>ij </italic></sub>in general, proving the following:</p><p><bold>Lemma 1</bold>. <italic>A cell d</italic><sub><italic>ij </italic></sub><italic>is dominated by d</italic><sub><italic>i</italic>+1,<italic>j</italic>+1 </sub><italic>if a</italic><sub><italic>j </italic></sub>= <italic>b</italic><sub><italic>i</italic></sub>.</p><p>Let us now consider what happens when <italic>a</italic><sub>1 </sub>&#x02260; <italic>b</italic><sub>1</sub>. In this case we can still find dominated cells in the second row and column, depending on the first matching character position in each. Let us assume that the first character in A matching <italic>b</italic><sub>1 </sub>is al, 2 &#x02264; <italic>l </italic>&#x02264; <italic>n</italic>. All cells <italic>d</italic><sub>1<italic>k</italic></sub>, 2 &#x02264; <italic>k </italic>&#x02264; <italic>l </italic>- 1 are dominated by <italic>d</italic><sub>11</sub>, for the same reasons that were described earlier. And a similar domination relation exists in the columns. Before we generalize the dominance relation with a theorem, we will introduce a new scoring scheme to take advantage of the indel unavoidability, which will create another optimization criterion, monotonicity in the rows and columns of certain parts in our graph. For the new scoring scheme and for the rest of the description of our algorithm, we will divide our matrix into two parts, separated by the main diagonal. The first part includes the center and the left corner of the matrix, where the second part includes the right corner of the matrix, together with the main diagonal (which is shared by both parts). The scoring scheme and the algorithm described further on will be analyzed on the part of the matrix left of the main diagonal, although all theory works symmetrically on the part right of the main diagonal, by substituting the rows with columns and vice versa.</p><p>The new scoring scheme, for the left part of the matrix, is implemented as follows: Every vertical transition (indel) incurs a cost of 2, since it strays away from the main diagonal and creates the need of another horizontal indel to compensate. All horizontal transitions do not carry any cost. The match and substitution costs remain 0 and 1 respectively. To obtain the edit distance s, we add <italic>n </italic>- <italic>m </italic>to the value of cell <italic>d</italic><sub><italic>mn</italic></sub>. The transformation is illustrated through an example in Fig. <xref ref-type="fig" rid="F2">2</xref>.</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Edit graphs under different scoring schemes</bold>. Edit graph cell values and optimal paths under different scoring schemes.</p></caption><graphic xlink:href="1471-2105-10-S1-S10-2"/></fig><p>To guarantee the correctness of an algorithm based on that scoring scheme, we will now prove the following lemma:</p><p><bold>Lemma 2</bold>. <italic>Under the new scoring scheme, the edit distance of A and B remains unchanged</italic>.</p><p><italic>Proof</italic>. It has already been shown that the edit distance is defined by an optimal path of the fewest possible edit operations carrying a cost, resulting in the minimum score at <italic>d</italic><sub><italic>mn</italic></sub>. We will prove the following two statements:</p><p>1. The score obtained from the optimal path remains unchanged and</p><p>2. No other path can lead to a sequence of fewer edit operations and thus a smaller score/edit distance.</p><p>To prove the first statement, we note the following: The number of match and substitution transitions in the optimal path does not alter the edit distance in the new scoring scheme, since the costs of these operations have not changed. With the optimal path starting at diagonal 0 and ending at diagonal <italic>n </italic>- <italic>m</italic>, there are <italic>n </italic>- <italic>m </italic>indels which can be omitted from our calculation, since with the new scoring scheme we add these at the end. The only remaining edit operations to examine are vertical indels left of the main diagonal and horizontal indels right of the main diagonal, which must be accompanied by compensatory horizontal and vertical indels in the respective parts, or the optimal path cannot end up in the main diagonal. Since these indels come in pairs, with half of them carrying the cost of 2 and half the cost of 0 in the new scoring scheme, the final edit distance remains unchanged.</p><p>The second statement follows from the previous arguments, since any path under the new scoring scheme carries the same cost as before, so a new path with a better score than the previous optimal path score contradicts the optimality of the latter under the original scoring scheme.</p><p>Since with the new scoring scheme horizontal transitions do not carry a cost, the values of cells in every row in the left part of the matrix are monotonically decreasing. The same holds for the columns in the right part of the matrix, which leads to the following:</p><p><bold>Corollary 1</bold>. <italic>Under the new scoring scheme, the values of cells in rows left of the main diagonal and in columns right of the main diagonal are monotonically decreasing as the indices of the corresponding cells increase</italic>.</p><p>Let us now consider all cells in a specific row <italic>x</italic>, left of the main diagonal. Values on this row are monotonically decreasing and we only need to keep the information of the first cells from the right where the values are changing (the leftmost cells of a series of cells with the same value), since the rest of the cells are dominated (can be reached with 0 cost from the aforementioned cells). Now, if we have two consecutive dominant cells <italic>d</italic><sub><italic>xy </italic></sub>and <italic>d</italic><sub><italic>xz </italic></sub>on row <italic>x</italic>, with <italic>y </italic>&#x0003c;<italic> z </italic>and <italic>d</italic><sub><italic>xy </italic></sub>= <italic>d</italic><sub><italic>xz </italic></sub>+ 1, then the value of <italic>d</italic><sub><italic>xy </italic></sub>can be propagated through a transition to row <italic>x </italic>+ 1 only if a match exists between <italic>b</italic><sub><italic>x </italic></sub>and <italic>a</italic><sub><italic>k</italic></sub>, with <italic>y </italic>&#x0003c;<italic> k </italic>&#x02264; <italic>z</italic>. In order to be able to locate such matches in constant time, we will create lookahead tables for each letter of the alphabet &#x003a3;, which can point to the next matching character from strings <italic>A </italic>and <italic>B</italic>. Basically these lookahead tables will be able to answer the question: Given a character <italic>c </italic>&#x02208; &#x003a3; and a position 1 &#x02264; <italic>k </italic>&#x02264; <italic>n</italic>, what is the smallest index <italic>l </italic>&#x02265; <italic>k </italic>such that <italic>a</italic><sub><italic>l </italic></sub>= <italic>c</italic>? And the same for string <italic>B</italic>. Such a lookahead table can be easily constructed in time and space O((<italic>n </italic>+ <italic>m</italic>)|&#x003a3;|), which for a fixed alphabet of constant size is linear, by traversing both strings in reverse order, once for each character of the alphabet.</p><p>One can easily verify that lemma 1 still holds, based on the same arguments used to prove it, under the new scoring scheme. In addition, the following corollary holds:</p><p><bold>Corollary 2</bold>. <italic>A cell d</italic><sub><italic>ij </italic></sub><italic>with value D dominates all cells d</italic><sub><italic>i</italic>-<italic>k</italic>, <italic>j</italic>-<italic>k</italic></sub>, 0 &#x02264; k &#x02264; max(<italic>i, j</italic>) <italic>with values </italic>&#x02265; <italic>D</italic>.</p><p><italic>Proof</italic>. It is easy to see, with a simple inductive argument, that a cell <italic>d</italic><sub><italic>ij </italic></sub>dominates all parental cells on the same diagonal with the same score. Since any cell dominates itself with a higher score (because every path from that cell will have a higher score equal to the diffierence of the two scores), the corollary follows.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><sec><title>The algorithm</title><p>The algorithm works separately on the two parts of the matrix left and right of the main diagonal. The description of the algorithm considers only the part of the matrix lying left of the main diagonal, with the assumption that all operations are symmetric on the right part of the matrix. An exception occurs when we describe the interface between the two parts.</p><p>Our edit distance algorithm is score based. On each iteration the edit distance score is incremented by 1 and the part of the edit graph that can be reached with the current score is determined. The initial score is 0, although we should keep in mind that, since at the end we add <italic>n </italic>- <italic>m </italic>to the score &#x02013; adjusting for the unavoidable indels that we get for free on horizontal transitions &#x02013; it can be considered as if the score is initialized with the value <italic>n </italic>- <italic>m</italic>.</p><p>During each iteration, we store the values and positions of the cells we work with in a double linked list, which will be referred to simply as list. To store the position of a cell we actually need only the column index where the cell resides, for reasons that will be explained later. The initialization phase starts with the determination of the cells which can be reached with a score of 0. Since all horizontal and match diagonal transitions (diagonal transitions corresponding to matching characters) have a cost of 0, we follow horizontal transitions until we locate a match, then advance to the next line and repeat. The process ends when we reach the main diagonal. We do not need to keep information on all cells with 0 value, the first cell with a value of 0 on each line suffices, since all further cells are dominated. These dominant leftmost cells can be located in constant time for each line, by using the lookahead tables. When we encounter a series of matches on the same diagonal, we only need to keep the value of the last (bottom-right) cell, since all other cells are dominated. The indices of cells accessed through this process increase monotonically, as we advance forward through rows, columns and diagonals. The initialization finishes when the main diagonal is reached. Thus at the end of the initialization step we have a list of cells with 0 value, each of which resides on a different row, column and diagonal of the matrix. An example of the initialization phase can be found in Fig. <xref ref-type="fig" rid="F3">3a</xref>.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>Edit distance algorithm iterations</bold>. Edit distance algorithm iterations. The main diagonal is depicted in blue, iteration transitions are drawn in red and green alternatively. Cells whose values are presented have been inserted in the list at the end of each iteration, where cells that their values are circled have been removed from the list, dominated by the cells they connect with arcs.</p></caption><graphic xlink:href="1471-2105-10-S1-S10-3"/></fig><p>On each subsequent iteration of the algorithm and with each increasing value of the score, the linked list is updated with new cells that can be reached from members of the list. The algorithm at iteration <italic>D</italic>, with <italic>D </italic>also being the current score, starts from the top of the list and processes one cell at a time. For each list cell examined having a value of <italic>D </italic>- 1 or <italic>D </italic>- 2, as will be proved in lemma 3, we either follow a substitution transition, if the cell's value is <italic>D </italic>- 1 or a vertical indel transition if the cell's value is <italic>D </italic>- 2. Let's assume we are examining list cell <italic>d</italic><sub><italic>ij </italic></sub>= <italic>D </italic>- 1. We know that <italic>d</italic><sub><italic>i</italic>+1, <italic>j</italic>+1 </sub>= <italic>D</italic>, since if <italic>d</italic><sub><italic>i</italic>+1, <italic>j</italic>+1 </sub>&#x0003c;<italic> D </italic>it would already be included in the list, unless dominated by another cell in the list, which is impossible since then <italic>d</italic><sub><italic>ij </italic></sub>would in turn be dominated by <italic>d</italic><sub><italic>i</italic>+1, <italic>j</italic>+1 </sub>and would not be in the list during the current iteration. We now find the largest <italic>k </italic>for which <italic>b</italic><sub><italic>i</italic>+<italic>k </italic></sub>= <italic>a</italic><sub><italic>j</italic>+<italic>k</italic></sub>, <italic>k </italic>&#x02265; 1 and insert cell <italic>d</italic><sub><italic>i</italic>+<italic>k</italic>, <italic>j</italic>+<italic>k </italic></sub>in the list. That is the last cell in a series of match transitions, starting at <italic>d</italic><sub><italic>i</italic>+1, <italic>j</italic>+1</sub>, if any exist. Next, we examine the cells following <italic>d</italic><sub><italic>ij </italic></sub>in the list and remove the ones that are dominated by <italic>d</italic><sub><italic>i</italic>+<italic>k</italic>, <italic>j</italic>+<italic>k</italic></sub>. At this step, list cells <italic>d</italic><sub><italic>op </italic></sub>in rows <italic>o </italic>&#x0003c;<italic>i </italic>+ <italic>k </italic>and on diagonals <italic>o </italic>- <italic>p </italic>such that <italic>i </italic>- <italic>j </italic>&#x0003c;<italic>o </italic>- <italic>p </italic>&#x02264;<italic>n </italic>- <italic>m </italic>are removed, all being dominated as proved later in theorem 1. Starting now at cell <italic>d</italic><sub><italic>i </italic>+ <italic>k</italic>, <italic>j </italic>+ <italic>k</italic></sub>, we repeat the process performed in the initialization, with the difference that for each new cell inserted in the list, all subsequent cells in the list that are dominated by the new member are removed. This process will stop once the next identified match in the lookahead table falls inside the dominated area. Precisely, if <italic>d</italic><sub><italic>op </italic></sub>is the last cell with value <italic>D </italic>that was inserted in the list, the next match from the lookahead tables resides at diagonal q and the next cell in the list resides at a diagonal <italic>p </italic>&#x02264; <italic>q </italic>and row <italic>r </italic>&#x02265; <italic>o</italic>, then the process of inserting new cells derived from <italic>d</italic><sub><italic>ij </italic></sub>is terminated and we proceed to the next cell in the list.</p><p>Each iteration finishes once we reach the main diagonal. The reader can follow the procedure, through the five iterations in calculating the edit distance of strings <italic>A </italic>= 'GATCGCGACC' and <italic>B </italic>= 'ACTTCTA', in Fig. <xref ref-type="fig" rid="F3">3</xref>.</p><p>One special case that was not covered in the above description is the handling of a cell insertion following a vertical indel transition, when another dominated cell on the same diagonal exists in the list. In this case, the only position the dominated cell can occupy is previous to the current cell examined, from which the transition emanated. This results in the removal of the dominated cell. This special case only requires a constant number of operations and does not alter the complexity of the algorithm. As already mentioned, the part of the matrix right of the main diagonal is processed in a symmetric way. At the end of each iteration, the cells of the main diagonal, which belongs to both parts, have to be updated. These cells reside at the end of the lists for both parts and the update is performed in constant time as well.</p><p>We will now proceed to prove the following theorem:</p><p><bold>Theorem 1</bold>. <italic>Cell d</italic><sub><italic>ij </italic></sub><italic>on diagonal i </italic>- <italic>j with value D dominates all cells d</italic><sub><italic>kl </italic></sub><italic>in the list with k </italic>&#x0003c;<italic> i</italic>, <italic>i </italic>- <italic>j </italic>&#x0003c;<italic> k </italic>- <italic>l </italic>&#x02264; <italic>n </italic>- <italic>m and values </italic>&#x0003c;<italic>D</italic>, <italic>meaning all list cells in rows above it and columns with larger indices</italic>.</p><p><italic>Proof</italic>. Since horizontal transitions carry a cost of 0, all cells in row <italic>i </italic>and column <italic>l </italic>with <italic>j </italic>&#x0003c;<italic> l </italic>&#x02264;<italic>n </italic>- <italic>m </italic>have a score of at most <italic>D</italic>. All cells <italic>d</italic><sub><italic>kl </italic></sub>in the list, residing in diagonals <italic>k </italic>- <italic>l </italic>with <italic>i </italic>- <italic>j </italic>&#x0003c;<italic> k </italic>- <italic>l </italic>&#x02264;<italic>n </italic>- <italic>m </italic>and in rows <italic>k </italic>with <italic>k </italic>&#x0003c;<italic> i </italic>lead diagonal transitions to cells <italic>d</italic><sub><italic>k </italic>+ 1, <italic>l </italic>+1 </sub>with score at most <italic>D</italic>, since <italic>a</italic><sub><italic>l </italic></sub>&#x02260; <italic>b</italic><sub><italic>k </italic></sub>(or <italic>d</italic><sub><italic>kl </italic></sub>would not belong to the list, dominated by <italic>d</italic><sub><italic>k</italic>+1, <italic>l</italic>+1</sub>). This implies that no diagonal transition from these cells can produce a value smaller than <italic>D </italic>in any cell on row <italic>i </italic>and column &#x0003e; <italic>j </italic>via a path passing through these cells, since values in the paths are monotonically increasing (because all edit operations have non-negative costs). If we now examine the vertical transitions emanating the <italic>d</italic><sub><italic>kl </italic></sub>cells under consideration, they also result in paths propagating scores at least <italic>D</italic>, which again cannot result in a better score on the cells on row <italic>i </italic>and column &#x0003e; <italic>j</italic>. All cells on diagonals &#x0003c;<italic>i </italic>- <italic>j </italic>do not need to be considered, since they cannot be reached from the claimed dominated cells of this theorem, unless a path reaches them through a cell in diagonal <italic>i </italic>- <italic>j</italic>. But in corollary 2 we showed that cells on this diagonal with scores &#x02265; <italic>D </italic>are already dominated by <italic>d</italic><sub><italic>ij</italic></sub>. Thus all <italic>d</italic><sub><italic>kl </italic></sub>cells are dominated by <italic>d</italic><sub><italic>ij</italic></sub>.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><p>The next corollary follows from the domination theorem 1:</p><p><bold>Corollary 3</bold>. <italic>No two cells in the list reside on the same column</italic>.</p><p><italic>Proof</italic>. Before a new candidate cell <italic>d</italic><sub><italic>ij </italic></sub>is inserted in the list, any list cell on the same column will be removed, since it is dominated by the newly inserted cell, based on the previous theorem.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><p>Now we have the necessary tools to prove the following lemma:</p><p><bold>Lemma 3</bold>. <italic>When iteration D starts, with </italic>1 &#x02264; <italic>D </italic>&#x02264; <italic>s </italic>- (<italic>m </italic>- <italic>n</italic>), <italic>all cells in the linked list have either a score of D </italic>- 1 <italic>or D </italic>- 2.</p><p><italic>Proof</italic>. Initially, after the initialization, the list holds cells with value 0, so the lemma holds. Every time a cell is inserted in the list it will remain until it is dominated by another cell or the algorithm terminates. Unless a cell with score <italic>D </italic>in the list is dominated and removed before its transitions are examined, when the algorithm reaches that cell the diagonal transition emanated from the cell will produce the next candidate, with score <italic>D </italic>+ 1, to be inserted in the list. The second time this cell is visited, the vertical transition from it will be examined. In that case, the next candidate with score <italic>D </italic>+ 2 will dominate the current cell, according to the previous theorem. Thus, even if a cell is not dominated by another inserted cell, it will be dominated by its siblings.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><p>A direct consequence of the previous lemma is the following:</p><p><bold>Corollary 4</bold>. <italic>At most two cells in the list can reside in the same diagonal, and their values differ by </italic>1. <italic>This holds for same row list cells as well</italic>.</p><p>A pseudo-code description of the algorithm is presented below. The description excludes special cases requiring substitutions of the currently examined cells of the list and only presents the operations of the algorithm in the part of the matrix left of the main diagonal. The procedure interfacing the left and right linked lists is omitted as well. The algorithm can be studied in more detail from the available code.</p><p>Initialize lookahead arrays <italic>X</italic></p><p>Initialize linked list <italic>L</italic></p><p>score <italic>D </italic>:= 0</p><p>line <italic>l </italic>:= 0</p><p>column <italic>c </italic>:= 0</p><p><bold>while </bold>Not reached main diagonal <bold>do</bold></p><p>&#x000a0;&#x000a0;&#x000a0;insert <italic>d</italic><sub><italic>lx </italic></sub>:= X[<italic>a</italic><sub><italic>l</italic></sub>][<italic>c</italic>] into <italic>L</italic></p><p>&#x000a0;&#x000a0;&#x000a0;<italic>c </italic>:= <italic>x</italic></p><p>&#x000a0;&#x000a0;&#x000a0;<italic>l </italic>+ +</p><p>end while</p><p><bold>while </bold>Not reached cell <italic>d</italic><sub><italic>mn </italic></sub><bold>do</bold></p><p>&#x000a0;&#x000a0;&#x000a0;D + +</p><p>&#x000a0;&#x000a0;&#x000a0;Current Cell <italic>d</italic><sub><italic>ij </italic></sub>:= <italic>L </italic>&#x02192; head</p><p>&#x000a0;&#x000a0;&#x000a0;<bold>repeat</bold></p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>if </bold><italic>d</italic><sub><italic>ij </italic></sub>= <italic>D </italic>- 1 <bold>then</bold></p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>d</italic><sub><italic>ij </italic></sub>:= <italic>process_next_candidate</italic>(<italic>d</italic><sub><italic>i</italic>+1, <italic>j</italic>+1</sub>)</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>else</bold></p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<italic>d</italic><sub><italic>ij </italic></sub>:= <italic>process_next_candidate</italic>(<italic>d</italic><sub><italic>i</italic>+1, <italic>j</italic></sub>)</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;<bold>end if</bold></p><p>&#x000a0;&#x000a0;&#x000a0;<bold>until </bold><italic>d</italic><sub><italic>ij </italic></sub>= <italic>L </italic>&#x02192; head</p><p>end while</p><p><bold>Function </bold>process_left_candidate(<italic>d</italic><sub><italic>kl</italic></sub>)</p><p><bold>while </bold><italic>a</italic><sub><italic>l </italic></sub>= <italic>b</italic><sub><italic>k </italic></sub><bold>do</bold></p><p>&#x000a0;&#x000a0;&#x000a0;<italic>k </italic>+ +</p><p>&#x000a0;&#x000a0;&#x000a0;<italic>l </italic>+ +</p><p>end while</p><p>Insert <italic>d</italic><sub><italic>kl </italic></sub>in list <italic>L</italic></p><p>Remove dominated <italic>d</italic><sub><italic>ij </italic></sub>&#x02192; next by <italic>d</italic><sub><italic>kl </italic></sub>from <italic>L</italic></p><p><bold>while </bold>not reached diagonal of <italic>d</italic><sub><italic>ij </italic></sub>&#x02192; next <bold>do</bold></p><p>&#x000a0;&#x000a0;&#x000a0;<italic>process_left_candidate</italic>(X[<italic>a</italic><sub><italic>k</italic>+1</sub>][<italic>l </italic>+ 1])</p><p>end while</p><p><bold>return </bold><italic>d</italic><sub><italic>ij </italic></sub>&#x02192; next</p></sec></sec><sec><title>Algorithm complexity</title><p>The algorithm described in the previous section is score based and as such the main loop executes an equal number of times with the value recorded at cell <italic>d</italic><sub><italic>mn </italic></sub>of the edit graph. Since we add the value <italic>n </italic>- <italic>m </italic>to that score in order to obtain the edit distance of strings A and B, the total number of iterations is equal to <italic>s </italic>- |<italic>n </italic>- <italic>m</italic>|.</p><p>At all times during the execution of the algorithm the linked list contains at most <italic>m </italic>cells, which is a direct consequence of corollary 3. Also, due to corollary 4, there can be at most 2<italic>s </italic>cells in the list at any given time, since the maximum number of diagonals on which the algorithm processes cells is s, consisting of the center of the matrix and diagonal bands of size (<italic>s </italic>- |<italic>n </italic>- <italic>m</italic>|)/2 from each side of the center, accessed while the algorithm iterates. Basically, for every two iterations of the algorithm, one further diagonal from each side of the center of the matrix is accessed.</p><p>All cells in the list are accessed in order and without backtracking during each iteration. Each cell undergoes through a constant number of structural accesses, once when it is inserted in the list, once when it is removed and two times when the diagonal and vertical transitions from this cell are examined, if there is a chance before it is dominated. During each iteration there are other cells accessed, the candidates for insertion in the list. While processing these cells we are advancing both the indices of columns and rows without backtracking, which proves, as with list cells, that there are at most <italic>m </italic>or <italic>s </italic>candidate cells examined during each iteration.</p><p>A candidate cell may be accessed several times while compared to a list cell, in order to determine a dominance relation. A list cell can also be accessed several times during the same process, to check whether it is dominated. However, the amortized cost for each cell is constant. Every time a candidate cell is re-examined, a cell from the list has been removed. And every time a list cell is re-examined, in the previous step it was not dominated by a candidate cell, the latter then having being inserted in the list and not being examined again on that iteration. Since each time we advance through either a candidate or a list cell, and since both sets have O(min(<italic>m</italic>, <italic>s</italic>)) cells (under the assumption that <italic>m </italic>&#x02264; <italic>n</italic>), the total number of constant time operations during an iteration is O(min(<italic>m, n, s</italic>)).</p><p>This analysis demonstrates that the total running time of our algorithm is O((<italic>s </italic>- |<italic>n </italic>- <italic>m</italic>|)&#x000b7;min(<italic>m, n, s</italic>) + <italic>m </italic>+ <italic>n</italic>), where the last linear <italic>m </italic>+ <italic>n </italic>component represents the time necessary to initialize the lookahead tables. It can be easily verified using simple algebra that <italic>s </italic>- |<italic>m </italic>- <italic>n</italic>| &#x02264; min(<italic>m</italic>, <italic>n</italic>), which provides another less tight upper bound of the worst case time behavior of the algorithm, O(min(<italic>m</italic>, <italic>n</italic>, <italic>s</italic>)<sup>2 </sup>+ <italic>m </italic>+ <italic>n</italic>). We can therefore observe that the quadratic factor in the time complexity is independent of the longest string being compared. The space usage of this algorithm is O(<italic>m </italic>+ <italic>n</italic>), dominated by the size of the lookahead tables kept in memory. This completes the proof of the next theorem:</p><p><bold>Theorem 2</bold>. <italic>The edit distance s of two strings A and B with lengths n and m respectively can be computed in time O</italic>((<italic>s </italic>- |<italic>n </italic>- <italic>m</italic>|)&#x000b7;min(<italic>m</italic>, <italic>n</italic>, <italic>s</italic>) + <italic>m </italic>+ <italic>n</italic>) <italic>and in space </italic>O(<italic>m </italic>+ <italic>n</italic>).</p></sec></sec><sec><title>Results and Discussion</title><p>We have implemented our new algorithm to test its performance in practice. For comparison purposes, we implemented the basic O(<italic>mn</italic>) algorithm, also known as Needleman-Wunsch [<xref ref-type="bibr" rid="B3">3</xref>], as well as the Ukkonen O(<italic>s</italic>&#x000b7;min(<italic>m</italic>, <italic>n</italic>)) algorithm [<xref ref-type="bibr" rid="B11">11</xref>]. All algorithms were implemented in perl, using the same input/output procedures and no optimizations. Benchmarking was performed with the benchmark perl module for the experiments averaging a large number of random runs, and the <italic>time </italic>unix command for individual experiments, the same method always used across algorithms. All tests were performed on an 8 GB RAM 2.93 GHz Intel processor IBM compatible desktop machine, running ubuntu linux. In all test cases the data completely fit in the main memory.</p><p>Since perl does not support pointer structures efficiently, we implemented the double linked list with arrays, using the fact that no two cells in the list can reside on the same column. This way we access list cells using their column index. As such, the list occupies more space than the minimum possible, where the implementation may have been more efficient in another programming language supporting these structures.</p><p>Ukkonen's algorithm implementation was based on the outline found in [<xref ref-type="bibr" rid="B11">11</xref>] and the more detailed description found in [<xref ref-type="bibr" rid="B13">13</xref>]. The version used is particularly simple by making use of recursion, but has larger than linear space demands, specifically O(<italic>s</italic>&#x000b7;max(<italic>m</italic>, <italic>n</italic>)). The basic algorithm was implemented using linear space and row-by-row iterations.</p><p>The first two experiments were run on random sequences over alphabets of 4 and 20 characters respectively, similar to random DNA/RNA and amino acid sequences. The length of the first sequence from the two compared was set at 1000 characters, where the length of the second sequence varied between 1000 and 3000 characters. We examined a total of nine length ratios <italic>n</italic>/<italic>m </italic>values between 1 and 3 (1 &#x02264; <italic>n</italic>/<italic>m </italic>&#x02264; 3). For each length ratio, 100 different comparisons were run, with the execution time and edit distance values averaged among these. The results are depicted in Fig. <xref ref-type="fig" rid="F4">4</xref>.</p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>Performance on random strings</bold>. Edit distance calculations on random strings with different length ratios, comparing the performance of ours, Ukkonen's and the basic algorithms.</p></caption><graphic xlink:href="1471-2105-10-S1-S10-4"/></fig><p>In these simulations it is worth noticing significant performance improvement of the new algorithm with increasing length ratio of the random strings, although the total length of the strings is increasing. This is not surprising, since the number of iterations <italic>s </italic>- |<italic>m </italic>- <italic>n</italic>| is decreasing, caused by a slower increase in edit distance than difference between the lengths of the two strings.</p><p>Ukkonen's algorithm performs poorly when comparing random strings over a large alphabet, because of the large expected edit distance value in these cases. This algorithm is designed for comparing similar strings, which is the case most often encountered in practice. In contrast, the basic algorithm, owing to its simplicity, performs uniformly and surpasses the other algorithms when the edit distance is large compared to string length, unless when the <italic>s </italic>- |<italic>n </italic>- <italic>m</italic>| value becomes small enough, where our algorithm takes the lead.</p><p>Next, we designed computational experiments performing comparisons most often encountered in practice, drawn from the computational biology domain. In all examples the sequence pairs examined have comparable lengths, not differing more than 5%. The results are presented in Table <xref ref-type="table" rid="T1">1</xref>. The first simulation involved 1000 random sequence pair comparisons from a pool of approximately 6800 vetted 16S ribosomal RNA sequences, provided by the Ribosomal Database Project (RDP). [<xref ref-type="bibr" rid="B14">14</xref>] These sequences average about 1350 characters in size, drawn from an alphabet of size 4. A random pair of 16S rRNA sequences from the same genus and another from the same class but different order are compared in the next two lines, followed by a comparison of two viral genomes and two virion proteins. As these results demonstrate, the performance of our algorithm compares favorably to Ukkonen's algorithm, which is asymptotically slower but has smaller constants, while the basic algorithm is outperformed in almost every case, except when matches are sparse. Performance comes with some cost though and it is interesting to note that the size of the program implementations of the three algorithms, the basic, Ukkonen's and ours, is 80, 160 and 700 lines of code respectively.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Algorithm performance comparing biologically related sequences of similar length</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center">Sequence A</td><td align="center">Sequence B</td><td align="center">Alphabet size</td><td align="center">(Average)<break/>length</td><td align="center">Our algorithm<break/>(sec)</td><td align="center">Ukkonen's algorithm<break/>(sec)</td><td align="center">Basic algorithm<break/>(sec)</td><td align="center">(Average)<break/>edit distance</td></tr></thead><tbody><tr><td align="center">Random 16S<break/>rRNA sequence</td><td align="center">Random 16S<break/>rRNA sequence</td><td align="center">4</td><td align="center">1350</td><td align="center">0.679</td><td align="center">0.811</td><td align="center">2.554</td><td align="center">421.3</td></tr><tr><td colspan="8"><hr></hr></td></tr><tr><td align="center">Hyphomonas 16S<break/>rRNA (AF082798)</td><td align="center">Hyphomonas 16S<break/>rRNA (AF082795)</td><td align="center">4</td><td align="center">1330</td><td align="center">0.25</td><td align="center">0.18</td><td align="center">2.14</td><td align="center">46</td></tr><tr><td colspan="8"><hr></hr></td></tr><tr><td align="center">Alphaproteobacteria 16S<break/>rRNA (AJ238567)</td><td align="center">Betaproteobacteria 16S<break/>rRNA (AJ239278)</td><td align="center">4</td><td align="center">1320</td><td align="center">0.42</td><td align="center">0.46</td><td align="center">2.07</td><td align="center">318</td></tr><tr><td colspan="8"><hr></hr></td></tr><tr><td align="center">Cucumber necrosis<break/>virus genome</td><td align="center">Lisianthus necrosis<break/>virus genome</td><td align="center">4</td><td align="center">4790</td><td align="center">6.70</td><td align="center">6.32</td><td align="center">28.27</td><td align="center">1154</td></tr><tr><td colspan="8"><hr></hr></td></tr><tr><td align="center">Human poliovirus 1<break/>virion protein</td><td align="center">Human Rhinovirus A<break/>virion protein</td><td align="center">20</td><td align="center">870</td><td align="center">1.02</td><td align="center">1.05</td><td align="center">0.88</td><td align="center">472</td></tr></tbody></table></table-wrap><p>The perl implementations of all three algorithms used in this paper for performance comparisons can be downloaded online. [<xref ref-type="bibr" rid="B15">15</xref>]</p></sec><sec><title>Conclusion</title><p>In this paper we have provided the design, analysis and implementation of a new algorithm for calculating the edit distance of two strings. This algorithm is shown to have improved asymptotic time behavior, while it is also demonstrated to perform very well in practice, especially when the lengths of the strings compared differ significantly. The performance of our algorithm in this case, which is encountered less often in instances of the edit distance problem, could find application in the related Longest Common Subsequence (LCS) and other similar problems solved with dynamic programming techniques.</p><p>Future directions for this algorithm include the investigation of further practical applications of the techniques described to other similar problems, as well as generalizing the results to cover additional edit operations such as swaps.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>Both authors designed and analyzed the algorithm, DP implemented the algorithm, performed the experiments and wrote the manuscript. Both authors read and approved the final manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>We would like to thank Gonzallo Navarro, Amihood Amir and Gad M. Landau for information provided regarding the complexity of the edit distance problem, and Victor Milenkovic for his useful input in writing this manuscript.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Levenstein</surname><given-names>V</given-names></name></person-group><article-title>Binary codes capable of correcting spurious insertions and deletions of ones</article-title><source>Probl Inf Transmission</source><year>1965</year><volume>1</volume><fpage>8</fpage><lpage>17</lpage></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Vintsyuk</surname><given-names>T</given-names></name></person-group><article-title>Speech discrimination by dynamic programming</article-title><source>Cybernetics</source><year>1968</year><volume>4</volume><fpage>52</fpage><lpage>58</lpage><pub-id pub-id-type="doi">10.1007/BF01074755</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Needleman</surname><given-names>S</given-names></name><name><surname>Wunsch</surname><given-names>C</given-names></name></person-group><article-title>A general method applicable to the search for similarities in the amino acid sequences of two proteins</article-title><source>J Mol Biol</source><year>1970</year><volume>48</volume><fpage>443</fpage><lpage>453</lpage><pub-id pub-id-type="pmid">5420325</pub-id><pub-id pub-id-type="doi">10.1016/0022-2836(70)90057-4</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sankoff</surname><given-names>D</given-names></name></person-group><article-title>Matching sequences under deletion/insertion constraints</article-title><source>Proceedings of the National Academy of Sciences of the USA</source><year>1972</year><volume>69</volume><fpage>4</fpage><lpage>6</lpage><pub-id pub-id-type="pmid">4500555</pub-id><pub-id pub-id-type="doi">10.1073/pnas.69.1.4</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sellers</surname><given-names>P</given-names></name></person-group><article-title>On the theory and computation of evolutionary distances</article-title><source>SIAM J Appl Math</source><year>1974</year><volume>26</volume><fpage>787</fpage><lpage>793</lpage><pub-id pub-id-type="doi">10.1137/0126070</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Wagner</surname><given-names>R</given-names></name><name><surname>Fisher</surname><given-names>M</given-names></name></person-group><article-title>The string to string correction problem</article-title><source>J ACM</source><year>1974</year><volume>21</volume><fpage>168</fpage><lpage>178</lpage><pub-id pub-id-type="doi">10.1145/321796.321811</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lowrance</surname><given-names>D</given-names></name><name><surname>Wagner</surname><given-names>R</given-names></name></person-group><article-title>An extension of the string-to-string correction problem</article-title><source>J ACM</source><year>1975</year><volume>22</volume><fpage>177</fpage><lpage>183</lpage><pub-id pub-id-type="doi">10.1145/321879.321880</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Masek</surname><given-names>W</given-names></name><name><surname>Paterson</surname><given-names>M</given-names></name></person-group><article-title>A faster algorithm for computing string edit distances</article-title><source>J Comput Syst</source><year>1980</year><volume>20</volume><fpage>18</fpage><lpage>31</lpage><pub-id pub-id-type="doi">10.1016/0022-0000(80)90002-1</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Arlazarov</surname><given-names>VL</given-names></name><name><surname>Dinic</surname><given-names>EA</given-names></name><name><surname>A</surname><given-names>KM</given-names></name><name><surname>Faradzev</surname><given-names>IA</given-names></name></person-group><article-title>On economic construction of the transitive closure of a directed graph</article-title><source>Soviet Math</source><year>1970</year><volume>11</volume><fpage>1209</fpage><lpage>1212</lpage></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hirschberg</surname><given-names>DS</given-names></name></person-group><article-title>A Linear Space Algorithm for Computing Maximal Common Subsequences</article-title><source>Communications of the ACM</source><year>1975</year><volume>18</volume><fpage>341</fpage><lpage>343</lpage><pub-id pub-id-type="doi">10.1145/360825.360861</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ukkonen</surname><given-names>E</given-names></name></person-group><article-title>Algorithms for approximate string matching</article-title><source>Information and Control</source><year>1985</year><volume>64</volume><fpage>100</fpage><lpage>118</lpage><pub-id pub-id-type="doi">10.1016/S0019-9958(85)80046-2</pub-id></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Myers</surname><given-names>EW</given-names></name></person-group><article-title>An O(ND) difference algorithm and its variations</article-title><source>Algorithmica</source><year>1986</year><volume>1</volume><fpage>251</fpage><lpage>266</lpage><pub-id pub-id-type="doi">10.1007/BF01840446</pub-id></citation></ref><ref id="B13"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Powell</surname><given-names>DR</given-names></name></person-group><article-title>Algorithms for Sequence Alignment</article-title><source>PhD thesis</source><year>2001</year><publisher-name>Monash University, School of Computer Science and Software Engineering</publisher-name></citation></ref><ref id="B14"><citation citation-type="other"><article-title>Ribosomal Database Project (RDP)</article-title><ext-link ext-link-type="uri" xlink:href="http://rdp.cme.msu.edu"/></citation></ref><ref id="B15"><citation citation-type="other"><article-title>Edit distance algorithm implementations</article-title><ext-link ext-link-type="uri" xlink:href="http://www.cs.miami.edu/~dimitris/edit_distance"/></citation></ref></ref-list></back></article>