<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208127</article-id><article-id pub-id-type="pmc">2648745</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S27</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S27</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Biclustering of gene expression data using reactive greedy randomized adaptive search procedure</article-title></title-group><contrib-group><contrib id="A1" equal-contrib="yes" corresp="yes" contrib-type="author"><name><surname>Dharan</surname><given-names>Smitha</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>smithadharan@gmail.com</email></contrib><contrib id="A2" equal-contrib="yes" contrib-type="author"><name><surname>Nair</surname><given-names>Achuthsankar S</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>sankar.achuth@gmail.com</email></contrib></contrib-group><aff id="I1"><label>1</label>Centre for Bioinformatics, University of Kerala, Thiruvananthapuram, Kerala, 695 581, India</aff><aff id="I2"><label>2</label>Department of Computer Engineering, College of Engineering, Chengannur, Kerala, 689 121 India</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S27</fpage><lpage>S27</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S27"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Dharan and Nair; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Dharan and Nair; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Dharan               Smitha                                             smithadharan@gmail.com            </dc:author><dc:title>            Biclustering of gene expression data using reactive greedy randomized adaptive search procedure         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S27-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S27&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>Biclustering algorithms belong to a distinct class of clustering algorithms that perform simultaneous clustering of both rows and columns of the gene expression matrix and can be a very useful analysis tool when some genes have multiple functions and experimental conditions are diverse. Cheng and Church have introduced a measure called mean squared residue score to evaluate the quality of a bicluster and has become one of the most popular measures to search for biclusters. In this paper, we review basic concepts of the metaheuristics <italic>Greedy Randomized Adaptive Search Procedure (GRASP)</italic>-construction and local search phases and propose a new method which is a variant of <italic>GRASP </italic>called <italic>Reactive Greedy Randomized Adaptive Search Procedure (Reactive GRASP) </italic>to detect significant biclusters from large microarray datasets. The method has two major steps. First, high quality bicluster seeds are generated by means of k-means clustering. In the second step, these seeds are grown using the Reactive GRASP, in which the basic parameter that defines the restrictiveness of the candidate list is self-adjusted, depending on the quality of the solutions found previously.</p></sec><sec><title>Results</title><p>We performed statistical and biological validations of the biclusters obtained and evaluated the method against the results of basic GRASP and as well as with the classic work of Cheng and Church. The experimental results indicate that the Reactive GRASP approach outperforms the basic GRASP algorithm and Cheng and Church approach.</p></sec><sec><title>Conclusion</title><p>The Reactive GRASP approach for the detection of significant biclusters is robust and does not require calibration efforts.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>Gene expression microarray is a highly popular technology that allows genome-wide measurement of RNA expression levels in a highly quantitative manner. Gene expression data is typically arranged as an <italic>m </italic>&#x000d7; <italic>n </italic>data matrix, with rows corresponding to genes and columns corresponding to experimental conditions. Conditions can be different environmental conditions or different time points corresponding to one or more environmental conditions. The (<italic>m</italic>, <italic>n</italic>)<sup>th </sup>entry of the gene expression matrix represents the expression level of the gene corresponding to row <italic>m </italic>under the specific condition corresponding to column <italic>n</italic>. The numerical value of the entry is usually the logarithm of the relative amount of the mRNA of the gene under the specific condition. By analyzing the gene expression data, we can potentially determine which genes behave in similar ways, how genes interact, which genes contribute to the same pathway, and so on. The similarity between the genes can be analyzed by clustering the gene expression data. Cluster analysis plays an important role in the microarray data analysis through the grouping of genes into subsets with similar expression patterns or similar function. However, clustering has its limitations. Mainly, clustering works on the assumption that related genes behave similarly across all measured conditions. But a general understanding of cellular processes expects subsets of genes to be co-regulated and co-expressed only under certain experimental conditions, but behaves almost independently under other conditions [<xref ref-type="bibr" rid="B1">1</xref>]. In order to overcome the above shortcoming of clustering, the concept of biclustering is applied to gene expression data.</p><p>Biclustering was first described in the literature by Hartigan [<xref ref-type="bibr" rid="B2">2</xref>]. It refers to a distinct class of clustering algorithms that perform simultaneous row column clustering. Cheng and Church [<xref ref-type="bibr" rid="B3">3</xref>] were the first to apply it to gene expression data. Biclustering identifies subsets of genes and subsets of conditions that shares similar expression patterns, by performing simultaneous clustering of both rows and columns of the gene expression matrix. As a result, homogeneous sub matrices of the gene expression matrix are obtained and they are known as biclusters. In [<xref ref-type="bibr" rid="B3">3</xref>], Cheng and Church proposed a similarity score called <italic>mean squared residue score </italic>as a measure of coherence of the rows and columns in the bicluster. When all the elements in a bicluster are similar, the mean squared residue score is low. The lower the score, stronger the coherence exhibited by the bicluster, and better is the quality of the bicluster. However, from a biological point of view, the interest resides in biclusters with subset of genes showing similar behaviour and not with similar values. Hence the method aims at finding large and maximal biclusters with mean squared residue score below a certain threshold, &#x003b4;, and the biclusters thus obtained are called &#x003b4;-biclusters. The value of &#x003b4; has to be estimated in advance, and it is different for every dataset [<xref ref-type="bibr" rid="B4">4</xref>].</p><p>In [<xref ref-type="bibr" rid="B3">3</xref>], Cheng and Church identified the problem of finding significant biclusters as being NP-Hard and employed a greedy node deletion algorithm in their search. Greedy search algorithms start with an initial solution and find a locally optimal solution by successive transformations that improve some cost function. The survey of biclustering algorithms for biological data analysis by Madeira and Oliveira [<xref ref-type="bibr" rid="B1">1</xref>] also identifies greedy search algorithms as a promising area. But greedy algorithms always make a choice that maximizes the local gain in the hope that this choice will lead to a globally good solution. It may make wrong decisions, gets stuck into local optima and thereby loose good biclusters. Metaheuristics technique such as Greedy Randomized Adaptive Search Procedure (GRASP) improves on pure greedy search due to their potential to escape from local minima.</p><p>In this work, we address the biclustering problem with a variant of the GRASP metaheuristics, Reactive GRASP, which is a combination of a semi-greedy heuristics and a local search procedure [<xref ref-type="bibr" rid="B5">5</xref>-<xref ref-type="bibr" rid="B7">7</xref>]. The approach starts from small high quality bicluster seeds, which are tightly co-regulated submatrices of the gene expression matrix. These seeds are further enlarged by adding more rows and columns to them. The seed generation phase is implemented using one-dimensional k-means clustering and the seeds are enlarged using the Reactive GRASP method. The algorithm makes use of <italic>mean squared residue score </italic>as the cost function to evaluate the quality of the obtained biclusters. To avoid getting stuck at local optima, Reactive GRASP is equipped with the heuristics for randomizing the search and thereby allows the search process to go beyond local optima. We evaluated our work against the classic work of Cheng and Church and also with our own work based on basic GRASP [<xref ref-type="bibr" rid="B8">8</xref>]. The results show that the Reactive GRASP method can generate larger and better biclusters than the others.</p></sec><sec sec-type="methods"><title>Methods</title><sec><title>Model of a bicluster</title><p>A bicluster is defined on a gene expression matrix. A gene expression matrix is an <italic>m </italic>&#x000d7; <italic>n </italic>matrix, whose rows represents the genes, columns the experimental conditions and (i, j)<sup>th </sup>element is a real number that represents the expression level of gene <italic>i </italic>under experimental condition <italic>j</italic>. Each row corresponds to the expression levels of a particular gene over all experimental conditions and each column corresponds to the expression levels of <italic>m </italic>genes under a specific experimental condition.</p><p>Let G = {g<sub>1</sub>, g<sub>2 </sub>..., g<sub>m</sub>} and C = {c<sub>1</sub>, c<sub>2</sub>,....., c<sub>n</sub>} represent a set of genes and a set of experimental conditions involved in a gene expression matrix, respectively. A bicluster is defined to be a subset of genes that exhibit similar behaviour under a subset of experimental conditions, and vice versa. Thus, in the gene expression matrix, a bicluster will appear as a sub matrix of it and represented as a pair A = (I, J) or simply as A<sub>IJ</sub>, where I &#x02286; G and J &#x02286; C. The rows and columns of the bicluster need not be contiguous as in the expression matrix.</p><p>A group of genes are said to be coherent if their level of expression reacts in parallel or correlates across a set of conditions. Similarly, a set of conditions may also have coherent levels of expression across a set of genes. The degree of coherence of a bicluster is measured using the concept of <italic>mean squared residue score, HScore</italic>, which represents the variance of a particular subset of genes under a particular subset of conditions with respect to the coherence. In [<xref ref-type="bibr" rid="B3">3</xref>], Cheng and Church defined the mean squared residue score as follows: It is defined for bicluster A<sub>IJ </sub>as the sum of the squared residues. R(a<sub>ij</sub>), the residue of an element a<sub>ij </sub>in the bicluster A<sub>IJ</sub>, i &#x02208; I and j &#x02208; J, is a measure of how well the element fits into that bicluster. It is defined to be:</p><p><disp-formula id="bmcM1"><label>(1)</label><italic>R</italic>(<italic>a</italic><sub><italic>ij</italic></sub>) = <italic>a</italic><sub><italic>ij </italic></sub>- <italic>a</italic><sub><italic>Ij </italic></sub>- <italic>a</italic><sub><italic>iJ </italic></sub>+ <italic>a</italic><sub><italic>Ij</italic></sub></disp-formula></p><p>Now, <italic>HScore </italic>is defined as in (2):</p><p><disp-formula id="bmcM2"><label>(2)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S27-i1" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mtable>                              <mml:mtr>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:mi>H</mml:mi>                                       <mml:mi>S</mml:mi>                                       <mml:mi>c</mml:mi>                                       <mml:mi>o</mml:mi>                                       <mml:mi>r</mml:mi>                                       <mml:mi>e</mml:mi>                                       <mml:mo>=</mml:mo>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:mstyle displaystyle="true">                                                <mml:munder>                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mrow>                                                      <mml:mi>i</mml:mi>                                                      <mml:mo>&#x02208;</mml:mo>                                                      <mml:mi>I</mml:mi>                                                      <mml:mo>,</mml:mo>                                                      <mml:mi>j</mml:mi>                                                      <mml:mo>&#x02208;</mml:mo>                                                      <mml:mi>J</mml:mi>                                                   </mml:mrow>                                                </mml:munder>                                                <mml:mrow>                                                   <mml:msup>                                                      <mml:mrow>                                                         <mml:mo stretchy="false">(</mml:mo>                                                         <mml:mi>R</mml:mi>                                                         <mml:mo stretchy="false">(</mml:mo>                                                         <mml:msub>                                                            <mml:mi>a</mml:mi>                                                            <mml:mrow>                                                               <mml:mi>i</mml:mi>                                                               <mml:mi>j</mml:mi>                                                            </mml:mrow>                                                         </mml:msub>                                                         <mml:mo stretchy="false">)</mml:mo>                                                         <mml:mo stretchy="false">)</mml:mo>                                                      </mml:mrow>                                                      <mml:mn>2</mml:mn>                                                   </mml:msup>                                                </mml:mrow>                                             </mml:mstyle>                                          </mml:mrow>                                          <mml:mrow>                                             <mml:mrow>                                                <mml:mo>|</mml:mo>                                                <mml:mi>I</mml:mi>                                                <mml:mo>|</mml:mo>                                             </mml:mrow>                                             <mml:mo>&#x02217;</mml:mo>                                             <mml:mrow>                                                <mml:mo>|</mml:mo>                                                <mml:mi>J</mml:mi>                                                <mml:mo>|</mml:mo>                                             </mml:mrow>                                          </mml:mrow>                                       </mml:mfrac>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:mtext>where&#x000a0;</mml:mtext>                                       <mml:msub>                                          <mml:mi>a</mml:mi>                                          <mml:mrow>                                             <mml:mi>I</mml:mi>                                             <mml:mi>j</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo>=</mml:mo>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:mstyle displaystyle="true">                                                <mml:munder>                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mrow>                                                      <mml:mi>i</mml:mi>                                                      <mml:mo>&#x02208;</mml:mo>                                                      <mml:mi>I</mml:mi>                                                   </mml:mrow>                                                </mml:munder>                                                <mml:mrow>                                                   <mml:msub>                                                      <mml:mi>a</mml:mi>                                                      <mml:mrow>                                                         <mml:mi>i</mml:mi>                                                         <mml:mi>j</mml:mi>                                                      </mml:mrow>                                                   </mml:msub>                                                </mml:mrow>                                             </mml:mstyle>                                          </mml:mrow>                                          <mml:mrow>                                             <mml:mrow>                                                <mml:mo>|</mml:mo>                                                <mml:mi>I</mml:mi>                                                <mml:mo>|</mml:mo>                                             </mml:mrow>                                          </mml:mrow>                                       </mml:mfrac>                                       <mml:mtext>&#x000a0;is&#x000a0;the&#x000a0;column&#x000a0;mean&#x000a0;of&#x000a0;column&#x000a0;j</mml:mtext>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>a</mml:mi>                                          <mml:mrow>                                             <mml:mi>i</mml:mi>                                             <mml:mi>J</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo>=</mml:mo>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:mstyle displaystyle="true">                                                <mml:munder>                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mrow>                                                      <mml:mi>j</mml:mi>                                                      <mml:mo>&#x02208;</mml:mo>                                                      <mml:mi>J</mml:mi>                                                   </mml:mrow>                                                </mml:munder>                                                <mml:mrow>                                                   <mml:msub>                                                      <mml:mi>a</mml:mi>                                                      <mml:mrow>                                                         <mml:mi>i</mml:mi>                                                         <mml:mi>j</mml:mi>                                                      </mml:mrow>                                                   </mml:msub>                                                </mml:mrow>                                             </mml:mstyle>                                          </mml:mrow>                                          <mml:mrow>                                             <mml:mrow>                                                <mml:mo>|</mml:mo>                                                <mml:mi>J</mml:mi>                                                <mml:mo>|</mml:mo>                                             </mml:mrow>                                          </mml:mrow>                                       </mml:mfrac>                                       <mml:mtext>&#x000a0;is&#x000a0;the&#x000a0;row&#x000a0;mean&#x000a0;of&#x000a0;row&#x000a0;i</mml:mtext>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                              <mml:mtr>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>a</mml:mi>                                          <mml:mrow>                                             <mml:mi>I</mml:mi>                                             <mml:mi>J</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo>=</mml:mo>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:mstyle displaystyle="true">                                                <mml:munder>                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mrow>                                                      <mml:mi>i</mml:mi>                                                      <mml:mo>&#x02208;</mml:mo>                                                      <mml:mi>I</mml:mi>                                                      <mml:mo>,</mml:mo>                                                      <mml:mi>j</mml:mi>                                                      <mml:mo>&#x02208;</mml:mo>                                                      <mml:mi>J</mml:mi>                                                   </mml:mrow>                                                </mml:munder>                                                <mml:mrow>                                                   <mml:msub>                                                      <mml:mi>a</mml:mi>                                                      <mml:mrow>                                                         <mml:mi>i</mml:mi>                                                         <mml:mi>j</mml:mi>                                                      </mml:mrow>                                                   </mml:msub>                                                </mml:mrow>                                             </mml:mstyle>                                          </mml:mrow>                                          <mml:mrow>                                             <mml:mrow>                                                <mml:mo>|</mml:mo>                                                <mml:mi>I</mml:mi>                                                <mml:mo>|</mml:mo>                                             </mml:mrow>                                             <mml:mo>*</mml:mo>                                             <mml:mrow>                                                <mml:mo>|</mml:mo>                                                <mml:mi>J</mml:mi>                                                <mml:mo>|</mml:mo>                                             </mml:mrow>                                          </mml:mrow>                                       </mml:mfrac>                                       <mml:msub>                                          <mml:mrow>                                             <mml:mtext>&#x000a0;is&#x000a0;the&#x000a0;mean&#x000a0;of&#x000a0;bicluster&#x000a0;A</mml:mtext>                                          </mml:mrow>                                          <mml:mrow>                                             <mml:mtext>IJ</mml:mtext>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo>.</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                           </mml:mtable>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>A bicluster is defined to be a &#x003b4;-bicluster if <italic>HScore </italic>(<italic>I</italic>, <italic>J</italic>) &#x02264; &#x003b4;, for some &#x003b4; &#x02265; 0, where &#x003b4; is the maximum acceptable <italic>mean squared residue score</italic>. The value of &#x003b4; has to be estimated in advance, and it is different for every dataset [<xref ref-type="bibr" rid="B4">4</xref>]. The <italic>HScore </italic>gives an indication of how the data is correlated in the sub matrix &#x02013; whether it has some coherence or is random. A matrix of equally spread random values over a range [a, b] has an expected <italic>HScore </italic>of (b-a)<sup>2</sup>/12 and it is independent of the size of the matrix. A high <italic>HScore </italic>indicates that the data is uncorrelated and a low <italic>HScore </italic>means that there is correlation in the matrix.</p></sec><sec><title>Formulation of the biclustering problem</title><p>The biclustering problem is NP-hard as proven by Cheng and Church (2000) [<xref ref-type="bibr" rid="B3">3</xref>]. Thus no polynomial time algorithm exists and they might require exponential computation time in the worst-case. In this work, a heuristics based search method is adopted for finding the &#x003b4;-biclusters in reasonable time. The problem is formulated as an optimization problem, which aims at minimizing the <italic>HScore</italic>. The algorithm has two major phases. In the first phase, an initial set of tightly co-regulated seed biclusters are generated. The second is the heuristics based seed growing phase, in which the seeds are further refined and enlarged by adding more genes and conditions until their <italic>HScore </italic>reaches a certain predetermined threshold.</p><p>Generally pure greedy algorithms make good local choices in the hope that they result in an optimal solution. But in case of situations like local minima, ridges and plateaus, they may make wrong decisions and thereby loose optimal biclusters [<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B10">10</xref>]. It is thus unlikely that a global maximum or maximal &#x003b4;-bicluster will be found. Metaheuristic algorithms incorporate mechanisms to prevent getting trapped in such confined areas of the search space. So here we use the Reactive Greedy Randomized Adaptive Search procedure (Reactive GRASP), which is a variant of the GRASP metaheuristics is used for the extraction of &#x003b4;-biclusters.</p><p>A good seed of a possible bicluster is actually a small bicluster whose <italic>HScore </italic>has reached the requirement but the volume may not be maximal. The simplest ways to generate quality bicluster seeds is to perform standard one-dimensional clustering on both rows and columns of the expression matrix separately and then combine them to generate different seeds [<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B11">11</xref>]. We have used k-means algorithm with cosine angle distance as the distance measure.</p><p>During seed generation, the gene expression matrix is partitioned into <italic>p </italic>gene clusters and <italic>q </italic>condition clusters. As the number of genes per each gene cluster is too high, each gene cluster is further divided into subclusters. As a result we get <italic>x </italic>geneclusters and <italic>q </italic>condition clusters. By combining these gene and condition clusters, we get x<sub>*</sub>q disjoint submatrices. Finally, the <italic>HScore </italic>values of the entire x<sub>*</sub>q submatrices are calculated and those having <italic>HScore </italic>value less than a threshold are selected as the seeds.</p></sec><sec><title>Greedy randomized adaptive search procedure: a review</title><p>GRASP is implemented as a multistart procedure, where each iteration is made up of a construction phase, where a randomized greedy solution is constructed, and a local search phase. The local search phase starts at the constructed solution and applies iterative improvement until a locally optimal solution is found. The GRASP algorithm is summarized in Table <xref ref-type="table" rid="T1">1</xref>.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Algorithm of greedy randomized search procedure</p></caption><table frame="hsides" rules="groups"><tbody><tr><td align="left">Algorithm GRASP (Seed)</td><td></td></tr><tr><td align="left">&#x02003;Current = Seed;</td><td></td></tr><tr><td align="left">&#x02003;While &#x0003c;termination condition not met&#x0003e; do</td><td></td></tr><tr><td align="left">&#x02003;&#x02003;Solution &#x02190; Greedy_Randomized_ Construction (Current);</td><td></td></tr><tr><td align="left">&#x02003;&#x02003;Solution &#x02190; Local_Search (Solution);</td><td></td></tr><tr><td align="left">&#x02003;&#x02003;Current &#x02190; Solution;</td><td></td></tr><tr><td align="left">&#x02003;End</td><td></td></tr></tbody></table></table-wrap><p>During the construction phase, the set of candidate elements are formed by all elements that can be incorporated to the partial solution under construction without destroying feasibility. The quality of a candidate element is determined by its contribution, at that point, to the cost of the solution being constructed. A greedy evaluation function measures this contribution for each candidate element. Accordingly a restricted candidate list (RCL) is constructed of high quality candidate elements. The number of elements in RCL can be limited either by rank or by quality relative to other candidates. In rank based RCL, <italic>r </italic>candidates with smallest greedy function value are selected from the candidate list and <italic>r </italic>determines how greedy or random the construction will be. The quality based RCL uses a greedy function cutoff value and only considers candidates with a greedy function value no greater than the cutoff. To implement this, a real-valued RCL parameter &#x003b1; &#x02208; [0..1] is used and it determines which elements are to be placed in the RCL at each iteration of the construction phase. Since in the case of a minimization problem, the case &#x003b1; = 0 corresponds to a pure greedy algorithm, while &#x003b1; = 1 is equivalent to a pure random construction. Thus, the parameter '&#x003b1;' controls the amount of greediness and randomness in the algorithm. In basic GRASP implementation, the same &#x003b1; is used along all iterations and it is usually determined through experimentation. In our earlier work based on GRASP, we used a quality-based implementation of RCL for the extraction of biclusters [<xref ref-type="bibr" rid="B8">8</xref>]. The element to be incorporated into the partial solution is randomly selected from those in the RCL. Once the selected element is incorporated to the partial solution, the candidate list is updated and the incremental costs are re-evaluated. The description of the construction phase is given in Table <xref ref-type="table" rid="T2">2</xref>.</p><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Algorithm of greedy randomized construction phase</p></caption><table frame="hsides" rules="groups"><tbody><tr><td align="left">Algorithm Greedy_Randomized_Construction(Seed)</td><td></td></tr><tr><td align="left">&#x02003;Solution &#x02190; Seed</td><td></td></tr><tr><td align="left">&#x02003;Calculate the incremental costs of the elements not included in the current solution</td><td></td></tr><tr><td align="left">&#x02003;Build the candidate list</td><td></td></tr><tr><td align="left">&#x02003;While &#x0003c;termination condition not met&#x0003e; do</td><td></td></tr><tr><td align="left">&#x02003;&#x02003;Build the restricted candidate list (RCL)</td><td></td></tr><tr><td align="left">&#x02003;&#x02003;Select an element s at random from RCL</td><td></td></tr><tr><td align="left">&#x02003;&#x02003;Solution &#x02190; Solution &#x0222a; s</td><td></td></tr><tr><td align="left">&#x02003;&#x02003;Recalculate the incremental costs and candidate list</td><td></td></tr><tr><td align="left">&#x02003;End</td><td></td></tr><tr><td align="left">&#x02003;Return Solution</td><td></td></tr><tr><td align="left">End</td><td></td></tr></tbody></table></table-wrap><p>The solution generated by a greedy randomized construction is not necessarily optimal. The local search phase usually improves the constructed solution. A local search algorithm works in an iterative fashion by successively replacing the current solution by a better solution in the neighbourhood of the current solution. It terminates when no better solution is found in the neighbourhood. In [<xref ref-type="bibr" rid="B6">6</xref>], Resende and Ribeiro reported that in most cases both first-improving and best-improving local search strategies lead to the same final solution, but in case of smaller computation times, the former outperforms the latter. Hence in our algorithm, a first improving strategy is used for the implementation of the local search. The description of the algorithm is given in Table <xref ref-type="table" rid="T3">3</xref>. In the algorithm <italic>N </italic>(solution) represents the neighbourhood of the solution and <italic>f </italic>represents the cost function corresponding to the problem.</p><table-wrap position="float" id="T3"><label>Table 3</label><caption><p>Algorithm of local search phase</p></caption><table frame="hsides" rules="groups"><tbody><tr><td align="left">Algorithm Local_Search (Solution)</td><td></td></tr><tr><td align="left">&#x02003;While there exists <italic>s </italic>&#x02208; <italic>N </italic>(Solution) such that <italic>f </italic>(Solution &#x0222a; <italic>s</italic>) &#x0003c;<italic>f </italic>(Solution) do</td><td></td></tr><tr><td align="left">&#x02003;Solution &#x02190; Solution &#x0222a; <italic>s</italic></td><td></td></tr><tr><td align="left">&#x02003;End</td><td></td></tr><tr><td align="left">Return Solution</td><td></td></tr></tbody></table></table-wrap><p>An especially appealing characteristic of GRASP is the ease with which it can be implemented. Few parameters need to be set and tuned. Basic implementation of GRASP relies exclusively on two parameters. The first controls the number of construction/local search iterations that will be applied and the second, the RCL parameter &#x003b1;, controls the blend of randomness and greediness in the solution construction procedure. But in [<xref ref-type="bibr" rid="B12">12</xref>], Prais and Ribeiro showed that using a single fixed value for &#x003b1; often hinders finding a high quality solution, which eventually could be found if another value was used. They proposed an extension of the basic GRASP called Reactive GRASP, in which the parameter &#x003b1; is not fixed, but instead is selected at each iteration from a discrete set of possible values. The solution values used along the previous iterations serve as a guide for the selection process. Reactive GRASP includes a memory mechanism that enables good solutions found in earlier iterations of the search to influence the search later.</p></sec><sec><title>Biclustering using GRASP</title><p>Biclustering using GRASP is implemented as a two-step procedure. In the first, the GRASP iterations are performed over the seed bicluster to enlarge it column wise and during the second step, another set of GRASP iterations add more rows while keeping the <italic>HScore </italic>below a certain predetermined threshold. During the construction phase of each GRASP iteration, a restricted candidate list (RCL) is made from the candidate list according to the greedy evaluation function as shown in (3).</p><p><disp-formula id="bmcM3"><label>(3)</label>RCL &#x02190; {s &#x02208; C or G|HScore (Solution &#x0222a; s) &#x02264; Smin + &#x003b1; (Smax-Smin)}</disp-formula></p><p>where</p><p>Smin &#x02190; min {HScore (Solution &#x0222a; t)|&#x02200; t &#x02208; C or G}</p><p>Smax &#x02190; max {HScore (Solution &#x0222a; t)|&#x02200; t &#x02208; C or G}</p><p>C is the candidate list of conditions</p><p>G is the candidate list of genes</p><p>&#x003b1; is the RCL threshold parameter, &#x003b1; &#x02208; [0..1]</p><p>The element to be incorporated into the partial solution is randomly selected from those in the RCL. Once the selected element is incorporated to the partial solution, the candidate list is updated and the incremental costs are reevaluated. The quality of elements in the RCL depends greatly on the threshold parameter &#x003b1;. &#x003b1; = 1 corresponds to pure random construction, as &#x003b1; &#x02192; 0; the algorithm behaves more or less like greedy algorithms. Hence for better results, proper tuning on the value of &#x003b1; is required and usually it is determined through experimentation. Since the solution constructed during the construction phase is not necessarily optimal, the local search is performed over the constructed solution for further improvements.</p></sec><sec><title>Biclustering using Reactive GRASP</title><p>In Reactive GRASP, instead of using a fixed value for the parameter &#x003b1;, it uses different values in different iterations. During each iteration the value of &#x003b1; is selected from a discrete set of possible values, say R = {&#x003b1;<sub>1</sub>,.....,&#x003b1;<sub>m</sub>}. The solution values found along the previous iterations serve as a guide for the selection process. Let p<sub>i </sub>be the selection probability associated with the choice of &#x003b1;<sub>i</sub>, for i = 1,....., m. Initially all p<sub>i</sub>'s are made equal to 1/m. The selection probabilities are periodically reevaluated using information collected during the search. After each iteration, with a particular &#x003b1;<sub>i</sub>, the difference in the current solution value and the value of the solution obtained in the previous iteration is calculated. Let A<sub>i </sub>be the average value of such differences obtained taking &#x003b1; = &#x003b1;<sub>i </sub>in the construction phase. The probability distribution is updated after each GRASP iteration by taking</p><p><disp-formula id="bmcM4"><label>(4)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S27-i2" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mrow>                              <mml:msub>                                 <mml:mi>p</mml:mi>                                 <mml:mo mathvariant="italic">i</mml:mo>                              </mml:msub>                           </mml:mrow>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>q</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                              </mml:mrow>                              <mml:mrow>                                 <mml:mstyle displaystyle="true">                                    <mml:munderover>                                       <mml:mo>&#x02211;</mml:mo>                                       <mml:mrow>                                          <mml:mi>j</mml:mi>                                          <mml:mo>=</mml:mo>                                          <mml:mn>1</mml:mn>                                       </mml:mrow>                                       <mml:mi>m</mml:mi>                                    </mml:munderover>                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>q</mml:mi>                                          <mml:mi>j</mml:mi>                                       </mml:msub>                                    </mml:mrow>                                 </mml:mstyle>                              </mml:mrow>                           </mml:mfrac>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>with q<sub>i </sub>= 1/A<sub>i </sub>for i = 1,..., m. The value of q<sub>i </sub>will be larger for values of &#x003b1; = &#x003b1;<sub>i </sub>leading to the best solutions on the average. Larger values of q<sub>i </sub>correspond to more suitable values for the parameter &#x003b1;. The probabilities associated with these more appropriate values will then increase when they are reevaluated.</p></sec><sec><title>Significance evaluation</title><p>The statistical significance of the biclusters obtained is evaluated by calculating the <italic>p-values</italic>, which signify how well they match with the known gene annotation. A smaller <italic>p-value</italic>, close to zero, is indicative of a better match [<xref ref-type="bibr" rid="B13">13</xref>]. Tanay et al. [<xref ref-type="bibr" rid="B14">14</xref>] proposed a technique called <italic>correspondence plot </italic>to evaluate the biclusters using prior biological knowledge. It takes advantage of a known classification of genes or experimental conditions. The plot depicts the distribution of <italic>p-values </italic>of the biclusters produced based on a known classification of conditions or a given gene annotation. For each value of <italic>p </italic>on a logarithmic scale, the plot presents the fraction of biclusters whose <italic>p-value </italic>is at most <italic>p </italic>out of the, say <italic>b</italic>, best biclusters. The <italic>p-values </italic>of the biclusters are calculated according to the known classification of genes as follows: It is the probability of finding at least <italic>k</italic> genes in a bicluster of <italic>n</italic> genes, belonging to a specific functional category comprising <italic>f</italic> genes out of total <italic>g</italic> annotated genes is given by</p><p><disp-formula id="bmcM5"><label>(5)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S27-i3" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>p</mml:mi>                              <mml:mi>i</mml:mi>                           </mml:msub>                           <mml:mo>=</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>i</mml:mi>                                    <mml:mo>=</mml:mo>                                    <mml:mi>k</mml:mi>                                 </mml:mrow>                                 <mml:mrow>                                    <mml:mi>min</mml:mi>                                    <mml:mo>&#x02061;</mml:mo>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>n</mml:mi>                                    <mml:mo>,</mml:mo>                                    <mml:mi>f</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                              </mml:munderover>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msup>                                          <mml:mtext>&#x000a0;</mml:mtext>                                          <mml:mi>f</mml:mi>                                       </mml:msup>                                       <mml:msub>                                          <mml:mi>C</mml:mi>                                          <mml:mi>i</mml:mi>                                       </mml:msub>                                       <mml:mo stretchy="false">)</mml:mo>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msup>                                          <mml:mtext>&#x000a0;</mml:mtext>                                          <mml:mrow>                                             <mml:mi>g</mml:mi>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mi>f</mml:mi>                                          </mml:mrow>                                       </mml:msup>                                       <mml:msub>                                          <mml:mi>C</mml:mi>                                          <mml:mrow>                                             <mml:mi>n</mml:mi>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mi>i</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:msup>                                          <mml:mtext>&#x000a0;</mml:mtext>                                          <mml:mi>g</mml:mi>                                       </mml:msup>                                       <mml:msub>                                          <mml:mi>C</mml:mi>                                          <mml:mi>n</mml:mi>                                       </mml:msub>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mrow>                           </mml:mstyle>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>In the correspondence plot, early departure of the curve from the x-axis of the plot indicates the existence of biclusters with low <italic>p-values</italic>. Consequently, area under the curve shows the approximate degree of statistical significance of the biclusters used to draw the curve [<xref ref-type="bibr" rid="B15">15</xref>]. For statistical validation, we used the 30 known categories of Yeast genes reported by Tavazoie et al. [<xref ref-type="bibr" rid="B16">16</xref>]. They used an iterative optimization-based partitional clustering to group 3000 genes into 30 expression classes which were highly enriched for genes of similar function on time-series of mRNA abundance, measured over two synchronized Saccharomyces cerevisiae cell cycles. Also to evaluate the biological significance of the obtained biclusters, in terms of the associated biological processes, molecular functions and cellular components respectively, we have used the SGD GO gene ontology term finder [<xref ref-type="bibr" rid="B17">17</xref>].</p></sec><sec><title>Time complexity of the algorithm</title><p>To find one bicluster from a seed, the algorithm has to compute the <italic>HScores </italic>of all the submatrices that may result from any row (gene) or column (condition) addition, before each choice can be made. Since <italic>m </italic>and <italic>n </italic>are the total number of genes and conditions in the gene expression matrix, the <italic>HScore </italic>can be calculated in O (<italic>mn</italic>) time. Hence in the worst case, the algorithm requires O (<italic>mn </italic>(<italic>m+n</italic>)) time.</p></sec></sec><sec><title>Results</title><sec><title>Dataset used</title><p>The proposed biclustering algorithm is implemented in <italic>Matlab </italic>and tested on the <italic>Yeast Saccharomyces Cerevisiae </italic>cell cycle expression dataset. The dataset is based on Tavazoie et al. [<xref ref-type="bibr" rid="B16">16</xref>] and is taken from [<xref ref-type="bibr" rid="B18">18</xref>]. It is a collection of 2884 genes and 17 experimental conditions (time points), having 34 null entries with -1 indicating the missing values. All entries are integers lying in the range 0 to 595. The value of &#x003b4; is used as an upper limit of allowable dissimilarity among genes and conditions. A higher &#x003b4; is indicative of diminishing homogeneity. Hence in our approach we used a value of 200 for &#x003b4;.</p></sec><sec><title>Biclustering using GRASP and Reactive GRASP</title><p>The Reactive GRASP and basic GRASP algorithms begin the search from tightly co-regulated bicluster seeds. These seeds are enlarged by adding more genes and conditions until the <italic>HScore </italic>of the bicluster reaches the given threshold (&#x003b4;) value. The seed growing is implemented in two phases-construction and local search. During the construction phase it picks a random move from among a restricted candidate list (RCL) of possible best moves. In case of a row or a column addition, RCL contains only top quality rows or columns whose inclusion to the current partial solution doesn't affect feasibility of the solution. The quality of elements in the RCL depends greatly on the threshold parameter &#x003b1; and in GRASP, the same value for &#x003b1; is used along all iterations. But it often hinders finding a high quality solution, which could be found if another value was used. Hence in reactive GRASP a self-adjustable &#x003b1; is used. During each iteration, the value of &#x003b1; is selected from a discrete set of possible values depending on the selection probabilities. The elements of the discrete set can be in the range [0..1]. In order to ensure the quality of solutions, we have completely eliminated the extreme values. Hence in our implementation of Reactive GRASP, we have used 10 numbers in the range [0.25 .. 0.60]. After the construction phase, local search is performed on these solutions to further improvise them.</p><p>In Figure <xref ref-type="fig" rid="F1">1</xref>, four of the biclusters found by the GRASP algorithm on the Yeast dataset are shown. From a visual inspection of the biclusters presented, one can notice that the genes present a similar behaviour under a set of conditions only. Figure <xref ref-type="fig" rid="F2">2</xref> shows the set of biclusters derived from the same seeds using the Reactive GRASP. The <italic>p-values </italic>of the biclusters show significant change from that of the GRASP method.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Biclusters extracted from the Yeast gene expression data using GRASP</bold>. The biclusters are labelled as A, B, C and D. The number of genes, number of conditions, HScore, p-value of the biclusters are (A) (20, 12, 198.70, 2.8479e-020) (B) (12, 11, 197.7, 3.6879e-015) (C) (11, 13, 197.79, 6.0545e-014) (D) (12, 13, 199.9, 2.9778e-009).</p></caption><graphic xlink:href="1471-2105-10-S1-S27-1"/></fig><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Biclusters extracted from the Yeast gene expression data using Reactive GRASP</bold>. The biclusters are labelled as A_R, B_R, C_R and D_R. The number of genes, number of conditions, HScore, p-value of the biclusters are (A_R) (22, 12, 198.81, 6.9185e-025) (B_R) (14, 11, 196.08, 1.3464e-017) (C_R) (14, 13, 197.63, 1.3464e-017) (D_R) (17, 13, 199.02, 7.7195e-019).</p></caption><graphic xlink:href="1471-2105-10-S1-S27-2"/></fig></sec><sec><title>Statistical and biological significance evaluation</title><p>The statistical significance of the biclusters obtained is evaluated by calculating the <italic>p-values</italic>, which signify how well they match with the known gene annotation. For a statistical comparison of the biclusters produced by our method with that of Cheng and Church, we used the <italic>correspondence plot </italic>proposed by Tanay et al. [<xref ref-type="bibr" rid="B14">14</xref>]. Figure <xref ref-type="fig" rid="F3">3</xref> presents the correspondence plot. In the plot, early departure of the curve from the x-axis of the plot indicates the existence of biclusters with low <italic>p-values</italic>. Consequently, area under the curve shows the approximate degree of statistical significance of the biclusters used to draw the curve [<xref ref-type="bibr" rid="B15">15</xref>]. It shows that the biclusters generated by the Reactive GRASP algorithm tend to be more statistically significant than the basic GRASP and Cheng and Church approach. While plotting the correspondence plot, we choose those biclusters in which more than 60% of their annotated members had the same class. Out of those, we only used biclusters that were functionally enriched.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p>Correspondence plot for the Yeast dataset.</p></caption><graphic xlink:href="1471-2105-10-S1-S27-3"/></fig><p>We apply the yeast genome gene ontology termfinder [<xref ref-type="bibr" rid="B17">17</xref>] on each discovered biclusters to evaluate their biological significance in terms of associated biological processes, molecular functions and cellular components respectively. For a sample set of biclusters in Figure <xref ref-type="fig" rid="F4">4</xref>, Table <xref ref-type="table" rid="T4">4</xref> describes the top GO terms of the three categories with the lowest p-values. The GO terms are displayed in the decreasing order of significance. For the bicluster labelled B1, the genes <italic>RFA1, POL12, POL30, CDC9, MSH6, RAD27, CDC45, RFA2</italic>, and <italic>CDC21 </italic>are together involved in the process of DNA-dependent DNA replication, DNA replication and DNA metabolic process. Each GO term is associated with a tuple, for example DNA-dependent DNA replication (9, 1.40e-11) indicates 9 out of the total 16 genes of B1 belong to this process and their statistical significance is 1.40e-11 i.e. p-value. Also from the table it is clear that the biclusters extracted are distinct along each category. Existence of biclusters comprising a significant proportion of those genes that are considered similar biologically is proof that a specific biclustering technique produces biologically relevant results. This shows that our algorithm is capable of identifying a broader range of biologically significant biclusters.</p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>Sample biclusters obtained from Reactive GRASP</bold>. The biclusters are labelled as B1, B2, B3 and B4. The number of genes, number of conditions, HScore are (B1) (16, 16, 199.79) (B2) (61, 14, 143.03) (B3) (12, 14, 198.50 (B4) (14, 12, 125.83).</p></caption><graphic xlink:href="1471-2105-10-S1-S27-4"/></fig><table-wrap position="float" id="T4"><label>Table 4</label><caption><p>Top GO terms (process, function, component) of the biclusters in Figure 4.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center">Bicluster</td><td align="center">Process</td><td align="center">Function</td><td align="center">Component</td></tr></thead><tbody><tr><td align="center">B1</td><td align="left">DNA-dependent DNA replication (9, 1.40e-11), DNA replication (9, 3.48e-10), DNA metabolic process(11, 5.45e-09), DNA repair (8, 4.20e-07)</td><td align="left">double-stranded DNA binding (4, 4.09e-06), structure-specific DNA binding (4, 8.45e-05), sequence-specific DNA binding(4, 4.5e-04)</td><td align="left">replication fork (7,4.10e-11), chromosomal part(8, 2.77e-07) Chromosome(8, 7.84e-07)</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">B2</td><td align="left">Translation (32,2.87e-15), Cellular protein metabolic process (36, 3.59e-9), Protein metabolic process(36, 4.81e-9), Cellular macromolecule biosynthetic process(36,2.51e-08)</td><td align="left">Structural constituent of ribosome (28, 3.59e-25) Structural molecule activity (28, 4.71e-20) Translation elongation factor activity (3, .00213)</td><td align="left">Cytosolic ribosome (29, 8.7e-30), Cytosolic part (29, 1.2e-26) Ribosome(29, 1.09e-25), Ribosomal subunit(32, 1.13e-24), Ribonucleoprotein complex(34, 7.48e-18) Cytosol (33, 2.05e-17)</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">B3</td><td align="left">Cell cycle process (6, 0.00055), Cell cycle(6, 0.00109), Mitotic cell cycle(5, 0.00145), Cell cycle phase(5, 0.00505)</td><td align="left">Kinase regular activity (2, 0.00410)</td><td align="left">Cellular bud (6, 1.73e-06), Site of polarized growth(6, 1.87e-06) Cellular bud neck(5, 2.22e-05) Incipient cellular bud site(3,0.00129)</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">B4</td><td align="left">Ribonucleoprotein complex biogenesis and assembly (10, 2.08e-07) Ribosome biogenesis(9, 1.07e-06)</td><td align="left">Methyl transferase activity (3,8.56e-03) Transferase activity, transferring one-carbon groups(3,9.17e-03)</td><td align="left">Organelle lumen(9,1.2e-04) Intracellular organelle lumen(9, 1.2e-04) Nuclear lumen(8, 2.2e-04) Nucleolus(6, 5.9e-04)</td></tr></tbody></table></table-wrap></sec></sec><sec><title>Discussion</title><p>In GRASP, an appropriate value of the RCL parameter &#x003b1; is clearly critical and relevant to achieve a good balance between computation time and solution quality. But it requires a lot of experimentation overhead to fix the value. Hence we proposed Reactive GRASP, which is a variant of GRASP, to tackle the biclustering problem. Reactive GRASP, being self-adjustable, changes the value of the RCL parameter periodically according with the quality of the solutions obtained recently. The approach looks more robust and doesn't require calibration efforts. The experimental results also indicate that the Reactive GRASP approach outperforms the basic GRASP and Cheng and Church algorithm.</p></sec><sec><title>Conclusion</title><p>This paper dealt with the extraction of biclusters in microarray gene expression data. We addressed the problem with a heuristics based seed-growing algorithm &#x02013; the Reactive GRASP metaheuristics &#x02013; which is a variant of the GRASP approach. The seed biclusters, which are tightly co-regulated submatrices, are obtained by performing k-means clustering algorithm to the rows and columns separately and then by combining them. During seed growing, these seed biclusters are further refined by adding more rows and columns to extend their size while keeping the mean squared residue score below a certain predefined threshold. Since Reactive GRASP being semi-greedy, it tries to combine the advantages of both random and greedy solution constructions and thereby gives the possibility to escape from locally optimal solutions. Also it makes use of a memory mechanism that enables good solutions found in earlier iterations of the search to influence the search later. To our knowledge, biclustering using GRASP techniques has not till been reported before in the literature. We have conducted and tested our algorithm on the Yeast dataset. The experimental results show that the algorithm is successful in finding statistically and biologically verifiable biclusters. Also the correspondence plot reveals that the algorithm finds biclusters that better aligned more closely with prior biological knowledge than that of basic GRASP and Cheng and Church approach.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>SD and ASN participated in the method design. SD performed all the experiments. SD and ASN participated in the result discussion. SD and ASN participated in the paper writing. ASN finalized the submission. All authors read and approved the final manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>We acknowledge the anonymous reviewers for their valuable suggestions. We also thank Dr. Oommen V. Oommen, Professor and Head, Department of Zoology, University of Kerala, India for the encouragement given to us for conducting this work.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Madeira</surname><given-names>SC</given-names></name><name><surname>Oliveira</surname><given-names>AL</given-names></name></person-group><article-title>Biclustering algorithms for biological data analysis: a survey</article-title><source>IEEE Trans Computational Biology and Bioinformatics</source><year>2004</year><volume>1</volume><fpage>24</fpage><lpage>48</lpage></citation></ref><ref id="B2"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Hartigan</surname><given-names>JA</given-names></name></person-group><source>Direct clustering of a data matrix</source><year>1972</year><volume>67</volume><publisher-name>The American Statistical Association</publisher-name><fpage>123</fpage><lpage>127</lpage></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Cheng</surname><given-names>Y</given-names></name><name><surname>Church</surname><given-names>GM</given-names></name></person-group><article-title>Biclustering of gene expression data</article-title><source>Proceedings of the International Conference on Intelligent Systems for Molecular Biology</source><year>2000</year><volume>8</volume><fpage>93</fpage><lpage>103</lpage></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Aguilar-Ruiz</surname><given-names>JesusS</given-names></name></person-group><article-title>Shifting and scaling patterns from gene expression data</article-title><source>Bioinformatics</source><year>2005</year><volume>21</volume><fpage>3840</fpage><lpage>3845</lpage><pub-id pub-id-type="pmid">16144809</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Feo</surname><given-names>TA</given-names></name><name><surname>Resende</surname><given-names>MGC</given-names></name></person-group><article-title>Greedy randomized adaptive search procedures</article-title><source>Global optimization</source><year>1995</year><volume>6</volume><fpage>109</fpage><lpage>133</lpage></citation></ref><ref id="B6"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Resende</surname><given-names>MGC</given-names></name><name><surname>Ribeiro</surname><given-names>CC</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Glover F, Kochenberger G</surname></name></person-group><article-title>Greedy randomized adaptive search procedures</article-title><source>Handbook of Metaheuristics</source><year>2003</year><publisher-name>Kluwer Academic Publishers</publisher-name><fpage>219</fpage><lpage>249</lpage></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Blum</surname><given-names>C</given-names></name><name><surname>Roli</surname><given-names>A</given-names></name></person-group><article-title>Metaheuristics in combinatorial optimization: overview and conceptual comparison</article-title><source>ACM Computing Surveys</source><year>2003</year><volume>35</volume><fpage>268</fpage><lpage>308</lpage></citation></ref><ref id="B8"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Dharan</surname><given-names>S</given-names></name><name><surname>Nair</surname><given-names>ASN</given-names></name></person-group><article-title>Biclustering of gene expression data using greedy randomized adaptive search procedure</article-title><source>Proceedings of IEEE TENCON 2008</source></citation></ref><ref id="B9"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Chakraborty</surname><given-names>A</given-names></name></person-group><article-title>Statistical identification of biclusters in gene expression data</article-title><source>Proceedings of CBGI</source><year>2005</year><fpage>1185</fpage><lpage>1190</lpage></citation></ref><ref id="B10"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>J</given-names></name><name><surname>Wang</surname><given-names>H</given-names></name><name><surname>Wang</surname><given-names>W</given-names></name><name><surname>Yu</surname><given-names>P</given-names></name></person-group><article-title>Enhanced biclustering on expression data</article-title><source>Proceedings of 3rd IEEE Symposium on Bioinformatics and Bioengineering (BIBE' 03)</source><year>2003</year><fpage>321</fpage><lpage>327</lpage></citation></ref><ref id="B11"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Chakraborty</surname><given-names>A</given-names></name></person-group><article-title>Biclustering of gene expression data by simulated annealing</article-title><source>Proceedings of Eighth International Conference on High-Performance Computing in Asia-Pacific Region (HPCASIA '05)</source><year>2005</year><fpage>627</fpage><lpage>632</lpage></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Prais</surname><given-names>M</given-names></name><name><surname>Ribeiro</surname><given-names>CC</given-names></name></person-group><article-title>Reactive GRASP: An application to a matrix decomposition problem in TDMA traffic assignment</article-title><source>INFORMS Journal on Computing</source><year>2000</year><volume>12</volume><fpage>164</fpage><lpage>176</lpage></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Banka</surname><given-names>H</given-names></name><name><surname>Mitra</surname><given-names>S</given-names></name></person-group><article-title>Evolutionary biclustering of gene expressions</article-title><source>ACM Ubiquity</source><year>2006</year><volume>7</volume><fpage>1</fpage><lpage>12</lpage></citation></ref><ref id="B14"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Tanay</surname><given-names>A</given-names></name><name><surname>Sharan</surname><given-names>R</given-names></name><name><surname>Shamir</surname><given-names>R</given-names></name></person-group><article-title>Discovering statistically significant biclusters in gene expression data</article-title><source>Bioinformatics</source><year>2002</year><fpage>136</fpage><lpage>144</lpage></citation></ref><ref id="B15"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Yoon</surname><given-names>S</given-names></name><name><surname>Nardini</surname><given-names>C</given-names></name><name><surname>Benini</surname><given-names>L</given-names></name><name><surname>De Micheli</surname><given-names>G</given-names></name></person-group><article-title>Discovering coherent biclusters from gene expression data using zero-suppressed binary decision diagrams</article-title><source>IEEE/ACM Transactions on Computational Biology and Bioinformatics</source><year>2005</year><volume>2</volume><fpage>339</fpage><lpage>354</lpage><pub-id pub-id-type="pmid">17044171</pub-id></citation></ref><ref id="B16"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Tavazoie</surname><given-names>S</given-names></name><name><surname>Hughes</surname><given-names>JD</given-names></name><name><surname>Campbell</surname><given-names>MJ</given-names></name><name><surname>Cho</surname><given-names>RJ</given-names></name><name><surname>Church</surname><given-names>GM</given-names></name></person-group><article-title>Systematic determination of genetic network architecture</article-title><source>Nat Genet</source><year>1999</year><volume>22</volume><fpage>281</fpage><lpage>285</lpage><pub-id pub-id-type="pmid">10391217</pub-id></citation></ref><ref id="B17"><citation citation-type="other"><article-title>SGD GO Termfinder</article-title><ext-link ext-link-type="uri" xlink:href="http://db.yeastgenome.org/cgi-bin/GO/goTermFinder"/></citation></ref><ref id="B18"><citation citation-type="other"><article-title>Yeast Saccharomyces cerevisiae cell cycle expression dataset</article-title><ext-link ext-link-type="uri" xlink:href="http://arep.med.harvard.edu/biclustering"/></citation></ref></ref-list></back></article>