<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208114</article-id><article-id pub-id-type="pmc">2648749</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S15</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S15</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Finding optimal threshold for correction error reads in DNA assembling</article-title></title-group><contrib-group><contrib id="A1" contrib-type="author"><name><surname>Chin</surname><given-names>Francis YL</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>chin@cs.hku.hk</email></contrib><contrib id="A2" corresp="yes" contrib-type="author"><name><surname>Leung</surname><given-names>Henry CM</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>cmleung2@cs.hku.hk</email></contrib><contrib id="A3" corresp="yes" contrib-type="author"><name><surname>Li</surname><given-names>Wei-Lin</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>weilin@ios.ac.cn</email></contrib><contrib id="A4" contrib-type="author"><name><surname>Yiu</surname><given-names>Siu-Ming</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>smyiu@cs.hku.hk</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Computer Science, The University of Hong Kong, Pokfulam, Hong Kong, PRChina</aff><aff id="I2"><label>2</label>the State Key Laboratory of Computer Science, Institute of software, Chinese Academy of Sciences, 100190, Beijing,  PR China</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S15</fpage><lpage>S15</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S15"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Chin et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Chin et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Chin               YL               Francis                              chin@cs.hku.hk            </dc:author><dc:title>            Finding optimal threshold for correction error reads in DNA assembling         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S15-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S15&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>DNA assembling is the problem of determining the nucleotide sequence of a genome from its substrings, called <italic>reads</italic>. In the experiments, there may be some errors on the reads which affect the performance of the DNA assembly algorithms. Existing algorithms, e.g. ECINDEL and SRCorr, correct the error reads by considering the number of times each length-<italic>k </italic>substring of the reads appear in the input. They treat those length-<italic>k </italic>substrings appear at least <italic>M </italic>times as correct substring and correct the error reads based on these substrings. However, since the threshold <italic>M </italic>is chosen without any solid theoretical analysis, these algorithms cannot guarantee their performances on error correction.</p></sec><sec><title>Results</title><p>In this paper, we propose a method to calculate the probabilities of false positive and false negative when determining whether a length-<italic>k </italic>substring is correct using threshold <italic>M</italic>. Based on this <italic>optimal </italic>threshold <italic>M </italic>that minimizes the total errors (false positives and false negatives). Experimental results on both real data and simulated data showed that our calculation is correct and we can reduce the total error substrings by 77.6% and 65.1% when compared to ECINDEL and SRCorr respectively.</p></sec><sec><title>Conclusion</title><p>We introduced a method to calculate the probability of false positives and false negatives of the length-<italic>k </italic>substring using different thresholds. Based on this calculation, we found the optimal threshold to minimize the total error of false positive plus false negative.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>DNA <italic>assembling </italic>is the problem of determining the nucleotide sequence of a genome from its substrings, called <italic>reads</italic>. Since DNA assembling is the first step in bioinformatics research, there are many different technologies, e.g. BAC-by-BAC approach [<xref ref-type="bibr" rid="B1">1</xref>], Sanger technique [<xref ref-type="bibr" rid="B2">2</xref>], for getting reads from a genome and there are many assembly algorithms [<xref ref-type="bibr" rid="B3">3</xref>-<xref ref-type="bibr" rid="B5">5</xref>] for solving the DNA assembling problem. In recent years, there is a technology breakthrough on getting reads from genomes. While the traditional technologies produce long reads (600&#x02013;700 bp) with low coverage (each nucleotide is covered by 10 different reads) and low error rate, the Next Generation Sequencing (NGS) technologies, e.g. Solexa [<xref ref-type="bibr" rid="B6">6</xref>], Illumina [<xref ref-type="bibr" rid="B7">7</xref>], can produce short reads (25&#x02013;300 bp) with high coverage (each nucleotide is covered by &#x0003e; 30 different reads) and high error rate using much less time and cost. Theoretically, we can determine the sequence of a genome in much shorter time and lower cost using the NGS technologies. However, many existing DNA assembling algorithms [<xref ref-type="bibr" rid="B8">8</xref>-<xref ref-type="bibr" rid="B10">10</xref>] were designed for traditional technologies which can handle reads with low error rate only and many new algorithms [<xref ref-type="bibr" rid="B11">11</xref>-<xref ref-type="bibr" rid="B14">14</xref>] designed for the NGS technologies assume the input reads are error free. Correcting errors in reads becomes an important problem for DNA assembling [<xref ref-type="bibr" rid="B15">15</xref>].</p><p>Since the NGS technology produces reads with high coverage, a read may be sampled several times in the genome. Under the assumption that an error read is unlikely to be sampled several time, Sundquist et al. [<xref ref-type="bibr" rid="B16">16</xref>] designed an algorithm called SHRAP which corrects the error reads by considering the number of times a read being sampled. If a read is sampled more than <italic>M </italic>times, for some predefined threshold <italic>M</italic>, it is considered as a correct read, otherwise, an error read which will not be used in the assembly step.</p><p>However, since the reads are randomly sampled from the genome, some correct reads may be sampled less (&#x0003c;<italic>M </italic>times) than the others, it is difficult to determine the threshold <italic>M </italic>to minimize the number of false negatives (increases with <italic>M</italic>) and the number of false positives (decreases with <italic>M</italic>). Besides, many reads with only one or two errors are wasted and will not be considered in the assembly step.</p><p>In order to consider reads with only one or two errors in the assembly step (which will increase the performance of the algorithm), Chaisson et al. [<xref ref-type="bibr" rid="B17">17</xref>] proposed another approach, called ECINDEL, to correct the errors in reads. Instead of considering the number of times a read being sampled, they considered the number of times each length-<italic>k </italic>substrings, called <italic>k</italic>-tuple, being sampled. A <italic>k</italic>-tuple is treated as correct if and only if it is sampled at least <italic>M </italic>times. By reducing the value of <italic>k</italic>, a higher threshold <italic>M </italic>can be set (compared to SHRAP) such that both the false positives and false negatives are small. Besides, error reads can be corrected by replacing some nucleotides in the reads such that all length-<italic>k </italic>substrings in the reads are correct <italic>k</italic>-tuples. Although this method seems nice, the value of <italic>k </italic>cannot be set to an arbitrary small number, e.g. when <italic>k </italic>= 1, we know that all 1-tuple, 'A', 'C', 'G' and 'T' are correct and we cannot use this information to correct the error reads. Thus there is still a problem of how to set the optimal thresholds <italic>k </italic>and <italic>M</italic>.</p><p>Wong et al. [<xref ref-type="bibr" rid="B15">15</xref>] designed another algorithm, called SRCorr, which improves ECINDEL by considering multiple <italic>k </italic>and <italic>M</italic>. Instead of considering only one pair of thresholds <italic>k </italic>and <italic>M</italic>, several sets of correct <italic>k</italic>-tuples with different lengths are determined and used to correct the error reads. Although some improvements have been made on correcting error reads, it is still difficult to set the thresholds.</p><p>In this paper, (1) we propose a method to calculate the probabilities of false positive and false negative for different substring lengths <italic>k </italic>and thresholds <italic>M </italic>in a data set. Experimental results show that the calculated probabilities match with the real data and simulated data. (2) Based on this calculation, we calculate the <italic>optimal M </italic>(minimizing the total errors = false positives + false negatives) for each substring length <italic>k</italic>. By using the optimal threshold <italic>M</italic>, the total errors can be reduced by 77.6% and 65.1% when compared to ECINDEL [<xref ref-type="bibr" rid="B17">17</xref>] and SRCorr [<xref ref-type="bibr" rid="B15">15</xref>] respectively.</p></sec><sec><title>Results and Discussion</title><p>When the hidden genome <italic>G </italic>is known, we can count the number of true positives TP (<italic>k</italic>-tuples occur in <italic>G </italic>which are sampled at least <italic>M </italic>times), false positives FP (<italic>k</italic>-tuples do not occur in <italic>G </italic>which are sampled at least <italic>M </italic>times) and false negatives FN (<italic>k</italic>-tuples occur in <italic>G </italic>which are sampled less than <italic>M </italic>times) for each threshold <italic>M</italic>. Therefore, we can find the optimal threshold <italic>M </italic>that minimizes the total errors FP + FN.</p><p>However, when solving the DNA assembling problem, the genome <italic>G </italic>is unknown. Both ECINDEL [<xref ref-type="bibr" rid="B17">17</xref>] and SRCorr [<xref ref-type="bibr" rid="B15">15</xref>] do not have a sound theoretical analysis on how to set the threshold <italic>M</italic>. When the number of sampled reads is large, even the incorrect <italic>k</italic>-tuples are sampled <italic>M </italic>times or more, these algorithms have many false positives. When the number of sampled reads is small, even the correct <italic>k</italic>-tuples are sampled less than <italic>M </italic>times, these algorithms have many false negatives. Instead of using an arbitrary threshold <italic>M</italic>, we calculate the expected number of true positives, false positives and false negatives according to the equations described in the Methods Section. By considering the optimal threshold <italic>M </italic>that minimizes the expected false positives plus false negatives (FP + FN), we can get a set of <italic>k</italic>-tuples with the minimum expected number of errors. In this paper, we will perform experiments on both real experimental data and simulated data. The experimental results show that (1) the expected number true positives, false positives and false negatives match with the real data. Therefore, the optimal threshold <italic>M </italic>calculated by us minimizes the total errors (FP + FN). (2) By using the optimal threshold <italic>M </italic>calculated by us, the total errors reduced by 77.6% and 65.1% when compared to ECINDEL and SRCorr respectively.</p><sec><title>Experimental results on real data</title><p>We performed experiments on a real data set from the human genome. The hidden genome is a subregion of the human genome of length 173427, length-35 reads are sampled from the genome using Solexa [<xref ref-type="bibr" rid="B6">6</xref>] techniques.</p><p>Figures <xref ref-type="fig" rid="F1">1</xref> and <xref ref-type="fig" rid="F2">2</xref> show the number of false positives and false negatives for different threshold <italic>M </italic>on this data set when the substring length <italic>k </italic>are 15 and 20 respectively. Since the number of false positives decreases with <italic>M </italic>and the number of false negatives increases with <italic>M</italic>, the total errors (FP + FN) is a U-shape curve. The minimum point of this curve represents the optimal threshold <italic>M </italic>that minimizes the total errors. Besides, the optimal <italic>M</italic>* increases when the length of the <italic>k</italic>-tuple decreases. For example, the optimal threshold <italic>M</italic>* for 15-tuples is 32 which is larger than the optimal threshold <italic>M</italic>* for 20-tuples (<italic>M</italic>* = 24). According to the equations in the Method Section, we can calculate the expected number of false positives and false negatives. Thus, we can find the threshold <italic>M </italic>with the minimum expected number of errors. We find that the threshold <italic>M </italic>is exactly the same as the optimal threshold <italic>M</italic>*</p><p>We compared the number of false positives and false negatives of ECINDEL and SRCorr with our algorithm. In the experiment, we used <italic>k </italic>= 15 which is the default parameter of SRCorr. Since SRCorr uses a range of substring length <italic>k</italic>, when comparing the performance on <italic>k</italic>-tuples, we considered the 15-tuples of SRCorr only. When comparing the performance on reads, SRCorr runs with multiple <italic>k </italic>and <italic>M </italic>to correct errors on reads. Tables <xref ref-type="table" rid="T1">1</xref> and <xref ref-type="table" rid="T2">2</xref> show the performance of the algorithms on 15-tuples and reads respectively.</p><p>As described in Table <xref ref-type="table" rid="T1">1</xref>, ECINDEL produces a set of 15-tuples with 12670 errors (FP + FN). By considering multiple thresholds, SRCorr reduces the number of errors to 8140. Since the converge of this dataset is high, instead of using a small threshold <italic>M </italic>(12 and 15), we calculated an optimal threshold <italic>M</italic>* = 32 and reduced the number of errors to 2839. Therefore, the number of errors were reduced by 77.6% and 65.1% when compared with ECINDEL and SRCorr respectively. With a better set of 15-tuples than ECINDEL and SRCorr, we corrected the reads such that the total errors reduced to 33477 when compared with ECINDEL(192533) and SRCorr(212287) respectively. Note that when considering the corrected reads, we have less false positives and less false negatives than these two algorithms.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>k = 15</bold>. Number of false positives, false negatives and their sum of 15-tuples from real data versus multiplicity.</p></caption><graphic xlink:href="1471-2105-10-S1-S15-1"/></fig><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>k = 20</bold>. Number of false positives, false negatives and their sum of 20-tuples from real data versus multiplicity.</p></caption><graphic xlink:href="1471-2105-10-S1-S15-2"/></fig><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Comparison of 15-tuples on real data set</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center">M</td><td align="center"># of false positives</td><td align="center"># of false negatives</td><td align="center">total errors</td></tr></thead><tbody><tr><td align="center">ECINDEL</td><td align="center">12</td><td align="center">12494</td><td align="center">176</td><td align="center">12670</td></tr><tr><td align="center">SRCorr</td><td align="center">15</td><td align="center">7890</td><td align="center">250</td><td align="center">8140</td></tr><tr><td align="center">Our Algorithm</td><td align="center">32</td><td align="center">1583</td><td align="center">1256</td><td align="center">2839</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Comparison of corrected reads on real data set</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center">M</td><td align="center"># of false positives</td><td align="center"># of false negatives</td><td align="center">total errors</td></tr></thead><tbody><tr><td align="center">ECINDEL</td><td align="center">12</td><td align="center">19334</td><td align="center">173199</td><td align="center">192533</td></tr><tr><td align="center">SRCorr</td><td align="center">15</td><td align="center">181628</td><td align="center">30659</td><td align="center">212287</td></tr><tr><td align="center">Our Algorithm</td><td align="center">32</td><td align="center">30039</td><td align="center">3438</td><td align="center">33477</td></tr></tbody></table></table-wrap></sec><sec><title>Experimental results on simulated data</title><p>In this section, we compared the performance of ECINDEL, SRCorr and our algorithm on simulated data. The simulated data was generated as follows: We generated a length-<italic>g </italic>genome sequence <italic>G </italic>with equal occurrence probability of each nucleotide (1/4). <italic>n </italic>length-35 reads were sampled from <italic>G </italic>with equal probabilities. Each nucleotide in each read could mutate to another nucleotide with probability <italic>p</italic><sub><italic>err</italic></sub>. The probability that a nucleotide mutates to each of the other nucleotide is the same (1/3). The <italic>n </italic>length-35 reads (after mutation) were considered as input for the algorithms. Similarly with the experiments on real data, we set the default parameter <italic>k </italic>= 15 of SRCorr when comparing the <italic>k</italic>-tuples. When comparing the performance on reads correction, SRCorr runs with multiple <italic>k </italic>and <italic>M</italic>.</p><p>Tables <xref ref-type="table" rid="T3">3</xref> and <xref ref-type="table" rid="T4">4</xref> show the performances of the algorithms on 15-tuples and reads respectively when <italic>g </italic>= 79745, <italic>n </italic>= 220000 and <italic>p</italic><sub><italic>err </italic></sub>= 4%.</p><table-wrap position="float" id="T3"><label>Table 3</label><caption><p>Comparison of 15-tuples on simulated data (coverage = 2.75&#x000d7;)</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center">M</td><td align="center"># of false positives</td><td align="center"># of false negatives</td><td align="center">total errors</td></tr></thead><tbody><tr><td align="center">ECINDEL</td><td align="center">12</td><td align="center">4</td><td align="center">18</td><td align="center">22</td></tr><tr><td align="center">SRCorr</td><td align="center">4</td><td align="center">5264</td><td align="center">5</td><td align="center">5269</td></tr><tr><td align="center">Our Algorithm</td><td align="center">11</td><td align="center">5</td><td align="center">13</td><td align="center">18</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T4"><label>Table 4</label><caption><p>Comparison of corrected reads on simulated data (coverage = 2.75&#x000d7;)</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center">M</td><td align="center"># of false positives</td><td align="center"># of false negatives</td><td align="center">total errors</td></tr></thead><tbody><tr><td align="center">ECINDEL</td><td align="center">12</td><td align="center">46459</td><td align="center">49204</td><td align="center">95663</td></tr><tr><td align="center">SRCorr</td><td align="center">4</td><td align="center">53036</td><td align="center">31699</td><td align="center">84735</td></tr><tr><td align="center">Our Algorithm</td><td align="center">11</td><td align="center">308</td><td align="center">8564</td><td align="center">8872</td></tr></tbody></table></table-wrap><p>Since there were relatively fewer reads being sampled (coverage = 2.75&#x000d7;) in this data set, SRCorr applied a small threshold <italic>M </italic>= 4 for the 15-tuples. As SRCorr chose this threshold without much analysis, the threshold selected was too small such that there were many false positives and the total errors was 5269 for the 15-tuples. ECINDEL applied a fix threshold <italic>M </italic>= 12 and the total errors was 22. Based on the optimal threshold <italic>M</italic>* = 11 we derived, we produced a set of 15-tuples with the fewest number of errors (18 errors). Similarly for the real data set, since we have derived a set of 15-tuples with less errors than ECINDEL and SRCorr, we could correct more error reads than ECINDEL and SRCorr (8872 errors instead of 95663 errors and 84735 errors). The corrected reads produced by us had less false positives and false negatives than ECINDEL. Since SRCorr applied a small threshold, 75863 more false positive reads were introduced when compared with our algorithm.</p><p>Table <xref ref-type="table" rid="T5">5</xref> and <xref ref-type="table" rid="T6">6</xref> show the performances of the algorithms on 15-tuples and reads respectively when <italic>g </italic>= 79745, <italic>n </italic>= 1000000 and <italic>p</italic><sub><italic>err </italic></sub>= 4%.</p><table-wrap position="float" id="T5"><label>Table 5</label><caption><p>Comparison of <italic>k</italic>-tuples on simulated data (coverage = 12.53&#x000d7;)</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center">M</td><td align="center"># of false positives</td><td align="center"># of false negatives</td><td align="center">total errors</td></tr></thead><tbody><tr><td align="center">ECINDEL</td><td align="center">12</td><td align="center">1699</td><td align="center">4</td><td align="center">1703</td></tr><tr><td align="center">SRCorr</td><td align="center">15</td><td align="center">1011</td><td align="center">5</td><td align="center">1016</td></tr><tr><td align="center">Our Algorithm</td><td align="center">52</td><td align="center">3</td><td align="center">15</td><td align="center">18</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T6"><label>Table 6</label><caption><p>Comparison of corrected reads on simulated data (coverage = 12.53&#x000d7;)</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center">M</td><td align="center"># of false positives</td><td align="center"># of false negatives</td><td align="center">total errors</td></tr></thead><tbody><tr><td align="center">ECINDEL</td><td align="center">12</td><td align="center">132850</td><td align="center">30338</td><td align="center">163188</td></tr><tr><td align="center">SRCorr</td><td align="center">15</td><td align="center">102288</td><td align="center">1512</td><td align="center">103800</td></tr><tr><td align="center">Our Algorithm</td><td align="center">52</td><td align="center">1216</td><td align="center">49</td><td align="center">1265</td></tr></tbody></table></table-wrap><p>When compared to the previous set of simulated data, we had more sampled reads in this data set (coverage = 12.53&#x000d7;). Since ECINDEL and SRCorr applied a small threshold (12 and 15) for determining correct 15-tuples, they had many errors (1703 and 1016). Instead of using a small threshold, we arrived at an optimal threshold <italic>M</italic>* = 52 which cound determine the correct 15-tuples with 18 errors only. With a set of 15-tuples with less errors, we could correct the errors in reads better than ECINDEL and SRCorr and produced a set of reads with 1265 errors, much less than ECINDEL and SRCorr (163188 and 103800 errors respectively), and in terms of the number of false positives and false negatives; both of them were less than ECINDEL's and SRCorr's results.</p></sec></sec><sec><title>Conclusion</title><p>We have studied the problem of correcting error reads in DNA assembling. We introduced a method to calculate the probability of false positives and false negatives of the <italic>k</italic>-tuples using different thresholds <italic>M</italic>. Based on this calculation, we found the optimal threshold <italic>M</italic>* that minimizes the total error (FP + FN). Our calculation can also be extended to total errors with different weightings of FP and FN. Our algorithm, which uses optimal threshold <italic>M</italic>* to correct error reads, performs better than the popular algorithms ECINDEL and SRCorr.</p><p>In the real biological data, we might not be able to remove all the false positives and false negatives by a fixed threshold <italic>M</italic>. It is mainly because the probability of each read being sampled is not the same in real experiment. This probability depends on the patterns of the reads, the positions of the reads in the genome and the adjacent reads. A better model might be needed to determine whether a <italic>k</italic>-tuple is correct (instead of using a fixed threshold <italic>M</italic>) and to correct more error reads.</p></sec><sec sec-type="methods"><title>Methods</title><p>In this section, we will first describe Chaisson et al.'s [<xref ref-type="bibr" rid="B17">17</xref>] approach, called ECINDEL, for correcting error reads. Sundquist et al.'s [<xref ref-type="bibr" rid="B16">16</xref>] approach is a special case of ECINDEL by setting <italic>k </italic>equals read length and Wong et al.'s [<xref ref-type="bibr" rid="B15">15</xref>] approach is a general case of ECINDEL by considering multiple <italic>k</italic>. Then we will describe how to calculate the probability of true positive, false positive and false negative for determining whether a <italic>k</italic>-tuple is correct by threshold <italic>M</italic>. Based on this calculation, we will describe how to determine the optimal threshold <italic>M</italic>* for Chaisson et al.'s, Sundquist et al.'s and Wong et al.'s approach.</p><sec><title>ECINDEL algorithm</title><p>Given a set of reads <italic>R </italic>from a hidden genome <italic>G</italic>, ECINDEL determines a set <italic>G</italic><sub><italic>k </italic></sub>of length-<italic>k </italic>substrings, <italic>k</italic>-<italic>tuples</italic>, which appear in more than <italic>M </italic>reads in <italic>R</italic>. ECINDEL considers all <italic>k</italic>-tuples in <italic>G</italic><sub><italic>k </italic></sub>correct (are substrings of <italic>G</italic>) and all <italic>k</italic>-tuples not in <italic>G</italic><sub><italic>k </italic></sub>incorrect (are not substrings of <italic>G</italic>). Under the assumption that all <italic>k</italic>-tuples of a correct read are correct, ECINDEL considers reads with all its <italic>k</italic>-tuples in <italic>G</italic><sub><italic>k </italic></sub>as correct reads. For those reads <italic>s </italic>with <italic>k</italic>-tuples not in <italic>G</italic><sub><italic>k</italic></sub>, ECINDEL tries to correct errors in <italic>s </italic>by modifiying <italic>s </italic>to another read <italic>s' </italic>with the minimum number of operations (edit distance) such that all <italic>k</italic>-tuples in <italic>s' </italic>are in <italic>G</italic><sub><italic>k</italic></sub>. As you can see, the performance of this algorithm depends on the quality of the set <italic>G</italic><sub><italic>k</italic></sub>. If there are many false negatives(correct <italic>k</italic>-tuple not in <italic>G</italic><sub><italic>k</italic></sub>), ECINDEL will modifiy the correct reads to error reads or another correct reads which will decrease the number of correct reads in the input. If there are many false positives (incorrect <italic>k</italic>-tuple in <italic>G</italic><sub><italic>k</italic></sub>), ECINDEL will treat some error reads as correct reads which will affect the performance of the assembly algorithms.</p><p>In order to calculate the probabilities of false positive and false negative, we assume the reads <italic>R </italic>sampled from <italic>G </italic>are generated as follows: Let <italic>G </italic>be a genome sequence of length <italic>g </italic>and we sample <italic>n </italic>length-<italic>l </italic>substrings (reads) (set <italic>R</italic>) from <italic>G </italic>independently. Every position is uniformly sampled from <italic>G </italic>with the same probability 1/(<italic>g </italic>- <italic>l </italic>+ 1) (The same position can be sampled more than once). Each nucleotide in each read in <italic>R </italic>may be erroneous with probability <italic>p</italic><sub><italic>err</italic></sub>. We consider all length-<italic>k </italic>substrings (<italic>k</italic>-tuples) of every length-<italic>l </italic>read in <italic>R</italic>, <italic>k </italic>= l, as input.</p><p>Given a <italic>k</italic>-tuple <italic>T</italic>, let</p><p>&#x02022; <italic>T</italic><sub><italic>t </italic></sub>be a variant of <italic>T </italic>with exactly <italic>t </italic>mismatches (<italic>t </italic>= 0, ..., <italic>k</italic>, <italic>T</italic><sub>0 </sub>= <italic>T</italic>).</p><p>&#x02022; <italic>Y</italic><sub><italic>r </italic></sub>be the event that <italic>T </italic>appears exactly <italic>r </italic>times in <italic>R</italic>.</p><p>&#x02022; <italic>X</italic><sub><italic>t </italic></sub>be the event that <italic>T</italic><sub><italic>t </italic></sub>is a part of the reference sequence.</p><p>Assume we treat all <italic>k</italic>-tuples <italic>T </italic>with sample numbers <italic>r </italic>&#x02265; <italic>M </italic>as substrings of <italic>G</italic>, we want to calculate the probabilities of <italic>T </italic>being a true positive <italic>Pr</italic>(<italic>X</italic><sub>0</sub>|&#x0222a;<sub><italic>r</italic>&#x02265;<italic>M </italic></sub><italic>Y</italic><sub><italic>r</italic></sub>), false positive 1 - <italic>Pr</italic>(<italic>X</italic><sub>0</sub>|&#x0222a;<sub><italic>r</italic>&#x02265;<italic>M </italic></sub><italic>Y</italic><sub><italic>r</italic></sub>) and false negative <italic>Pr</italic>(<italic>X</italic><sub>0</sub>|&#x0222a;<sub><italic>r </italic>&#x0003c;<italic>M </italic></sub><italic>Y</italic><sub><italic>r</italic></sub>)).</p></sec><sec><title>Probabilities of false positive and false negative</title><p>In this section, we will calculate the probabilities of <italic>T </italic>being a true positive <italic>Pr</italic>(<italic>X</italic><sub>0</sub>|&#x0222a;<sub><italic>r</italic>&#x02265;<italic>M </italic></sub><italic>Y</italic><sub><italic>r</italic></sub>), false positive 1- <italic>Pr</italic>(<italic>X</italic><sub>0</sub>|&#x0222a;<sub><italic>r </italic>&#x0003e; <italic>M </italic></sub><italic>Y</italic><sub><italic>r</italic></sub>) and false negative <italic>Pr</italic>(<italic>X</italic><sub>0</sub>|&#x0222a;<sub><italic>r </italic>&#x0003c;<italic>M </italic></sub><italic>Y</italic><sub><italic>r</italic></sub>)) assuming that <italic>T </italic>is a <italic>k</italic>-tuple where sample number &#x02265; threshold <italic>M</italic>. Since the calculation of these probabilities depends on the value of <italic>Pr</italic>(<italic>Y</italic><sub><italic>r</italic></sub>), the probability that <italic>T </italic>appears exactly <italic>r </italic>times in <italic>R</italic>, we will first describe how to calculate <italic>Pr</italic>(<italic>Y</italic><sub><italic>r</italic></sub>). Then we will describe how to calculate the true positive, false positive and false negative based on <italic>Pr</italic>(<italic>Y</italic><sub><italic>r</italic></sub>). Assume <italic>k</italic>-tuple <italic>T </italic>is sampled <italic>r </italic>times in the set of reads <italic>R</italic>, the <italic>r </italic>samples of <italic>T </italic>coming from <italic>r </italic>reads (length-<italic>l </italic>substrings in <italic>G</italic>) appear in different positions of <italic>G </italic>and multiple copies of <italic>T </italic>may be sampled from the same position. Copies of <italic>T </italic>are sampled at different positions either because (1) a <italic>k</italic>-tuple <italic>T </italic>= <italic>T</italic><sub>0 </sub>occurs in one of these positions of <italic>G </italic>or (2) a variant <italic>T</italic><sub><italic>t </italic></sub>of <italic>T </italic>occurs in one of these positions of <italic>G </italic>and <italic>T </italic>is sampled because of error. When <italic>t </italic>is small (e.g. <italic>t </italic>= 0, 1, 2), the probability that <italic>T </italic>being sampled from these positions will be considered. When <italic>t </italic>is large (e.g. <italic>t </italic>= <italic>k</italic>), the probability that <italic>T </italic>being sampled from these positions is low and can be ignored. We first calculate the probability <italic>p</italic><sub><italic>occ</italic></sub>(<italic>g</italic>, <italic>t</italic>) that a variant <italic>T</italic><sub><italic>t </italic></sub>of <italic>T</italic>, <italic>t </italic>= 0, ..., <italic>k</italic>, appears in a particular position of a length-<italic>g </italic>genome sequence <italic>G</italic>. Then we calculate the probability <italic>p</italic><sub><italic>sam</italic></sub>(<italic>g</italic>, <italic>s'</italic>) that a particular position is sampled <italic>s' </italic>times and the probability <italic>p</italic><sub><italic>count</italic></sub>(<italic>g</italic>, <italic>s'</italic>, <italic>r'</italic>) that <italic>r' </italic>out of these <italic>s' </italic>samples are <italic>T </italic>. By considering all positions of <italic>G</italic>, we can calculate the probability <italic>Pr</italic>(<italic>Y</italic><sub><italic>r</italic></sub>) that <italic>T </italic>appears exactly <italic>r </italic>times in <italic>R</italic>.</p><p>Given a length-<italic>g </italic>random genome <italic>G </italic>with each nucleotide having the same occurrence probability (1/4), the probability that a variant <italic>T</italic><sub><italic>t </italic></sub>of <italic>T </italic>occurs at a particular position <italic>i </italic>of <italic>G</italic>, i.e. <italic>G </italic>[<italic>i</italic>...<italic>i </italic>+ <italic>k </italic>- 1] is a variant <italic>T</italic><sub><italic>t </italic></sub>of <italic>T</italic>, is</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S15-i1" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>p</mml:mi>                              <mml:mrow>                                 <mml:mi>o</mml:mi>                                 <mml:mi>c</mml:mi>                                 <mml:mi>c</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>g</mml:mi>                           <mml:mo>,</mml:mo>                           <mml:mi>t</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:msup>                                    <mml:mn>3</mml:mn>                                    <mml:mi>t</mml:mi>                                 </mml:msup>                                 <mml:mrow>                                    <mml:mo>(</mml:mo>                                    <mml:mrow>                                       <mml:mtable>                                          <mml:mtr>                                             <mml:mtd>                                                <mml:mi>k</mml:mi>                                             </mml:mtd>                                          </mml:mtr>                                          <mml:mtr>                                             <mml:mtd>                                                <mml:mi>t</mml:mi>                                             </mml:mtd>                                          </mml:mtr>                                       </mml:mtable>                                    </mml:mrow>                                    <mml:mo>)</mml:mo>                                 </mml:mrow>                              </mml:mrow>                              <mml:mrow>                                 <mml:msup>                                    <mml:mn>4</mml:mn>                                    <mml:mi>k</mml:mi>                                 </mml:msup>                              </mml:mrow>                           </mml:mfrac>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>Genome sequences, especially the non-coding sequences, are highly heterogeneous in composition. The i.i.d. model cannot reflect the real situation of the genome sequences well. On the other hand, genome <italic>G </italic>is generated by other models, e.g. Markov Chain, <italic>p</italic><sub><italic>occ</italic></sub>(<italic>g</italic>, <italic>t</italic>) can also be calculated easily. However, this part has little effect on the overall result, as the number can be cut in the later calculation.</p><p>Let <italic>T</italic><sub><italic>t </italic></sub>be a <italic>k</italic>-length substring obtained at position <italic>i </italic>of <italic>G</italic>. Since only those reads containing the substring from position <italic>i </italic>to <italic>i </italic>- <italic>k </italic>+ 1 can contribute <italic>T</italic><sub><italic>t</italic></sub>, copy of <italic>T</italic><sub><italic>t </italic></sub>can be obtained from at most <italic>l </italic>- <italic>k </italic>+ 1 different reads, exactly <italic>l </italic>- <italic>k </italic>+ 1 reads in most cases when <italic>l </italic>- <italic>k </italic>+ 1 &#x02264; <italic>i </italic>&#x02264; <italic>g </italic>- <italic>l </italic>+ 1. When <italic>g </italic>&#x0003e;&#x0003e; <italic>l</italic>, the probability that <italic>T</italic><sub><italic>t </italic></sub>is sampled <italic>s' </italic>times at can be approximated by</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S15-i2" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>p</mml:mi>                              <mml:mrow>                                 <mml:mi>s</mml:mi>                                 <mml:mi>a</mml:mi>                                 <mml:mi>m</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>g</mml:mi>                           <mml:mo>,</mml:mo>                           <mml:msup>                              <mml:mi>s</mml:mi>                              <mml:mo>&#x02032;</mml:mo>                           </mml:msup>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mtable>                                    <mml:mtr>                                       <mml:mtd>                                          <mml:mi>n</mml:mi>                                       </mml:mtd>                                    </mml:mtr>                                    <mml:mtr>                                       <mml:mtd>                                          <mml:msup>                                             <mml:mi>s</mml:mi>                                             <mml:mo>&#x02032;</mml:mo>                                          </mml:msup>                                       </mml:mtd>                                    </mml:mtr>                                 </mml:mtable>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                           <mml:msup>                              <mml:mrow>                                 <mml:mrow>                                    <mml:mo>(</mml:mo>                                    <mml:mrow>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:mi>l</mml:mi>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mi>k</mml:mi>                                             <mml:mo>+</mml:mo>                                             <mml:mn>1</mml:mn>                                          </mml:mrow>                                          <mml:mi>g</mml:mi>                                       </mml:mfrac>                                    </mml:mrow>                                    <mml:mo>)</mml:mo>                                 </mml:mrow>                              </mml:mrow>                              <mml:msup>                                 <mml:mi>s</mml:mi>                                 <mml:mo>&#x02032;</mml:mo>                              </mml:msup>                           </mml:msup>                           <mml:msup>                              <mml:mrow>                                 <mml:mrow>                                    <mml:mo>(</mml:mo>                                    <mml:mrow>                                       <mml:mn>1</mml:mn>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:mi>l</mml:mi>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mi>k</mml:mi>                                             <mml:mo>+</mml:mo>                                             <mml:mn>1</mml:mn>                                          </mml:mrow>                                          <mml:mi>g</mml:mi>                                       </mml:mfrac>                                    </mml:mrow>                                    <mml:mo>)</mml:mo>                                 </mml:mrow>                              </mml:mrow>                              <mml:mrow>                                 <mml:mi>n</mml:mi>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:msup>                                    <mml:mi>s</mml:mi>                                    <mml:mo>&#x02032;</mml:mo>                                 </mml:msup>                              </mml:mrow>                           </mml:msup>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>When <italic>g </italic>is large, <italic>p</italic><sub><italic>sam</italic></sub>(<italic>g</italic>, <italic>s'</italic>) can be approximated by the normal distribution with mean equals</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S15-i3" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>n</mml:mi>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>l</mml:mi>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mi>k</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                    </mml:mrow>                                    <mml:mi>g</mml:mi>                                 </mml:mfrac>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>and variance equals</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S15-i4" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>n</mml:mi>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>l</mml:mi>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mi>k</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                    </mml:mrow>                                    <mml:mi>g</mml:mi>                                 </mml:mfrac>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mn>1</mml:mn>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>l</mml:mi>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mi>k</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                    </mml:mrow>                                    <mml:mi>g</mml:mi>                                 </mml:mfrac>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>In some real experimental data where each position is not sampled with the same probability, we may estimate the mean and variance of <italic>p</italic><sub><italic>sam</italic></sub>(<italic>g</italic>, <italic>s'</italic>) from training data.</p><p>When a read with variant <italic>T</italic><sub><italic>t </italic></sub>of <italic>T </italic>is sampled, the probability <italic>p</italic><sub><italic>t </italic></sub>that we get the <italic>k</italic>-tuple <italic>T </italic>instead of <italic>T</italic><sub><italic>t </italic></sub>as input because of error is</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S15-i5" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>p</mml:mi>                              <mml:mi>t</mml:mi>                           </mml:msub>                           <mml:mo>=</mml:mo>                           <mml:msup>                              <mml:mrow>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:msub>                                    <mml:mi>p</mml:mi>                                    <mml:mrow>                                       <mml:mi>e</mml:mi>                                       <mml:mi>r</mml:mi>                                       <mml:mi>r</mml:mi>                                    </mml:mrow>                                 </mml:msub>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mrow>                              <mml:mrow>                                 <mml:mi>k</mml:mi>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:mi>t</mml:mi>                              </mml:mrow>                           </mml:msup>                           <mml:msup>                              <mml:mrow>                                 <mml:mrow>                                    <mml:mo>(</mml:mo>                                    <mml:mrow>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>p</mml:mi>                                                <mml:mrow>                                                   <mml:mi>e</mml:mi>                                                   <mml:mi>r</mml:mi>                                                   <mml:mi>r</mml:mi>                                                </mml:mrow>                                             </mml:msub>                                          </mml:mrow>                                          <mml:mn>3</mml:mn>                                       </mml:mfrac>                                    </mml:mrow>                                    <mml:mo>)</mml:mo>                                 </mml:mrow>                              </mml:mrow>                              <mml:mi>t</mml:mi>                           </mml:msup>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where <italic>p</italic><sub><italic>err </italic></sub>is the probability of single nucleotide error occurrence. Note that as <italic>p</italic><sub><italic>err </italic></sub>is usually very small, <italic>p</italic><sub><italic>t </italic></sub>can be ignored and assumed zero when <italic>t </italic>&#x02265; 3 in practice. Here we assume when there is error, the occurrence probability of each nucleotide (three possible nucleotides) is the same. Similar as <italic>p</italic><sub><italic>occ</italic></sub>(<italic>g</italic>, <italic>t</italic>), the formula for <italic>p</italic><sub><italic>t </italic></sub>can be modified when genome <italic>G </italic>is generated by other models. The probability that the <italic>k</italic>-tuple <italic>G </italic>[<italic>i</italic>...<italic>i </italic>+ <italic>k </italic>- 1] is sampled <italic>s' </italic>times and <italic>r'</italic>(<italic>r' </italic>&#x02264; <italic>s'</italic>) of them is <italic>T </italic>because of errors is</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S15-i6" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>p</mml:mi>                              <mml:mrow>                                 <mml:mi>c</mml:mi>                                 <mml:mi>o</mml:mi>                                 <mml:mi>u</mml:mi>                                 <mml:mi>n</mml:mi>                                 <mml:mi>t</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>g</mml:mi>                           <mml:mo>,</mml:mo>                           <mml:msup>                              <mml:mi>s</mml:mi>                              <mml:mo>&#x02032;</mml:mo>                           </mml:msup>                           <mml:mo>,</mml:mo>                           <mml:msup>                              <mml:mi>r</mml:mi>                              <mml:mo>&#x02032;</mml:mo>                           </mml:msup>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:msup>                                       <mml:mi>t</mml:mi>                                       <mml:mo>&#x02032;</mml:mo>                                    </mml:msup>                                    <mml:mo>=</mml:mo>                                    <mml:mn>0</mml:mn>                                 </mml:mrow>                                 <mml:mi>t</mml:mi>                              </mml:munderover>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>p</mml:mi>                                    <mml:mrow>                                       <mml:mi>o</mml:mi>                                       <mml:mi>c</mml:mi>                                       <mml:mi>c</mml:mi>                                    </mml:mrow>                                 </mml:msub>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>g</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:msup>                                    <mml:mi>t</mml:mi>                                    <mml:mo>&#x02032;</mml:mo>                                 </mml:msup>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:msub>                                    <mml:mi>p</mml:mi>                                    <mml:mrow>                                       <mml:mi>s</mml:mi>                                       <mml:mi>a</mml:mi>                                       <mml:mi>m</mml:mi>                                    </mml:mrow>                                 </mml:msub>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>g</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:msup>                                    <mml:mi>s</mml:mi>                                    <mml:mo>&#x02032;</mml:mo>                                 </mml:msup>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mrow>                                    <mml:mo>(</mml:mo>                                    <mml:mrow>                                       <mml:mrow>                                          <mml:mo>(</mml:mo>                                          <mml:mrow>                                             <mml:mtable>                                                <mml:mtr>                                                   <mml:mtd>                                                      <mml:msup>                                                         <mml:mi>s</mml:mi>                                                         <mml:mo>&#x02032;</mml:mo>                                                      </mml:msup>                                                   </mml:mtd>                                                </mml:mtr>                                                <mml:mtr>                                                   <mml:mtd>                                                      <mml:msup>                                                         <mml:mi>r</mml:mi>                                                         <mml:mo>&#x02032;</mml:mo>                                                      </mml:msup>                                                   </mml:mtd>                                                </mml:mtr>                                             </mml:mtable>                                          </mml:mrow>                                          <mml:mo>)</mml:mo>                                       </mml:mrow>                                       <mml:msubsup>                                          <mml:mi>p</mml:mi>                                          <mml:msup>                                             <mml:mi>t</mml:mi>                                             <mml:mo>&#x02032;</mml:mo>                                          </mml:msup>                                          <mml:msup>                                             <mml:mi>r</mml:mi>                                             <mml:mo>&#x02032;</mml:mo>                                          </mml:msup>                                       </mml:msubsup>                                       <mml:msup>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mn>1</mml:mn>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:msub>                                                <mml:mi>p</mml:mi>                                                <mml:msup>                                                   <mml:mi>t</mml:mi>                                                   <mml:mo>&#x02032;</mml:mo>                                                </mml:msup>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                          <mml:mrow>                                             <mml:msup>                                                <mml:mi>s</mml:mi>                                                <mml:mo>&#x02032;</mml:mo>                                             </mml:msup>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:msup>                                                <mml:mi>r</mml:mi>                                                <mml:mo>&#x02032;</mml:mo>                                             </mml:msup>                                          </mml:mrow>                                       </mml:msup>                                    </mml:mrow>                                    <mml:mo>)</mml:mo>                                 </mml:mrow>                              </mml:mrow>                           </mml:mstyle>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where <italic>G </italic>[<italic>i</italic>...<italic>i </italic>+ <italic>k </italic>- 1] = <italic>T</italic><sub><italic>t</italic>'</sub>, 0 &#x02264; <italic>t' </italic>&#x02264; <italic>t</italic>. In order to get <italic>r </italic>samples of <italic>T </italic>from the <italic>n </italic>reads, <italic>d</italic>(<italic>d </italic>= 1, ..., <italic>r</italic>) variants of <italic>T </italic>appear in different positions of <italic>G </italic>and <italic>r</italic><sub><italic>j </italic></sub>samples of <italic>T </italic>are getting from the <italic>j</italic>-th variants such that &#x003a3;<italic>r</italic><sub><italic>j </italic></sub>= <italic>r</italic>. Therefore, the probability that <italic>T </italic>appears exactly <italic>r </italic>times in the input is approximately</p><p><disp-formula id="bmcM1"><label>(1)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S15-i7" overflow="scroll">                     <mml:semantics>                        <mml:mtable>                           <mml:mtr>                              <mml:mtd>                                 <mml:msub>                                    <mml:mi>P</mml:mi>                                    <mml:mi>r</mml:mi>                                 </mml:msub>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:msub>                                    <mml:mi>Y</mml:mi>                                    <mml:mi>r</mml:mi>                                 </mml:msub>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:mo>=</mml:mo>                                 <mml:mstyle displaystyle="true">                                    <mml:munderover>                                       <mml:mo>&#x02211;</mml:mo>                                       <mml:mrow>                                          <mml:mi>d</mml:mi>                                          <mml:mo>=</mml:mo>                                          <mml:mn>1</mml:mn>                                       </mml:mrow>                                       <mml:mi>r</mml:mi>                                    </mml:munderover>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:munder>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>&#x02264;</mml:mo>                                                <mml:mstyle displaystyle="true">                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mrow>                                                      <mml:msub>                                                         <mml:mi>s</mml:mi>                                                         <mml:mi>j</mml:mi>                                                      </mml:msub>                                                   </mml:mrow>                                                </mml:mstyle>                                                <mml:mo>&#x02264;</mml:mo>                                                <mml:mi>n</mml:mi>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>l</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mi>k</mml:mi>                                                <mml:mo>+</mml:mo>                                                <mml:mn>1</mml:mn>                                                <mml:mo stretchy="false">)</mml:mo>                                             </mml:mrow>                                          </mml:munder>                                          <mml:mrow>                                             <mml:mstyle displaystyle="true">                                                <mml:munder>                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mrow>                                                      <mml:msub>                                                         <mml:mi>r</mml:mi>                                                         <mml:mi>j</mml:mi>                                                      </mml:msub>                                                      <mml:mo>&#x02264;</mml:mo>                                                      <mml:msub>                                                         <mml:mi>s</mml:mi>                                                         <mml:mi>j</mml:mi>                                                      </mml:msub>                                                      <mml:mo>,</mml:mo>                                                      <mml:mstyle displaystyle="true">                                                         <mml:mo>&#x02211;</mml:mo>                                                         <mml:mrow>                                                            <mml:msub>                                                               <mml:mi>r</mml:mi>                                                               <mml:mi>j</mml:mi>                                                            </mml:msub>                                                            <mml:mo>=</mml:mo>                                                            <mml:mi>r</mml:mi>                                                         </mml:mrow>                                                      </mml:mstyle>                                                   </mml:mrow>                                                </mml:munder>                                                <mml:mrow>                                                   <mml:mfrac>                                                      <mml:mrow>                                                         <mml:mo stretchy="false">(</mml:mo>                                                         <mml:mi>n</mml:mi>                                                         <mml:mo>&#x02212;</mml:mo>                                                         <mml:mi>k</mml:mi>                                                         <mml:mo>+</mml:mo>                                                         <mml:mn>1</mml:mn>                                                         <mml:mo stretchy="false">)</mml:mo>                                                         <mml:mo>!</mml:mo>                                                      </mml:mrow>                                                      <mml:mrow>                                                         <mml:mi>d</mml:mi>                                                         <mml:mo>!</mml:mo>                                                      </mml:mrow>                                                   </mml:mfrac>                                                </mml:mrow>                                             </mml:mstyle>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:mstyle>                                 <mml:mstyle displaystyle="true">                                    <mml:munder>                                       <mml:mo>&#x0220f;</mml:mo>                                       <mml:mrow>                                          <mml:msub>                                             <mml:mi>s</mml:mi>                                             <mml:mi>j</mml:mi>                                          </mml:msub>                                       </mml:mrow>                                    </mml:munder>                                    <mml:mrow>                                       <mml:msub>                                          <mml:mi>p</mml:mi>                                          <mml:mrow>                                             <mml:mi>c</mml:mi>                                             <mml:mi>o</mml:mi>                                             <mml:mi>u</mml:mi>                                             <mml:mi>n</mml:mi>                                             <mml:mi>t</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>g</mml:mi>                                       <mml:mo>,</mml:mo>                                       <mml:msub>                                          <mml:mi>s</mml:mi>                                          <mml:mi>j</mml:mi>                                       </mml:msub>                                       <mml:mo>,</mml:mo>                                       <mml:msub>                                          <mml:mi>r</mml:mi>                                          <mml:mi>j</mml:mi>                                       </mml:msub>                                    </mml:mrow>                                 </mml:mstyle>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:msup>                                    <mml:mrow>                                       <mml:mo>(</mml:mo>                                       <mml:mrow>                                          <mml:mstyle displaystyle="true">                                             <mml:munder>                                                <mml:mo>&#x02211;</mml:mo>                                                <mml:mrow>                                                   <mml:mi>t</mml:mi>                                                   <mml:mo>=</mml:mo>                                                   <mml:mn>1</mml:mn>                                                   <mml:mo>,</mml:mo>                                                   <mml:mn>...</mml:mn>                                                   <mml:mo>,</mml:mo>                                                   <mml:mi>k</mml:mi>                                                </mml:mrow>                                             </mml:munder>                                             <mml:mrow>                                                <mml:msub>                                                   <mml:mi>p</mml:mi>                                                   <mml:mrow>                                                      <mml:mi>o</mml:mi>                                                      <mml:mi>c</mml:mi>                                                      <mml:mi>c</mml:mi>                                                   </mml:mrow>                                                </mml:msub>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>g</mml:mi>                                                <mml:mo>,</mml:mo>                                                <mml:mi>t</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mn>1</mml:mn>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:msub>                                                   <mml:mi>p</mml:mi>                                                   <mml:mi>t</mml:mi>                                                </mml:msub>                                                <mml:mo stretchy="false">)</mml:mo>                                             </mml:mrow>                                          </mml:mstyle>                                       </mml:mrow>                                       <mml:mo>)</mml:mo>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mi>n</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>l</mml:mi>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mi>k</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mstyle displaystyle="true">                                          <mml:mo>&#x02211;</mml:mo>                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>s</mml:mi>                                                <mml:mi>j</mml:mi>                                             </mml:msub>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:msup>                              </mml:mtd>                           </mml:mtr>                        </mml:mtable>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>Equation (1) is an approximation because we have not considered the interdependence of the positions of the <italic>d </italic>variants of <italic>T </italic>and the samples in the remaining positions. This approximation is fine when <italic>g </italic>&#x0003e;&#x0003e; <italic>d </italic>and <italic>n </italic>is large, which is valid for most experimental data.</p><p>Once we calculate <italic>Pr</italic>(<italic>Y</italic><sub><italic>r</italic></sub>), we can calculate the probability of true positive as follows:</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S15-i8" overflow="scroll">                     <mml:semantics>                        <mml:mtable columnalign="left">                           <mml:mtr>                              <mml:mtd>                                 <mml:mi>P</mml:mi>                                 <mml:mi>r</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:msub>                                    <mml:mi>X</mml:mi>                                    <mml:mn>0</mml:mn>                                 </mml:msub>                                 <mml:mo>|</mml:mo>                                 <mml:msub>                                    <mml:mo>&#x0222a;</mml:mo>                                    <mml:mrow>                                       <mml:mi>r</mml:mi>                                       <mml:mo>&#x02265;</mml:mo>                                       <mml:mi>M</mml:mi>                                    </mml:mrow>                                 </mml:msub>                                 <mml:msub>                                    <mml:mi>Y</mml:mi>                                    <mml:mi>r</mml:mi>                                 </mml:msub>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:mo>=</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>P</mml:mi>                                       <mml:mi>r</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msub>                                          <mml:mo>&#x0222a;</mml:mo>                                          <mml:mrow>                                             <mml:mi>r</mml:mi>                                             <mml:mo>&#x02265;</mml:mo>                                             <mml:mi>M</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msub>                                          <mml:mi>Y</mml:mi>                                          <mml:mi>r</mml:mi>                                       </mml:msub>                                       <mml:mo>&#x02229;</mml:mo>                                       <mml:msub>                                          <mml:mi>X</mml:mi>                                          <mml:mn>0</mml:mn>                                       </mml:msub>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mi>P</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msub>                                          <mml:mo>&#x0222a;</mml:mo>                                          <mml:mrow>                                             <mml:mi>r</mml:mi>                                             <mml:mo>&#x02265;</mml:mo>                                             <mml:mi>M</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:msub>                                          <mml:mi>Y</mml:mi>                                          <mml:mi>r</mml:mi>                                       </mml:msub>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:mo>=</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mi>M</mml:mi>                                             </mml:mrow>                                             <mml:mi>n</mml:mi>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mi>P</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo>&#x02229;</mml:mo>                                             <mml:msub>                                                <mml:mi>X</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mi>M</mml:mi>                                             </mml:mrow>                                             <mml:mi>n</mml:mi>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mi>P</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                          </mml:mrow>                                       </mml:mstyle>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:mo>=</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mi>M</mml:mi>                                             </mml:mrow>                                             <mml:mi>n</mml:mi>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mn>1</mml:mn>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mi>P</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo>&#x02229;</mml:mo>                                             <mml:mo>&#x000ac;</mml:mo>                                             <mml:msub>                                                <mml:mi>X</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mi>M</mml:mi>                                             </mml:mrow>                                             <mml:mi>n</mml:mi>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mi>P</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:mo>=</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mi>M</mml:mi>                                             </mml:mrow>                                             <mml:mi>n</mml:mi>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mn>1</mml:mn>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mi>P</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo>|</mml:mo>                                             <mml:mo>&#x000ac;</mml:mo>                                             <mml:msub>                                                <mml:mi>X</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mi>P</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mo>&#x000ac;</mml:mo>                                             <mml:msub>                                                <mml:mi>X</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mi>M</mml:mi>                                             </mml:mrow>                                             <mml:mi>n</mml:mi>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mi>P</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mtd>                           </mml:mtr>                        </mml:mtable>                                             </mml:semantics>                  </mml:math></disp-formula></p><p><italic>P</italic>(<italic>Y</italic><sub><italic>r</italic></sub>) can be calculated from Equation (1). <italic>Pr</italic>(&#x000ac; <italic>X</italic><sub>0</sub>) = (1 - <italic>p</italic><sub><italic>occ</italic></sub>(<italic>g</italic>, 0))<sup><italic>n</italic>-<italic>k</italic>+1 </sup>and <italic>Pr</italic>(<italic>Y</italic><sub><italic>r</italic></sub>|&#x000ac; <italic>X</italic><sub>0</sub>) can be calculated from Equation (1) by considering that the probability that <italic>T </italic>appearing in <italic>G </italic>is zero, i.e. set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S15-i9" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>p</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mrow><mml:mi>o</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>g</italic>, 0) = 0 and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S15-i9" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>p</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mrow><mml:mi>o</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>g, t</italic>) = <italic>p</italic><sub><italic>occ </italic></sub>(<italic>g</italic>, <italic>t</italic>)/(1 - <italic>p</italic><sub><italic>occ</italic></sub>(<italic>g</italic>, 0)).</p><p>The probability of false positive one minus the probability of true positive</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S15-i10" overflow="scroll">                     <mml:semantics>                        <mml:mtable columnalign="left">                           <mml:mtr>                              <mml:mtd>                                 <mml:mn>1</mml:mn>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:mi>P</mml:mi>                                 <mml:mi>r</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:msub>                                    <mml:mi>X</mml:mi>                                    <mml:mn>0</mml:mn>                                 </mml:msub>                                 <mml:mo>|</mml:mo>                                 <mml:msub>                                    <mml:mo>&#x0222a;</mml:mo>                                    <mml:mrow>                                       <mml:mi>r</mml:mi>                                       <mml:mo>&#x02265;</mml:mo>                                       <mml:mi>M</mml:mi>                                    </mml:mrow>                                 </mml:msub>                                 <mml:msub>                                    <mml:mi>Y</mml:mi>                                    <mml:mi>r</mml:mi>                                 </mml:msub>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:mo>=</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mi>M</mml:mi>                                             </mml:mrow>                                             <mml:mi>n</mml:mi>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mn>1</mml:mn>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mi>P</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo>|</mml:mo>                                             <mml:mo>&#x000ac;</mml:mo>                                             <mml:msub>                                                <mml:mi>X</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mi>P</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mo>&#x000ac;</mml:mo>                                             <mml:msub>                                                <mml:mi>X</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mi>M</mml:mi>                                             </mml:mrow>                                             <mml:mi>n</mml:mi>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mi>P</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mtd>                           </mml:mtr>                        </mml:mtable>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>The probability of false negative can also be calculated similarly:</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S15-i11" overflow="scroll">                     <mml:semantics>                        <mml:mtable columnalign="left">                           <mml:mtr>                              <mml:mtd>                                 <mml:mi>P</mml:mi>                                 <mml:mi>r</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:msub>                                    <mml:mi>X</mml:mi>                                    <mml:mn>0</mml:mn>                                 </mml:msub>                                 <mml:mo>|</mml:mo>                                 <mml:msub>                                    <mml:mo>&#x0222a;</mml:mo>                                    <mml:mrow>                                       <mml:mi>r</mml:mi>                                       <mml:mo>&#x0003c;</mml:mo>                                       <mml:mi>M</mml:mi>                                    </mml:mrow>                                 </mml:msub>                                 <mml:msub>                                    <mml:mi>Y</mml:mi>                                    <mml:mi>r</mml:mi>                                 </mml:msub>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:mo>=</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>P</mml:mi>                                       <mml:mi>r</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msub>                                          <mml:mo>&#x0222a;</mml:mo>                                          <mml:mrow>                                             <mml:mi>r</mml:mi>                                             <mml:mo>&#x0003c;</mml:mo>                                             <mml:mi>M</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msub>                                          <mml:mi>Y</mml:mi>                                          <mml:mi>r</mml:mi>                                       </mml:msub>                                       <mml:mo>&#x02229;</mml:mo>                                       <mml:msub>                                          <mml:mi>X</mml:mi>                                          <mml:mn>0</mml:mn>                                       </mml:msub>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mi>P</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:msub>                                          <mml:mo>&#x0222a;</mml:mo>                                          <mml:mrow>                                             <mml:mi>r</mml:mi>                                             <mml:mo>&#x0003c;</mml:mo>                                             <mml:mi>M</mml:mi>                                          </mml:mrow>                                       </mml:msub>                                       <mml:msub>                                          <mml:mi>Y</mml:mi>                                          <mml:mi>r</mml:mi>                                       </mml:msub>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:mo>=</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mn>0</mml:mn>                                             </mml:mrow>                                             <mml:mrow>                                                <mml:mi>M</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mn>1</mml:mn>                                             </mml:mrow>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mi>P</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo>&#x02229;</mml:mo>                                             <mml:msub>                                                <mml:mi>X</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mn>0</mml:mn>                                             </mml:mrow>                                             <mml:mrow>                                                <mml:mi>M</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mn>1</mml:mn>                                             </mml:mrow>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mi>P</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:mo>=</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mn>0</mml:mn>                                             </mml:mrow>                                             <mml:mrow>                                                <mml:mi>M</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mn>1</mml:mn>                                             </mml:mrow>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mn>1</mml:mn>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mi>P</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo>&#x02229;</mml:mo>                                             <mml:mo>&#x000ac;</mml:mo>                                             <mml:msub>                                                <mml:mi>X</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mn>0</mml:mn>                                             </mml:mrow>                                             <mml:mrow>                                                <mml:mi>M</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mn>1</mml:mn>                                             </mml:mrow>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mi>P</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mtd>                           </mml:mtr>                           <mml:mtr>                              <mml:mtd>                                 <mml:mo>=</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mn>0</mml:mn>                                             </mml:mrow>                                             <mml:mrow>                                                <mml:mi>M</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mn>1</mml:mn>                                             </mml:mrow>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mn>1</mml:mn>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mi>P</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo>|</mml:mo>                                             <mml:mo>&#x000ac;</mml:mo>                                             <mml:msub>                                                <mml:mi>X</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mi>P</mml:mi>                                             <mml:mi>r</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mo>&#x000ac;</mml:mo>                                             <mml:msub>                                                <mml:mi>X</mml:mi>                                                <mml:mn>0</mml:mn>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:msubsup>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>r</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mn>0</mml:mn>                                             </mml:mrow>                                             <mml:mrow>                                                <mml:mi>M</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mn>1</mml:mn>                                             </mml:mrow>                                          </mml:msubsup>                                          <mml:mrow>                                             <mml:mi>P</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>Y</mml:mi>                                                <mml:mi>r</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mtd>                           </mml:mtr>                        </mml:mtable>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>Since we only consider integer threshold <italic>M</italic>, once we calculate the probabilities of true positive, false positive and false negative for all possible thresholds <italic>M </italic>for a particular substring length <italic>k</italic>. We can then find the optimal threshold <italic>M</italic>* for that particular <italic>k </italic>which minimizes the total errors FP + FN or maximizes the total accuracy.</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-S1-S15-i12" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msqrt>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>T</mml:mi>                                       <mml:mi>P</mml:mi>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mi>T</mml:mi>                                       <mml:mi>P</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mi>F</mml:mi>                                       <mml:mi>P</mml:mi>                                    </mml:mrow>                                 </mml:mfrac>                                 <mml:mo>&#x02022;</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>T</mml:mi>                                       <mml:mi>P</mml:mi>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mi>T</mml:mi>                                       <mml:mi>P</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mi>F</mml:mi>                                       <mml:mi>N</mml:mi>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mrow>                           </mml:msqrt>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p></sec></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>FC and SMY studied the read correction problem, suggested the main idea of calculating the optimal threshold M. HL and WLL worked out the details of calculation, worked out the experiments and drafted the manuscript. All authors read and approved the final manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>This work was supported in part by Hong Kong RGC Grant HKU 711608E and Seed Funding Programme for Basic Research (200611159001) of the University of Hong Kong.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sanger</surname><given-names>F</given-names></name><name><surname>Coulson</surname><given-names>AR</given-names></name><name><surname>Barrell</surname><given-names>BG</given-names></name><name><surname>Smith</surname><given-names>AJ</given-names></name><name><surname>Roe</surname><given-names>BA</given-names></name></person-group><article-title>Cloning in singlestranded bacteriophage as an aid to rapid DNA sequencing</article-title><source>J Mol Biol</source><year>1980</year><volume>143</volume><fpage>161</fpage><lpage>178</lpage><pub-id pub-id-type="pmid">6260957</pub-id></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sanger</surname><given-names>F</given-names></name><name><surname>Nicklen</surname><given-names>S</given-names></name><name><surname>Coulson</surname><given-names>AR</given-names></name></person-group><article-title>DNA sequencing with chainterminating inhibitors</article-title><source>Proc Natl Acad Sci USA</source><year>1977</year><volume>74</volume><fpage>5463</fpage><lpage>5467</lpage><pub-id pub-id-type="pmid">271968</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sanger</surname><given-names>F</given-names></name><name><surname>Coulson</surname><given-names>AR</given-names></name><name><surname>Hong</surname><given-names>GF</given-names></name><name><surname>Hill</surname><given-names>DF</given-names></name><name><surname>Petersen</surname><given-names>GB</given-names></name></person-group><article-title>Nucleotide sequence of bacteriophage lambda DNA</article-title><source>J Mol Biol</source><year>1982</year><volume>162</volume><fpage>729</fpage><lpage>773</lpage><pub-id pub-id-type="pmid">6221115</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Fiers</surname><given-names>W</given-names></name><name><surname>Contreras</surname><given-names>R</given-names></name><name><surname>Haegeman</surname><given-names>G</given-names></name><name><surname>Rogiers</surname><given-names>R</given-names></name><name><surname>Voorde</surname><given-names>A vande</given-names></name><etal></etal></person-group><article-title>Complete nucleotide sequence of SV40 DNA</article-title><source>Nature</source><year>1978</year><volume>273</volume><fpage>113</fpage><lpage>20</lpage><pub-id pub-id-type="pmid">205802</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Chee</surname><given-names>MS</given-names></name><name><surname>Bankier</surname><given-names>AT</given-names></name><name><surname>Beck</surname><given-names>S</given-names></name><name><surname>Bohni</surname><given-names>R</given-names></name><name><surname>Brown</surname><given-names>CM</given-names></name></person-group><article-title>Analysis of the protein-coding content of the sequence of human cytomegalovirus strain AD169</article-title><source>Curr Top Microbiol Immunol</source><year>1990</year><volume>154</volume><fpage>125</fpage><lpage>169</lpage><pub-id pub-id-type="pmid">2161319</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bentley</surname><given-names>DR</given-names></name></person-group><article-title>Whole-genome re-sequencing</article-title><source>Curr Opin Genet Dev</source><year>2006</year><volume>16</volume><fpage>545</fpage><lpage>552</lpage><pub-id pub-id-type="pmid">17055251</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Margulies</surname><given-names>M</given-names></name><name><surname>Egholm</surname><given-names>M</given-names></name><name><surname>Altman</surname><given-names>WE</given-names></name><name><surname>Attiya</surname><given-names>S</given-names></name><name><surname>Bader</surname><given-names>JS</given-names></name><name><surname>Bemben</surname><given-names>LA</given-names></name><name><surname>Berka</surname><given-names>J</given-names></name><name><surname>Braverman</surname><given-names>MS</given-names></name><name><surname>Chen</surname><given-names>YJ</given-names></name><name><surname>Chen</surname><given-names>Z</given-names></name><etal></etal></person-group><article-title>Genome sequencing in microfabricated high-density picolitre reactors</article-title><source>Nature</source><year>2005</year><volume>437</volume><fpage>376</fpage><lpage>380</lpage><pub-id pub-id-type="pmid">16056220</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ewing</surname><given-names>B</given-names></name><name><surname>Green</surname><given-names>P</given-names></name></person-group><article-title>Base-calling of automated sequencer traces using Phred. II Error probabilities</article-title><source>Genome Res</source><year>1994</year><volume>8</volume><fpage>186</fpage><lpage>194</lpage><pub-id pub-id-type="pmid">9521922</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pevzner</surname><given-names>P</given-names></name><name><surname>Tang</surname><given-names>H</given-names></name></person-group><article-title>Fragment assembly with double-barreled data</article-title><source>Bioinformatics</source><year>2001</year><volume>20</volume><fpage>S225</fpage><lpage>233</lpage><pub-id pub-id-type="pmid">11473013</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Myers</surname><given-names>EW</given-names></name><name><surname>Sutton</surname><given-names>GG</given-names></name><name><surname>Delcher</surname><given-names>AL</given-names></name><name><surname>Dew</surname><given-names>IM</given-names></name><name><surname>Fasulo</surname><given-names>DP</given-names></name><name><surname>Flanigan</surname><given-names>MJ</given-names></name><name><surname>Kravitz</surname><given-names>SA</given-names></name><name><surname>Mobarry</surname><given-names>CM</given-names></name><name><surname>Remington</surname><given-names>KA</given-names></name><name><surname>Anson</surname><given-names>EL</given-names></name><name><surname>Bolanos</surname><given-names>RA</given-names></name><name><surname>Chou</surname><given-names>HH</given-names></name><name><surname>Jordan</surname><given-names>CM</given-names></name><name><surname>Halpern</surname><given-names>AL</given-names></name><name><surname>Lonardi</surname><given-names>S</given-names></name><name><surname>Beasley</surname><given-names>EM</given-names></name><name><surname>Brandon</surname><given-names>RC</given-names></name><name><surname>Chen</surname><given-names>L</given-names></name><name><surname>Dunn</surname><given-names>PJ</given-names></name><name><surname>Lai</surname><given-names>Z</given-names></name><name><surname>Liang</surname><given-names>Y</given-names></name><name><surname>Nusskern</surname><given-names>DR</given-names></name><name><surname>Zhan</surname><given-names>M</given-names></name><name><surname>Zhang</surname><given-names>Q</given-names></name><name><surname>Zheng</surname><given-names>X</given-names></name><name><surname>Rubin</surname><given-names>GM</given-names></name><name><surname>Adams</surname><given-names>MD</given-names></name><name><surname>Venter</surname><given-names>JC</given-names></name></person-group><article-title>A Whole-Genome Assembly of Drosophila</article-title><source>Science</source><year>2000</year><volume>287</volume><fpage>2196</fpage><lpage>2204</lpage><pub-id pub-id-type="pmid">10731133</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Warren</surname><given-names>RL</given-names></name><name><surname>Sutton</surname><given-names>GG</given-names></name><name><surname>Jones</surname><given-names>SJ</given-names></name><name><surname>Holt</surname><given-names>RA</given-names></name></person-group><article-title>Assembling millions of short DNA sequencs using SSAKE</article-title><source>Bioinformatics</source><year>2007</year><volume>23</volume><fpage>500</fpage><lpage>501</lpage><pub-id pub-id-type="pmid">17158514</pub-id></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Juliane</surname><given-names>CD</given-names></name><name><surname>Claudio</surname><given-names>L</given-names></name><name><surname>Tatiana</surname><given-names>B</given-names></name><name><surname>Heinz</surname><given-names>H</given-names></name></person-group><article-title>SHARCGS, a fast and highly accurate short-read assembly algorithm for de novo genomic sequencing</article-title><source>Genome Res</source><year>2007</year><volume>17</volume><fpage>1697</fpage><lpage>1706</lpage><pub-id pub-id-type="pmid">17908823</pub-id></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jeck</surname><given-names>WR</given-names></name><name><surname>Reinhardt</surname><given-names>JA</given-names></name><name><surname>Baltrus</surname><given-names>DA</given-names></name><name><surname>Hickenbotham</surname><given-names>MT</given-names></name><name><surname>Magrini</surname><given-names>V</given-names></name><name><surname>Mardis</surname><given-names>ER</given-names></name><name><surname>Dangl</surname><given-names>JL</given-names></name><name><surname>Jones</surname><given-names>CD</given-names></name></person-group><article-title>Extending assembly of short DNA sequences to handle error</article-title><source>Bioinformatics</source><year>2007</year><volume>23</volume><fpage>2942</fpage><lpage>2944</lpage><pub-id pub-id-type="pmid">17893086</pub-id></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Medvedev</surname><given-names>P</given-names></name><name><surname>Brudno</surname><given-names>M</given-names></name></person-group><article-title>Ab Initio whole genome shotgun assembly with mated short reads</article-title><source>Research in Computational Molecular Biology</source><year>2008</year><volume>4955/2008</volume><fpage>50</fpage><lpage>64</lpage></citation></ref><ref id="B15"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Wong</surname><given-names>T</given-names></name><name><surname>Lam</surname><given-names>TW</given-names></name><name><surname>Chan</surname><given-names>PY</given-names></name><name><surname>Yiu</surname><given-names>SM</given-names></name></person-group><article-title>Correct short reads with high error rates for improved sequencing result</article-title><source>International Journal of Bioinformatics Research and Applications</source><comment></comment></citation></ref><ref id="B16"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sundquist</surname><given-names>A</given-names></name><name><surname>Ronaghi</surname><given-names>M</given-names></name><name><surname>Tang</surname><given-names>H</given-names></name><name><surname>Pevzner</surname><given-names>P</given-names></name><name><surname>Batzoglou</surname><given-names>S</given-names></name></person-group><article-title>Whole genome Sequencing and Assembly with High-throughput, Short-read Technologies</article-title><source>PLoS</source><year>2007</year><volume>5</volume><fpage>e454</fpage></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Chaisson</surname><given-names>M</given-names></name><name><surname>Pevzner</surname><given-names>P</given-names></name><name><surname>Tang</surname><given-names>H</given-names></name></person-group><article-title>Fragment Assembly with Short Reads</article-title><source>Bioinformatics</source><year>2004</year><volume>20</volume><fpage>2067</fpage><lpage>2074</lpage><pub-id pub-id-type="pmid">15059830</pub-id></citation></ref></ref-list></back></article>