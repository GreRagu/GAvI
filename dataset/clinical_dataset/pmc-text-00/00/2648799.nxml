<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208113</article-id><article-id pub-id-type="pmc">2648799</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S14</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S14</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Parallel short sequence assembly of transcriptomes</article-title></title-group><contrib-group><contrib id="A1" corresp="yes" contrib-type="author"><name><surname>Jackson</surname><given-names>Benjamin G</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>zbbrox@iastate.edu</email></contrib><contrib id="A2" contrib-type="author"><name><surname>Schnable</surname><given-names>Patrick S</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>schnable@iastate.edu</email></contrib><contrib id="A3" contrib-type="author"><name><surname>Aluru</surname><given-names>Srinivas</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>aluru@iastate.edu</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Electrical and Computer Engineering, Iowa State University, Ames, IA 50011, USA</aff><aff id="I2"><label>2</label>Center for Plant Genomics, Iowa State University, Ames, IA 50011, USA</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S14</fpage><lpage>S14</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S14"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Jackson et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Jackson et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Jackson               G               Benjamin                              zbbrox@iastate.edu            </dc:author><dc:title>            Parallel short sequence assembly of transcriptomes         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S14-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S14&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>The <italic>de novo </italic>assembly of genomes and transcriptomes from short sequences is a challenging problem. Because of the high coverage needed to assemble short sequences as well as the overhead of modeling the assembly problem as a graph problem, the methods for short sequence assembly are often validated using data from BACs or small sized prokaryotic genomes.</p></sec><sec><title>Results</title><p>We present a parallel method for transcriptome assembly from large short sequence data sets. Our solution uses a rigorous graph theoretic framework and tames the computational and space complexity using parallel computers. First, we construct a distributed bidirected graph that captures overlap information. Next, we compact all chains in this graph to determine long unique contigs using undirected parallel list ranking, a problem for which we present an algorithm. Finally, we process this compacted distributed graph to resolve unique regions that are separated by repeats, exploiting the naturally occurring coverage variations arising from differential expression.</p></sec><sec><title>Conclusion</title><p>We demonstrate the validity of our method using a synthetic high coverage data set generated from the predicted coding regions of <italic>Zea mays</italic>. We assemble 925 million sequences consisting of 40 billion nucleotides in a few minutes on a 1024 processor Blue Gene/L. Our method is the first fully distributed method for assembling a non-hierarchical short sequence data set and can scale to large problem sizes.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><sec><title>Introduction</title><p>The development of high-throughput short sequencing technologies, such as the Illumina Solexa and Applied Biosystems Solid systems, has sparked renewed interest in sequence assembly. The promise of inexpensive short reads has opened the door to the possibilities of resequencing individuals and sequencing more organisms at lower cost.</p><p>An important problem in short sequence assembly is <italic>de novo </italic>genome reconstruction. For genomes with high repeat content, this task is already difficult with the much longer Sanger reads [<xref ref-type="bibr" rid="B1">1</xref>]. For accurate assembly of short sequences, many have proposed using more rigorous graph models rather than to the overlap-based greedy heuristics often utilized for Sanger reads. Graph models of particular interest include De Bruijn graphs and string graphs in either directed or bidirected forms.</p><p>As graph models of assembly are compute and memory intensive, and the coverage needed with short read technologies is large, it is difficult to validate the proposed methods on large eukaryotic genomes. Pevzner <italic>et al. </italic>[<xref ref-type="bibr" rid="B2">2</xref>] originally tested the EULER assembler using bacterial genomes. Myers [<xref ref-type="bibr" rid="B3">3</xref>], Medvedev <italic>et al. </italic>[<xref ref-type="bibr" rid="B4">4</xref>], and Hernadez <italic>et al. </italic>[<xref ref-type="bibr" rid="B5">5</xref>] also demonstrate their methods on prokaryotes. Zerbino <italic>et al. </italic>[<xref ref-type="bibr" rid="B6">6</xref>], Warren <italic>et al. </italic>[<xref ref-type="bibr" rid="B7">7</xref>] and Dohm <italic>et al. </italic>[<xref ref-type="bibr" rid="B8">8</xref>] validated their methods using single BACs.</p><p>Butler <italic>et al. </italic>[<xref ref-type="bibr" rid="B9">9</xref>] computed an assembly of 39 million bases in 2 days using a database and a workstation with 64 gigabytes of RAM. They use a modified directed string graph model for assembly, and require clone pairs of three different lengths to achieve the result. Their paper, while presenting a sequential method, does demonstrate that the <italic>de novo </italic>assembly of long genomes using very short shotgun sequences is possible.</p><p>Sundquist <italic>et al. </italic>[<xref ref-type="bibr" rid="B10">10</xref>] propose the SHRAP hierarchical short sequence protocol and method for assembling hierarchical data in parallel. The hierarchical nature of their problem results in a natural decomposition into smaller problems that can be distributed, which is fundamentally different from the problem of assembling shotgun data in parallel, which we present here.</p><p>In this paper, we present a method for assembling the transcriptome of an organism from short reads derived from unnormalized expression libraries. We follow Myers' and Medvedev's lead [<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B11">11</xref>] and model the assembly problem as that of finding a tour of a bidirected string graph, which we consider a natural model. Importantly, we address the challenges of constructing and manipulating this graph using multiprocessor computers. In addition to speeding up the assembly process, the main benefit of using such machines is the large amount of memory available for the manipulation of the graph for large problems.</p><p>Our method is a fully distributed parallel method that can process high coverage data sets and quickly reconstruct the underlying sequences. First, we construct the distributed bidirected string graph. Once the graph has been constructed, we identify and compact chains within the graph, which correspond to unique long contigs. The final step of the algorithm is to process the graph in such a way that we can reduce the edges, and, correspondingly, increase the length of each edge, or the length of each contig in the assembly. In this manipulation, we make novel use of the variation in sequence coverage of the transcriptome naturally arising due to differential expression. Coverage has been used in assembly methods before, particularly in transforming the assembly problem to that of network flow [<xref ref-type="bibr" rid="B3">3</xref>]. However, instead of using uniform coverage as do these methods, our method leverages non uniform coverage.</p><p>We analyze the error in Solexa data and then use this analysis to generate synthetic data for the maize (<italic>Zea mays</italic>) transcriptome. We then use a parallel implementation of our method to assemble 40 billion bases in a few minutes on a 1024 node Blue Gene/L computer. We validate the method by aligning our assembled contigs back to the reference genome.</p></sec><sec><title>Model of parallel computation</title><p>To ensure practical applicability, we use the distributed memory model of parallel computation. Each processor has access to its local memory, and remote memory access is achieved through communication over an interconnection network. The run-time of an algorithm is characterized by the parallel computation time and communication time. We use the permutation network model, in which each processor can simultaneously send/receive a message of <italic>m </italic>bytes provided no two source/destination processors have the same id. The communication complexity is then measured by the number of such communication rounds, and the total volume of parallel communication. The former accounts for the number of times the expensive latency cost is paid, while the latter accounts for the cost of network routing.</p><p>Let <italic>p </italic>denote the number of processors. We make use of the regular all-to-all communication primitive, in which each processor sends a distinct message of <italic>O</italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S14-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mrow><mml:msup><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) bytes to every other processor (i.e., one communication round with <italic>O</italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S14-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) parallel communication volume). A many-to-many communication is similar, except that each processor sends and receives variable sized chunks of data. A bounded many-to-many communication can be made to behave as a regular all-to-all communication with total size <italic>r </italic>+ <italic>s</italic>, where <italic>s </italic>is the total number of elements sent by any processor and <italic>r </italic>is the maximum number of elements received by any processor [<xref ref-type="bibr" rid="B12">12</xref>].</p><p>When we refer to an element in an array sending a message to another element in an array, we implicitly mean that each processor will collect all such messages and send and receive them using a many-to-many communication before routing them to their final array destination.</p><p>Parallel sorting is an important subroutine in our method, and the best algorithm for parallel sort on distributed memory machines that achieves a good final distribution of the sorted values is regular sample sort [<xref ref-type="bibr" rid="B13">13</xref>]. A regular sample sort uses a constant number of bounded many-to-many communications and <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S14-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) local computation for integer sort, and <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S14-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:mfrac><mml:mi>log</mml:mi><mml:mo>&#x02061;</mml:mo><mml:mfrac><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) local computation time for comparison sort.</p><p>A primary concern in the development of parallel algorithms is to demonstrate that the algorithm scales well as the number of processors increases. This allows one to handle larger problem sizes by using larger machines without compromising on time to solution. Perfect speedup is characterized as linear speedup with number of processors.</p></sec><sec><title>The bidirected graph model</title><p>In a bidirected graph <italic>G </italic>= {<italic>V</italic>,<italic>E</italic>}, each edge has two directions, one associated with each incident node. For each ordered pair of nodes (<italic>u</italic>,<italic>v</italic>) there are four possible connecting edges: <italic>u</italic>&#x025b7;-&#x025b7;<italic>v</italic>, <italic>u</italic>&#x025c1;-&#x025c1;<italic>v</italic>, <italic>u</italic>&#x025c1;-&#x025b7;<italic>v</italic>, and <italic>u</italic>&#x025b7;-&#x025b7;<italic>v</italic>. Edges are represented by tuples &#x0003c;<italic>u</italic>, <italic>v</italic>, <italic>d</italic><sub><italic>u</italic></sub>, <italic>d</italic><sub><italic>v</italic></sub>&#x0003e;, with <italic>d</italic><sub><italic>u</italic></sub>, <italic>d</italic><sub><italic>v </italic></sub>&#x02208; {&#x025b7;, &#x025c1;}. For each unordered pair of nodes {<italic>u</italic>, <italic>v</italic>} exactly two such tuples exist, one for each of the ordered pairs (<italic>u</italic>, <italic>v</italic>) and (<italic>v</italic>, <italic>u</italic>), respectively. Accordingly, we represent the bidirected graph as a distributed tuple list, two tuples per edge.</p><p>In this representation, sorting tuples by node labels will distribute edges such that all edges adjacent to a given node reside in the same processor. Alternatively, sorting tuples by a canonical representation (for example considering the smaller node ID followed by the larger node ID) will move both tuples corresponding to an edge to the same processor.</p><p>The sequence assembly problem is naturally modeled as a bidirected graph (See Fig. <xref ref-type="fig" rid="F1">1</xref>) [<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B11">11</xref>]. Consider each input sequence as a DNA molecule by taking both the sequence and its complementary strand. By convention, we label the lexicographically larger of the two strands as '+', and the lexicographically smaller of the two strands as '-'. We begin with a bidirected De Bruijn graph of the input sequences [<xref ref-type="bibr" rid="B11">11</xref>] and transform it into a bidirected string graph, which is an edge labeled graph upon which some traversal of the graph corresponds to the underlying genomic sequence [<xref ref-type="bibr" rid="B3">3</xref>].</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Bidirected graph</bold>. The bidirected model for use in assembly. The figure shows the four edge types as described in the text, as well as the corresponding edge labels in the string graph.</p></caption><graphic xlink:href="1471-2105-10-S1-S14-1"/></fig><p>In the bidirected De Bruijn graph, each node <italic>u </italic>corresponds to a <italic>k</italic>-molecule present in some input sequence. We label its two strands by <italic>u</italic><sup>+ </sup>and <italic>u</italic><sup>-</sup>. If two such molecules <italic>u </italic>and <italic>v </italic>contain a <italic>k </italic>- 1 length overlap, they can do so in four possible ways, each of which directly corresponds to the types of edges in a bidirected graph.</p><p>&#x02022; Case I: The (<italic>k </italic>- 1)-length suffix of <italic>u</italic><sup>+ </sup>is a prefix of <italic>v</italic><sup>+</sup>. This is denoted <italic>u</italic>&#x025b7;-&#x025b7;<italic>v</italic>.</p><p>&#x02022; Case II: The (<italic>k </italic>- 1)-length suffix of <italic>u</italic><sup>- </sup>is a prefix of <italic>v</italic><sup>-</sup>. This is denoted <italic>u</italic>&#x025c1;-&#x025c1;<italic>v</italic>.</p><p>&#x02022; Case III: The (<italic>k </italic>- 1)-length suffix of <italic>u</italic><sup>- </sup>is a prefix of <italic>v</italic><sup>+</sup>. This is denoted <italic>u</italic>&#x025c1;-&#x025b7;<italic>v</italic>.</p><p>&#x02022; Case IV: The (<italic>k </italic>- 1)-length suffix of <italic>u</italic><sup>+ </sup>is a prefix of <italic>v</italic><sup>-</sup>. This is denoted <italic>u</italic>&#x025b7;-&#x025c1;<italic>v</italic>.</p><p>The bidirected De Bruijn graph can be easily converted into a bidirected string graph, with two character labels on each edge, <italic>c</italic><sub><italic>u </italic></sub>and <italic>c</italic><sub><italic>v </italic></sub>where <italic>c</italic><sub><italic>u </italic></sub>corresponds to the next character on the DNA molecule when traveling away from <italic>u </italic>along the edge, and <italic>c</italic><sub><italic>v </italic></sub>corresponds to the next character on the DNA molecule when traveling away from <italic>v </italic>along the edge. This data is added to the edge tuple, resulting in tuples of the form &#x027e8;<italic>u</italic>, <italic>v</italic>, <italic>d</italic><sub><italic>u</italic></sub>, <italic>d</italic><sub><italic>v</italic></sub>, <italic>c</italic><sub><italic>u</italic></sub>, <italic>c</italic><sub><italic>v</italic></sub>&#x027e9;.</p><p>A valid path in a bidirected graph is any ordered sequence of tuples &#x027e8;<italic>e</italic><sub>1</sub>, <italic>e</italic><sub>2</sub>, ... <italic>e</italic><sub><italic>x</italic></sub>&#x027e9;, where <italic>e</italic><sub><italic>i </italic></sub>= &#x027e8;<italic>u</italic><sub><italic>i</italic></sub>, <italic>v</italic><sub><italic>i</italic></sub>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S14-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S14-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">d</mml:mi><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>&#x027e9;, such that <italic>v</italic><sub><italic>i </italic></sub>= <italic>u</italic><sub><italic>i</italic>+1 </sub>and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S14-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02260;</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> for all consecutive tuples <italic>e</italic><sub><italic>i </italic></sub>and <italic>e</italic><sub><italic>i</italic>+1 </sub>in the path.</p><p>Conceptually, what it means to travel along an edge that "changes direction" is to align the positive strand in node <italic>u </italic>to the negative strand in node <italic>v</italic>. To travel along an edge that maintains its direction is to align the positive to positive. One advantage of this model is that a single tour of the graph is used to construct both strands of the double stranded DNA simultaneously. Another advantage is that the number of nodes in the graph is reduced by half when compared to a directed graph model.</p></sec></sec><sec sec-type="methods"><title>Methods</title><sec><title>Parallel graph construction</title><p>We are given <italic>m </italic>sequences of total length <italic>n</italic>, sampled from a genome of total length <italic>g</italic>, distributed among <italic>p </italic>processors such that there are <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S14-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula> bases per processor. We wish to construct a bidirected string graph with <italic>O</italic>(<italic>g</italic>) edges and nodes, distributed among processors such that each processor knows all edges adjacent to <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S14-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>g</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) nodes. For a detailed description and analysis of graph construction, as well as refinements to the basic algorithm presented here, see Jackson <italic>et al. </italic>[<xref ref-type="bibr" rid="B14">14</xref>].</p><p>We represent each <italic>k</italic>-molecule in the input sequence as a base 4 number (in 2<italic>k </italic>bits) using its lexicographically larger stand. These representatives can then be sorted in parallel, with identical elements merged into one. Due to the 4-letter DNA alphabet, a <italic>k</italic>-molecule <italic>u </italic>could overlap with at most 8 <italic>k</italic>-molecules <italic>v</italic>. We construct the messages to be sent to hypothetical molecules <italic>v </italic>that could be attached to <italic>u</italic>, such that for all such molecules, either <italic>v </italic>will send a message to <italic>u </italic>or <italic>u </italic>will send a message to <italic>v</italic>.</p><p>The messages are constructed for each of the three ways in which <italic>u </italic>can overlap with <italic>v</italic>. We construct each message such that it can be sent to the representative of <italic>v </italic>(we target the hypothetical positive strand). For each message, we construct a tuple &#x027e8;<italic>id</italic>, <italic>dest</italic>, <italic>type</italic>, <italic>char</italic>&#x027e9;, where <italic>id </italic>is the node id of <italic>u</italic>, <italic>dest </italic>is the representative of <italic>v</italic>, <italic>type </italic>is the type of the message, which will inform the type of edge to draw in the graph, and <italic>char </italic>is the character to be associated with the edge when moving from <italic>u </italic>to <italic>v</italic>. Each hypothetical edge in the bidirected De Bruijn graph is thus represented by exactly one message.</p><p>For each message &#x027e8;<italic>id</italic>, <italic>dest</italic>, <italic>type</italic>, <italic>char</italic>&#x027e9; received by <italic>k</italic>-molecule <italic>v</italic>, we generate two tuples. The resulting tuple list is sorted and any duplicates are removed, resulting in a distributed tuple list representation of the graph.</p><p>Using a linear time radix sort, parallel graph construction is achieved in <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S14-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) parallel compute time, <italic>O</italic>(1) communication rounds, and <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S14-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) parallel communication volume.</p><sec><title>Dealing with error</title><p>Pevzner et al. [<xref ref-type="bibr" rid="B2">2</xref>] and Dohm et al. [<xref ref-type="bibr" rid="B8">8</xref>] deal with erroneous sequences by editing those that have suspicious <italic>k</italic>-mers. The idea is that, given high coverage, errors will manifest themselves in the sequences as <italic>k</italic>-mers that occur only once. This is because as long as error is not systematic, the likelihood of seeing the same error twice at the same position is low. If a sequence containing a suspicious <italic>k</italic>-mer can be uniquely edited into a valid sequence, then the editing is done; if not, the sequence is discarded.</p><p>This approach, being a preprocessing step, can be used in conjunction with any assembly method to greatly reduce error in input sequences, and many recent works on assembly have advocated its use. We can use the same concept to identify error at a later stage in the method, by removing the offending <italic>k</italic>-mers from the bidirected De Bruijn graph.</p></sec></sec><sec><title>Parallel identification of unique contigs</title><p>The bidirected graph generated in the previous section will likely have many long chains, each corresponding to sequences that can be unambiguously assembled into a single contig. These chains are then connected in a more interesting topology that must be further analyzed. Will will compact these chains (forming a single edge in the graph for each chain) using undirected list ranking.</p><sec><title>Weighted undirected list ranking problem</title><p>For the undirected list ranking problem, we are given a set of weighted, undirected lists of total length <italic>n </italic>as an array of tuples &#x02112;[<italic>u</italic>] = &#x027e8;<italic>A</italic><sub>1</sub>, <italic>W</italic><sub>1</sub>, <italic>A</italic><sub>2</sub>, <italic>W</italic><sub>2</sub>&#x027e9; of size <italic>n</italic>, where <italic>u.A</italic><sub>1 </sub>and <italic>u.A</italic><sub>2 </sub>hold pointers to the two nodes adjacent to node <italic>u</italic>, and <italic>u.W</italic><sub>1 </sub>and <italic>u.W</italic><sub>2 </sub>hold the corresponding weights. If <italic>u </italic>is an endpoint, then either <italic>u.A</italic><sub>1 </sub>or <italic>u.A</italic><sub>2 </sub>will point to <italic>u</italic>. If <italic>u </italic>is the sole element of a list, then both <italic>u.A</italic><sub>1 </sub>and <italic>u.A</italic><sub>2 </sub>will point to <italic>u</italic>. If <italic>u.A</italic><sub><italic>i </italic></sub>= <italic>v</italic>, then either <italic>v.A</italic><sub>1 </sub>= <italic>u </italic>or <italic>v.A</italic><sub>2 </sub>= <italic>u</italic>. If <italic>u.A</italic><sub><italic>i </italic></sub>= <italic>v </italic>and <italic>v.A</italic><sub><italic>j </italic></sub>= <italic>u</italic>, then <italic>u.W</italic><sub><italic>i </italic></sub>= <italic>v.W</italic><sub><italic>j</italic></sub>.</p><p>For the undirected list ranking problem, we wish to compute the tuple <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>u</italic>] = &#x027e8;<italic>R</italic><sub>1</sub>, <italic>E</italic><sub>1</sub>, <italic>R</italic><sub>2</sub>, <italic>E</italic><sub>2</sub>&#x027e9;. <italic>u.R</italic><sub>1 </sub>is the rank of <italic>u </italic>relative to <italic>u.E</italic><sub>1</sub>, the list endpoint in the direction of <italic>u.A</italic><sub>1</sub>. <italic>u.R</italic><sub>2 </sub>and <italic>u.E</italic><sub>2 </sub>are respectively defined in the direction of <italic>u.A</italic><sub>2</sub>.</p></sec><sec><title>List ranking transformation</title><p>Conceptually, graph compaction involves replacing all chains in the graph with single edges, labeled by the concatenation of all edge labels along the chain. We will now show how to transform this problem to the problem of undirected list ranking. Consider edge tuples &#x027e8;<italic>u</italic>, <italic>v</italic>, <italic>d</italic><sub><italic>u</italic></sub>, <italic>d</italic><sub><italic>v</italic></sub>, <italic>c</italic><sub><italic>u</italic></sub>, <italic>c</italic><sub><italic>v</italic></sub>&#x027e9; augmented with two additional pieces of information <italic>id </italic>and <italic>adj</italic>. We will transform the graph compaction problem to the undirected list ranking problem using the following algorithm:</p><p>1. Sort all tuples with the smaller node id as the primary key and the larger node id as the secondary key. This results in both tuples for a given edge coming together in the sorted order.</p><p>2. If necessary, shift boundary tuples to guarantee that no edge is split between processors.</p><p>3. Give each pair of tuples a unique ID in the range 1 to |<italic>E</italic>|.</p><p>4. Sort all tuples with the first node id as the primary key and the second node id as the secondary key. This results in all tuples for a given node coming together in the sorted order.</p><p>5. If necessary, shift boundary tuples to guarantee that all tuples with the same first node id are on the same processor.</p><p>6. For each set of tuples <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-S1-S14-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> sharing the first node id <italic>u</italic>:</p><p>(a) If <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-10-S1-S14-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> = {<italic>x</italic>, <italic>y</italic>} and <italic>x.d</italic><sub><italic>u </italic></sub>&#x02260; <italic>y.d</italic><sub><italic>u </italic></sub>(there is a valid path through this node in the graph), then set <italic>x.adj </italic>&#x02190; <italic>y.ID </italic>and <italic>y.adj </italic>&#x02190; <italic>x.ID</italic>.</p><p>(b) Otherwise, for all tuples <italic>x </italic>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-10-S1-S14-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> set <italic>x.adj </italic>&#x02190; <italic>x.id</italic>.</p><p>7. Sort all tuples with the smaller node id as the primary key and the larger node id as the secondary key. Shift boundary tuples as necessary.</p><p>8. For each pair of tuples <italic>x </italic>and <italic>y </italic>corresponding to the same edge, set &#x02112;[<italic>id</italic>] &#x02190; &#x027e8;<italic>x.adj</italic>, 1, <italic>y.adj</italic>, 1&#x027e9;.</p><p>The runtime of the transformation is dominated by a constant number of parallel sort operations.</p></sec><sec><title>Parallel list ranking</title><p>The undirected list ranking problem is a modification of the traditional list ranking problem, which has been extensively studied on parallel computers. The sparse ruling set algorithm achieves the best run time on large data sets with a large number of processors [<xref ref-type="bibr" rid="B15">15</xref>], and we have accordingly designed a modified version of the sparse ruling set algorithm for undirected lists.</p><p>The sparse ruling set algorithm is a recursive algorithm on a weighted list (each edge is associated with a weight or distance). In the base case, the lists are gathered to one processor and solved using a serial list ranking algorithm, in linear time.</p><p>For the inductive case of the algorithm, we wish to achieve the following objectives. First, we wish to mark some subset of nodes which include all endpoints and some other nodes. Second, we wish to find the distance between each unmarked node and its two closest marked nodes. Finally, we wish to find the distance between adjacent marked nodes.</p><p>Once we have this information, we will set the adjacencies of each marked node to the nearest marked nodes in the list, and the weights as the distance to those marked nodes, and recursively solve the problem (see Fig. <xref ref-type="fig" rid="F2">2</xref>). After the recursion, we will know <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula> for all marked nodes. We can use the stored distance information from the unmarked nodes to the marked nodes to compute <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula> for all unmarked nodes.</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Sparse ruling set algorithm</bold>. The recursive step of the sparse ruling set algorithm. a) The input lists. b) The marked list with edges drawn between marked nodes, as well as pointers from unmarked nodes to nearest marked nodes (dashed). Edge weights are shown via line widths. c) The recursive problem (notice that list on the right has been completed and does not form a recursive subproblem).</p></caption><graphic xlink:href="1471-2105-10-S1-S14-2"/></fig><p>We will now formally describe an in place recursive algorithm. The algorithm communicates messages with four components: &#x02133; = &#x027e8;<italic>t</italic>, <italic>s</italic>, <italic>m</italic>, <italic>r</italic>&#x027e9;, where <italic>t </italic>is the target of the message, <italic>m </italic>is the id of the originating marked node, <italic>s </italic>is the source of the message, and <italic>r </italic>is the distance to the originating marked node.</p><p>For each node <italic>u </italic>we define <italic>u.i</italic>, an integer marking of the node. Let <italic>l </italic>identify the level of recursion. <italic>u.i </italic>and <italic>l </italic>will be used in conjunction to identify unmarked nodes and marked nodes for each recursion level, allowing for an in place algorithm. For each level <italic>l</italic>, <italic>u.i </italic>= <italic>l </italic>if and only if then <italic>u </italic>is an unmarked node. <italic>u.i </italic>= <italic>l </italic>+ 1 if and only if <italic>u </italic>is a marked node. Initially <italic>u.i </italic>= 0 for all <italic>u</italic>. Initially <italic>l </italic>= 0. Let <italic>n</italic><sub><italic>l </italic></sub>be the number of nodes with <italic>u.i </italic>= <italic>l</italic>. We execute the following recursive algorithm:</p><p>1. <bold>Mark nodes: </bold>For each node <italic>u </italic>that is unmarked (<italic>u.i </italic>= <italic>l</italic>), mark <italic>u </italic>(<italic>u.i </italic>&#x02190; <italic>l </italic>+ 1) under the following conditions:</p><p>&#x02022; <italic>u </italic>is an end point.</p><p>&#x02022; with some probability <italic>&#x003c1;</italic>.</p><p>2. <bold>Construct messages: </bold>For each node <italic>u </italic>that is a marked node, construct messages to be sent to the neighbors of <italic>u</italic>: &#x027e8;<italic>u</italic>.<italic>A</italic><sub>1</sub>, <italic>u</italic>, <italic>u</italic>, <italic>u</italic>.<italic>W</italic><sub>1</sub>&#x027e9; and &#x027e8;<italic>u</italic>.<italic>A</italic><sub>2</sub>, <italic>u</italic>, <italic>u</italic>, <italic>u</italic>.<italic>W</italic><sub>2</sub>&#x027e9;</p><p>3. <bold>Propagate messages: </bold>While there exist some messages to send:</p><p>(a) Send and receive all messages. This is a many-to-many communication.</p><p>(b) For each message &#x02133; received with target <italic>t</italic>, we can get the origin of the message by comparing <italic>s </italic>with <italic>t.A</italic><sub>1 </sub>and <italic>t.A</italic><sub>2</sub>. We will assume that <italic>s </italic>= <italic>t.A</italic><sub>1</sub>; the other case is handled similarly.</p><p>&#x02022; If <italic>t </italic>is a marked node then set the new adjacencies and weights for the recursive problem: <italic>t.A</italic><sub>1 </sub>&#x02190; <italic>m </italic>and <italic>t.W</italic><sub>1 </sub>&#x02190; <italic>r</italic>.</p><p>&#x02022; If <italic>t </italic>is an unmarked node then:</p><p>&#x025cb; Record the originating marked node and the distance to it: <italic>t.E</italic><sub>1 </sub>&#x02190; <italic>m </italic>and <italic>t.R</italic><sub>1 </sub>&#x02190; <italic>r</italic>.</p><p>&#x025cb; Propogate &#x02133; as &#x027e8;<italic>t</italic>.<italic>A</italic><sub>2</sub>, <italic>m</italic>, <italic>t</italic>, <italic>r </italic>+ <italic>t</italic>.<italic>W</italic><sub>2</sub>&#x027e9;.</p><p>4. <bold>Recursion: </bold>At this point, the recursive problem has been initialized. If <italic>n</italic><sub><italic>l</italic>+1 </sub>&#x0003c;<italic>T </italic>proceed with the base case. Otherwise recurse with <italic>l </italic>&#x02190; <italic>l </italic>+ 1.</p><p>5. <bold>Recursive Result: </bold>When the recursion is complete, all marked nodes will have <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>u</italic>] computed.</p><p>6. <bold>Compute </bold><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>u</italic>] <bold>for all unmarked nodes: </bold>For each <italic>u </italic>with <italic>u.i </italic>= <italic>l</italic>:</p><p>(a) <bold>Get flanking nodes</bold>: For flanking nodes: <italic>v </italic>&#x02190; <italic>u.E</italic><sub>1 </sub>and <italic>w </italic>&#x02190; <italic>u.E</italic><sub>2</sub>, gather <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>v</italic>] and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M21" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>w</italic>] if <italic>v </italic>and <italic>w </italic>are not local. Notice that <italic>v </italic>and <italic>w </italic>are marked.</p><p>(b) <bold>Calculate </bold><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M22" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>u</italic>]: It must be the case that either <italic>v.E</italic><sub>1 </sub>= <italic>w.E</italic><sub>1 </sub>or <italic>v.E</italic><sub>1 </sub>= <italic>w.E</italic><sub>2</sub>. We will consider the first case, as the second case is handled similarly.</p><p>&#x02022; If (<italic>v.R</italic><sub>1 </sub><italic>&#x0003c; w.R</italic><sub>1</sub>) then set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M23" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>u</italic>] &#x02190; &#x027e8;<italic>u.R</italic><sub>1 </sub>+ <italic>v.R</italic><sub>1</sub>,<italic>v.E</italic><sub>1</sub>,<italic>w.R</italic><sub>2 </sub>- <italic>u.R</italic><sub>2</sub>,<italic>v.E</italic><sub>2</sub>&#x027e9;.</p><p>&#x02022; If (<italic>v.R</italic><sub>1 </sub><italic>&#x0003e; w.R</italic><sub>1</sub>) then set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M24" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>u</italic>] &#x02190; &#x027e8;<italic>v.R</italic><sub>1 </sub>- <italic>u.R</italic><sub>1</sub>,<italic>v.E</italic><sub>2</sub>,<italic>w.R</italic><sub>2 </sub>+ <italic>u.R</italic><sub>2</sub>,<italic>v.E</italic><sub>1</sub>&#x027e9;.</p><p>The base case of the algorithm requires gathering all remaining <italic>n' </italic>marked nodes to a single processor to be ranked. To do so, we must map the pointers in the original array of size <italic>n </italic>to the new array of size <italic>n'</italic>. We construct an additional array that maps from the domain of <italic>n' </italic>to the domain of <italic>n</italic>. Once this array is gathered to a single processor, an inverted mapping is created. This inverted mapping is used to map the adjacency pointers, which index into the global domain, to the smaller domain.</p></sec><sec><title>Run-time analysis</title><p>The number of rounds of message passing in Step 3 is given by the longest distance between two marked nodes. As each node is randomly marked, this distance is bounded by 3<italic>p </italic>ln(<italic>n</italic><sub><italic>l</italic></sub>) with high probability [<xref ref-type="bibr" rid="B16">16</xref>]. Therefore, the expected number of communication rounds is <italic>O</italic>(log(<italic>n</italic><sub><italic>l</italic></sub>)). The communication volume over these <italic>O</italic>(log(<italic>n</italic><sub><italic>l</italic></sub>)) rounds is <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M25" name="1471-2105-10-S1-S14-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>). Because <italic>n</italic><sub><italic>l </italic></sub>is expected to exponentially decrease in <italic>O</italic>(log <italic>n</italic>) recursive calls, the the total expected run-time of undirected list ranking is given by <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M26" name="1471-2105-10-S1-S14-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) parallel compute time, <italic>O</italic>(log<sup>2 </sup><italic>n</italic>) communication rounds, and <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M27" name="1471-2105-10-S1-S14-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) parallel communication volume.</p></sec><sec><title>Compacted graph construction</title><p>After solving the list ranking transformation, we will set <italic>id </italic>and <italic>adj </italic>for tuples <italic>x </italic>and <italic>y </italic>as follows:</p><p>&#x02022; if <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M28" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>id</italic>].<italic>E</italic><sub>1 </sub>&#x02264; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M29" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>id</italic>].<italic>E</italic><sub>2</sub>:</p><p>&#x025cb; <italic>x.id &#x02190; y.id &#x02190; </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M30" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>id</italic>].<italic>E</italic><sub>1</sub></p><p>&#x025cb; <italic>x.adj &#x02190; y.adj &#x02190; </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M31" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>id</italic>].<italic>R</italic><sub>1</sub></p><p>&#x02022; if <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M32" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>id</italic>].<italic>E</italic><sub>1 </sub>&#x0003e; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M33" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>id</italic>].<italic>E</italic><sub>2</sub>:</p><p>&#x025cb; <italic>x.id &#x02190; y.id &#x02190; </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M34" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>id</italic>].<italic>E</italic><sub>2</sub></p><p>&#x025cb; <italic>x.adj &#x02190; y.adj &#x02190; </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M35" name="1471-2105-10-S1-S14-i9" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">R</mml:mi></mml:semantics></mml:math></inline-formula>[<italic>id</italic>].<italic>R</italic><sub>2</sub></p><p>The <italic>id </italic>component of each edge tuple corresponds to the chain <italic>id</italic>, and the <italic>adj </italic>component of each edge tuple corresponds to the chain position. By sorting the tuples using these two fields as the primary key and the secondary key respectively, we can order all tuples according to their chain membership and position. If we shift boundary elements such that all elements with the same <italic>id </italic>are on the same processor, all tuples belonging to the same chain will be local to a processor. From these sorted tuples, we will construct our compacted graph representation.</p><p>First, we must store chains, each chain consisting of a sequence of bases. Each base in the chain is represented by a tuple &#x027e8;<italic>b</italic><sub>1</sub>, <italic>b</italic><sub>2</sub>, <italic>id</italic>, <italic>pos</italic>&#x027e9;, where <italic>b</italic><sub>1</sub>,<italic>b</italic><sub>2 </sub>&#x02208; {<italic>A</italic>, <italic>C</italic>,<italic>G</italic>,<italic>T</italic>}. This representation arises naturally from the tuples in the sorted order described above, and in fact the transformation to this representation only removes redundant and unnecessary information.</p><p>In addition to the chains, we also construct a distributed tuple list that models the compacted string graph. Each tuple is of the form &#x027e8;<italic>u</italic>, <italic>v</italic>, <italic>d</italic><sub><italic>u</italic></sub>, <italic>d</italic><sub><italic>v</italic></sub>, <italic>cov</italic>, <italic>ch</italic>_<italic>id</italic>, <italic>ch</italic>_<italic>dir</italic>&#x027e9;, with <italic>u </italic>the first endpoint, <italic>v </italic>the second endpoint, <italic>d</italic><sub><italic>u </italic></sub>the direction of the arrowhead at <italic>u</italic>, <italic>d</italic><sub><italic>v </italic></sub>the direction of the arrowhead at <italic>v</italic>, <italic>cov </italic>the average coverage on that edge, <italic>ch_id </italic>the identifier of the chain that labels this edge, and <italic>ch_dir </italic>= {<italic>forward</italic>, <italic>reverse</italic>} corresponding to which strand of the chain should be read when moving from <italic>u </italic>to <italic>v</italic>.</p><p>The tuples for the compacted graph can be easily constructed by scanning the original graph tuples in the sorted order described above. For every chain starting with tuple &#x027e8;<italic>u</italic>, <italic>v</italic>, <italic>d</italic><sub><italic>u</italic></sub>, <italic>d</italic><sub><italic>v</italic></sub>, <italic>c</italic><sub><italic>u</italic></sub>, <italic>c</italic><sub><italic>v</italic></sub>, <italic>id</italic>, 0&#x027e9; and ending with tuple &#x027e8;<italic>x</italic>, <italic>y</italic>, <italic>d</italic><sub><italic>x</italic></sub>, <italic>d</italic><sub><italic>y</italic></sub>, <italic>c</italic><sub><italic>x</italic></sub>, <italic>c</italic><sub><italic>y</italic></sub>, <italic>id, adj</italic>&#x027e9;, we construct tuples &#x027e8;<italic>u</italic>, <italic>y</italic>, <italic>d</italic><sub><italic>u</italic></sub>, <italic>d</italic><sub><italic>y</italic></sub>, <italic>cov</italic>, <italic>id</italic>, <italic>forward</italic>&#x027e9; and &#x027e8;<italic>y</italic>, <italic>u</italic>, <italic>d</italic><sub><italic>y</italic></sub>, <italic>d</italic><sub><italic>u</italic></sub>, <italic>cov</italic>, <italic>id</italic>, <italic>reverse</italic>&#x027e9;. Assume that the coverage information for each can be calcualted as the average coverage of all positions along the chain.</p></sec></sec><sec><title>Graph reduction</title><p>At this point of graph processing, much of the repeat structure of the genome will be hidden in the graph, and as a result the length of all chains will be less than <italic>g</italic>. We wish to perform a sequence of reductions that will simultaneously simplify the graph while expanding the length of all chains to approach the size of <italic>g</italic>. We do this by performing graph manipulations centered at some nodes.</p><p>Consider the set of tuples <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M36" name="1471-2105-10-S1-S14-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> = {<italic>t</italic><sub>1</sub>, <italic>t</italic><sub>2</sub>, ... <italic>t</italic><sub><italic>k</italic></sub>} all sharing the first node id <italic>u</italic>. These tuples correspond to edges incident to <italic>u </italic>in the graph. We can partition <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M37" name="1471-2105-10-S1-S14-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> into two sets <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M38" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M39" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, where <italic>t</italic><sub><italic>i </italic></sub>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M40" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> if and only if <italic>t</italic><sub><italic>i</italic></sub>.<italic>d</italic><sub><italic>u </italic></sub>= &#x025c1;, while <italic>t</italic><sub><italic>j </italic></sub>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M41" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> if and only if <italic>t</italic><sub><italic>j</italic></sub>.<italic>d</italic><sub><italic>u </italic></sub>= &#x025b7;. Thus, conceptually when traversing the graph, if we enter the node <italic>u </italic>along an edge that corresponds to a tuple in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M42" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, we must exit the node in an edge that corresponds to a tuple in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M43" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, and vice versa. This means that for each <italic>t</italic><sub><italic>i </italic></sub>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M44" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> there are |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M45" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| possible continuations, and for each <italic>t</italic><sub><italic>j </italic></sub>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M46" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> there are |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M47" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| possible continuations. Our goal is to reduce these possibilities.</p><p>First, we will choose some <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M48" name="1471-2105-10-S1-S14-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">I</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub><mml:mo>&#x02286;</mml:mo><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> to remove from <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M49" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>. Next, for each <italic>t</italic><sub><italic>i </italic></sub>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M50" name="1471-2105-10-S1-S14-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">I</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, we define a subset <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M51" name="1471-2105-10-S1-S14-i17" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">O</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub><mml:mo>&#x02286;</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>. These are the nodes from <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M52" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> that we wish to remain connected to <italic>t</italic><sub><italic>i</italic></sub>. We then can define <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M53" name="1471-2105-10-S1-S14-i18" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">O</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mo>&#x0222a;</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> as the set of edges to remove from <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M54" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>.</p><p>When we remove graph edges corresponding to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M55" name="1471-2105-10-S1-S14-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">I</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M56" name="1471-2105-10-S1-S14-i19" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">O</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, we will replace them with the following edges. For each <italic>t</italic><sub><italic>i </italic></sub>= &#x027e8;<italic>u</italic>, <italic>v</italic>, <italic>d</italic><sub><italic>u</italic></sub>, <italic>d</italic><sub><italic>v</italic></sub>, ...&#x027e9; &#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M57" name="1471-2105-10-S1-S14-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">I</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> and <italic>t</italic><sub><italic>j </italic></sub>= &#x027e8;<italic>u</italic>, <italic>w</italic>, <italic>d</italic><sub><italic>u</italic></sub>, <italic>d</italic><sub><italic>w</italic></sub>, ...&#x027e9; &#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M58" name="1471-2105-10-S1-S14-i20" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>, construct new edge with tuples &#x027e8;<italic>v</italic>, <italic>w</italic>, <italic>d</italic><sub><italic>v</italic></sub>, <italic>d</italic><sub><italic>w</italic></sub>, ...&#x027e9; and &#x027e8;<italic>w</italic>, <italic>v</italic>, <italic>d</italic><sub><italic>w</italic></sub>, <italic>d</italic><sub><italic>v</italic></sub>, ...&#x027e9;. We will also update the chain associated with these new edges to be the concatenation of the corresponding chains for the deleted edges. We call this sequence of operations a graph reduction centered on node <italic>u</italic>.</p><p>The actual choice of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M59" name="1471-2105-10-S1-S14-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">I</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M60" name="1471-2105-10-S1-S14-i19" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">O</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> result from the following rules:</p><sec><title>Rule 1: Y to V reduction</title><p>We show an example of this rule being applied in Fig. <xref ref-type="fig" rid="F3">3.a</xref>. A Y-node is a node in which |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M61" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| = 1 and |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M62" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| &#x0003e; 1 (or vice versa). We will consider the case where |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M63" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| = 1 and |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M64" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| = <italic>k</italic>. For the Y to V transformation, we set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M65" name="1471-2105-10-S1-S14-i21" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">I</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub><mml:mo>&#x02190;</mml:mo><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M66" name="1471-2105-10-S1-S14-i22" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">O</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub><mml:mo>&#x02190;</mml:mo><mml:msubsup><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo>&#x02190;</mml:mo><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>. Because the adjacency list for <italic>u </italic>is now empty, we consider <italic>u </italic>removed from the graph. In essence, this rule allows for repeated elements from the genome to be duplicated in the graph. With each such operation, we would expect the total length of all edge labels in the graph to approach the actual length of the genome, but still be bounded by said length.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>Graph reduction rules</bold>. The three graph reduction rules as described in the text: a) Y to V reduction b) loop reduction c) coverage matching. Each figure is labeled with a node identifier and chain identifier, and shows the structure of the graph before and after the reduction. It also shows how the underlying chains are concatenated for each type of reduction.</p></caption><graphic xlink:href="1471-2105-10-S1-S14-3"/></fig></sec><sec><title>Rule 2: Loop reduction</title><p>We show an example of this rule being applied in Fig. <xref ref-type="fig" rid="F3">3.b</xref>. A loop node is a node in which <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M67" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> = {&#x027e8;<italic>u</italic>, <italic>v</italic>, &#x025c1;, <italic>d</italic><sub><italic>v</italic></sub>, ...&#x027e9;, &#x027e8;&#x0003c;<italic>u</italic>, <italic>u</italic>, &#x025c1;, &#x025b7;, ...&#x027e9;} and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M68" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> = {&#x027e8;<italic>u</italic>, <italic>w</italic>, &#x025b7;, <italic>d</italic><sub><italic>w</italic></sub>, ...&#x027e9;, &#x027e8;<italic>u</italic>, <italic>u</italic>, &#x025b7;, &#x025c1;, ...&#x027e9;. There exists exactly one valid traversal of the graph at a loop node <italic>u</italic>: enter <italic>u</italic>, take the loop, and then exit <italic>u</italic>. As in the previous rule, we remove all edges adjacent to <italic>u</italic>, but this time we replace these adjacencies with a single edge. As shown in Fig. <xref ref-type="fig" rid="F3">3.b</xref>, the resulting chain is the concatenation of three chains (labeled <italic>x</italic>, <italic>y</italic>, and <italic>z </italic>in the figure).</p><p>These two rules were also described by Medvedev <italic>et al. </italic>[<xref ref-type="bibr" rid="B11">11</xref>]. Their iterative application to the graph results in a graph that Medvedev termed the <italic>conflict graph</italic>, consisting entirely of nodes that fall under two classes-either |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M69" name="1471-2105-10-S1-S14-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">A</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| = 1 or |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M70" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| &#x0003e; 1 and |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M71" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| &#x0003e; 1.</p></sec><sec><title>Rule 3: Coverage matching</title><p>We show an example of this rule being applied in Fig. <xref ref-type="fig" rid="F3">3.c</xref>. We will make use of the special nature of transcriptome data to match incoming tuples with outgoing tuples. Consider an incoming tuple <italic>t</italic><sub><italic>i </italic></sub>and outgoing tuple <italic>t</italic><sub><italic>j</italic></sub>. If |<italic>cov</italic><sub><italic>i </italic></sub>- <italic>cov</italic><sub><italic>j</italic></sub>| &#x0003c;<italic>T</italic>, where <italic>T </italic>is some threshold, then we term <italic>t</italic><sub><italic>i </italic></sub>and <italic>t</italic><sub><italic>j </italic></sub><italic>compatible</italic>. If <italic>t</italic><sub><italic>i </italic></sub>is only compatible with <italic>t</italic><sub><italic>j </italic></sub>and <italic>t</italic><sub><italic>j </italic></sub>is only compatible with <italic>t</italic><sub><italic>i</italic></sub>, then we term them <italic>uniquely compatible</italic>. We now define <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M72" name="1471-2105-10-S1-S14-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi mathvariant="script">I</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> to be that set of all tuples <italic>t</italic><sub><italic>i </italic></sub>in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M73" name="1471-2105-10-S1-S14-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">I</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> that have a uniquely compatible tuple <italic>t</italic><sub><italic>j </italic></sub>in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M74" name="1471-2105-10-S1-S14-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> and define <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M75" name="1471-2105-10-S1-S14-i20" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi mathvariant="script">O</mml:mi><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> = {<italic>t</italic><sub><italic>j</italic></sub>}.</p><p>We have introduced this rule for the specific problem of transcriptome assembly. Through this rule we leverage the coverage information inherent in the graph to reduce the number of possible traversals of the graph.</p></sec><sec><title>Parallel graph reduction</title><p>We wish to perform the described graph reduction in parallel. In general, we will proceed in a series of iterations. In each iteration we will identify nodes that center reductions and carry out those reductions in parallel.</p><p>The first step is to find nodes that will center reductions. We can identify all nodes obeying one or more of our reduction rules in parallel because our rules require only local adjacency information, which is available on a single processor if we sort tuples by the first node ID. However, we cannot concurrently carry out reductions on all of these nodes, because if nodes <italic>u </italic>and <italic>v </italic>both center reductions, and <italic>u </italic>and <italic>v </italic>are adjacent in the graph, the operations they wish to perform will be incompatible. This is because node <italic>u </italic>might want to remove itself from the graph, while node <italic>v </italic>might wish to make a new edge with <italic>u </italic>as an endpoint.</p><p>For this reason during each iteration we can only operate on an independent set of the nodes identified as centering valid reductions. An independent set of nodes is a set of nodes such that the induced graph has an empty edge set. Finding a maximum independent set is NP-hard [<xref ref-type="bibr" rid="B17">17</xref>] (it is equivalent to finding the maximum sized clique in the complement graph). A randomized parallel algorithm for fining a <italic>maximal </italic>independent exists [<xref ref-type="bibr" rid="B18">18</xref>], but it uses <italic>O</italic>(log <italic>n</italic>) communication rounds. Instead, we describe a heuristic algorithm that chooses a large independent set of nodes assuming that the nodes have similar degree and the node identifiers are randomly permuted. When the following algorithm completes, black nodes mark an independent set.</p><p>1. Mark all nodes white.</p><p>2. For each node <italic>u </italic>identified as centering a reduction:</p><p>(a) Mark <italic>u </italic>black.</p><p>(b) Send messages to all nodes adjacent to <italic>u</italic>.</p><p>(c) For each black node <italic>v </italic>adjacent to <italic>u</italic>, if <italic>u.id </italic>&#x0003e; <italic>v.id</italic>, mark <italic>u </italic>white.</p><p>The second step is to carry out the reductions in parallel. For this we define a sufficient set of four operations. For each of the operations, the processor holding the reduction node sends messages to the processors holding the tuples and chains to be modified.</p><p>1. <bold>Delete</bold>(<italic>u</italic>,<italic>v)</italic>: Deletes two tuples.</p><p>2. <bold>Insert</bold>(<italic>u</italic>, <italic>v</italic>, <italic>d</italic><sub><italic>u</italic></sub>, <italic>d</italic><sub><italic>v</italic></sub>, <italic>cov</italic>, <italic>ch_id</italic>, <italic>ch_dir)</italic>: Creates two tuples for the new edge.</p><p>3. <bold>Update</bold><italic>(ch_id</italic><sub><italic>old</italic></sub>, <italic>ch_id</italic>, <italic>of f set</italic>, <italic>flip)</italic>: Updates chain identified by <italic>ch_id</italic><sub><italic>old</italic></sub>: sets the identifier to <italic>ch_id</italic>, adds <italic>of f set </italic>to the molecule positions, and possibly flips the orientation of the chain by reversing the order.</p><p>4. <bold>Duplicate</bold><italic>(ch_id</italic><sub><italic>old</italic></sub>, <italic>ch_id</italic>, <italic>of f set, flip)</italic>: Copies the chain and then updates it.</p><p>We will now describe the parallel algorithm for graph reduction.</p><p>1. Find all reduction nodes in the graph.</p><p>2. Find an independent set of such nodes using the heuristic described above.</p><p>3. For all nodes in the independent set, create messages for updating the graph, and distribute these messages using a many to many communication.</p><p>4. Process in parallel the graph manipulation messages. This can be done using a single scan of the distributed tuple array.</p><p>5. Process in parallel the chain manipulation messages. This can be done using two scans of distributed tuple array.</p><p>6. Re-sort the graph and chain tuples to maintain sorted order.</p><p>7. If some reduction in the graph has occurred, continue with Step 1.</p></sec><sec><title>Run-time analysis</title><p>Steps 1, 2, 3, and 4 take <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M76" name="1471-2105-10-S1-S14-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) local computation, where <italic>n </italic>is the number of nodes in the graph, and a constant number of communication rounds. Steps 5 and 6 take <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M77" name="1471-2105-10-S1-S14-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>g</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) local computation and a constant number of communication rounds with <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M78" name="1471-2105-10-S1-S14-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>g</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) communication volume, where <italic>g </italic>is the size of genome. Because in practice the size the graph is much less than the size of the genome the running time of each iteration is <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M79" name="1471-2105-10-S1-S14-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>g</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>), the communication volume is <italic>O </italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M80" name="1471-2105-10-S1-S14-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mi>g</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>), and the number of communication rounds is <italic>O</italic>(1).</p><p>Because the time taken for Step 6 dominates the runtime and is independent of the number of chains being processed, we see benefit in trying to limit the number of iterations. Still, we use a heuristic rule to find an independent set of reduction nodes that works well in practice, and empirically we observe the number of iterations to be on the order of <italic>log</italic>(<italic>n</italic>). More importantly, the resulting program was able to process large inputs in a matter of seconds using this rule. Whether using the parallel randomized algorithm [<xref ref-type="bibr" rid="B18">18</xref>] to find a maximal independent set significantly reduces the number of iterations and improves the runtime is an open question.</p></sec></sec><sec><title>Writing the contigs</title><p>Once we have constructed the graph, compacted the chains, and finished graph reduction, we can output the contigs by traversing the final chains. The starting point for traversal will dictate which of the two strands of DNA will be written. From each chain in the graph, we can output a strand of DNA with (<italic>l </italic>+ <italic>k </italic>- 1) nucleotides, where <italic>l </italic>is the length of the chain (See Fig. <xref ref-type="fig" rid="F1">1</xref>). This is because the strand of DNA read when traversing one strand is offset (<italic>k</italic>-1) positions from the strand read from reading in the other direction. This means that after reading <italic>l </italic>nucleotides from the chain in the one direction as <italic>s</italic>, and reading (<italic>k </italic>- 1) nucleotides in the opposite direction as <italic>e</italic>, the full sequence read can be written as <italic>se'</italic>, where <italic>e' </italic>is the complementary strand of <italic>e</italic>.</p></sec></sec><sec><title>Results and Discussion</title><sec><title>Synthetic data</title><p>The Illumina sequencing machine currently reports 36 length reads with the ability to report 50 length reads currently in testing. We analyzed data from a single Illumina run from the Michael Smith Genome Sciences Center to produce a model for the generation of vast amounts of synthetic data. The Illumina quality file consists of a vector &#x027e8;<italic>Q</italic><sub><italic>A</italic></sub>, <italic>Q</italic><sub><italic>C</italic></sub>, <italic>Q</italic><sub><italic>G</italic></sub>, <italic>Q</italic><sub><italic>T</italic></sub>&#x027e9;, where <italic>Q</italic><sub><italic>N </italic></sub>is the quality score for calling the nucleotide <italic>N</italic>, calculated using the following formula, where <italic>p </italic>is the probability of the nucleotide being <italic>N</italic>:</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M81" name="1471-2105-10-S1-S14-i23" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>Q</mml:mi>                           <mml:mo>=</mml:mo>                           <mml:mn>10</mml:mn>                           <mml:mi>l</mml:mi>                           <mml:mi>o</mml:mi>                           <mml:msub>                              <mml:mi>g</mml:mi>                              <mml:mrow>                                 <mml:mn>10</mml:mn>                              </mml:mrow>                           </mml:msub>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mi>p</mml:mi>                                    <mml:mrow>                                       <mml:mn>1</mml:mn>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:mi>p</mml:mi>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>The <italic>Q </italic>values are integers in the range [-40, 40], with <italic>Q </italic>= -40 &#x02194; <italic>p </italic>= 0, <italic>Q </italic>= 0 &#x02194; <italic>p </italic>= .5 and <italic>Q </italic>= 40 &#x02194; <italic>p </italic>= 1. To measure the goodness of a base call, we look at the difference between the highest <italic>Q </italic>value and the second highest <italic>Q </italic>value. We want this difference to be significant to consider the call to be valid. For our analysis we chose to consider a difference greater than 10 between the maximum <italic>Q </italic>value and second highest <italic>Q </italic>value to be significant. This corresponds to an underlying probability difference of between .4 and .5.</p><p>To adequately generate synthetic data, we are interested in three questions about the Illumina sequence quality: 1) What is the probability that the base call is bad at a particular position (between 1 and 36)? 2) What is the probability that a base call is bad at a particular position, given no bad base calls in a previous position? 3) What is the probability that a base call is bad at a particular position, given some bad base call in a previous position?</p><p>As can be seen in Fig. <xref ref-type="fig" rid="F4">4</xref>, the conditional probability that a base is bad if we have previously seen a bad base is high in Illumina data. Conversely, the probability that a base is bad given that all previous bases are good remains low across all positions. From this data, we can infer that once a bad base call is made, whatever condition caused this state remains in effect for the remainder of the base calls, causing the rest of the sequence to be unreliable. At the same time, the sequence before this switchover point is of high quality. For this reason, it seems reasonable to model properly trimmed Illumina sequences as nearly perfect sequences, and we do so by randomly selecting read lengths between 30 and 50.</p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>Error analysis of Illumina data</bold>. Error Analysis of Illumina Data by position. We analyzed the percentage of bad bases (center line), the percentage of bad bases, given some bad base in a previous position (top line), and the percentage of bad bases, given no bad base in a previous position (bottom line).</p></caption><graphic xlink:href="1471-2105-10-S1-S14-4"/></fig><p>We generated synthetic data from the genic regions of maize, predicted using FGENESH v.2.6 (using the monocots matrix) on the previously assembled maize genomic islands [<xref ref-type="bibr" rid="B1">1</xref>]. We used 61,428 gene structures to generate simulated high coverage transcriptome data. Each gene was sampled at a random coverage between 50&#x000d7; and 1000&#x000d7; using read lengths of 30 to 50 base pairs, resulting in a data set of 925 million reads and 40 billion bases. As discussed in the results section, we assume an adequate preprocessing of the sequences will remove nearly all errors.</p></sec><sec><title>Performance results</title><p>We completed performance scalability testing using <italic>p </italic>= 64 to <italic>p </italic>= 1024 and <italic>k </italic>= 30 on a 1024 node Blue Gene/L supercomputer. We timed each stage of the algorithm individually and present the results in Table <xref ref-type="table" rid="T1">1</xref>.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Performance results. Runtime in seconds for the transcriptome data set with approximately 40 billion bases. <italic>p </italic>indicates the number of processors. The last column is the total runtime of all phases, not including file input.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="right"><italic>P</italic></td><td align="center">Read Data</td><td align="right">Construct Graph</td><td align="right">Compact Graph</td><td align="right">Reduce Graph</td><td align="right">Total</td></tr></thead><tbody><tr><td align="right">64</td><td align="center">516.47</td><td align="right">73.06</td><td align="right">81.17</td><td align="right">256.8</td><td align="right">411.03</td></tr><tr><td align="right">128</td><td align="center">364.20</td><td align="right">40.70</td><td align="right">43.17</td><td align="right">107.68</td><td align="right">191.55</td></tr><tr><td align="right">256</td><td align="center">189.94</td><td align="right">22.63</td><td align="right">24.17</td><td align="right">59.27</td><td align="right">106.07</td></tr><tr><td align="right">512</td><td align="center">195.04</td><td align="right">13.37</td><td align="right">15.42</td><td align="right">33.23</td><td align="right">62.02</td></tr><tr><td align="right">1024</td><td align="center">168.26</td><td align="right">8.08</td><td align="right">11.64</td><td align="right">20.13</td><td align="right">39.85</td></tr></tbody></table></table-wrap><p>As can be seen in the table, stages that are not I/O bound achieved a respectable 6:63X speedup when increasing the number of processors from 64 to 512. The reduction in incremental performance towards higher values of <italic>p </italic>is a natural reflection of the problem size becoming smaller per processor. The poor I/O performance is due to the lack of a parallel I/O interconnect on the system tested. As the number of processors increases, the serial interconnect becomes saturated as more processors concurrently read from disk. Disregarding I/O, the assembly of 40 billion bases finished in about 40 seconds using 1024 nodes. Even including serial I/O, the assembly ran in a few minutes.</p></sec><sec><title>Validation and analysis</title><p>We analyzed the effect of varying <italic>k </italic>on the resulting compacted graph size and hence the quality of the resulting contigs, as shown in Table <xref ref-type="table" rid="T2">2</xref>. As we increase <italic>k</italic>, we see a significant reduction in the number of final contigs produced by our algorithm, from 338,000 for <italic>k </italic>= 20 to 114,000 for <italic>k </italic>= 30. While the relative difference in the number of unique <italic>k</italic>-mers does not change much while varying <italic>k</italic>, the absolute difference in the number of unique <italic>k</italic>-mers is similar to the absolute difference in the output size, which is significant.</p><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Effect of <italic>k </italic>on graph size. Effect of varying <italic>k </italic>on graph size.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center"><italic>K</italic></td><td align="right">Unique k-mers</td><td align="right">Num Edges</td><td align="right">Compacted Edges</td><td align="right">Reduced Edges</td></tr></thead><tbody><tr><td align="center">20</td><td align="right">20,537,274</td><td align="right">20,658,206</td><td align="right">451,718</td><td align="right">338,121</td></tr><tr><td align="center">25</td><td align="right">20,717,553</td><td align="right">20,741,818</td><td align="right">205,858</td><td align="right">149,018</td></tr><tr><td align="center">30</td><td align="right">20,758,869</td><td align="right">20,764,256</td><td align="right">154,965</td><td align="right">114,028</td></tr></tbody></table></table-wrap><p>For <italic>k </italic>= 30 there were approximately two contigs per reference gene. For validation, we used the BLAST tool to align the assembled contigs to the reference. We post-processed the BLAST results to verify that each contig fully aligned to some predicted gene in the reference. Our analysis showed that 92% of the contigs correctly aligned back to the reference. The remaining contigs are mostly the result of over-collapsing edges during graph manipulation. Improving this result is an area of ongoing research.</p><p>We also measured how well contigs of length 500 or greater covered the reference sequence. This measure is similar to the <italic>n</italic>50 measure usually used for assessing the quality of a genome assembly, however in our case only a subset of the reference genes will have lengths greater than <italic>n</italic>. We found that approximately 38% of the applicable reference was covered by contigs with length greater than 500. The maximum length contig was 4017. The maximum length contig in the reference was 5704.</p></sec></sec><sec><title>Conclusion</title><p>We presented a parallel method for the assembly of unpaired short reads, using a distributed bidirected string graph. In doing so, we address the challenge of effectively manipulating large distributed graphs on parallel computers. We also present a method for making use of variable coverage to resolve conflicts that arise due to repeats. We produce a <italic>de novo </italic>assembly of the <italic>Zea mays </italic>transcriptome, using synthetically generated sequences derived from it. Our method is very fast, producing an assembly of 925 million reads (40 billion nucleotides) in a few minutes. Our final assembly consists of an average of two contigs per predicted gene for this complex plant genome. <italic>De novo </italic>assembly of a genome using short reads will almost certainly require the integration of clone pairs into the proposed method. We are currently working on developing a parallel method for <italic>de novo </italic>genome assembly incorporating clone pair information.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>BJ developed the algorithmic solutions, implemented the software, and drafted the manuscript. PS provided domain expertise, contributed to understanding the problem and the experimental processes, and provided ongoing feedback. SA conceived the problem, critiqued the solution, and assisted in the development and revision of the manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>We thank Chad Brewbaker, Scott Emrich, Xiao Yang, and Jaroslaw Zola for their input and feedback. This project was supported in part by the National Science Foundation under CNS-0521568, DBI-0527192, and CCF-0431140, and by the Plant Sciences Institute Innovative Research Grants program. This article was invited to be published as part of the supplemental issue of the 2009 Asia Pacific Bioinformatics Conference.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Emrich</surname><given-names>S</given-names></name><name><surname>Aluru</surname><given-names>S</given-names></name><name><surname>Fu</surname><given-names>Y</given-names></name><name><surname>Wen</surname><given-names>T</given-names></name><name><surname>Narayanan</surname><given-names>M</given-names></name><name><surname>Guo</surname><given-names>L</given-names></name><name><surname>Ashlock</surname><given-names>D</given-names></name><name><surname>Schnable</surname><given-names>P</given-names></name></person-group><article-title>A Strategy for Assembling the Maize (Zea mays L.) Genome</article-title><source>Bioinformatics</source><year>2004</year><volume>20</volume><fpage>140</fpage><lpage>147</lpage><pub-id pub-id-type="pmid">14734303</pub-id></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pevzner</surname><given-names>P</given-names></name><name><surname>Tang</surname><given-names>H</given-names></name><name><surname>Waterman</surname><given-names>M</given-names></name></person-group><article-title>Fragment assembly with double-barreled data</article-title><source>Proceedings of the National Academy of Sciences</source><year>2001</year><volume>98</volume><fpage>9748</fpage><lpage>9753</lpage></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Myers</surname><given-names>E</given-names></name></person-group><article-title>The fragment assembly string graph</article-title><source>Bioinformatics</source><year>2005</year><volume>21</volume><fpage>ii79</fpage><lpage>ii85</lpage><pub-id pub-id-type="pmid">16204131</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Medvedev</surname><given-names>P</given-names></name><name><surname>Brudno</surname><given-names>M</given-names></name></person-group><article-title>Ab Initio Whole Genome Shotgun Assembly with Mated Short Reads</article-title><source>Lecture Notes in Computer Science</source><year>2008</year><volume>4955</volume><fpage>50</fpage><lpage>64</lpage></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hernandez</surname><given-names>D</given-names></name><name><surname>Francois</surname><given-names>P</given-names></name><name><surname>Farinelli</surname><given-names>L</given-names></name><name><surname>Osteras</surname><given-names>M</given-names></name><name><surname>Schrenzel</surname><given-names>J</given-names></name></person-group><article-title>De novo bacterial genome sequencing: Millions of very short reads assembled on a desktop computer</article-title><source>Genome Research</source><year>2008</year><volume>18</volume><fpage>802</fpage><lpage>809</lpage><pub-id pub-id-type="pmid">18332092</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Zerbino</surname><given-names>D</given-names></name><name><surname>Birney</surname><given-names>E</given-names></name></person-group><article-title>Velvet: Algorithms for De Novo Short Read Assembly Using De Bruijn Graphs</article-title><source>Genome Research</source><year>2008</year><pub-id pub-id-type="pmid">18349386</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Warren</surname><given-names>R</given-names></name><name><surname>Sutton</surname><given-names>G</given-names></name><name><surname>Jones</surname><given-names>S</given-names></name><name><surname>Holt</surname><given-names>R</given-names></name></person-group><article-title>Assembling millions of short DNA sequences using SSAKE</article-title><source>Bioinformatics</source><year>2007</year><volume>23</volume><fpage>500</fpage><lpage>501</lpage><pub-id pub-id-type="pmid">17158514</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Dohm</surname><given-names>J</given-names></name><name><surname>Lottaz</surname><given-names>C</given-names></name><name><surname>Borodina</surname><given-names>T</given-names></name><name><surname>Himmelbauer</surname><given-names>H</given-names></name></person-group><article-title>SHARCGS, a fast and highly accurate short-read assembly algorithm for de novo genomic sequencing</article-title><source>Genome Research</source><year>1997</year><volume>17</volume><fpage>1697</fpage><lpage>1706</lpage><pub-id pub-id-type="pmid">17908823</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Butler</surname><given-names>J</given-names></name><name><surname>MacCallum</surname><given-names>I</given-names></name><name><surname>Kleber</surname><given-names>M</given-names></name><name><surname>Shlyakhter</surname><given-names>I</given-names></name><name><surname>Belmonte</surname><given-names>M</given-names></name><name><surname>Lander</surname><given-names>E</given-names></name><name><surname>Nusbaum</surname><given-names>C</given-names></name><name><surname>Jaffe</surname><given-names>D</given-names></name></person-group><article-title>ALL-PATHS: De novo assembly of whole-genome shotgun microreads</article-title><source>Genome Research</source><year>2008</year><volume>18</volume><fpage>810</fpage><lpage>820</lpage><pub-id pub-id-type="pmid">18340039</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sundquist</surname><given-names>A</given-names></name><name><surname>Ronaghi</surname><given-names>M</given-names></name><name><surname>Tang</surname><given-names>H</given-names></name><name><surname>Pevzner</surname><given-names>P</given-names></name><name><surname>Batzoglou</surname><given-names>S</given-names></name></person-group><article-title>Whole-Genome Sequencing and Assembly with High-Throughput, Short Read Technologies</article-title><source>PLoS ONE</source><year>2007</year><volume>2</volume><fpage>e484</fpage><pub-id pub-id-type="pmid">17534434</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Medvedev</surname><given-names>P</given-names></name><name><surname>Georgiou</surname><given-names>K</given-names></name><name><surname>Myers</surname><given-names>G</given-names></name><name><surname>Brudno</surname><given-names>M</given-names></name></person-group><article-title>Computability of Models for Sequence Assembly</article-title><source>Lecture Notes in Computer Science</source><year>2007</year><volume>4645</volume><fpage>289</fpage><lpage>301</lpage></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Shankar</surname><given-names>R</given-names></name><name><surname>Ranka</surname><given-names>S</given-names></name></person-group><article-title>Random Data Accesses on a Coarse-Grained Parallel Machine. II. One-to-Many and Many-to-One Mappings</article-title><source>Journal of Parallel and Distributed Computing</source><year>1997</year><volume>44</volume><fpage>24</fpage><lpage>34</lpage></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Helman</surname><given-names>D</given-names></name><name><surname>Ja'Ja'</surname><given-names>J</given-names></name><name><surname>Bader</surname><given-names>D</given-names></name></person-group><article-title>A new deterministic parallel sorting algorithm with an experimental evaluation</article-title><source>Journal of Experimental Algorithms</source><year>1998</year><volume>3</volume><fpage>4</fpage></citation></ref><ref id="B14"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Jackson</surname><given-names>B</given-names></name><name><surname>Aluru</surname><given-names>S</given-names></name></person-group><article-title>Parallel Construction of Bidirected String Graphs for Genome Assembly</article-title><source>Proceedings of the International Conference on Parallel Processsing</source><year>2008</year><fpage>346</fpage><lpage>353</lpage></citation></ref><ref id="B15"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sibeyn</surname><given-names>J</given-names></name><name><surname>Guillaume</surname><given-names>F</given-names></name><name><surname>Seidel</surname><given-names>T</given-names></name></person-group><article-title>Practical Parallel List Ranking</article-title><source>Journal of Parallel and Distributed Computing</source><year>1999</year><volume>56</volume><fpage>156</fpage><lpage>180</lpage></citation></ref><ref id="B16"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Dehne</surname><given-names>FKHA</given-names></name><name><surname>Song</surname><given-names>SW</given-names></name></person-group><article-title>Randomized Parallel List Ranking for Distributed Memory Multiprocessors</article-title><source>Asian Computing Science Conference</source><year>1996</year><fpage>1</fpage><lpage>10</lpage></citation></ref><ref id="B17"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Karp</surname><given-names>R</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Miller R, Thatcher J</surname></name></person-group><article-title>Reducibility Among Combinatorial Problems</article-title><source>Complexity and Computer Computations</source><year>1972</year><fpage>85</fpage><lpage>103</lpage></citation></ref><ref id="B18"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Motwani</surname><given-names>R</given-names></name><name><surname>Raghavan</surname><given-names>P</given-names></name></person-group><source>Randomized Algorithms</source><year>1995</year><publisher-name>New York, NY, USA: Cambridge Press</publisher-name></citation></ref></ref-list></back></article>