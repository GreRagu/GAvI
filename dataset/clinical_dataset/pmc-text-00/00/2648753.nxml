<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208165</article-id><article-id pub-id-type="pmc">2648753</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S61</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S61</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>On optimal comparability editing with applications to molecular diagnostics</article-title></title-group><contrib-group><contrib id="A1" equal-contrib="yes" contrib-type="author"><name><surname>B&#x000f6;cker</surname><given-names>Sebastian</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>boecker@minet.uni-jena.de</email></contrib><contrib id="A2" equal-contrib="yes" contrib-type="author"><name><surname>Briesemeister</surname><given-names>Sebastian</given-names></name><xref ref-type="aff" rid="I3">3</xref><email>briese@informatik.uni-tuebingen.de</email></contrib><contrib id="A3" equal-contrib="yes" corresp="yes" contrib-type="author"><name><surname>Klau</surname><given-names>Gunnar W</given-names></name><xref ref-type="aff" rid="I4">4</xref><email>gunnar.klau@cwi.nl</email></contrib></contrib-group><aff id="I1"><label>1</label>Institut f&#x000fc;r Informatik, Friedrich-Schiller-Universit&#x000e4;t, Jena, Germany</aff><aff id="I2"><label>2</label>Jena Centre for Bioinformatics, Jena, Germany</aff><aff id="I3"><label>3</label>Div. for Simulation of Biological Systems, ZBIT/WSI, Eberhard Karls Universit&#x000e4;t T&#x000fc;bingen, Germany</aff><aff id="I4"><label>4</label>CWI, P.O. Box 94079, 1090 GB Amsterdam, The Netherlands</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S61</fpage><lpage>S61</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S61"/><permissions><copyright-statement>Copyright &#x000a9; 2009 B&#x000f6;cker et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>B&#x000f6;cker et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               B&#x000f6;cker               Sebastian                                             boecker@minet.uni-jena.de            </dc:author><dc:title>            On optimal comparability editing with applications to molecular diagnostics         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S61-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S61&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>The C<sc>OMPARABILITY</sc> E<sc>DITING</sc> problem appears in the context of hierarchical disease classification based on noisy data. We are given a directed graph <italic>G </italic>representing hierarchical relationships between patient subgroups. The task is to identify the minimum number of edge insertions or deletions to transform <italic>G </italic>into a transitive graph, that is, if edges (<italic>u</italic>, <italic>v</italic>) and (<italic>v</italic>, <italic>w</italic>) are present then edge (<italic>u</italic>, <italic>w</italic>) must be present, too.</p></sec><sec><title>Results</title><p>We present two new approaches for the problem based on fixed-parameter algorithmics and integer linear programming. In contrast to previously used heuristics, our approaches compute provably optimal solutions.</p></sec><sec><title>Conclusion</title><p>Our computational results demonstrate that our exact algorithms are by far more efficient in practice than a previously used heuristic approach. In addition to the superior running time performance, our algorithms are capable of enumerating all optimal solutions, and naturally solve the weighted version of the problem.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>Jacob <italic>et al</italic>. [<xref ref-type="bibr" rid="B1">1</xref>] raise the following problem from molecular diagnostics: For a group of patients that share a disease, we have to assign each patient to a well-defined subgroup in a hierarchical classification scheme of sub-diseases, based on molecular characteristics of the patient [<xref ref-type="bibr" rid="B2">2</xref>]. Such characteristics can be measured using high-throughput genomic approaches such as gene expression microarrays or SNP arrays, and may be accompanied by other data such as fluorescent in situ hybridization. The task is to deduce the hierarchical structure in the integrated noisy data sets by an automated approach. To do so, Jacob <italic>et al</italic>. [<xref ref-type="bibr" rid="B1">1</xref>] proceed in two steps: First, hierarchical dependencies between patient subgroups are stored in a directed graph, where vertices correspond to experimental characteristics (properties), and a directed edge between two properties <italic>A </italic>and <italic>B </italic>indicates that patients with property <italic>A </italic>are a (noisy) superset of patients with property <italic>B</italic>. Constructing this graph is straightforward using basic concepts from statistics: for example, one can choose a threshold <italic>&#x003b1; </italic>&#x02208; [0, 1] and include an edge (<italic>A</italic>, <italic>B</italic>) if the ratio of patients with feature <italic>B </italic>that also exhibit feature <italic>A </italic>is greater or equal to <italic>&#x003b1; </italic>[<xref ref-type="bibr" rid="B1">1</xref>]. Parameter <italic>&#x003b1; </italic>can be used to scale the sparseness of the resulting graph.</p><p>The second step consists in <italic>cleaning </italic>the input graph: if property <italic>A </italic>is a superset for property <italic>B</italic>, and <italic>B </italic>is a superset for property <italic>C</italic>, then it is understood that <italic>A </italic>must also be a superset for property <italic>C</italic>.</p><p>Unfortunately, noise in the high-throughput data often leads to cases where edge (<italic>A</italic>, <italic>C</italic>) is not included during graph construction, even though edges (<italic>A</italic>, <italic>B</italic>) and (<italic>B</italic>, <italic>C</italic>) are present. From a graph-theoretical point of view, we require that for directed edges (<italic>u</italic>, <italic>v</italic>) and (<italic>v</italic>, <italic>w</italic>) present in the graph, also (<italic>u</italic>, <italic>w</italic>) has to be present. A graph that satisfies this property for all vertex triples is called <italic>transitive</italic>. If the input graph is not transitive, then it is natural to ask for the most parsimonious way to transform the input graph into a transitive graph, that is, the minimum number of edge modifications (insertions or deletions) such that the resulting graph is transitive. This problem is called <italic>transitive approximation </italic>[<xref ref-type="bibr" rid="B3">3</xref>] or C<sc>OMPARABILITY</sc> E<sc>DITING </sc>[<xref ref-type="bibr" rid="B4">4</xref>], and we stick with the latter term. Important problem variants include W<sc>EIGHTED</sc> C<sc>OMPARABILITY</sc> E<sc>DITING</sc> where each edge has individual modification costs, and enumerating <italic>all </italic>optimal solutions. Unfortunately, (weighted) C<sc>OMPARABILITY</sc> E<sc>DITING</sc> is <italic>NP</italic>-complete [<xref ref-type="bibr" rid="B4">4</xref>]. Recently, Jacob <italic>et al</italic>. have presented a heuristic approach for the problem [<xref ref-type="bibr" rid="B1">1</xref>].</p><p>The C<sc>OMPARABILITY</sc> E<sc>DITING</sc> problem is closely related to its undirected counterpart C<sc>LUSTER</sc> E<sc>DITING</sc>: Here, we are given an undirected graph as input, and our task is to find a set of edge modifications of minimum cardinality, such that the modified graph consists of disjoint cliques. This problem is also <italic>NP</italic>-complete [<xref ref-type="bibr" rid="B5">5</xref>]. To find exact solutions, we can formulate the problem as an integer linear program (ILP) and use a cutting plane approach for its solution [<xref ref-type="bibr" rid="B6">6</xref>]. Another way to find exact solutions for C<sc>LUSTER</sc> E<sc>DITING</sc> are fixed-parameter algorithms, using the number (or total cost) of edge modifications as parameter <italic>k </italic>[<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B8">8</xref>]. The currently fastest algorithms for C<sc>LUSTER</sc> E<sc>DITING</sc> use both the ILP formulation and fixed-parameter algorithmics and, despite the hardness of the problem, allow to efficiently solve instances with thousands of vertices [<xref ref-type="bibr" rid="B9">9</xref>].</p><sec><title>Our contributions</title><p>We have adopted both the ILP formulation and the fixed-parameter algorithms (FPT) developed for C<sc>LUSTER</sc> E<sc>DITING</sc> to work with its directed counterpart, C<sc>OMPARABILITY</sc> E<sc>DITING</sc>. Both approaches guarantee that <italic>exact </italic>solutions are found. In addition, FPT guarantees worst-case running times, with exponential dependency on the parameter <italic>k </italic>only. The ILP formulation is, in practice, several thousand-fold faster than the heuristics from [<xref ref-type="bibr" rid="B1">1</xref>] even for small instances with 25 vertices. Combining FPT data reduction and ILP to solve the remaining problem leads to best running times. Both FPT and ILP can enumerate all optimal solutions, and for FPT this is possible with almost no computational overhead. Both approaches also work for W<sc>EIGHTED</sc> C<sc>OMPARABILITY</sc> E<sc>DITING</sc>, which might lead to better solutions, for example, in the molecular diagnostics application: one might use the difference to the threshold <italic>&#x003b1; </italic>as modification cost of an edge, so that edges with measurements close to the threshold can be inserted or deleted cheaper than edges that deviate by a large extent from the threshold.</p></sec></sec><sec sec-type="methods"><title>Methods</title><sec><title>Preliminaries</title><p>Throughout this paper, let <italic>n </italic>:= |<italic>V</italic>|. We sometimes assume that <italic>V </italic>= {1, ..., <italic>n</italic>}. We write <italic>uv </italic>as shorthand for an ordered pair (<italic>u</italic>, <italic>v</italic>) &#x02208; <italic>V</italic><sup>2</sup>. For weighted instances, let <italic>s </italic>: <italic>V</italic><sup>2 </sup>&#x02192; &#x0211d; encode the input graph: For <italic>s</italic>(<italic>uv</italic>) &#x0003e; 0 a directed edge <italic>uv </italic>is present in the graph and has deletion cost <italic>s</italic>(<italic>uv</italic>), while for <italic>s</italic>(<italic>uv</italic>) &#x02264; 0 the edge <italic>uv </italic>is absent from the graph and has insertion cost -<italic>s</italic>(<italic>uv</italic>). An unweighted C<sc>OMPARABILITY</sc> E<sc>DITING</sc> instance can be encoded using <italic>s</italic>(<italic>uv</italic>) &#x02208; {&#x000b1; 1}. We call edges with <italic>s</italic>(<italic>uv</italic>) = &#x0221e; <italic>permanent </italic>and with <italic>s</italic>(<italic>uv</italic>) = -&#x0221e; <italic>forbidden</italic>. Let <italic>N</italic><sub>+</sub>(<italic>v</italic>) denote the <italic>successors </italic>of <italic>v</italic>, <italic>N</italic><sub>+</sub>(<italic>v</italic>) = {<italic>w </italic>&#x02208; <italic>V </italic>| <italic>s</italic>(<italic>vw</italic>) &#x0003e; 0}. Similarly, let <italic>N</italic><sub>-</sub>(<italic>v</italic>) denote the <italic>predecessors </italic>of <italic>v</italic>, <italic>N</italic><sub>-</sub>(<italic>v</italic>) = {<italic>u </italic>&#x02208; <italic>V </italic>| <italic>s</italic>(<italic>uv</italic>) &#x0003e; 0}.</p><p>A directed graph <italic>G </italic>= (<italic>V</italic>, <italic>E</italic>) is <italic>transitive </italic>if for any three vertices <italic>u</italic>, <italic>v</italic>, <italic>w </italic>&#x02208; <italic>V </italic>with <italic>uv </italic>&#x02208; <italic>E </italic>and <italic>vw </italic>&#x02208; <italic>E </italic>we also have <italic>uw </italic>&#x02208; <italic>E</italic>. Any three vertices violating this condition are called a <italic>conflict triple</italic>.</p></sec><sec><title>A fixed-parameter algorithm</title><p>The main idea behind many FPT graph modification algorithms is to localize and resolve forbidden substructures, either during preprocessing or in a search tree. In this paper, we transform any directed input graph <italic>G </italic>into a transitive graph by resolving all conflict triples. Our fixed-parameter algorithms sometimes require a maximum number of edge modifications <italic>k </italic>to be known in advance: To find an optimal solution we call this algorithm repeatedly, increasing <italic>k</italic>.</p><p>We first present methods for the data reduction of (unweighted and weighted) C<sc>OMPARABILITY</sc> E<sc>DITING</sc> instances. We describe polynomial-time reduction rules and apply these rules over and over again until no further rule will apply.</p><sec><title>Parameter-dependent data reduction</title><p>Our parameter-dependent data reduction is similar to that for C<sc>LUSTER</sc> E<sc>DITING</sc> in [<xref ref-type="bibr" rid="B8">8</xref>]. For every tuple <italic>uv </italic>we define induced costs <italic>icf </italic>(<italic>uv</italic>) and <italic>icp</italic>(<italic>uv</italic>) for marking <italic>uv </italic>as forbidden or permanent, respectively:</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S61-i1" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mtable columnalign="left">                                 <mml:mtr columnalign="left">                                    <mml:mtd columnalign="left">                                       <mml:mrow>                                          <mml:mi>i</mml:mi>                                          <mml:mi>c</mml:mi>                                          <mml:mi>f</mml:mi>                                          <mml:mo stretchy="false">(</mml:mo>                                          <mml:mi>u</mml:mi>                                          <mml:mi>v</mml:mi>                                          <mml:mo stretchy="false">)</mml:mo>                                       </mml:mrow>                                    </mml:mtd>                                    <mml:mtd columnalign="left">                                       <mml:mo>=</mml:mo>                                    </mml:mtd>                                    <mml:mtd columnalign="left">                                       <mml:mrow>                                          <mml:mstyle displaystyle="true">                                             <mml:munder>                                                <mml:mo>&#x02211;</mml:mo>                                                <mml:mrow>                                                   <mml:mi>x</mml:mi>                                                   <mml:mo>&#x02208;</mml:mo>                                                   <mml:msub>                                                      <mml:mi>N</mml:mi>                                                      <mml:mo>+</mml:mo>                                                   </mml:msub>                                                   <mml:mo stretchy="false">(</mml:mo>                                                   <mml:mi>u</mml:mi>                                                   <mml:mo stretchy="false">)</mml:mo>                                                   <mml:mo>&#x02229;</mml:mo>                                                   <mml:msub>                                                      <mml:mi>N</mml:mi>                                                      <mml:mo>&#x02212;</mml:mo>                                                   </mml:msub>                                                   <mml:mo stretchy="false">(</mml:mo>                                                   <mml:mi>v</mml:mi>                                                   <mml:mo stretchy="false">)</mml:mo>                                                </mml:mrow>                                             </mml:munder>                                             <mml:mrow>                                                <mml:mi>min</mml:mi>                                                <mml:mo>&#x02061;</mml:mo>                                                <mml:mo>{</mml:mo>                                                <mml:mi>s</mml:mi>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>u</mml:mi>                                                <mml:mi>x</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                                <mml:mo>,</mml:mo>                                                <mml:mi>s</mml:mi>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>x</mml:mi>                                                <mml:mi>v</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                                <mml:mo>}</mml:mo>                                             </mml:mrow>                                          </mml:mstyle>                                       </mml:mrow>                                    </mml:mtd>                                 </mml:mtr>                                 <mml:mtr columnalign="left">                                    <mml:mtd columnalign="left">                                       <mml:mrow>                                          <mml:mi>i</mml:mi>                                          <mml:mi>c</mml:mi>                                          <mml:mi>p</mml:mi>                                          <mml:mo stretchy="false">(</mml:mo>                                          <mml:mi>u</mml:mi>                                          <mml:mi>v</mml:mi>                                          <mml:mo stretchy="false">)</mml:mo>                                       </mml:mrow>                                    </mml:mtd>                                    <mml:mtd columnalign="left">                                       <mml:mo>=</mml:mo>                                    </mml:mtd>                                    <mml:mtd columnalign="left">                                       <mml:mrow>                                          <mml:mstyle displaystyle="true">                                             <mml:munder>                                                <mml:mo>&#x02211;</mml:mo>                                                <mml:mrow>                                                   <mml:mi>x</mml:mi>                                                   <mml:mo>&#x02208;</mml:mo>                                                   <mml:msub>                                                      <mml:mi>N</mml:mi>                                                      <mml:mo>&#x02212;</mml:mo>                                                   </mml:msub>                                                   <mml:mo stretchy="false">(</mml:mo>                                                   <mml:mi>u</mml:mi>                                                   <mml:mo stretchy="false">)</mml:mo>                                                   <mml:mo>\</mml:mo>                                                   <mml:msub>                                                      <mml:mi>N</mml:mi>                                                      <mml:mo>&#x02212;</mml:mo>                                                   </mml:msub>                                                   <mml:mo stretchy="false">(</mml:mo>                                                   <mml:mi>v</mml:mi>                                                   <mml:mo stretchy="false">)</mml:mo>                                                </mml:mrow>                                             </mml:munder>                                             <mml:mrow>                                                <mml:mi>min</mml:mi>                                                <mml:mo>&#x02061;</mml:mo>                                                <mml:mo>{</mml:mo>                                                <mml:mi>s</mml:mi>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>x</mml:mi>                                                <mml:mi>u</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                                <mml:mo>,</mml:mo>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mi>s</mml:mi>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>x</mml:mi>                                                <mml:mi>v</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                                <mml:mo>}</mml:mo>                                             </mml:mrow>                                          </mml:mstyle>                                       </mml:mrow>                                    </mml:mtd>                                 </mml:mtr>                                 <mml:mtr columnalign="left">                                    <mml:mtd columnalign="left">                                       <mml:mrow/>                                    </mml:mtd>                                    <mml:mtd columnalign="left">                                       <mml:mrow/>                                    </mml:mtd>                                    <mml:mtd columnalign="left">                                       <mml:mrow>                                          <mml:mo>+</mml:mo>                                          <mml:mstyle displaystyle="true">                                             <mml:munder>                                                <mml:mo>&#x02211;</mml:mo>                                                <mml:mrow>                                                   <mml:mi>y</mml:mi>                                                   <mml:mo>&#x02208;</mml:mo>                                                   <mml:msub>                                                      <mml:mi>N</mml:mi>                                                      <mml:mo>+</mml:mo>                                                   </mml:msub>                                                   <mml:mo stretchy="false">(</mml:mo>                                                   <mml:mi>v</mml:mi>                                                   <mml:mo stretchy="false">)</mml:mo>                                                   <mml:mo>\</mml:mo>                                                   <mml:msub>                                                      <mml:mi>N</mml:mi>                                                      <mml:mo>+</mml:mo>                                                   </mml:msub>                                                   <mml:mo stretchy="false">(</mml:mo>                                                   <mml:mi>u</mml:mi>                                                   <mml:mo stretchy="false">)</mml:mo>                                                </mml:mrow>                                             </mml:munder>                                             <mml:mrow>                                                <mml:mi>min</mml:mi>                                                <mml:mo>&#x02061;</mml:mo>                                                <mml:mo>{</mml:mo>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mi>s</mml:mi>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>u</mml:mi>                                                <mml:mi>y</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                                <mml:mo>,</mml:mo>                                                <mml:mi>s</mml:mi>                                                <mml:mo stretchy="false">(</mml:mo>                                                <mml:mi>v</mml:mi>                                                <mml:mi>y</mml:mi>                                                <mml:mo stretchy="false">)</mml:mo>                                                <mml:mo>}</mml:mo>                                             </mml:mrow>                                          </mml:mstyle>                                       </mml:mrow>                                    </mml:mtd>                                 </mml:mtr>                              </mml:mtable>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>We use these values and also take into account costs for inserting or deleting <italic>uv</italic>:</p><p>&#x02022; For all <italic>u</italic>, <italic>v </italic>&#x02208; <italic>V </italic>where</p><p><disp-formula><italic>icf</italic>(<italic>uv</italic>) + max{0, <italic>s</italic>(<italic>uv</italic>)} &#x0003e; <italic>k </italic>:</disp-formula></p><p>Insert <italic>uv </italic>if necessary, and mark <italic>uv </italic>as permanent by assigning <italic>s</italic>(<italic>uv</italic>) &#x02190; +&#x0221e;.</p><p>&#x02022; For all <italic>u</italic>, <italic>v </italic>&#x02208; <italic>V </italic>where</p><p><disp-formula><italic>icp</italic>(<italic>uv</italic>) + max{0, -<italic>s</italic>(<italic>uv</italic>)} &#x0003e; <italic>k </italic>:</disp-formula></p><p>Delete <italic>uv </italic>if necessary, and mark <italic>uv </italic>as forbidden by assigning <italic>s</italic>(<italic>uv</italic>) &#x02190; -&#x0221e;.</p><p>If there is a pair <italic>uv </italic>such that both conditions hold simultaneously, the problem instance is not solvable. To understand these rules, assume that an edge <italic>uv </italic>is <italic>not </italic>present in an optimal solution. Then, for edges <italic>ux </italic>and <italic>xv </italic>present in the input, either <italic>ux </italic>or <italic>xv </italic>(or potentially both) have to be deleted to make the graph transitive.</p><p>Clearly, we can also remove isolated vertices and edges. Unfortunately, we are currently not able to give a problem kernel for C<sc>OMPARABILITY</sc> E<sc>DITING</sc>: A <italic>problem kernel </italic>is a set of reduction rules so that after exhaustive application of the rules, the remaining instance has size polynomial in the parameter <italic>k </italic>and independent of the original problem size <italic>n </italic>[<xref ref-type="bibr" rid="B10">10</xref>]. Our reduction rules are obviously not a problem kernel, because we never reduce the number of vertices in the graph except when vertices or edges become isolated. Constructing a problem kernel remains an interesting open problem.</p><p>If both <italic>uv </italic>and <italic>vu </italic>are permanent, we can <italic>merge </italic>vertices <italic>u</italic>, <italic>v </italic>into a new vertex <italic>u</italic>': For each vertex <italic>w </italic>&#x02208; <italic>V </italic>\{<italic>u</italic>, <italic>v</italic>} we join <italic>uw</italic>, <italic>vw </italic>such that <italic>s</italic>(<italic>u</italic>'<italic>w</italic>) &#x02190; <italic>s</italic>(<italic>uw</italic>) + <italic>s</italic>(<italic>vw</italic>). Moreover, in case <italic>w </italic>is a non-common neighbor of <italic>u</italic>, <italic>v </italic>we can reduce <italic>k </italic>by min{|<italic>s</italic>(<italic>uw</italic>)|,|<italic>s</italic>(<italic>vw</italic>)|}. But it almost never happens in application that both <italic>uv </italic>and <italic>vu </italic>are permanent simultaneously, so this technique can rarely be applied. In particular, if the input graph is acyclic then no vertices will ever be merged.</p></sec><sec><title>Algorithm engineering and parameter-independent data reduction</title><p>First, we describe a fast method to compute a lower bound on the cost of W<sc>EIGHTED</sc> C<sc>OMPARABILITY</sc> E<sc>DITING</sc>: Let <italic>CT </italic>be a set of edge-disjoint conflict triples. Then,</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S61-i2" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mstyle displaystyle="true">                                 <mml:munder>                                    <mml:mo>&#x02211;</mml:mo>                                    <mml:mrow>                                       <mml:mi>u</mml:mi>                                       <mml:mi>v</mml:mi>                                       <mml:mi>w</mml:mi>                                       <mml:mo>&#x02208;</mml:mo>                                       <mml:mi>C</mml:mi>                                       <mml:mi>T</mml:mi>                                    </mml:mrow>                                 </mml:munder>                                 <mml:mrow>                                    <mml:mi>min</mml:mi>                                    <mml:mo>&#x02061;</mml:mo>                                    <mml:mo>{</mml:mo>                                    <mml:mi>s</mml:mi>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>u</mml:mi>                                    <mml:mi>v</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                    <mml:mo>,</mml:mo>                                    <mml:mi>s</mml:mi>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>v</mml:mi>                                    <mml:mi>w</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                    <mml:mo>,</mml:mo>                                    <mml:mo>&#x02212;</mml:mo>                                    <mml:mi>s</mml:mi>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>u</mml:mi>                                    <mml:mi>w</mml:mi>                                    <mml:mo stretchy="false">)</mml:mo>                                    <mml:mo>}</mml:mo>                                 </mml:mrow>                              </mml:mstyle>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>is a lower bound for solving all conflict triples in <italic>CT </italic>. Since finding the set <italic>CT </italic>maximizing this value is computationally expensive, we greedily construct a set of edge-disjoint conflict triples <italic>CT </italic>and use the above sum as a lower bound. We can use such lower bounds to make induced costs <italic>icf </italic>(<italic>uv</italic>) and <italic>icp</italic>(<italic>uv</italic>) tighter: let <italic>b</italic>(<italic>G</italic>, <italic>uv</italic>) be a lower bound that ignores all edges <italic>uw</italic>, <italic>wu</italic>, <italic>vw</italic>, and <italic>wv </italic>in its computation, for all <italic>w </italic>&#x02208; <italic>V </italic>\{<italic>u</italic>, <italic>v</italic>}. Then, we can set an edge to forbidden or permanent if</p><p><disp-formula><italic>icp</italic><sub>*</sub>(<italic>uv</italic>) := <italic>icp</italic>(<italic>uv</italic>) + max{0, -<italic>s</italic>(<italic>uv</italic>)} + <italic>b</italic>(<italic>G</italic>, <italic>uv</italic>) &#x0003e; <italic>k</italic></disp-formula></p><p>or</p><p><disp-formula><italic>icf</italic><sub>*</sub>(<italic>uv</italic>) := <italic>icf</italic>(<italic>uv</italic>) + max{0, <italic>s</italic>(<italic>uv</italic>)} + <italic>b</italic>(<italic>G</italic>, <italic>uv</italic>) &#x0003e; <italic>k</italic></disp-formula></p><p>holds, respectively.</p><p>We now utilize an idea from [<xref ref-type="bibr" rid="B9">9</xref>] to transform the above parameter-dependent data reduction into a parameter-independent one. Therefore we use an <italic>upper bound </italic>for the modification costs of <italic>G </italic>as our parameter <italic>k</italic>. Without the knowledge of a current parameter both parameter-dependent data reduction rules can now be applied during the preprocessing. To calculate the upper bound we use a greedy approach that iteratively searches for edges where reduction rules almost apply. In detail, we search for an edge <italic>uv </italic>such that max{<italic>icp</italic><sub>*</sub>(<italic>uv</italic>), <italic>icf</italic><sub>*</sub>(<italic>uv</italic>)} is maximum and set <italic>uv </italic>to forbidden or permanent, respectively. Note that we can use any other upper bound for this reduction as well. The combination of lower and upper bounds makes this reduction very effective in application.</p><p>In our preprocessing, we mark an edge as permanent or forbidden when we can guarantee that this edge is always or never part of an optimal solution, respectively. This will usually not reduce the size of the instance. However, we will see in the section devoted to our computational results that in practice, adding information about permanent and forbidden edges makes it easier to solve the remaining instance. Note that we can process the reduced instance with <italic>any </italic>exact method or even heuristics.</p></sec><sec><title>Branching strategy</title><p>After parameter-independent data reduction, the remaining instance can be solved using a branching tree strategy. In such algorithms, we identify a conflict triple and then branch into sub-cases to repair this conflict. Let <italic>uvw </italic>be a conflict triple so that <italic>uv </italic>and <italic>vw </italic>are edges but <italic>uw </italic>is not. Recursively branch into three cases:</p><p>1. Insert <italic>uw</italic>, mark <italic>uv</italic>, <italic>uw</italic>, and <italic>vw </italic>as permanent.</p><p>2. Delete <italic>uv</italic>, mark <italic>vw </italic>as permanent, and <italic>uv </italic>and <italic>uw </italic>as forbidden.</p><p>3. Delete <italic>vw</italic>, mark <italic>vw </italic>as forbidden.</p><p>In each branch, we lower <italic>k </italic>by the insertion or deletion cost required for the executed operation. When a connected component decomposes into two components, we calculate the optimum solutions for these components separately. If <italic>k </italic>falls below zero, we discard the respective branch of the algorithm. Keeping in mind that we can find a conflict triple in time <italic>O</italic>(<italic>n</italic><sup>3</sup>), the branching algorithm has running time <italic>O</italic>(3<sup><italic>k</italic></sup>&#x000b7;<italic>n</italic><sup>3</sup>). Unfortunately, we cannot replace the polynomial factor by a summand because no polynomial-size problem kernel is known for the problem.</p><p>As an algorithm engineering technique, we do not process conflict triples in an arbitrary order but instead, choose that conflict triple <italic>uvw </italic>such that <italic>icp</italic>(<italic>uv</italic>) + <italic>icp</italic>(<italic>vw</italic>) + <italic>icf</italic>(<italic>uw</italic>) is maximal. Doing so, we choose a triple that results in a comparatively small branching number while avoiding the time-consuming exact computation of branching numbers. The branching number is the root of the characteristic polynomial of the branching vector and governs the asymptotic size of the search tree, see again [<xref ref-type="bibr" rid="B10">10</xref>] for details. To find an optimal solution we call the algorithm repeatedly, increasing <italic>k </italic>in an interval defined by lower and upper bound for this problem instance. While traversing the search tree, we apply reduction rules in every recursion step. Clearly, lower bounds as described in the section on parameter-independent data reduction, can also be used to stop search tree recursion more efficiently.</p><p>It is understood that our algorithm can also enumerate all optimal solutions, by completely traversing the search tree.</p></sec></sec><sec><title>An integer linear programming approach</title><p>Let <italic>x </italic>be a binary decision vector with <italic>x</italic><sub><italic>ij </italic></sub>= 1 if directed edge (<italic>i</italic>, <italic>j</italic>) is part of the solution and <italic>x</italic><sub><italic>ij </italic></sub>= 0 otherwise. Then, an optimal solution to W<sc>EIGHTED</sc> C<sc>OMPARABILITY</sc> E<sc>DITING</sc> can be found by solving</p><p><disp-formula id="bmcM1"><label>(1)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S61-i3" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>min</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munder>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>i</mml:mi>                                    <mml:mi>j</mml:mi>                                    <mml:mo>&#x02208;</mml:mo>                                    <mml:mi>E</mml:mi>                                 </mml:mrow>                              </mml:munder>                              <mml:mrow>                                 <mml:mi>s</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>i</mml:mi>                                 <mml:mi>j</mml:mi>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:mstyle displaystyle="true">                                    <mml:munderover>                                       <mml:mo>&#x02211;</mml:mo>                                       <mml:mrow>                                          <mml:mi>i</mml:mi>                                          <mml:mo>=</mml:mo>                                          <mml:mn>1</mml:mn>                                       </mml:mrow>                                       <mml:mi>n</mml:mi>                                    </mml:munderover>                                    <mml:mrow>                                       <mml:mstyle displaystyle="true">                                          <mml:munderover>                                             <mml:mo>&#x02211;</mml:mo>                                             <mml:mrow>                                                <mml:mi>j</mml:mi>                                                <mml:mo>=</mml:mo>                                                <mml:mn>1</mml:mn>                                             </mml:mrow>                                             <mml:mi>n</mml:mi>                                          </mml:munderover>                                          <mml:mrow>                                             <mml:mi>s</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:mi>i</mml:mi>                                             <mml:mi>j</mml:mi>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:msub>                                                <mml:mi>x</mml:mi>                                                <mml:mrow>                                                   <mml:mi>i</mml:mi>                                                   <mml:mi>j</mml:mi>                                                </mml:mrow>                                             </mml:msub>                                          </mml:mrow>                                       </mml:mstyle>                                    </mml:mrow>                                 </mml:mstyle>                              </mml:mrow>                           </mml:mstyle>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p><disp-formula id="bmcM2"><label>(2)</label>s. t. <italic>x</italic><sub><italic>ij </italic></sub>+ <italic>x</italic><sub><italic>jk </italic></sub>- <italic>x</italic><sub><italic>ik </italic></sub>&#x02264; 1&#x000a0;&#x000a0;&#x000a0;&#x02200;1 &#x02264; <italic>i</italic>, <italic>j</italic>, <italic>k </italic>&#x02264; <italic>n</italic></disp-formula></p><p><disp-formula id="bmcM3"><label>(3)</label><italic>x</italic><sub><italic>ij </italic></sub>= 0&#x000a0;&#x000a0;&#x000a0;&#x02200;<italic>ij </italic>with <italic>s</italic>(<italic>ij</italic>) = -&#x0221e;</disp-formula></p><p><disp-formula id="bmcM4"><label>(4)</label><italic>x</italic><sub><italic>ij </italic></sub>= 1&#x000a0;&#x000a0;&#x000a0;&#x02200;<italic>ij </italic>with <italic>s</italic>(<italic>ij</italic>) = &#x0221e;</disp-formula></p><p><disp-formula id="bmcM5"><label>(5)</label><italic>x</italic><sub><italic>ij </italic></sub>&#x02208; {0, 1}&#x000a0;&#x000a0;&#x000a0;&#x02200;1 &#x02264; <italic>i</italic>, <italic>j </italic>&#x02264; <italic>n</italic>.</disp-formula></p><p>The <italic>n</italic><sup>3 </sup><italic>triangle inequalities </italic>(2) of the ILP ensure that no conflict triple as shown in Fig. <xref ref-type="fig" rid="F1">1(a)</xref> occurs in the solution and model exactly the definition of transitivity. Equations (3) and (4) exclude forbidden edges and force permanent edges to be part of the solution.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>The integer linear programming approach</bold>. (a) Conflict triple, (b) small example instance of W<sc>EIGHTED</sc> C<sc>OMPARABILITY</sc> E<sc>DITING</sc>, and (c) corresponding integer linear program. Solid edges are present in the graphs, dashed edges are absent. Edges missing from the complete directed graph in (b) have zero weight.</p></caption><graphic xlink:href="1471-2105-10-S1-S61-1"/></fig><p>Let <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S61-i4" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> be a feasible solution of the ILP and let <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S61-i5" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> be the corresponding edge set. It is easy to see that the graph <italic>G </italic>= (<italic>V</italic>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S61-i5" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>) is transitive. The objective function properly sums up the deletion and insertion costs as detailed by Table <xref ref-type="table" rid="T1">1</xref>.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p> Deletion and insertion costs used in the objective function of the ILP approach.</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center"><italic>ij </italic>&#x02208; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S61-i5" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula></td><td align="center"><italic>ij </italic>&#x02209; <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S61-i5" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula></td></tr></thead><tbody><tr><td align="left">(<italic>i</italic>, <italic>j</italic>) &#x02208; <italic>E</italic></td><td align="center"><italic>s</italic>(<italic>ij</italic>) - <italic>s</italic>(<italic>ij</italic>) = 0</td><td align="center"><italic>s</italic>(<italic>ij</italic>) - 0 &#x0003e; 0</td></tr><tr><td align="left">(<italic>i</italic>, <italic>j</italic>) &#x02209; <italic>E</italic></td><td align="center">-<italic>s</italic>(<italic>ij</italic>) &#x0003e; 0</td><td align="center">0</td></tr></tbody></table></table-wrap><p>Thus, an optimal solution of the ILP corresponds to an optimal solution of W<sc>EIGHTED</sc> C<sc>OMPARABILITY</sc> E<sc>DITING</sc>. Figures <xref ref-type="fig" rid="F1">1(b)</xref> and <xref ref-type="fig" rid="F1">1(c)</xref> show a small example instance of the problem and the corresponding ILP. The ILP formulation basically describes the partial order polytope of a complete directed graph.</p><p>M&#x000fc;ller [<xref ref-type="bibr" rid="B11">11</xref>] has investigated the facial structure of partial order polytopes and his results on facet-defining inequalities and their separation can directly be used to develop an effective branch-and-cut algorithm for W<sc>EIGHTED</sc> C<sc>OMPARABILITY</sc> E<sc>DITING</sc>:</p><p>We start optimizing the LP relaxation (1) with an empty constraint set. Let <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S61-i4" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> denote the vector corresponding to an intermediate solution of the linear programming relaxation. We first check whether <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S61-i4" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> violates any triangle inequalities. If this is the case, we add the violated inequalities, resolve, and iterate. Otherwise, we check whether <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S61-i4" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> is integral. If so, we stop, and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S61-i4" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> is an optimal solution. If, however, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-S1-S61-i4" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x000af;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> has fractional entries, we may separate additional facet-defining inequalities. M&#x000fc;ller proposes to focus on <italic>odd closed walk inequalities </italic>and presents an efficient separation algorithm in [<xref ref-type="bibr" rid="B11">11</xref>]. If we find cutting planes in the separation procedure we iterate, otherwise we branch. Applying the cutting plane method at each node of the branch-and-bound tree leads to a <italic>branch-and-cut algorithm</italic>.</p><p>Note that in our current implementation we have not yet realized additional cutting planes because separating triangle inequalities proved to be sufficient for the tested instance sizes. Once larger or more complicated instances have to be dealt with, the separation of odd closed walk inequalities seems to be a promising direction to approach new orders of magnitude in instance size.</p><p>To enumerate solutions with the ILP approach, we propose the following, straightforward iterative cutting plane approach. Cutting of a given solution <italic>x</italic>*, as done in line 3 of the algorithm, can be realized by adding inequality</p><p><disp-formula id="bmcM6"><label>(6)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-10-S1-S61-i6" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mstyle displaystyle="true">                              <mml:munder>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>i</mml:mi>                                    <mml:mo>|</mml:mo>                                    <mml:msubsup>                                       <mml:mi>x</mml:mi>                                       <mml:mi>i</mml:mi>                                       <mml:mo>&#x02217;</mml:mo>                                    </mml:msubsup>                                    <mml:mo>=</mml:mo>                                    <mml:mn>0</mml:mn>                                 </mml:mrow>                              </mml:munder>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>x</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                              </mml:mrow>                           </mml:mstyle>                           <mml:mo>+</mml:mo>                           <mml:mstyle displaystyle="true">                              <mml:munder>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>i</mml:mi>                                    <mml:mo>|</mml:mo>                                    <mml:msubsup>                                       <mml:mi>x</mml:mi>                                       <mml:mi>i</mml:mi>                                       <mml:mo>&#x02217;</mml:mo>                                    </mml:msubsup>                                    <mml:mo>=</mml:mo>                                    <mml:mn>1</mml:mn>                                 </mml:mrow>                              </mml:munder>                              <mml:mrow>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:msub>                                    <mml:mi>x</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mo>&#x02265;</mml:mo>                                 <mml:mn>0</mml:mn>                              </mml:mrow>                           </mml:mstyle>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>1 find first optimal solution <italic>x</italic>* with value <italic>z</italic><sub>0 </sub>= <italic>z</italic>*;</p><p>2 <bold>repeat</bold></p><p>3&#x000a0;&#x000a0;&#x000a0;add cutting plane (6) which cuts off <italic>x</italic>*;</p><p>4&#x000a0;&#x000a0;&#x000a0;find next optimal solution <italic>x</italic>* with value <italic>z</italic>*;</p><p>5 <bold>until </bold><italic>z</italic>* &#x0003e; <italic>z</italic><sub>0 </sub><italic>or ILP infeasible </italic>;</p></sec></sec><sec><title>Results and discussion</title><p>We evaluate the performance of our algorithms on three datasets. First, Jacob <italic>et al</italic>. [<xref ref-type="bibr" rid="B1">1</xref>] synthetically created graphs for a fixed number of nodes <italic>n </italic>and an edge probability <italic>p</italic>. Two vertices <italic>u</italic>, <italic>v </italic>&#x02208; <italic>V </italic>:= {1, ..., <italic>n</italic>} with <italic>u </italic>&#x0003c;<italic>v </italic>are connected by a directed edge (<italic>u</italic>, <italic>v</italic>) with probability <italic>p</italic>. For each combination of <italic>n </italic>&#x02208; {10, 15, 20, 25} and <italic>p </italic>&#x02208; {0.1, 0.2, ..., 0.9} they generated 20 graphs. On average, these graphs are most distant from the transitive state for <italic>p </italic>= 0.5.</p><p>Second, we generated a dataset of larger graphs. We defined these graphs by the number of nodes <italic>n </italic>and the number of edge changes <italic>k</italic>. Initially, we generate a transitive graph that has <italic>n </italic>nodes <italic>V </italic>:= {1, ..., <italic>n</italic>} and contains all <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-10-S1-S61-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> directed edges of the form (<italic>u</italic>, <italic>v</italic>) for <italic>u </italic>&#x0003c;<italic>v</italic>. Next, we choose <italic>k </italic>distinct vertex tuples <italic>uv </italic>&#x02208; <italic>V</italic><sup>2 </sup>and delete or insert the corresponding edges. The resulting graph has distance at most <italic>k </italic>to a transitive graph.</p><p>Third, we also evaluate our algorithms on the biological dataset from [<xref ref-type="bibr" rid="B1">1</xref>], which results from an extensive study with patients suffering from mature aggressive lymphomas. Here, we demonstrate that the FPT approach can enumerate all optimal instances in short computation time.</p><sec><title>Performance of reduction rules</title><p>Combining FPT reduction rules with upper and lower bounds allows us to reduce input graphs in advance. In contrast to the C<sc>LUSTER </sc>E<sc>DITING </sc>problem this will usually not reduce the graph size. However, we can mark some edges in the graph as permanent or forbidden. We measure the reduction ratio by estimating the real modification costs using the mean of upper and lower bound. The <italic>reduction ratio </italic>is defined as <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1471-2105-10-S1-S61-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mtext>reduced</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mtext>original</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>, where <italic>costs</italic><sub>original </sub>and <italic>costs</italic><sub>reduced </sub>are the estimated modification costs before and after the reduction. Table <xref ref-type="table" rid="T2">2</xref> shows that reduction of the first artificial dataset is less effective for edge probabilities around <italic>p </italic>&#x02248; 0.5. We attribute this to the fact that graphs with <italic>p </italic>&#x02248; 0.5 are almost random and have strong local defects, whereas other graphs are closer to the transitive state. Average running times for the reduction are between 4 ms for graphs with 10 vertices, and 95 ms for 25 vertices.</p><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Reduction ratios for artificial data by Jacob et al. Average reduction ratio for different edge probabilities. Each group contains 80 instances.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">edge probability</td><td align="center">0.1</td><td align="center">0.2</td><td align="center">0.3</td><td align="center">0.4</td><td align="center">0.5</td><td align="center">0.6</td><td align="center">0.7</td><td align="center">0.8</td><td align="center">0.9</td></tr></thead><tbody><tr><td align="left">avg. reduction ratio</td><td align="center">0.33</td><td align="center">0.20</td><td align="center">0.08</td><td align="center">0.05</td><td align="center">0.03</td><td align="center">0.15</td><td align="center">0.24</td><td align="center">0.21</td><td align="center">0.74</td></tr></tbody></table></table-wrap><p>Our data reduction reduces graphs even more effectively if they are large and close to the transitive state. Using the second artificial dataset, we found that if the ratio <italic>k</italic>/<italic>n </italic>is less than 3, our reduction achieves a reduction ratio of 98.5%. This is in fact very promising for biological data since here, input graphs are usually close to the transitive state. Average running times for the reduction are between 4.1 s for graphs with 100 vertices, and 5.9 min for large graphs with 500 vertices.</p></sec><sec><title>Artificial data by Jacob et al</title><p>We compare the running times of our exact FPT and ILP algorithms to the running times of the heuristic algorithm of Jacob <italic>et al</italic>. [<xref ref-type="bibr" rid="B1">1</xref>]. The reader should keep in mind that both our algorithms <italic>guarantee </italic>to find optimal solutions. Figure <xref ref-type="fig" rid="F2">2</xref> shows running times for different graph sizes. Clearly, the performance of the algorithms differs significantly. Running times of the heuristic approach continually increase with greater edge probability. In contrast, our FPT and ILP algorithms show highest running times for the most "complicated" graphs with edge probability around 0.5. Clearly, running times of all three algorithms increase for larger graph size. The ILP algorithm outperforms the other two algorithms for graphs with more than 10 nodes by several orders of magnitude and computes provably optimal solutions for all instances in less than a second. The FPT algorithm shows good performance for nearly transitive graphs and solves them in less than an hour. Table <xref ref-type="table" rid="T3">3</xref> shows some detailed running times.</p><table-wrap position="float" id="T3"><label>Table 3</label><caption><p>Runtimes for artificial data by Jacob et al. Average runtimes of the heuristic approach of Jacob et al. [<xref ref-type="bibr" rid="B1">1</xref>], the FPT algorithm, and the ILP approach. (*) The FPT algorithm was not able to solve 17 instances of size 25 with edge probability 0.5 within 7 days of computation.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">size</td><td align="center" colspan="3">10</td><td align="center" colspan="3">25</td></tr><tr><td align="left">edge probability</td><td align="center">0.2</td><td align="center">0.5</td><td align="center">0.8</td><td align="center">0.2</td><td align="center">0.5</td><td align="center">0.8</td></tr></thead><tbody><tr><td align="left">avg. cost</td><td align="center">2.35</td><td align="center">6.15</td><td align="center">5.95</td><td align="center">20.2</td><td align="center">60.5</td><td align="center">46.6</td></tr><tr><td align="left">time Jacob <italic>et al</italic>.</td><td align="center">&#x0003c; 0.2 s</td><td align="center">&#x0003c; 0.2 s</td><td align="center">&#x0003c; 0.2 s</td><td align="center">2.95 h</td><td align="center">12.2 h</td><td align="center">30.4 h</td></tr><tr><td align="left">time FPT</td><td align="center">4 ms</td><td align="center">7 ms</td><td align="center">5 ms</td><td align="center">209 ms</td><td align="center">12.2 h*</td><td align="center">5.9 min</td></tr><tr><td align="left">time ILP</td><td align="center">&#x0003c; 0.5 ms</td><td align="center">1.5 ms</td><td align="center">0.5 ms</td><td align="center">2 ms</td><td align="center">0.65 s</td><td align="center">30 ms</td></tr></tbody></table></table-wrap><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Artificial data by Jacob et al</bold>. Performance of the heuristic approach of Jacob <italic>et al.</italic>, the FPT algorithm, and the ILP approach.</p></caption><graphic xlink:href="1471-2105-10-S1-S61-2"/></fig><p>Most graphs derived from real-world data are almost transitive. This is due to the fact that the "true" graph is known to be transitive but the input graph suffers from some noise in the data. Our second benchmark set of larger artificial graphs accommodates this aspect, and we compare FPT and ILP on this dataset. To allow for a fair comparison, we first apply our data reduction preprocessing, and solve the reduced instances with FPT branching and the ILP algorithm. Figure <xref ref-type="fig" rid="F3">3</xref> shows the running times of all three approaches. All approaches can solve large instances with up to 1 500 edge modifications in a matter of minutes. Again, performance of the ILP approach strongly depends on the graph size and less pronounced on the number of modifications. The opposite can be observed for the FPT algorithm. Since the benchmark set contains large graphs with moderate modification costs, the FPT algorithm outperforms the ILP algorithm on this data. However, in case we use our data reduction in advance, running time of the combined FPT-ILP approach is significantly smaller than those of both algorithms and shows the best overall performance. Our results indicate that both algorithms are suitable for even larger graphs.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>Larger artificial data</bold>. Average runtimes of the FPT algorithm, the ILP approach, and the ILP approach on preprocessed instances.</p></caption><graphic xlink:href="1471-2105-10-S1-S61-3"/></fig></sec><sec><title>Lymphoma dataset</title><p>Finally, we run the FPT algorithm on the data on mature aggressive B-cell lymphoma from Jacob <italic>et al</italic>. and enumerate all optimal solutions. This results in twelve optimal solutions shown in Fig. <xref ref-type="fig" rid="F4">4</xref>. All optimal solutions were enumerated in only 25 ms. In contrast, Jacob <italic>et al</italic>. [<xref ref-type="bibr" rid="B1">1</xref>] report only six optimal solutions that were found by their heuristic.</p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>Lymphoma dataset from </bold>[<xref ref-type="bibr" rid="B1">1</xref>]<bold> (mature aggressive B-cell lymphoma)</bold>. All twelve optimal solutions enumerated in 25 ms with the FPT approach. The node numbers correspond to the molecular characteristics given in Table <xref ref-type="table" rid="T4">4</xref>.</p></caption><graphic xlink:href="1471-2105-10-S1-S61-4"/></fig><table-wrap position="float" id="T4"><label>Table 4</label><caption><p>Lymphoma dataset from [<xref ref-type="bibr" rid="B1">1</xref>] (mature aggressive B-cell lymphoma). Mapping of node numbers in Figure 4, the abbreviations used in [<xref ref-type="bibr" rid="B1">1</xref>], and the molecular characteristics.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">node nr</td><td align="left">abbrev. in Jacob <italic>et al</italic>.</td><td align="left">molecular characteristic</td></tr></thead><tbody><tr><td align="left">1</td><td align="left">CD10</td><td align="left">Antibodies for biomarker CD10 are present in histological section of lymphoma tissue</td></tr><tr><td align="left">2</td><td align="left">Ki-67</td><td align="left">Antibodies for biomarker Ki-67 are present in histological section of lymphoma tissue</td></tr><tr><td align="left">3</td><td align="left">CD5</td><td align="left">Antibodies for biomarker CD5 are present in histological section of lymphoma tissue</td></tr><tr><td align="left">4</td><td align="left">bcl6BR</td><td align="left">Breakpoint in the BCL6 locus</td></tr><tr><td align="left">5</td><td align="left">IGH-BCL2</td><td align="left">Fusion of BCL locus to immunoglobulin IGH</td></tr><tr><td align="left">6</td><td align="left">ABC</td><td align="left">Gene expression profile similar to activated B-cells</td></tr><tr><td align="left">7</td><td align="left">GCB</td><td align="left">Gene expression profile similar to germinal center B-cells</td></tr><tr><td align="left">8</td><td align="left">mBL</td><td align="left">Gene expression signature which characterices molecular Burkitt lymphoma (Hummel <italic>et al</italic>.)</td></tr><tr><td align="left">9</td><td align="left">non-mBL</td><td align="left">Absent gene expression signature non-mBL.</td></tr><tr><td align="left">10</td><td align="left">IG-MYC</td><td align="left">Translocation of MYC locus involving fusion of MYC to immunoglobulins IGH, IGK or IGL</td></tr><tr><td align="left">11</td><td align="left">atyp.myc</td><td align="left">Breakpoint in the MYC locus without fusion to an immunoglobulin</td></tr><tr><td align="left">12</td><td align="left">MYC-</td><td align="left">No abberation of the MYC locus</td></tr><tr><td align="left">13</td><td align="left">CD10-</td><td align="left">Antibodies for biomarker CD10 are absent in histological section of lymphoma tissue</td></tr><tr><td align="left">14</td><td align="left">Ki-67-</td><td align="left">Antibodies for biomarker Ki-67 are absent in histological section of lymphoma tissue</td></tr><tr><td align="left">15</td><td align="left">CD5-</td><td align="left">Antibodies for biomarker CD5 are absent in histological section of lymphoma tissue</td></tr><tr><td align="left">16</td><td align="left">bcl6BR-</td><td align="left">No breakpoint in the BCL6 locus</td></tr><tr><td align="left">17</td><td align="left">IGH-BCL2-</td><td align="left">No fusion of BCL locus to immunoglobulin IGH</td></tr></tbody></table></table-wrap></sec></sec><sec><title>Conclusions and outlook</title><p>We have studied the W<sc>EIGHTED</sc> C<sc>OMPARABILITY</sc> E<sc>DITING</sc> problem and have presented two exact algorithms for its solution. Our experimental results demonstrate that the exact approaches significantly outperform the heuristic approach proposed in [<xref ref-type="bibr" rid="B1">1</xref>]. In addition to the superior running time performance, our algorithms are capable of enumerating all optimal solutions, and naturally solve the weighted version of the problem.</p><p>In the future we plan to implement the full cutting plane approach including the odd closed walk inequalities proposed by M&#x000fc;ller [<xref ref-type="bibr" rid="B11">11</xref>] and expect an even better performance behavior of the ILP approach. On the FPT side, constructing a problem kernel remains an interesting open problem. Further, we want to study the weighted problem variant more intensively, since weighted directed graphs seem to be more realistic models of molecular properties than unweighted ones. Labeling edges of molecular graphs with probabilities or log-likelihoods may lead to fewer and medically more meaningful optimal solutions and may also help to distinguish good solutions from false positive transformations. Finally, a more precise ranking of multiple (optimal and non-optimal) solutions might prove beneficial for the interpretation of results, and also hints on the "reliability" of edges. Clearly, detecting hierarchical relationships in noisy data may have applications that go beyond hierarchical disease classification.</p><p>The source code of our reduction and comparability editing tools, as well as the data used in this article is publicly available as the charles package of the open software library planet-lisa [<xref ref-type="bibr" rid="B12">12</xref>]. Furthermore, we plan to implement a web interface for our tools in order to give a large community access to our exact clustering and comparability editing tools and to facilitate comparison and evaluation.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>SB&#x000f6;, SBr, and GWK jointly conducted the research, performed the experiments, and wrote the paper.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>We thank Rainer Spang's group in Regensburg and, in particular, Juby Jacob for providing us with the data from [<xref ref-type="bibr" rid="B1">1</xref>]. SBr gratefully acknowledges financial support from LGFG Promotionsverbund "Pflanzliche Sensorhistidinkinasen" at the University of T&#x000fc;bingen.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jacob</surname><given-names>J</given-names></name><name><surname>Jentsch</surname><given-names>M</given-names></name><name><surname>Kostka</surname><given-names>D</given-names></name><name><surname>Bentink</surname><given-names>S</given-names></name><name><surname>Spang</surname><given-names>R</given-names></name></person-group><article-title>Detecting hierarchical structure in molecular characteristics of disease using transitive approximations of directed graphs</article-title><source>Bioinformatics</source><year>2008</year><volume>24</volume><fpage>995</fpage><lpage>1001</lpage><pub-id pub-id-type="pmid">18285370</pub-id></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hummel</surname><given-names>M</given-names></name><etal></etal></person-group><article-title>A biologic definition of Burkitt's lymphoma from transcriptional and genomic profiling</article-title><source>N Engl J Med</source><year>2006</year><volume>354</volume><fpage>2419</fpage><lpage>2430</lpage><pub-id pub-id-type="pmid">16760442</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Delvaux</surname><given-names>S</given-names></name><name><surname>Horsten</surname><given-names>L</given-names></name></person-group><article-title>On best transitive approximations to simple graphs</article-title><source>Acta Inform</source><year>2004</year><volume>40</volume><fpage>637</fpage><lpage>655</lpage></citation></ref><ref id="B4"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Natanzon</surname><given-names>A</given-names></name><name><surname>Shamir</surname><given-names>R</given-names></name><name><surname>Sharan</surname><given-names>R</given-names></name></person-group><article-title>Complexity Classification of Some Edge Modification Problems</article-title><source>Proc of Workshop on Graph-Theoretic Concepts in Computer Science (WG 1999)</source><year>1999</year><volume>1665</volume><publisher-name>Lect. Notes Comput. Sc., Springer</publisher-name><fpage>65</fpage><lpage>77</lpage></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>K&#x00159;iv&#x000e1;nek</surname><given-names>M</given-names></name><name><surname>Mor&#x000e1;vek</surname><given-names>J</given-names></name></person-group><article-title>NP-Hard Problems in Hierarchical-Tree Clustering</article-title><source>Acta Inform</source><year>1986</year><volume>23</volume><fpage>311</fpage><lpage>323</lpage></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gr&#x000f6;tschel</surname><given-names>M</given-names></name><name><surname>Wakabayashi</surname><given-names>Y</given-names></name></person-group><article-title>A cutting plane algorithm for a clustering problem</article-title><source>Math Program</source><year>1989</year><volume>45</volume><fpage>52</fpage><lpage>96</lpage></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gramm</surname><given-names>J</given-names></name><name><surname>Guo</surname><given-names>J</given-names></name><name><surname>H&#x000fc;ffner</surname><given-names>F</given-names></name><name><surname>Niedermeier</surname><given-names>R</given-names></name></person-group><article-title>Graph-modeled data clustering: Fixed-parameter algorithms for clique generation</article-title><source>Theor Comput Syst</source><year>2005</year><volume>38</volume><fpage>373</fpage><lpage>392</lpage></citation></ref><ref id="B8"><citation citation-type="book"><person-group person-group-type="author"><name><surname>B&#x000f6;cker</surname><given-names>S</given-names></name><name><surname>Briesemeister</surname><given-names>S</given-names></name><name><surname>Bui</surname><given-names>QBA</given-names></name><name><surname>Tru&#x000df;</surname><given-names>A</given-names></name></person-group><article-title>A fixed-parameter approach for Weighted Cluster Editing</article-title><source>Proc of Asia-Pacific Bioinformatics Conference (APBC 2008)</source><year>2008</year><volume>5</volume><publisher-name>Series on Advances in Bioinformatics and Computational Biology, Imperial College Press</publisher-name><fpage>211</fpage><lpage>220</lpage></citation></ref><ref id="B9"><citation citation-type="book"><person-group person-group-type="author"><name><surname>B&#x000f6;cker</surname><given-names>S</given-names></name><name><surname>Briesemeister</surname><given-names>S</given-names></name><name><surname>Klau</surname><given-names>GW</given-names></name></person-group><article-title>Exact Algorithms for Cluster Editing: Evaluation and Experiments</article-title><source>Proc of Workshop on Experimental Algorithms (WEA 2008)</source><year>2008</year><volume>5038</volume><publisher-name>Lect. Notes Comput. Sc., Springer</publisher-name><fpage>289</fpage><lpage>302</lpage></citation></ref><ref id="B10"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Niedermeier</surname><given-names>R</given-names></name></person-group><source>Invitation to Fixed-Parameter Algorithms</source><year>2006</year><publisher-name>Oxford University Press</publisher-name></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>M&#x000fc;ller</surname><given-names>R</given-names></name></person-group><article-title>On the partial order polytope of a digraph</article-title><source>Mathematical Programming</source><year>1996</year><volume>73</volume><fpage>31</fpage><lpage>49</lpage></citation></ref><ref id="B12"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Klau</surname><given-names>GW</given-names></name><etal></etal></person-group><source>[web page]</source><ext-link ext-link-type="uri" xlink:href="http://www.planet-lisa.net"/><comment>[Accessed 25 September 2008]</comment></citation></ref></ref-list></back></article>