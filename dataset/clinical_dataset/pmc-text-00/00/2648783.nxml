<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208163</article-id><article-id pub-id-type="pmc">2648783</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S6</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S6</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Maximum independent sets of commuting and noninterfering inversions</article-title></title-group><contrib-group><contrib id="A1" contrib-type="author"><name><surname>Swenson</surname><given-names>Krister M</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>krister.swenson@epfl.ch</email></contrib><contrib id="A2" contrib-type="author"><name><surname>To</surname><given-names>Yokuki</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>dongy@engr.sc.edu</email></contrib><contrib id="A3" contrib-type="author"><name><surname>Tang</surname><given-names>Jijun</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>jtang@cse.sc.edu</email></contrib><contrib id="A4" corresp="yes" contrib-type="author"><name><surname>Moret</surname><given-names>Bernard ME</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I3">3</xref><email>bernard.moret@epfl.ch</email></contrib></contrib-group><aff id="I1"><label>1</label>Laboratory for Computational Biology and Bioinformatics, School of Computer and Communication Sciences, Ecole Polytechnique F&#x000e9;d&#x000e9;rale de Lausanne, Switzerland</aff><aff id="I2"><label>2</label>Department of Computer Science and Engineering, University of South Carolina, Columbia, SC 29208, USA</aff><aff id="I3"><label>3</label>Swiss Institute of Bioinformatics, Lausanne, Switzerland</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S6</fpage><lpage>S6</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S6"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Swenson et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Swenson et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Swenson               M               Krister                              krister.swenson@epfl.ch            </dc:author><dc:title>            Maximum independent sets of commuting and noninterfering inversions         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S6-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S6&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>Given three signed permutations, an inversion median is a fourth permutation that minimizes the sum of the pairwise inversion distances between it and the three others. This problem is NP-hard as well as hard to approximate. Yet median-based approaches to phylogenetic reconstruction have been shown to be among the most accurate, especially in the presence of long branches. Most existing approaches have used heuristics that attempt to find a longest sequence of inversions from one of the three permutations that, at each step in the sequence, moves closer to the other two permutations; yet very little is known about the quality of solutions returned by such approaches.</p></sec><sec><title>Results</title><p>Recently, Arndt and Tang took a step towards finding longer such sequences by using sets of commuting inversions. In this paper, we formalize the problem of finding such sequences of inversions with what we call signatures and provide algorithms to find maximum cardinality sets of commuting and noninterfering inversions.</p></sec><sec><title>Conclusion</title><p>Our results offer a framework in which to study the inversion median problem, faster algorithms to obtain good medians, and an approach to study characteristic events along an evolutionary path.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>The ordering and strandedness of genes on each chromosome of many organisms are now available, with many more to be added in the near future. Using this information, one can represent a genome as a collection of chromosomes, each of which is a linear or circular sequence of gene identifiers. Variations in the placement of the same genes, as well as variation in gene content and multiplicity, among organisms can then be analyzed. This data is of great interest to evolutionary biologists (and has been for quite some time: see [<xref ref-type="bibr" rid="B1">1</xref>]), but also to comparative genomicists (see, e.g., [<xref ref-type="bibr" rid="B2">2</xref>,<xref ref-type="bibr" rid="B3">3</xref>]) and to any researcher interested in understanding evolutionary changes in pathogens. Even when the data are restricted to singleton gene families (that is, when duplication and loss mechanisms are ignored), the resulting <italic>gene-order </italic>data have proved very useful in the analysis of small genomes (such as organelles) and in comparative genomics. In the past ten years, there has been a large increase in work done on analyzing such data, gene-order data in particular (see, e.g., [<xref ref-type="bibr" rid="B4">4</xref>]). Evolutionary biologists have sought to exploit the advantages of gene-order data (no need for reconciliation of gene trees, very little saturation, existence of rare events that uniquely characterize some very old divergences, etc.), but have had to contend with the high computational complexity of working with such data.</p><p>Of particular interest in a phylogenetic context is the problem of finding the median of three genomes, that is, finding a fourth genome that minimizes the sum of the pairwise distances between it and the three given genomes [<xref ref-type="bibr" rid="B5">5</xref>]. This problem, while being fairly easy for aligned sequence data, is NP-hard for gene-order data [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B7">7</xref>]. Since phylogenetic reconstruction based on reconstructing ancestral states may need to compute such medians repeatedly, fast approximations or heuristics are usually needed, although exact methods have done well for small genomes (from organelles, for instance) [<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>]. One such heuristic, implemented in the popular software MGR [<xref ref-type="bibr" rid="B10">10</xref>], attempts to find a longest sequence of inversions from one of the three given genomes that, at each step in the sequence, moves closer to the other two genomes. However, nothing is known about the theoretical behavior of this heuristic and no systematic experimental investigation of its usefulness has been conducted. Experimental evidence indicates that it leads to worse trees than an optimal median-solver [<xref ref-type="bibr" rid="B11">11</xref>], at least on small genomes, perhaps because the MGR search is limited to a small subset of possible paths. Recently, Arndt and Tang [<xref ref-type="bibr" rid="B12">12</xref>] provided significant improvement on this heuristic by considering sets of <italic>commuting </italic>inversions, that is, inversions that can be arbitrarily reordered among themselves without affecting the end result; using a somewhat different framework, Bernt <italic>et al</italic>. [<xref ref-type="bibr" rid="B13">13</xref>] proposed an approach that is also based on such inversions.</p><p>In this paper, we show that finding maximum cardinality sets of commuting inversions is equivalent to finding maximum independent sets on circle graphs and so can be done in low polynomial time&#x02013;we give a simple algorithm for this purpose. We also shed light on the relationship between maximal sets of noninterfering inversions and independent sets on circle graphs. We further classify sets of commuting inversions into <italic>interfering </italic>and noninterfering inversions, where <italic>noninterfering inversions </italic>are commuting inversions that also make maximal progress (e.g., towards a median), and introduce the notion of an inversion <italic>signature</italic>, which captures the unique rearrangements common to all sorting paths. Finally, we characterize the relationship of sets of noninterfering inversions to signatures and that of signatures to inversion medians.</p><p>For most of the paper, we show how to analyze single permutations in terms of commuting and noninterfering inversions; in later sections, we show how to extend the analysis to multiple permutations.</p><sec><title>Commuting and noninterfering inversions</title><p>An <italic>inversion &#x003c1;</italic>(<italic>i</italic>, <italic>j</italic>) transforms permutation <italic>&#x003c0; </italic>= <italic>&#x003c0;</italic><sub>1 </sub>&#x022ef; <italic>&#x003c0;</italic><sub><italic>i</italic>-1</sub><italic>&#x003c0;</italic><sub><italic>i</italic></sub>&#x022ef;<italic>&#x003c0;</italic><sub><italic>j</italic>-1</sub><italic>&#x003c0;</italic><sub><italic>j</italic></sub><italic>&#x003c0;</italic><sub><italic>j</italic>+1</sub>&#x022ef;<italic>&#x003c0;</italic><sub><italic>n</italic></sub> into permutation <italic>&#x003c0;</italic>' = <italic>&#x003c0;</italic><sub>1</sub>&#x022ef;<italic>&#x003c0;</italic><sub><italic>i</italic>-1</sub><italic>&#x003c0;</italic><sub><italic>j</italic></sub><italic>&#x003c0;</italic><sub><italic>j</italic>-1</sub>&#x022ef;<italic>&#x003c0;</italic><sub><italic>n</italic></sub>. Thus, the <italic>inversion distance problem </italic>between <italic>&#x003c0; </italic>and <italic>&#x003c4; </italic>refers to finding a minimum series of inversions <italic>&#x003c1;</italic><sub>1</sub>, <italic>&#x003c1;</italic><sub>2</sub>,&#x022ef;, <italic>&#x003c1;</italic><sub><italic>t </italic></sub>so that <italic>&#x003c0;</italic>&#x000b7;<italic>&#x003c1;</italic><sub>1</sub>&#x000b7;<italic>&#x003c1;</italic><sub>2</sub>&#x022ef;<italic>&#x003c1;</italic><sub><italic>t </italic></sub>= <italic>&#x003c4;</italic>. Because any series of inversions that sorts permutation <italic>&#x003c4;</italic><sub>1 </sub>to some permutation <italic>&#x003c4;</italic><sub>2 </sub>will also sort <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S6-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msubsup><mml:mi>&#x003c4;</mml:mi><mml:mn>2</mml:mn><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> to the <italic>identity </italic>1 2 3 4 &#x022ef; <italic>n</italic>, we often only consider one permutation <italic>&#x003c0; </italic>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S6-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msubsup><mml:mi>&#x003c4;</mml:mi><mml:mn>2</mml:mn><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> and call <italic>d</italic>(<italic>&#x003c0;</italic>) = <italic>t </italic>the <italic>inversion distance</italic>. Hannenhalli and Pevzner [<xref ref-type="bibr" rid="B14">14</xref>] showed how to use a graph representation of the two permutations, henceforth referred to as the <italic>HP-graph</italic>. An element <italic>&#x003c0;</italic><sub><italic>i </italic></sub>is represented by vertices <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S6-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>&#x003c0;</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S6-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>&#x003c0;</mml:mi><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>, where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S6-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>&#x003c0;</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> is to the left of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S6-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>&#x003c0;</mml:mi><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> if and only if <italic>&#x003c0;</italic><sub><italic>i </italic></sub>is positive, and the permutation is bracketed by <italic>L</italic><sup>+ </sup>on the left and <italic>R</italic><sup>- </sup>on the right. <italic>Reality </italic>edges represent current adjacencies and so connect vertices from adjacent elements, while <italic>desire </italic>edges represent adjacencies for the sorted permutation (the identity) and so connect <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S6-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>&#x003c0;</mml:mi><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S6-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>&#x003c0;</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x02212;</mml:mo></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula>. Every vertex has degree two so that every vertex is part of a cycle; cycles that overlap when embedding on a line, with all desire edges on the same side of the line, are part of a <italic>component</italic>. Each reality edge on a cycle has a relative <italic>direction </italic>imposed by a tour of the cycle, carried out by noting in which direction the edges are traversed relative to the embedding. In Figure <xref ref-type="fig" rid="F1">1</xref>, edges (L<sup>+</sup>, 6<sup>+</sup>) and (2<sup>-</sup>, 1<sup>-</sup>) share a direction while all the others are of the opposite direction.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>An example of breakpoint graph</bold>. <italic>G</italic>(<italic>&#x003c0; </italic>= -6 -4 -2 1 -3 -5). Black edges are reality edges and gray edges are desire edges.</p></caption><graphic xlink:href="1471-2105-10-S1-S6-1"/></fig><p>We say that inversion <italic>&#x003c1;</italic>(<italic>i</italic>, <italic>j</italic>) <italic>acts upon </italic>a reality edge e if e is either the <italic>i</italic>th or (<italic>j </italic>+ 1)st reality edge from the left; similarly, we say that inversion <italic>&#x003c1;</italic>(<italic>i</italic>, <italic>j</italic>) <italic>acts upon </italic>a desire edge <italic>e </italic>if <italic>e </italic>is incident on the rightmost vertex of the <italic>i</italic>th reality edge or on the leftmost vertex of the (<italic>j </italic>+ 1)st reality edge. In our example, the inversion over substring "-6 -4 -2 1 -3" (also known as <italic>&#x003c1;</italic>(1, 5)) acts upon reality edges (L<sup>+</sup>, 6<sup>+</sup>) and (3<sup>-</sup>, 5<sup>+</sup>). It acts upon desire edges (6<sup>+</sup>, R<sup>-</sup>) and (3<sup>-</sup>, 2<sup>+</sup>) and so affects vertices 6<sup>+ </sup>and 3<sup>-</sup>. An <italic>oriented </italic>inversion acts upon reality edges from the same cycle of opposite direction. A component is oriented iff it has an oriented inversion that acts upon it, otherwise it is unoriented. A permutation that has at least one unoriented cycle has at least one <italic>hurdle</italic>, indicating that at least one additional inversion will be needed. See [<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B15">15</xref>] for a more complete description.</p><p>Oriented inversions are of particular interest because, in the absence of hurdles, they are the only inversions that move <italic>&#x003c0; </italic>one inversion closer to the identity. A set of oriented inversions on a permutation <italic>&#x003c0; commutes </italic>iff the application of its inversions, in any order, yields the same final permutation.</p><p><bold>Definition 1</bold>. <italic>A set of m inversions on &#x003c0; </italic>(<italic>with respect to &#x003c4;</italic>) <italic>is </italic>noninterfering <italic>if and only if</italic></p><p>1. <italic>the set is commuting; and</italic></p><p>2. <italic>applying these inversions in any order moves &#x003c0; closer to &#x003c4; by m inversions</italic>.</p><p><bold>Example 1</bold>. <italic>For &#x003c0; </italic>= <italic>-6 -4 -2 1 -3 -5 a maximum cardinality set of commuting inversions is </italic>{<italic>&#x003c1;</italic>(1, 1), <italic>&#x003c1;</italic>(1, 4), <italic>&#x003c1;</italic>(1, 5), <italic>&#x003c1;</italic>(1, 6), <italic>&#x003c1;</italic>(2, 3), <italic>&#x003c1;</italic>(3, 3), <italic>&#x003c1;</italic>(4, 4)} <italic>while a maximum cardinality set of noninterfering inversions is </italic>{<italic>&#x003c1;</italic>(1, 1), <italic>&#x003c1;</italic>(1, 2), <italic>&#x003c1;</italic>(1, 4), <italic>&#x003c1;</italic>(4, 4)}.</p></sec><sec><title>Inversion graphs and inversion signatures</title><p><italic>A sorting path </italic>is a shortest sequence of oriented inversions on <italic>&#x003c0; </italic>with respect to some <italic>&#x003c4;</italic>. The <italic>inversion graph </italic>is the graph of all sorting paths between <italic>&#x003c0; </italic>and <italic>&#x003c4;</italic>; the permutations are vertices and edges link permutations that are one inversion away from each other.</p><p><bold>Definition 2</bold>. <italic>The intersection of all inversion graphs from a set of permutations P to permutation &#x003c4; is the </italic>inversion signature subgraph <italic>and any vertex </italic>(<italic>permutation</italic>) <italic>in this subgraph is an </italic>inversion signature.</p><p>A signature is <italic>maximal </italic>if there exists no neighbor to it in the signature subgraph that is farther from <italic>&#x003c4;</italic>; a maximal signature that is as far from <italic>&#x003c4; </italic>as any other is called a <italic>maximum </italic>signature.</p><p><bold>Example 2</bold>. <italic>In Figure </italic><xref ref-type="fig" rid="F2">2</xref><italic> we have P </italic>= {<italic>2 -1 -3</italic>, <italic>-2 3 1 </italic>} <italic>and &#x003c4; </italic>= <italic>1 2 3 </italic>(<italic>the </italic>identity <italic>permutation of length 3</italic>). <italic>The inversion signature subgraph is outlined in bold. The signatures in this case are -2 -1 -3</italic>, <italic>-2 -1 3</italic>, <italic>1 2 -3</italic>, <italic>and the trivial signature &#x003c4; </italic>= <italic>1 2 3</italic>. <italic>The only maximum signature is also the only maximal signature -2 -1 -3</italic>.</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>The union of the inversion graphs for <italic>P </italic>= {-2 3 1, 2 -1 -3} and <italic>&#x003c4; </italic>= 1 2 3</bold>. The inversion signature subgraph for <italic>P </italic>is highlighted in bold.</p></caption><graphic xlink:href="1471-2105-10-S1-S6-2"/></fig><p>A set of noninterfering inversions of size <italic>m </italic>constitutes a subgraph of the signature subgraph of size <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S6-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msubsup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>m</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>i</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>m</mml:mi></mml:msup></mml:mrow></mml:semantics></mml:math></inline-formula>. Siepel et al. [<xref ref-type="bibr" rid="B9">9</xref>] showed that a median for any signature between <italic>&#x003c4; </italic>and <italic>P </italic>is also a median for <italic>&#x003c4; </italic>and <italic>P</italic>.</p></sec><sec><title>Circle graphs and permutation graphs</title><p>Consider drawing a set of chords with each endpoint of the chord on the same circle. The <italic>circle graph </italic>represents the intersection of these chords where each vertex corresponds to a chord and each edge corresponds to intersecting chords [<xref ref-type="bibr" rid="B16">16</xref>]. For a permutation we can define a <italic>permutation graph </italic>as follows. Each vertex is an element of the permutation and an edge (<italic>u</italic>, <italic>v</italic>) exists iff <italic>v </italic>&#x0003e; <italic>u </italic>and <italic>v </italic>appears to the left of <italic>u </italic>in the permutation [<xref ref-type="bibr" rid="B17">17</xref>]. Clearly, any permutation graph is a circle graph.</p></sec></sec><sec sec-type="methods"><title>Methods</title><sec><title>Maximum sets of commuting inversions</title><p>We now show how to find a maximum cardinality set of commuting inversions efficiently&#x02013;omitting most proofs due to space limitations. We can interpret the indices of an inversion to be indices of an interval on a line. Two intervals are said to <italic>overlap </italic>if they share more than one point and neither is contained within the other.</p><p><bold>Lemma 1</bold>. <italic>A set C of inversions commutes if and only if no two inversions from C overlap</italic>.</p><p><italic>Proof</italic>. Assume the pair <italic>a, b </italic>&#x02208; <italic>C </italic>overlaps. Fix an ordering of all inversions from <italic>C </italic>so that <italic>b </italic>is the last inversion and it immediately follows <italic>a</italic>. For this ordering the rightmost element of <italic>a </italic>will end up to the left of the leftmost element of <italic>a</italic>. Now take an ordering identical to the previous one but with <italic>a </italic>following <italic>b</italic>; this yields a contradiction because the rightmost element of <italic>a </italic>is right of the leftmost element of <italic>a</italic>. The other direction is trivial.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><p>We have a set of intervals that, when projected onto a circle, yields a chord model of a circle graph [<xref ref-type="bibr" rid="B18">18</xref>];</p><p>Figure <xref ref-type="fig" rid="F3">3(a)</xref> illustrates the concept. Call this circle graph <italic>G</italic><sub><italic>C</italic></sub>; a maximum independent set of <italic>G</italic><sub><italic>C </italic></sub>corresponds to a maximum independent set of commuting inversions. The HP-graph can be built in linear time [<xref ref-type="bibr" rid="B19">19</xref>] and a maximum independent set of <italic>G</italic><sub><italic>C </italic></sub>can be computed in <italic>O</italic>(<italic>n</italic><sup>2</sup>) time with the algorithm of Valiente [<xref ref-type="bibr" rid="B20">20</xref>]; we thus have the following theorem.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p>The chord models for circle graphs representing the constraints on G(<italic>&#x003c0; </italic>= -6 -4 -2 1 -3 -5).</p></caption><graphic xlink:href="1471-2105-10-S1-S6-3"/></fig><p><bold>Theorem 1</bold>. <italic>A maximum cardinality set of commuting inversions can be found in O</italic>(<italic>n</italic><sup>2</sup>) <italic>steps</italic>.</p></sec><sec><title>Maximum sets of noninterfering inversions</title><p>Finding a set of noninterfering inversions is more demanding than finding a set of commuting inversions, but we can also use maximum independent sets in the circle graph&#x02013;except that now we need to use the union of two circle graphs.</p><p>A set of noninterfering inversions is also a set of commuting inversions; but additional constraints must be introduced to ensure that the selected set of commuting inversions also sort the permutation. We now proceed to develop the theoretical background to represent these additional constraints by another circle graph, beginning with single-cycle components of the HP-graph and then extending the characterization to general components.</p><sec><title>Single cycle components</title><p>One important property of commuting inversions is that the application of one inversion cannot alter the orientation of an inversion with which it commutes.</p><p><bold>Lemma 2</bold>. <italic>Given commuting oriented inversions &#x003c1;</italic>(<italic>i</italic>, <italic>j</italic>) <italic>and &#x003c3; </italic>(<italic>k</italic>, <italic>l</italic>), <italic>the application of &#x003c1; will either make &#x003c3; span two different cycles or leave &#x003c3; oriented</italic>.</p><p><italic>Proof</italic>. Call <italic>r </italic>and <italic>s </italic>the reality edges acted upon by <italic>&#x003c3;</italic>. At least one of <italic>r </italic>or <italic>s </italic>remains intact after the application of <italic>&#x003c1;</italic>, say <italic>r</italic>. At least one of the vertices incident to <italic>s </italic>must remain intact, say <italic>v</italic>. There is a path <italic>P </italic>from <italic>v </italic>to some <italic>u </italic>incident to <italic>r </italic>that does not include <italic>r</italic>. The adjacencies of <italic>v </italic>and <italic>u </italic>are not affected by <italic>&#x003c1;</italic>; moreover, because <italic>&#x003c3; </italic>is oriented, if <italic>v </italic>is on some side of <italic>s </italic>then <italic>u </italic>is on the same side of <italic>r</italic>. But <italic>&#x003c1; </italic>can only remove a subpath of the cycle when creating another cycle. Because <italic>&#x003c1;</italic> and <italic>&#x003c3; </italic>commute, <italic>u </italic>and <italic>v </italic>will remain on the same sides of their respective reality edges, thus leaving the inversion <italic>&#x003c3; </italic>oriented.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><p>Each oriented inversion will split the cycle by swapping the affected vertices of the desire edges acted upon. Thus, when we embed the cycle on a circle, we can represent the action of an inversion as a chord with its endpoints on those desire edges. For two inversions that intersect and act upon a disjoint set of desire edges, we know that applying one of them will put the reality edges acted upon by the other on different cycles; so in this case intersecting chords represent inversions that interfere.</p><p>Finding the interactions between inversions that share a reality edge is harder. Consider the set of inversions that share a reality edge as an endpoint and share the same desire edge; for example, the set of inversions that share reality edge (2<sup>-</sup>, 1<sup>-</sup>) is {<italic>&#x003c1;</italic>(2, 3), <italic>&#x003c1;</italic>(3, 3), <italic>&#x003c1;</italic>(4, 4), <italic>&#x003c1;</italic>(4, 5), <italic>&#x003c1;</italic>(4, 6)}, which can be partitioned into inversions that share (2<sup>-</sup>, 1<sup>+</sup>) {<italic>&#x003c1;</italic>(2, 3), <italic>&#x003c1;</italic>(3, 3)} and those that share (1<sup>-</sup>, L<sup>+</sup>) {<italic>&#x003c1;</italic>(4, 4), <italic>&#x003c1;</italic>(4, 5), <italic>&#x003c1;</italic>(4, 6)}. Let us order such a set <italic>I </italic>in two ways. The ordering <italic>&#x003b1;</italic>: <italic>I </italic>&#x021a6; &#x02115; numbers inversions from shortest to longest. There exists a vertex <italic>v </italic>that is affected by every inversion in the set (because of the sharing of edges); our second ordering <italic>&#x003b2;</italic>: <italic>I </italic>&#x021a6; &#x02115; numbers inversions by the order in which we visit the <italic>other </italic>("non-<italic>v</italic>") endpoint, starting at the common reality edge and proceeding through <italic>v</italic>.</p><p><bold>Lemma 3</bold>. <italic>Given inversions i</italic>, <italic>j </italic>&#x02208; <italic>I</italic>, <italic>i interferes with j iff we have &#x003b1;</italic>(<italic>i</italic>) &#x0003e; <italic>&#x003b1; </italic>(<italic>j</italic>) <italic>and &#x003b2; </italic>(<italic>i</italic>) &#x0003c;<italic>&#x003b2; </italic>(<italic>j</italic>).</p><p>In other words, an inversion interferes with all shorter inversions that appear after it on the cycle.</p><p><italic>Proof</italic>. <italic>v </italic>is the shared vertex that is affected by all inversions in <italic>I</italic>. For an inversion <italic>i </italic>&#x02208; <italic>I </italic>and any <italic>j </italic>&#x02208; {<italic>k</italic>||<italic>k </italic>&#x02208; <italic>I</italic>\{<italic>i </italic>} and <italic>&#x003b1; </italic>(<italic>i</italic>) &#x0003e; <italic>&#x003b1; </italic>(<italic>k</italic>)} with endpoints <italic>v </italic>and <italic>u </italic>respectively, <italic>i </italic>interferes with <italic>j </italic>iff <italic>u </italic>ends up on a different cycle than <italic>v </italic>after applying <italic>i</italic>. If we follow the cycle in the same order used to build <italic>&#x003b2;</italic>, the reality edges we visit before encountering <italic>u </italic>are those that remain on the cycle with <italic>v </italic>when it is attached by the new reality edge. So those inversions that act upon such reality edges remain oriented and they are exactly those <italic>j </italic>that have <italic>&#x003b2; </italic>(<italic>j</italic>) &#x0003c;<italic>&#x003b2; </italic>(<italic>i</italic>). The others will respect <italic>&#x003b2; </italic>(<italic>i</italic>) &#x0003c;<italic>&#x003b2; </italic>(<italic>j</italic>).&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><p><bold>Example 3</bold>. <italic>Figure </italic><xref ref-type="fig" rid="F4">4(a)</xref><italic> shows the graph from Figure </italic><xref ref-type="fig" rid="F1">1</xref><italic> embedded on a circle. &#x003b1; imposes the ordering on all inversions that share desire edge </italic>(6<sup>+</sup>, R<sup>-</sup>) <italic>so that &#x003b1; </italic>(<italic>&#x003c1;</italic>(1, 1)) &#x0003c;<italic>&#x003b1; </italic>(<italic>&#x003c1;</italic>(1, 2)) &#x0003c;<italic>&#x003b1; </italic>(<italic>&#x003c1;</italic>(1, 4)) &#x0003c;<italic>&#x003b1; </italic>(<italic>&#x003c1;</italic>(1, 5)) &#x0003c;<italic>&#x003b1; </italic>(<italic>&#x003c1;</italic>(1, 6)). <italic>We also have &#x003b2; </italic>(<italic>&#x003c1;</italic>(1, 6)) &#x0003c;<italic>&#x003b2; </italic>(<italic>&#x003c1;</italic>(1, 1)) &#x0003c;<italic>&#x003b2; </italic>(<italic>&#x003c1;</italic>(1, 5)) &#x0003c;<italic>&#x003b2; </italic>(<italic>&#x003c1;</italic>(1, 2)) &#x0003c;<italic>&#x003b2; </italic>(<italic>&#x003c1;</italic>(1, 4)). <italic>So for </italic>(1, 5) <italic>we have &#x003b1; </italic>(<italic>&#x003c1;</italic>(1, 5)) &#x0003e; <italic>&#x003b1; </italic>(<italic>&#x003c1;</italic>(1, 4)) &#x0003e; <italic>&#x003b1; </italic>(<italic>&#x003c1;</italic>(1, 2)), <italic>as well as &#x003b2; </italic>(<italic>&#x003c1;</italic>(1, 5)) &#x0003c;<italic>&#x003b2; </italic>(<italic>&#x003c1;</italic>(1, 2)) &#x0003c;<italic>&#x003b2; </italic>(<italic>&#x003c1;</italic>(1, 4)), <italic>which tells us that &#x003c1;</italic>(1, 5) <italic>interferes with &#x003c1;</italic>(1, 2) <italic>and &#x003c1;</italic>(1, 4). <italic>Further</italic>, <italic>&#x003b1; </italic>(<italic>&#x003c1;</italic>(1, 5)) &#x0003c;<italic>&#x003b1; </italic>(<italic>&#x003c1;</italic>(1, 6)) <italic>and &#x003b2; </italic>(<italic>&#x003c1;</italic>(1, 5)) &#x0003e; <italic>&#x003b2; </italic>(<italic>&#x003c1;</italic>(1, 6)) <italic>shows that &#x003c1;</italic>(1, 5) <italic>interferes with &#x003c1;</italic>(1, 6). <italic>Figure </italic><xref ref-type="fig" rid="F4">4(b)</xref><italic> shows the result of applying inversion &#x003c1;</italic>(1, 5) <italic>on the graph</italic>.</p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold><italic>G</italic>(<italic>&#x003c0; </italic>= -6 -4 -2 1 -3 -5) embedded on a circle</bold>. We see the affect that inversion <italic>&#x003c1;</italic>(1, 5) has on those inversions acting upon the same desire edge; <italic>&#x003c1;</italic>(1, 5) interferes with <italic>&#x003c1;</italic>(1, 2), <italic>&#x003c1;</italic>(1, 4), and <italic>&#x003c1;</italic>(1, 6), but not <italic>&#x003c1;</italic>(1, 1).</p></caption><graphic xlink:href="1471-2105-10-S1-S6-4"/></fig><p><bold>Corollary 1</bold>. <italic>The interference relationship between all inversions that act on the same desire edge can be represented by a permutation graph</italic>.</p><p><bold>Theorem 2</bold>. <italic>G<sub>S </sub>can be represented by a circle graph</italic>.</p><p><italic>Proof</italic>. If two inversions both act on a reality edge, then apply Corollary 1. Otherwise, embed the cycle on a circle and notice that the effect of an inversion is to split the circle (see Figure <xref ref-type="fig" rid="F4">4</xref>). A chord model representing the interference between two inversions that do not share a reality edge is obtained by drawing a chord for each inversion between the reality edges it acts upon.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><p>Figure <xref ref-type="fig" rid="F3">3</xref> shows the two circle graphs that represent the constraints of the HP-graph from Figure <xref ref-type="fig" rid="F1">1</xref>. In this case, <italic>G</italic><sub><italic>C </italic></sub>is a subgraph of <italic>G</italic><sub><italic>S </italic></sub>so <italic>G</italic><sub><italic>C </italic></sub>&#x0222a; <italic>G</italic><sub><italic>S </italic></sub>is a circle graph. A maximum cardinality set of noninterfering inversions would be represented by the set of chords {<italic>AB</italic>, <italic>AC</italic>, <italic>AE</italic>, <italic>DE</italic>} (matching that from Example 1).</p><p>The union of two circle graphs, however, need not yield a circle graph. To handle this issue, we decompose the instance into computationally easy and hard subinstances by using the first of two phases from the polynomial-time circle graph recognition algorithm of Bouchet [<xref ref-type="bibr" rid="B21">21</xref>,<xref ref-type="bibr" rid="B22">22</xref>]. This first phase repeatedly decomposes the graph by <italic>join decomposition</italic>; it finds a complete bipartite decomposition, call it <italic>V</italic><sub>1<italic>c </italic></sub>&#x02286; <italic>V</italic><sub>1 </sub>and <italic>V</italic><sub>2<italic>c </italic></sub>&#x02286; <italic>V</italic><sub>2</sub>, then replaces it by the two graphs induced by taking only vertices in <italic>V</italic><sub>1 </sub>and <italic>V</italic><sub>2</sub>, and adding a marker vertex to each graph connected to only <italic>V</italic><sub>1<italic>c </italic></sub>and <italic>V</italic><sub>2<italic>c </italic></sub>respectively. If such a decomposition does not exist, the subgraph at hand is said to be <italic>prime</italic>. In the second phase, a chord model is found for each prime subgraph. If every prime subgraph yields a chord model, then we can apply the quadratic-time algorithm of Valiente [<xref ref-type="bibr" rid="B20">20</xref>] to find the maximum independent set of the circle graph and we are done. If only some subgraphs yield a chord model, we can handle those independently with the same algorithm. Thus the computationally hard subgraphs are those prime subgraphs that do not yield a chord model; it is on these subgraphs that we are forced to run a general algorithm for maximum independent set.</p><p>Figure <xref ref-type="fig" rid="F5">5</xref> shows how a set of vertices is partitioned into connected components <italic>V</italic><sub>1 </sub>= <italic>V</italic><sub>1<italic>a </italic></sub>&#x0222a; <italic>V</italic><sub>1<italic>b </italic></sub>&#x0222a; <italic>V</italic><sub>1<italic>c </italic></sub>and <italic>V</italic><sub>2 </sub>= <italic>V</italic><sub>2<italic>a </italic></sub>&#x0222a; <italic>V</italic><sub>2<italic>b </italic></sub>&#x0222a; <italic>V</italic><sub>2<italic>c, </italic></sub>where <italic>V</italic><sub>1<italic>a</italic></sub>, <italic>V</italic><sub>2<italic>a</italic></sub>, <italic>V</italic><sub>1<italic>b</italic></sub>, and <italic>V</italic><sub>2<italic>b </italic></sub>are possibly empty sets.</p><fig position="float" id="F5"><label>Figure 5</label><caption><p>What the chord model of a join decomposition looks like if such a chord model exists.</p></caption><graphic xlink:href="1471-2105-10-S1-S6-5"/></fig><p>In our setting, the sets <italic>V</italic><sub>1<italic>a</italic></sub>, <italic>V</italic><sub>1<italic>b</italic></sub>, and <italic>V</italic><sub>1<italic>c </italic></sub>(resp. <italic>V</italic><sub>2<italic>a</italic></sub>, <italic>V</italic><sub>2<italic>b</italic></sub>, and <italic>V</italic><sub>2<italic>c</italic></sub>) may not actually yield chord models, but the representation of Figure <xref ref-type="fig" rid="F5">5</xref> shows how the independent sets of such a decomposition interact with each other.</p><p>When composing solutions of independent sets on hard subgraphs, solutions we denote by <italic>MIS</italic>(&#x000b7;), we must consider two possibilities: (i) vertices from <italic>V</italic><sub>1<italic>c </italic></sub>and <italic>V</italic><sub>2<italic>c </italic></sub>are used for <italic>MIS</italic>(<italic>V</italic><sub>1</sub>) and <italic>MIS</italic>(<italic>V</italic><sub>2</sub>) respectively; or (ii) vertices from neither or only one of the two are used. In the later case vertices from both independent sets will be in the independent set for <italic>G</italic><sub><italic>S </italic></sub>&#x02229; <italic>G</italic><sub><italic>C</italic></sub>. In the former case we can use the vertices from <italic>V</italic><sub>1<italic>c </italic></sub>or from <italic>V</italic><sub>2<italic>c </italic></sub>but not both, so we recursively test <italic>MIS</italic>(<italic>V</italic><sub>1<italic>a </italic></sub>&#x0222a; <italic>V</italic><sub>1<italic>b</italic></sub>) + <italic>MIS</italic>(<italic>V</italic><sub>2</sub>) and <italic>MIS</italic>(<italic>V</italic><sub>2<italic>a </italic></sub>&#x0222a; <italic>V</italic><sub>2<italic>b</italic></sub>) + <italic>MIS</italic>(<italic>V</italic><sub>1</sub>) and use the larger of the two as the score for the subproblem.</p></sec><sec><title>Multiple cycle instances</title><p>We now show how to transform a multiple cycle component into a single cycle while appropriately ignoring inversions that are created by the process.</p><p>Hannenhalli and Pevzner [<xref ref-type="bibr" rid="B14">14</xref>] introduced the notion of a (<italic>g</italic>, <italic>b</italic>)-<italic>split </italic>where a cycle of length six or larger is split by adding two vertices so as to preserve at least one minimum sorting path. Such a change in the graph can be represented in the corresponding permutation by a remapping of some vertex labels, a process called a (<italic>g</italic>, <italic>b</italic>)-<italic>padding</italic>. Here we introduce the inverse operation to the split, the (<italic>d</italic>, <italic>r</italic>)-<italic>join</italic>, which takes two cycles and joins them so as to preserve all sorting paths, along with an inverse analog to the padding, the (<italic>d</italic>, <italic>r</italic>)-<italic>shrink</italic>. A (<italic>d</italic>, <italic>r</italic>)-join removes the vertices <italic>x</italic><sup>- </sup>and <italic>x</italic><sup>+ </sup>(from two different cycles) for some permutation element <italic>x </italic>along with reality edges (<italic>x</italic><sup>-</sup>, <italic>r</italic><sub>1</sub>) and (<italic>x</italic><sup>+</sup>, <italic>r</italic><sub>2</sub>) and desire edges (<italic>x</italic><sup>-</sup>, <italic>d</italic><sub>1</sub>) and (<italic>x</italic><sup>+</sup>, <italic>d</italic><sub>2</sub>). The edges <italic>r </italic>= (<italic>r</italic><sub>1</sub>, <italic>r</italic><sub>2</sub>) and <italic>d </italic>= (<italic>d</italic><sub>1</sub>, <italic>d</italic><sub>2</sub>) are then added to form a valid HP-graph <italic>&#x001e6;</italic>(<italic>&#x003c0;</italic>). It is easy to verify that a (<italic>d</italic>, <italic>r</italic>)-join operation is equivalent to a (<italic>d</italic>, <italic>r</italic>)-shrink which acts by removing the element <italic>x </italic>and renaming all other elements with magnitude <italic>i </italic>&#x0003e; <italic>x </italic>to have magnitude <italic>i </italic>- 1 with the same sign. Hence we have <italic>G</italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S6-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>&#x002c7;</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>) = <italic>&#x001e6;</italic>(<italic>&#x003c0;</italic>).</p><p><bold>Lemma 4</bold>. <italic>Apply to permutation &#x003c0; a </italic>(<italic>d</italic>, <italic>r</italic>)-<italic>shrink by removing an element x </italic>(<italic>corresponding to vertices x</italic><sup>-</sup><italic>and x</italic><sup>+ </sup><italic>from two different cycles) to obtain </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S6-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>&#x002c7;</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. <italic>The inversion graph for &#x003c0; is a subgraph of the inversion graph for </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S6-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>&#x002c7;</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula><italic>and d </italic>(<italic>&#x003c0;</italic>) <italic>equals d</italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-S1-S6-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>&#x002c7;</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>).</p><p><italic>Proof</italic>. The length of the permutation decreases by one but so does the number of cycles, therefore we have <italic>d</italic>(<italic>&#x003c0;</italic>) = <italic>d</italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-10-S1-S6-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>&#x002c7;</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>). We now show that the (<italic>d</italic>, <italic>r</italic>)-join of cycles <italic>C</italic><sub>1 </sub>and <italic>C</italic><sub>2 </sub>turning <italic>G</italic>(<italic>&#x003c0;</italic>) to <italic>&#x001e6;</italic>(<italic>&#x003c0;</italic>) will preserve the relative direction between edges. Fix a direction on the cycle with reality edge (<italic>x</italic><sup>-</sup>, <italic>r</italic><sub>1</sub>) by visiting <italic>r</italic><sub>1 </sub>before <italic>x</italic><sup>- </sup>followed by <italic>d</italic><sub>1</sub>. Similarly, fix a direction on the cycle with edge (<italic>x</italic><sup>+</sup>, <italic>r</italic><sub>2</sub>) by visiting <italic>d</italic><sub>2 </sub>before <italic>x</italic><sup>+ </sup>followed by <italic>r</italic><sub>2</sub>. Thus, after the application of the (<italic>d</italic>, <italic>r</italic>)-join the remaining reality edge <italic>r </italic>can be visited from <italic>r</italic><sub>1 </sub>to <italic>r</italic><sub>2 </sub>in a tour continuing to <italic>d</italic><sub>2 </sub>and <italic>d</italic><sub>1 </sub>from desire edge <italic>d</italic>. Since the direction for the new edges is consistent with the direction of the removed edges, the direction of <italic>r </italic>to reality edges in <italic>C</italic><sub>1 </sub>and <italic>C</italic><sub>2 </sub>is also consistent. So any inversion that acts on edges (<italic>x</italic><sup>-</sup>, <italic>r</italic><sub>1</sub>) or (<italic>x</italic><sup>+</sup>, <italic>r</italic><sub>2</sub>) for a sorting path on <italic>&#x003c0; </italic>will now act on <italic>r </italic>for a sorting path on <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-10-S1-S6-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>&#x002c7;</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. Since (<italic>x</italic><sup>-</sup>, <italic>r</italic><sub>1</sub>) and (<italic>x</italic><sup>+</sup>, <italic>r</italic><sub>2</sub>) are on different cycles of <italic>G</italic>(<italic>&#x003c0;</italic>), there can be no oriented inversions done that act on both at the same time.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><p>An important corollary is that all oriented inversions on <italic>&#x003c0; </italic>will be preserved. Thus, we can shrink a multiple cycle component to an "equivalent" cycle and then run the algorithm while ignoring oriented inversions introduced by the shrinking process.</p></sec></sec><sec><title>Handling multiple permutations</title><p>When improving the MGR heuristic for medians or implementing a greedy heuristic for maximum signature computation, one needs to consider sets of inversions that occur in multiple permutations. This is done by simply ignoring intervals that do not occur as oriented inversions in all permutations, while merging the constraints on the remainder of the permutations. That is, to find the maximum independent set of commuting or noninterfering inversions on many permutations, take the intersection of the sets of oriented inversions over all permutations and run our algorithm on the union of the remaining constraints.</p></sec><sec><title>Two notes on hurdles</title><p>Hurdles complicate our analysis in two places. First, while inversions that are unsafe on their own are easily identified and thus removed from consideration before running our algorithm, it is possible that a set of noninterfering inversions, each of which is safe by itself, can collude to create a hurdle. We can check for this problem, but the time requirements immediately increase as a result.</p><p>Second, a permutation that already contains many hurdles automatically yields a large (exponential in the number of hurdles) number of sorting paths, since hurdles can be merged two by two in almost every possible way (it suffices that the merged hurdles be nonadjacent, for instance). Each combination of hurdle merges yields a new set of oriented inversions, but it is not clear whether an exponential search of these combinations is necessary. Fortunately, hurdles are very rare in practice (for genomes subjected to rearrangements through inversions, at least) [<xref ref-type="bibr" rid="B23">23</xref>,<xref ref-type="bibr" rid="B24">24</xref>].</p></sec><sec><title>A new median solver</title><p>We improved the MGR heuristic using maximum independent sets of noninterfering inversions. Given three genomes <italic>G</italic><sub>1</sub>, <italic>G</italic><sub>2 </sub>and <italic>G</italic><sub>3</sub>, we define the median score of a genome <italic>G </italic>to be <italic>d</italic>(<italic>G</italic>, <italic>G</italic><sub>1</sub>) + <italic>d</italic>(<italic>G</italic>, <italic>G</italic><sub>2</sub>) + <italic>d</italic>(<italic>G</italic>, <italic>G</italic><sub>3</sub>), where <italic>d</italic>(<italic>G</italic>, <italic>G</italic><sub><italic>i</italic></sub>) is the distance between genome <italic>G </italic>and <italic>G</italic><sub><italic>i</italic></sub>. To find the genome that minimizes the median score, the new median solver chooses the maximum independent set of inversions which brings <italic>G</italic><sub>1 </sub>closer to both <italic>G</italic><sub>2 </sub>and <italic>G</italic><sub>3</sub>. The algorithm will then iteratively compute maximum independent sets of inversions in the three genomes until the maximum sets are empty. At the end of this procedure, the three given genomes are transformed to three (potentially) new genomes and we report the one with the lowest median score as the resulting median.</p></sec></sec><sec><title>Results and discussion</title><p>To assess the speed and accuracy of our new solver, we tested it using the same datasets used by Arndt and Tang [<xref ref-type="bibr" rid="B12">12</xref>]. These datasets were generated by assigning the identity permutation to the internal node and three leaves were created by applying rearrangement events along each edge. The number of events on each edge is a function of the total number of evolutionary events and of the tree shape. The total number of events used was in the range of 80 to 140 and three tree shapes were used: trees with edges of almost equal length; trees with one edge about twice longer than the other two; and trees with one edge about three times longer than the other two. We compared the new method to Caprara's median solver (exact but slow), to MGR, and to the solver of Arndt and Tang. For each combination of parameters, ten trees were generated and the average results are reported.</p><p>Table <xref ref-type="table" rid="T1">1</xref> and Table <xref ref-type="table" rid="T2">2</xref> show the median scores found by each method, and Table <xref ref-type="table" rid="T3">3</xref> and Table <xref ref-type="table" rid="T4">4</xref> show the time used by each method. Our new method not only runs significantly faster than MGR&#x02013;when the datasets have many inversions, our new method is about 20 ~30 times faster than MGR&#x02013;but it also returns more accurate medians. Our new method also improves on that of Arndt and Tang: it is from 3 to 100 times faster while never losing more than 1 ~2% in accuracy. The search strategies of these two solvers are different: our solver only searches maximum independent sets and will halt when the set is empty, while Arndt's solver uses a heuristic to decide the independent sets and will keep searching even when there is no independent set. Thus Arndt's solver is much slower but a bit more accurate than our new median solver. The accuracy of our new solver can be further improved with some additional computation. The three new genomes obtained when the search stops actually form a new instance of the median problem. We applied Caprara's solver to these new, smaller, median problems and found that the scores were improved for small to medium numbers of inversions&#x02013;often to the point of matching the optimal solution. (For large numbers of inversions, however, the new median instances remained very difficult to solve exactly.)</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Comparison of median scores for <italic>r </italic>&#x02264; 100</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center" colspan="2">(1:1:1)</td><td align="center" colspan="2">(2:1:1)</td><td align="center" colspan="2">(3:1:1)</td></tr><tr><td></td><td colspan="6"><hr></hr></td></tr><tr><td></td><td align="center">r = 80</td><td align="center">r = 100</td><td align="center">r = 80</td><td align="center">r = 100</td><td align="center">r = 80</td><td align="center">r = 100</td></tr></thead><tbody><tr><td align="center">Score lower bound</td><td align="center">86.2</td><td align="center">104.2</td><td align="center">89.4</td><td align="center">105.8</td><td align="center">85.7</td><td align="center">101.3</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">Caprara's median score</td><td align="center">87.9</td><td align="center">107.6</td><td align="center">91.4</td><td align="center">109.8</td><td align="center">88.0</td><td align="center">105.2</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">Arndt's median score</td><td align="center">88.2</td><td align="center">109.5</td><td align="center">91.8</td><td align="center">111.4</td><td align="center">89.1</td><td align="center">106.7</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">MGR median score</td><td align="center">90.3</td><td align="center">113.7</td><td align="center">94.3</td><td align="center">116.8</td><td align="center">89.8</td><td align="center">110.0</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">New method's median score</td><td align="center">89.1</td><td align="center">111.8</td><td align="center">92.6</td><td align="center">114.1</td><td align="center">90.0</td><td align="center">108.1</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Comparison of median scores for <italic>r </italic>&#x02265; 120. N/A indicates a method cannot finish</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center" colspan="2">(1:1:1)</td><td align="center" colspan="2">(2:1:1)</td><td align="center" colspan="2">(3:1:1)</td></tr><tr><td></td><td colspan="6"><hr></hr></td></tr><tr><td></td><td align="center">r = 120</td><td align="center">r = 140</td><td align="center">r = 120</td><td align="center">r = 140</td><td align="center">r = 120</td><td align="center">r = 140</td></tr></thead><tbody><tr><td align="center">Score lower bound</td><td align="center">116.1</td><td align="center">123.5</td><td align="center">116.1</td><td align="center">122.7</td><td align="center">110.3</td><td align="center">117.6</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">Caprara's median score</td><td align="center">N/A</td><td align="center">N/A</td><td align="center">N/A</td><td align="center">N/A</td><td align="center">N/A</td><td align="center">N/A</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">Arndt's median score</td><td align="center">125.8</td><td align="center">135.3</td><td align="center">124.5</td><td align="center">134.7</td><td align="center">117.9</td><td align="center">127.0</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">MGR median score</td><td align="center">132.9</td><td align="center">143.6</td><td align="center">131.4</td><td align="center">142.8</td><td align="center">123.6</td><td align="center">135.1</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">New method's median score</td><td align="center">127.9</td><td align="center">139.5</td><td align="center">126.9</td><td align="center">138.5</td><td align="center">120.6</td><td align="center">130.1</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T3"><label>Table 3</label><caption><p>Comparison of running time for <italic>r </italic>&#x02264; 100 (in seconds)</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center" colspan="2">(1:1:1)</td><td align="center" colspan="2">(2:1:1)</td><td align="center" colspan="2">(3:1:1)</td></tr><tr><td></td><td colspan="6"><hr></hr></td></tr><tr><td></td><td align="center">r = 80</td><td align="center">r = 100</td><td align="center">r = 80</td><td align="center">r = 100</td><td align="center">r = 80</td><td align="center">r = 100</td></tr></thead><tbody><tr><td align="center">Caprara's time</td><td align="center">3.6</td><td align="center">12876</td><td align="center">57.2</td><td align="center">31387</td><td align="center">4.3</td><td align="center">6908</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">Arndt's time</td><td align="center">324</td><td align="center">551</td><td align="center">123</td><td align="center">409</td><td align="center">1.6</td><td align="center">9.3</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">MGR time</td><td align="center">11.2</td><td align="center">51.9</td><td align="center">11.6</td><td align="center">78.2</td><td align="center">10.3</td><td align="center">35</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">New method's time</td><td align="center">3.3</td><td align="center">5.3</td><td align="center">4.1</td><td align="center">8.4</td><td align="center">4.6</td><td align="center">9.1</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T4"><label>Table 4</label><caption><p>Comparison of running time for <italic>r </italic>&#x02265; 120 (in seconds)</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="center" colspan="2">(1:1:1)</td><td align="center" colspan="2">(2:1:1)</td><td align="center" colspan="2">(3:1:1)</td></tr><tr><td></td><td colspan="6"><hr></hr></td></tr><tr><td></td><td align="center">r = 120</td><td align="center">r = 140</td><td align="center">r = 120</td><td align="center">r = 140</td><td align="center">r = 120</td><td align="center">r = 140</td></tr></thead><tbody><tr><td align="center">Caprara's time</td><td align="center">&#x0003e; 172880</td><td align="center">&#x0003e; 172880</td><td align="center">&#x0003e; 172880</td><td align="center">&#x0003e; 172880</td><td align="center">&#x0003e; 172880</td><td align="center">&#x0003e; 172880</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">Arndt's time</td><td align="center">1485</td><td align="center">1187</td><td align="center">673</td><td align="center">453</td><td align="center">30</td><td align="center">226</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">MGR time</td><td align="center">271.6</td><td align="center">560.1</td><td align="center">237.8</td><td align="center">626.9</td><td align="center">135.3</td><td align="center">385.4</td></tr><tr><td colspan="7"><hr></hr></td></tr><tr><td align="center">New method's time</td><td align="center">13.8</td><td align="center">19.7</td><td align="center">11.1</td><td align="center">21.3</td><td align="center">9.2</td><td align="center">12.4</td></tr></tbody></table></table-wrap></sec><sec><title>Conclusion</title><p>We presented two new algorithms: a quadratic-time algorithm to compute a maximum set of commuting inversions and a more complex algorithm to compute a maximum set of noninterfering inversions. The latter algorithm can also run in quadratic time by using the circle graph recognition of Spinrad [<xref ref-type="bibr" rid="B25">25</xref>]&#x02013;and the conditions under which this algorithm can be used are detectable in low polynomial time. When these conditions are not met, our algorithm decomposes the instance so that only certain subinstances require exponential work. It is worth noting that, due to the intersection step in our algorithm, the more genomes that are compared, the sparser the intersection will be and the faster the algorithm will run.</p><p>Arndt and Tang [<xref ref-type="bibr" rid="B12">12</xref>] showed that an MGR-style search for medians can be improved through a better choice of inversions; our new median solver, using the algorithm for computing a maximum set of noninterfering inversions, further improves on these results, both in terms of accuracy and in terms of speed. We expect further research into the relationship between inversion medians, signatures, and noninterfering inversions will uncover much more structure that can be used to design yet faster algorithms, thereby providing a practical tool for the reconstruction of ancestral genomes.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>KMS and BMEM contributed to the development and implementation of the algorithms, and YT and JT were in charge of developing the new median solver and conducting simulations.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>YT and JT were supported by US National Institutes of Health (NIH grant number R01 GM078991). All experiments were conducted on a 128-core shared memory computer funded by US National Science Foundation (NSF grant number CNS 0708391).</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Downie</surname><given-names>S</given-names></name><name><surname>Palmer</surname><given-names>J</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Soltis P, Soltis D, Doyle J</surname></name></person-group><article-title>Use of chloroplast DNA rearrangements in reconstructing plant phylogeny</article-title><source>Plant Molecular Systematics</source><year>1992</year><publisher-name>Chapman and Hall</publisher-name><fpage>14</fpage><lpage>35</lpage></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Darling</surname><given-names>A</given-names></name><name><surname>Mau</surname><given-names>B</given-names></name><name><surname>Blattner</surname><given-names>F</given-names></name><name><surname>Perna</surname><given-names>N</given-names></name></person-group><article-title>Mauve: Multiple Alignment of Conserved Genomic Sequence With Rearrangements</article-title><source>Genome Res</source><year>2004</year><volume>14</volume><fpage>1394</fpage><lpage>1403</lpage><pub-id pub-id-type="pmid">15231754</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pevzner</surname><given-names>P</given-names></name><name><surname>Tesler</surname><given-names>G</given-names></name></person-group><article-title>Human and mouse genomic sequences reveal extensive breakpoint reuse in mammalian evolution</article-title><source>Proc Natl Acad Sci USA</source><year>2003</year><volume>100</volume><fpage>7672</fpage><lpage>7677</lpage><pub-id pub-id-type="pmid">12810957</pub-id></citation></ref><ref id="B4"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Moret</surname><given-names>B</given-names></name><name><surname>Tang</surname><given-names>J</given-names></name><name><surname>Warnow</surname><given-names>T</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Gascuel O</surname></name></person-group><article-title>Reconstructing phylogenies from gene-content and gene</article-title><source>Mathematics of Evolution and Phylogeny</source><year>2005</year><publisher-name>Oxford University Press, UK</publisher-name><fpage>321</fpage><lpage>352</lpage></citation></ref><ref id="B5"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Sankoff</surname><given-names>D</given-names></name><name><surname>Blanchette</surname><given-names>M</given-names></name></person-group><article-title>The median problem for breakpoints in comparative genomics</article-title><source>Proc 3rd Int'l Conf Computing and Combinatorics (COCOON'97)</source><year>1997</year><volume>1276</volume><publisher-name>Lecture Notes in Computer Science, Springer Verlag, Berlin</publisher-name><fpage>251</fpage><lpage>264</lpage></citation></ref><ref id="B6"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Caprara</surname><given-names>A</given-names></name></person-group><article-title>Formulations and hardness of multiple sorting by reversals</article-title><source>Proc 3rd Ann Int'l Conf Comput Mol Biol (RECOMB'99)</source><year>1999</year><publisher-name>ACM Press, New York</publisher-name><fpage>84</fpage><lpage>93</lpage></citation></ref><ref id="B7"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Pe'er</surname><given-names>I</given-names></name><name><surname>Shamir</surname><given-names>R</given-names></name></person-group><article-title>The median problems for breakpoints are NP-complete</article-title><source>Elec Colloq on Comput Complexity</source><year>1998</year><fpage>71</fpage></citation></ref><ref id="B8"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Moret</surname><given-names>B</given-names></name><name><surname>Siepel</surname><given-names>A</given-names></name><name><surname>Tang</surname><given-names>J</given-names></name><name><surname>Liu</surname><given-names>T</given-names></name></person-group><article-title>Inversion medians outperform breakpoint medians in phylogeny reconstruction from gene-order data</article-title><source>Proc 2nd Int'l Workshop Algs in Bioinformatics (WABI'02)</source><year>2002</year><volume>2452</volume><publisher-name>Lecture Notes in Computer Science, Springer Verlag, Berlin</publisher-name><fpage>521</fpage><lpage>536</lpage></citation></ref><ref id="B9"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Siepel</surname><given-names>A</given-names></name><name><surname>Moret</surname><given-names>B</given-names></name></person-group><article-title>Finding an Optimal Inversion Median: Experimental Results</article-title><source>Proc 1st Int'l Workshop Algs in Bioinformatics (WABI'01)</source><year>2001</year><volume>2149</volume><publisher-name>Lecture Notes in Computer Science, Springer Verlag, Berlin</publisher-name><fpage>189</fpage><lpage>203</lpage></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Tesler</surname><given-names>G</given-names></name></person-group><article-title>Efficient algorithms for multichromosomal genome rearrangements</article-title><source>J Comput Syst Sci</source><year>2002</year><volume>65</volume><fpage>587</fpage><lpage>609</lpage></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Swenson</surname><given-names>K</given-names></name><name><surname>Arndt</surname><given-names>W</given-names></name><name><surname>Tang</surname><given-names>J</given-names></name><name><surname>Moret</surname><given-names>B</given-names></name></person-group><article-title>Phylogenetic reconstruction from complete gene orders of whole genomes</article-title><source>Proc 6th Asia Pacific Bioinformatics Conf (APBC'08)  in Advances in Bioinformatics and Computational Biology</source><year>2008</year><volume>6</volume><fpage>241</fpage><lpage>250</lpage><comment></comment></citation></ref><ref id="B12"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Arndt</surname><given-names>W</given-names></name><name><surname>Tang</surname><given-names>J</given-names></name></person-group><article-title>Improving inversion median computation using commuting reversals and cycle information</article-title><source>Proc 5th RECOMB Work on Comp Genomics (RECOMBCG'07)</source><year>2007</year><volume>4751</volume><publisher-name>Lecture Notes in Computer Science, Springer Verlag, Berlin</publisher-name><fpage>30</fpage><lpage>44</lpage></citation></ref><ref id="B13"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Bernt</surname><given-names>M</given-names></name><name><surname>Merkle</surname><given-names>D</given-names></name><name><surname>Middendorf</surname><given-names>M</given-names></name></person-group><article-title>Genome Rearrangement Based on Reversals that Preserve Conserved Intervals</article-title><source>IEEE-ACM Trans Computational Biology and Bioinformatics</source><year>2006</year></citation></ref><ref id="B14"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Hannenhalli</surname><given-names>S</given-names></name><name><surname>Pevzner</surname><given-names>P</given-names></name></person-group><article-title>Transforming cabbage into turnip (polynomial algorithm for sorting signed permutations by reversals)</article-title><source>Proc 27th Ann ACM Symp Theory of Comput (STOC'95)</source><year>1995</year><publisher-name>ACM Press, New York</publisher-name><fpage>178</fpage><lpage>189</lpage></citation></ref><ref id="B15"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Setubal</surname><given-names>J</given-names></name><name><surname>Meidanis</surname><given-names>J</given-names></name></person-group><source>Introduction to Computational Molecular Biology</source><year>1997</year><publisher-name>PWS Publishers, Boston, MA</publisher-name></citation></ref><ref id="B16"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Even</surname><given-names>S</given-names></name><name><surname>Itai</surname><given-names>A</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Zvi Kohavi and Azaria Paz</surname></name></person-group><article-title>Queues, Stacks, and Graphs</article-title><source>Theory of Machines and Computations</source><year>1971</year><publisher-name>Proceedings of an International Symposium on the Theory of Machines and Computations, Technion--Israel Inst. of Technol., Haifa, Israel, Aug. 1971, Academic Press, New York</publisher-name><fpage>71</fpage><lpage>86</lpage></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Even</surname><given-names>S</given-names></name><name><surname>Pnueli</surname><given-names>A</given-names></name><name><surname>Lempel</surname><given-names>A</given-names></name></person-group><article-title>Permutation Graphs and Transitive Graphs</article-title><source>JACM</source><year>1972</year><volume>19</volume><fpage>400</fpage><lpage>410</lpage></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gavril</surname><given-names>F</given-names></name></person-group><article-title>Algorithms for a maximum clique and a maximum independent set of a circle graph</article-title><source>Networks</source><year>1973</year><volume>3</volume><fpage>261</fpage><lpage>273</lpage></citation></ref><ref id="B19"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bader</surname><given-names>D</given-names></name><name><surname>Moret</surname><given-names>B</given-names></name><name><surname>Yan</surname><given-names>M</given-names></name></person-group><article-title>A fast linear-time algorithm for inversion distance with an experimental comparison</article-title><source>J Comput Biol</source><year>2001</year><volume>8</volume><fpage>483</fpage><lpage>491</lpage><pub-id pub-id-type="pmid">11694179</pub-id></citation></ref><ref id="B20"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Valiente</surname><given-names>G</given-names></name></person-group><article-title>A New Simple Algorithm for the Maximum-Weight Independent Set Problem on Circle Graphs</article-title><source>Proc 14th Int'l Symp Alg and Comp (ISAAC'03)</source><year>2003</year><volume>2906</volume><publisher-name>Lecture Notes in Computer Science, Springer Verlag, Berlin</publisher-name><fpage>129</fpage><lpage>137</lpage></citation></ref><ref id="B21"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bouchet</surname><given-names>A</given-names></name></person-group><article-title>Reducing prime graphs and recognizing circle graphs</article-title><source>Combinatorica</source><year>1987</year><volume>7</volume><fpage>243</fpage><lpage>254</lpage></citation></ref><ref id="B22"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Spinrad</surname><given-names>J</given-names></name></person-group><source>Efficient Graph Representations</source><year>2003</year><publisher-name>American Mathematical Society</publisher-name></citation></ref><ref id="B23"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Caprara</surname><given-names>A</given-names></name></person-group><article-title>On the tightness of the alternating-cycle lower bound for sorting by reversals</article-title><source>J Combin Optimization</source><year>1999</year><volume>3</volume><fpage>149</fpage><lpage>182</lpage></citation></ref><ref id="B24"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Swenson</surname><given-names>K</given-names></name><name><surname>Lin</surname><given-names>Y</given-names></name><name><surname>Rajan</surname><given-names>V</given-names></name><name><surname>Moret</surname><given-names>B</given-names></name></person-group><article-title>Hurdles Hardly Have to be Heeded</article-title><source>Proc 6th RECOMB Work on Comp Genomics (RECOMBCG'08)</source><year>2009</year><volume>5267</volume><publisher-name>Lecture Notes in Computer Science, Springer Verlag, Berlin</publisher-name><fpage>239</fpage><lpage>249</lpage></citation></ref><ref id="B25"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Spinrad</surname><given-names>J</given-names></name></person-group><article-title>Recognition of circle graphs</article-title><source>Journal of Algorithms</source><year>1994</year><volume>16</volume><fpage>264</fpage><lpage>282</lpage></citation></ref></ref-list></back></article>