<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article" xml:lang="EN"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Front Neuroinformatics</journal-id><journal-id journal-id-type="publisher-id">Front. Neuroinform.</journal-id><journal-title>Frontiers in Neuroinformatics</journal-title><issn pub-type="epub">1662-5196</issn><publisher><publisher-name>Frontiers Research Foundation</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19198646</article-id><article-id pub-id-type="pmc">2634532</article-id><article-id pub-id-type="doi">10.3389/neuro.11.009.2008</article-id><article-categories><subj-group subj-group-type="heading"><subject>Neuroscience</subject><subj-group><subject>Original Research</subject></subj-group></subj-group></article-categories><title-group><article-title>Python for Large-Scale Electrophysiology</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Spacek</surname><given-names>Martin</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="author-notes" rid="fn001">*</xref></contrib><contrib contrib-type="author"><name><surname>Blanche</surname><given-names>Tim</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib><contrib contrib-type="author"><name><surname>Swindale</surname><given-names>Nicholas</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff1"><sup>1</sup><institution>Ophthalmology and Visual Sciences, University of British Columbia</institution><country>Vancouver, BC, Canada</country></aff><aff id="aff2"><sup>2</sup><institution>Redwood Center for Theoretical Neuroscience, University of California</institution><country>Berkeley, CA, USA</country></aff><author-notes><fn fn-type="edited-by"><p>Edited by: Rolf K&#x000f6;tter, Radboud University Nijmegen, The Netherlands</p></fn><fn fn-type="edited-by"><p>Reviewed by: Michele Giugliano, Ecole Polytechnique F&#x000e9;d&#x000e9;rale de Lausanne, Switzerland; Gaute T. Einevoll, Norwegian University of Life Sciences, Norway</p></fn><corresp id="fn001">*Correspondence: Martin Spacek, Department of Ophthalmology and Visual Sciences, University of British Columbia, 2550 Willow Street, Vancouver, BC V5Z 3N9, Canada. e-mail: <email>frontiers@mspacek.mm.st</email></corresp></author-notes><pub-date pub-type="epreprint"><day>04</day><month>11</month><year>2008</year></pub-date><pub-date pub-type="epub"><day>28</day><month>1</month><year>2009</year></pub-date><pub-date pub-type="collection"><year>2008</year></pub-date><volume>2</volume><elocation-id>9</elocation-id><history><date date-type="received"><day>18</day><month>9</month><year>2008</year></date><date date-type="accepted"><day>19</day><month>12</month><year>2008</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2009 Spacek, Blanche and Swindale.</copyright-statement><copyright-year>2009</copyright-year><license license-type="open-access" xlink:href="http://www.frontiersin.org/licenseagreement"><p>This is an open-access article subject to an exclusive license agreement between the authors and the Frontiers Research Foundation, which permits unrestricted use, distribution, and reproduction in any medium, provided the original authors and source are credited.</p></license></permissions><abstract><p>Electrophysiology is increasingly moving towards highly parallel recording techniques which generate large data sets. We record extracellularly <italic>in vivo</italic> in cat and rat visual cortex with 54-channel silicon polytrodes, under time-locked visual stimulation, from localized neuronal populations within a cortical column. To help deal with the complexity of generating and analysing these data, we used the Python programming language to develop three software projects: one for temporally precise visual stimulus generation (&#x0201c;dimstim&#x0201d;); one for electrophysiological waveform visualization and spike sorting (&#x0201c;spyke&#x0201d;); and one for spike train and stimulus analysis (&#x0201c;neuropy&#x0201d;). All three are open source and available for download (<monospace><uri xlink:type="simple" xlink:href="http://swindale.ecc.ubc.ca/code">http://swindale.ecc.ubc.ca/code</uri></monospace>). The requirements and solutions for these projects differed greatly, yet we found Python to be well suited for all three. Here we present our software as a showcase of the extensive capabilities of Python in neuroscience.</p></abstract><kwd-group><kwd>Python</kwd><kwd>silicon polytrodes</kwd><kwd>primary visual cortex</kwd><kwd>in-vivo</kwd></kwd-group><counts><fig-count count="5"/><table-count count="0"/><equation-count count="0"/><ref-count count="20"/><page-count count="10"/><word-count count="7351"/></counts></article-meta></front><body><sec sec-type="introduction"><title>Introduction</title><p>As systems neuroscience moves increasingly towards highly parallel physiological recording techniques, generation, management, and analysis of large complex data sets is becoming the norm. We are interested in the function of localized neuronal populations in visual cortex. The goal is to understand how neurons in visual cortex respond to visual stimuli, to the extent that the responses to arbitrary stimuli can be predicted. Accurate prediction will require an understanding of how these neurons interact with each other. Neurons in close proximity are more likely to show functionally interesting interactions, and insights into how such localized populations work may help guide understanding of other parts of cortex, or even the brain as a whole. To this end we need to record and analyse the simultaneous spiking behaviour of many neurons in response to a wide variety of visual stimuli.</p><p>We use 54-channel silicon polytrodes, in both rat and cat primary visual cortex, to extracellularly sample spiking activity constrained to roughly a cortical column (Figure <xref ref-type="fig" rid="F1">1</xref>A) (Blanche et al., <xref ref-type="bibr" rid="B2">2005</xref>). Time-locked visual stimuli are presented to the animal while simultaneously recording from dozens of neurons (Figure <xref ref-type="fig" rid="F1">1</xref>B). Waveforms are recorded continuously at a rate of 2.7&#x02009;MB/s for up to 90&#x02009;min (&#x0223c;15&#x02009;GB) at a time. A single animal experiment can last up to 3 days and generate hundreds of GB of data. Setting up our electrophysiology rig, with custom acquisition software written in Delphi (Blanche, <xref ref-type="bibr" rid="B1">2005</xref>), was the first step. Although we had existing solutions in place for visual stimulation, waveform visualization and spike sorting, and spike train analysis, all three had limitations which were addressed by rewriting our software in Python.</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>(A)</bold> One of several 54-channel silicon polytrode designs used. Recording sites are closely spaced, such that a spike will typically appear on several sites at the same time (see Figure <xref ref-type="fig" rid="F3">3</xref>). <bold>(B)</bold> Experimental setup. Stimuli are presented to the animal while stimulus information and extracellular voltage waveforms are acquired and saved to disk.</p></caption><graphic xlink:href="fninf-02-009-g001"/></fig><p>The first of those tackled was visual stimulation. After an extensive search for existing software, we discovered the &#x0201c;Vision Egg&#x0201d; (Straw, <xref ref-type="bibr" rid="B16">2008</xref>), a Python library for generating stimuli. We chose the Vision Egg partly because of the language it was written in and written for: Python. We were thus introduced to Python via one of its many packages, and the experience was so positive that it encouraged us to standardize on Python for the spike sorting and spike train analysis projects to follow. For one of us (M. Spacek), the switch to Python has made programming a much more enjoyable and productive experience, and has resulted in greatly improved programming skills.</p><p>The benefits of Python have been extolled at length elsewhere (Hetland, <xref ref-type="bibr" rid="B6">2005</xref>; Langtangen, <xref ref-type="bibr" rid="B8">2008</xref>; Lutz, <xref ref-type="bibr" rid="B9">2006</xref>). Briefly, Python is a powerful, dynamically typed, interpreted language that &#x0201c;fits your brain&#x0201d;, with syntax akin to &#x0201c;executable pseudocode&#x0201d;. Python's clear, simple syntax is perhaps its biggest selling point. Some of its clarity stems from a philosophy to provide &#x0201c;one &#x02013; and preferably only one &#x02013; obvious way&#x0201d; to do a given task (Peters, <xref ref-type="bibr" rid="B11">2004</xref>), making features easy to remember. Its clarity is also due to a strong adherence to object-oriented programming principles [Chapter 7 of Hetland (<xref ref-type="bibr" rid="B6">2005</xref>) is an excellent introduction]. In Python, nearly everything is an object, even numbers and functions. This means that everything has attributes and methods (methods are functions that are bound to and act on objects), and can thus be treated in a similar way. An object is an instance of a class. A class can inherit attributes and methods from other classes hierarchically, allowing for substantial code reuse, and therefore less code to maintain. Python code is succinct compared to most other languages: a lot can be accomplished in only a few lines. Finally, Python is free and open source, and encourages open source software development. This is partly due to its interpreted nature: the source code and executable are typically one and the same.</p><p>Python has a stable and feature-rich numeric library called NumPy<xref ref-type="fn" rid="fn1">1</xref> which provides an N-dimensional array object. NumPy arrays can be subjected to vectorized operations, most of which call static C functions, allowing them to run almost as fast as pure C code. Yet, these operations remain accessible from within succinct Python code. NumPy turns Python into an effective replacement for MatLab (The MathWorks, Natick, MA, USA), and is used extensively by dimstim, spyke, and neuropy.</p><p>While all three projects presented here were written in Python, their use and implementation are very different. Dimstim is script based and is run from the system's command line. Spyke has a graphical user interface (GUI) and looks like a native application, while neuropy is typically accessed from the Python command line as a library. Here, we explore some of the features and benefits of Python and its many add-on packages for the electrophysiologist, by introducing our own three packages as detailed working examples.</p></sec><sec><title>Dimstim: Visual Stimulus Generation</title><p>In our experiments, we needed a way to display and control a wide variety of stimuli with many different parameters, often shuffled with respect to each other in various ways. Since spike times are acquired at sub-millisecond temporal resolution, and since precise spike timing may play a role in neural coding (Mainen and Sejnowski, <xref ref-type="bibr" rid="B10">1995</xref>; VanRullen and Thorpe, <xref ref-type="bibr" rid="B18">2002</xref>), we also wanted high temporal precision in the stimulus. Our prior stimulus software was written in Fortran and ran under DOS with a 32-bit extender. It was written for the 8514/A graphics standard which has now lapsed. The last graphics cards to support it were limited in the size and speed of movie frames they could draw to screen. Moreover, these cards were limited to a screen refresh rate of 100&#x02009;Hz at our desired resolution. We found significant artefactual phase-locking of responses in visual cortex at this frequency (Blanche, <xref ref-type="bibr" rid="B1">2005</xref>), which has been a concern reported elsewhere (Williams et al., <xref ref-type="bibr" rid="B19">2004</xref>; Wollman and Palmer, <xref ref-type="bibr" rid="B20">1995</xref>). For these reasons, we needed a better solution.</p><p>Dimstim displays full-screen stimuli at a refresh rate of 200&#x02009;Hz, providing precise control of the display at 5&#x02009;ms intervals without frame drops. Stimuli include manually controlled, drifting, and flashed bars and gratings, sparse noise, and m-sequence noise (Golomb, <xref ref-type="bibr" rid="B5">1967</xref>) and natural scene movies. Stimulus parameters can be shuffled with or without replacement, independently or in covariation with each other. Parameters include spatial location and phase, orientation, speed, duration, size, mask, contrast, brightness, and spatial and temporal frequencies. Each stimulus session is fully specified by its own user-editable script. A copy of the script, and an index of the contents of the screen on each screen refresh, are sent to the acquisition computer, for simultaneous recording of stimulus and neuronal responses.</p><p>Dimstim relies heavily on the Vision Egg<xref ref-type="fn" rid="fn2">2</xref> library (Straw, <xref ref-type="bibr" rid="B16">2008</xref>) to generate stimuli. The Vision Egg uses the well-established OpenGL<xref ref-type="fn" rid="fn3">3</xref> graphics language, which thanks to the demands of video games, is now supported by all modern video cards on all major platforms. We currently use an Nvidia GeForce 7600 graphics card running under Windows XP. Stimuli are displayed on a 19'' Iiyama HM903DTB and a 22'' HM204DTA CRT monitor, two of only a handful of consumer monitors that are capable of 800&#x02009;&#x000d7;&#x02009;600 resolution at 200&#x02009;Hz. Unfortunately, like most other CRTs, these particular models have now been discontinued, but used ones may still be available. Hopefully the timing of LCD monitors will improve such that they can replace CRTs for temporally precise stimulus control.</p><p>Multitasking operating systems (OSes) present a challenge for real-time control of the screen. Often, the OS will decide to delay an operation to maintain responsiveness in other areas. This can lead to frame drops, but can be mitigated by increasing the priority of the Python process. Setting the process and thread priorities to their maximum levels in the Vision Egg completely eliminated frame drops in Windows XP, but with the unfortunate loss of mouse and keyboard polling. In dimstim, this meant that the user had no way of interrupting the stimulus script, other than by resetting the computer. Moving to a computer with a dual core CPU alleviated this problem, as the maximum priority Python process was delegated to one core without interruption, while other OS tasks such as keyboard polling ran normally on the second core.</p><p>Dimstim communicates stimulus parameters on a frame-by-frame basis to the acquisition computer via a PCI digital output board (DT340, Data Translations, Marlboro, MA, USA), for simultaneous recording of stimulus timing alongside neuronal responses. Parameters are described by sending the row index of a large lookup table (&#x0201c;sweep table&#x0201d;) on every screen refresh. The sweep table contains all the combinations of the dynamic parameters, i.e. those stimulus parameters that can vary from one screen refresh to the next.</p><p>The digital output board is controlled by its driver's C library. Because Python is written in C (other implementations also exist), it has a C application programming interface (API), and extensions to Python can be written in C. We wrote such an extension to interact with the board's C library, but today this is no longer necessary. A new built-in Python module called &#x0201c;ctypes&#x0201d; now allows interaction with a C library on any platform directly from within Python code. This is much simpler, as it removes the need to both write and compile C extension code using Python's somewhat tedious C API. If dimstim were rewritten today, ctypes would be the method of choice. Dimstim includes a demo (<monospace>olda_demo.py</monospace>) of how to use ctypes to directly interact with Data Translations' Open Layers data acquisition library. Libraries for cards from other vendors (such as National Instruments' NI-DAQmx) can be similarly accessed.</p><p>Frame timing was tested with a photodiode placed on the monitor. The photodiode signal, along with the raster signal from the video card and the digital outputs from the stimulus computer, were all recorded simultaneously. We discovered that the contents of the screen always lagged by one screen refresh, due to OpenGL's buffer swapping behaviour (Straw, <xref ref-type="bibr" rid="B16">2008</xref>). This was corrected for by adding one frame time (5&#x02009;ms) to the timestamp of the digitized raster signal in the acquisition system.</p><p>Gamma correction was used to ensure linear control of screen luminance. Several levels of uncorrected luminance were measured with a light meter (Minolta LS-100) and fit to a power law expression to determine the exponent corresponding to the gamma value of the screen (Blanche, <xref ref-type="bibr" rid="B1">2005</xref>; Straw, <xref ref-type="bibr" rid="B16">2008</xref>). Gamma correction can be set independently for each script, or globally across all scripts in dimstim's config file.</p><p>Natural scene movies used by dimstim were filmed outdoors with an ordinary compact digital camera (Canon PowerShot SD200) with 320&#x02009;&#x000d7;&#x02009;240 resolution at 60 frames per second (fps). Unfortunately, this camera could record no more than 1&#x02009;min of video at a time. To generate longer movies, multiple clips were filmed in succession, while keeping the camera as motionless as possible between the end of one clip and the start of the next. Concatenation of and conversion from multiple colour .avi files to a single uncompressed greyscale movie file was done using David McNab's y4m<xref ref-type="fn" rid="fn4">4</xref> package. Processed movies were displayed in dimstim with the same visual angle subtended by the camera, at 67 fps (three 5&#x02009;ms screen refreshes per movie frame).</p><sec><title>Usage</title><p>Dimstim's config file stores default values for a variety of generic parameters that apply to most stimuli. These parameters include spatial location, size, orientation offset, and temporal and spatial frequencies. For simplicity, all spatial parameters are specified in degrees of visual angle. The config file can be edited by hand, but the typical procedure when optimizing parameters for the current neural population is to run a manually controlled bar or grating stimulus. For user convenience, the stimulus is shown simultaneously on two displays driven by two video outputs from the graphics card: one for the animal, and one for the user. The parameters of the manual stimulus are controlled in real-time with the mouse and keyboard. Once the user is satisfied, the parameters are saved to the config file. These can later be retrieved by an experiment script for use as default values.</p><p>An example script for a drifting sinusoidal grating experiment is shown in Figure <xref ref-type="fig" rid="F2">2</xref>. The script works in a bottom-up fashion. First, objects for storage of static and dynamic parameters are instantiated (&#x0201c;s&#x0201d; and &#x0201c;d&#x0201d; respectively, lines 5&#x02013;6). To these are bound various different parameters as attributes (denoted by a &#x0201c;.&#x0201d;). In this example, most values are declared directly by the script, but two static parameters, grating orientation offset and gamma correction, are retrieved from their defaults in the config file, using the dimstim config parser object named &#x0201c;dc&#x0201d; (lines 15 and 23). Dynamic parameters, if assigned a list of multiple values, will iterate over those values over the course of the experiment. In this case, grating orientation, spatial frequency, and temporal frequency are all assigned multiple values (lines 28, 36, 38). The rest remain constant for the duration of the experiment. In order to describe their interdependence and shuffling, each multiple-value dynamic parameter must be declared as a &#x0201c;Variable&#x0201d; (lines 53&#x02013;55). Variables with the same dimension value (&#x0201c;dim&#x0201d; keyword argument) covary with each other, and must therefore all have the same number of values and the same shuffle flag. Variables with different dimension values vary independently in a combinatorial fashion, with the lowest numbered dimension varying slowest, and the highest varying fastest. This is implemented by dynamically generating a string object containing Python code with the correct number of nested for loops (equalling the number of independent variables specified in the script), and then executing the contents of the string with Python's <monospace>exec()</monospace> function (see the <monospace>dimstim.Core.SweepTable</monospace> class). Next, the number of times to cycle through all combinations, and the frequency at which to insert a blank screen sweep (for determining baseline firing rates) are specified in their own objects (lines 57&#x02013;58). Finally, all these objects are passed together to the Grating class (which like all other dimstim stimuli, inherits from the Experiment class) to instantiate a Grating experiment object, and the experiment is run (lines 62&#x02013;65). With 12 orientations, 6 spatial frequencies, and 4 temporal frequencies, this experiment has 288 unique parameter combinations, presented in shuffled order. Each is presented four times for a total of 1152 stimulus sweeps, lasting 4&#x02009;s each, for a total experiment time of about 77&#x02009;min (not including blank sweeps).</p><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>A dimstim script describing a drifting sinusoidal grating</bold>. Such scripts may be edited at will, and are the primary way the user interacts with dimstim. After some error checking, the script executes from the system's command line, to which status messages are printed. Comments, denoted by <monospace>#</monospace> and <monospace>"""</monospace> in Python, are highlighted in red. Line numbers have been added for reference. See text for more details.</p></caption><graphic xlink:href="fninf-02-009-g002"/></fig><p>Before running, various checks are done to alert for any obvious errors in the user edited script. Then, a copy of the entire script is sent to the acquisition computer. This makes it possible to later reconstruct the sweep table for analysis, and even replay the entire experiment exactly, without the need for access to the original script on the stimulus computer. To ensure accurate timing, stimuli run only on the animal display, while the user display shows the system command line. In between experiments when no stimuli are running, a blank grey desktop is shown on the animal display. Scripts can be paused or cancelled using the keyboard.</p></sec></sec><sec><title>Spyke: Waveform Visualization and Spike Sorting</title><p>Once neural waveform and stimulus data were saved to disk by our acquisition system (written in Delphi), we needed a way to retrieve the data for visualization and spike sorting. Our existing program for this, also written in Delphi, had some bugs and missing features. However, the Delphi environment required a license, the program would only run in Windows, and the code was more procedural than object-oriented. In particular, some of the code had blocks (if statements, for/while statements) that were nested many layers deep, making it difficult to follow. &#x0201c;Flat is better than nested&#x0201d; (Peters, <xref ref-type="bibr" rid="B11">2004</xref>) is another Python philosophy. Several short, shallow blocks of code are easier to understand and manage than one long deep block. We decided to start from scratch in Python.</p><p>Spyke has a cross-platform GUI with native widgets for data visualization and navigation, and spike sorting (Figure <xref ref-type="fig" rid="F3">3</xref>). Spike waveforms are displayed in two ways: spatially according to the polytrode channel layout (spike window), and vertically in chart form (chart window). Local field potential (LFP) waveforms are also displayed vertically in chart form (LFP window). Polytrode channels are closely spaced (43&#x02013;75 &#x003bc;m) over two or three columns (Figure <xref ref-type="fig" rid="F1">1</xref>A). A single spike can generate a signal on multiple channels, hence the need to visualize waveforms according to their polytrode channel layout. Channels are colour-coded to make them easy to distinguish and align across windows. Spyke looks and behaves like a native GUI application, with menus, buttons, and resizable windows. Navigation is mouse and keyboard based. A horizontal slider and combo box at the top of the main spyke window control file position in time. Left and right arrow keys, and page up and page down keys step through the data with single timepoint or 1 ms resolution respectively. Clicking on any data window (spike, chart, or LFP) centres all three windows on that timepoint. Holding CTRL and scrolling the mouse wheel over a data window zooms it in or out in time. Holding CTRL and clicking on a channel enables or disables it. Hovering the mouse over a data window displays a tooltip with the timestamp, channel, and voltage currently under the mouse cursor.</p><fig id="F3" position="float"><label>Figure 3</label><caption><p><bold>Main spyke window (<italic>top</italic>), with data windows (<italic>bottom</italic>) showing high-pass waveforms in polytrode layout (<italic>left</italic>) and chart layout (<italic>middle</italic>)</bold>. A third data window shows the low-pass LFP waveforms (<italic>right</italic>) concurrently recorded from a subset of channels (colour coded). All data are centred on the same timepoint. The shaded region in the middle of both the chart and LFP windows represents the time range spanned by the window to its left.</p></caption><graphic xlink:href="fninf-02-009-g003"/></fig><p>Spyke uses the wxPython<xref ref-type="fn" rid="fn5">5</xref> library for its GUI. This is a Python interface to the wxWidgets C++ GUI library which generates widgets on Windows, Linux, and OSX. Now well over a decade old (Rappin and Dunn, <xref ref-type="bibr" rid="B12">2006</xref>), wxPython is a stable library that has adapted to changing OSes. Widgets include everything from windows, menus, and buttons, to more complex list and tree controls. WxPython has a big advantage over other GUI libraries in its use of widgets that are native to the OS the program is running on, such that they look and behave identically to normally created widgets in that OS. WxGlade<xref ref-type="fn" rid="fn6">6</xref> was used to visually lay out the GUI. Itself a wxPython based GUI application, wxGlade takes the programmer's visual layout and automatically generates the corresponding layout code in Python. This code can then be included in the programmer's own code base, typically by defining a class that inherits from the automatically generated code. Although wxGlade is not necessary for writing a GUI with wxPython, we found it much faster and easier than writing all of the layout code by hand.</p><p>Unfortunately, some widgets are inherently different on different OSes. Writing and testing a wxPython GUI on only one OS will therefore not guarantee perfect functionality on another. To do so would require checking for the current OS, and implementing certain things differently depending on the OS. Spyke does not currently do this, and has so far only been thoroughly tested in Windows. A cross-platform GUI library faces many challenges. Although wxPython is one of the best (Rappin and Dunn, <xref ref-type="bibr" rid="B12">2006</xref>), it has bugs<xref ref-type="fn" rid="fn7">7</xref> &#x02013; some of them longstanding &#x02013; that had to be worked around in spyke.</p><p>Although the widgets are handled by wxPython, waveforms are plotted using matplotlib<xref ref-type="fn" rid="fn8">8</xref>. Matplotlib is a 2D plotting library for Python that generates publication quality figures. It has two interfaces: one that mimics the familiar plotting commands of MatLab, and another that is much more object-oriented. Spyke embeds matplotlib figures within wxPython windows. Scaling of plots is handled automatically by matplotlib, such that when the wxPython window is resized by dragging its corner or edge, the plotted traces inside resize accordingly. Another benefit of matplotlib is its antialiasing abilities, providing beautiful output with subpixel resolution. There is some performance penalty for using such a high level drawing library, but performance is fast enough on fairly ordinary hardware (Pentium M 1.6 GHz notebook), even when scrolling through 54 channels of data with thousands of data points on screen at a time. More importantly, matplotlib makes plotting very easy to do.</p><p>The data acquisition files are complex, with different types of data multiplexed throughout the file. On opening, the file must be parsed to determine the number and offset values of hundreds of thousands of records in the file. For multi GB files, this can take up to a few minutes. To deal with this, the parsing information is saved to disk for quicker future retrieval. This is done using Python's <monospace>pickle</monospace> module, which can take a snapshot of almost any Python object in memory, serialize it, and save it to disk as a &#x0201c;pickle&#x0201d;. A pickle can then later be restored (unpickled) to memory as a live Python object, even on a different platform. In this case, a custom written File object containing all of the parse information is saved to disk as a .parse file of only a few MB in size. Restoring from the .parse file is about an order of magnitude faster than reparsing the entire acquisition file.</p><p>Segments of waveform data are loaded from the acquisition file, Nyquist interpolated, and sample-and-hold delay (SHD) corrected on the fly as needed (Blanche and Swindale, <xref ref-type="bibr" rid="B3">2006</xref>). Interpolation is performed to improve spike detection, and Nyquist interpolation is the optimum method of reconstructing a bandwidth-limited signal at arbitrary resolution. To do so, a set of sinc function kernels is generated (one kernel per interpolated data point, each kernel with a different phase offset) and convolved with the data. For SHD correction, a different set of kernels is generated for each channel. Correcting for each channel's SHD requires appropriate modification of the phase offset of each kernel for that channel. For example, interpolating from 25 to 50&#x02009;kHz with SHD correction requires two appropriately phase corrected kernels per channel. Each kernel is separately convolved with the data (using <monospace>numpy.convolve()</monospace>), and the resulting data points are interleaved to return the final interpolated waveform.</p><sec><title>Spike sorting</title><p>Spike sorting is done by template matching (Blanche, <xref ref-type="bibr" rid="B1">2005</xref>). Event detection is the first step in generating the required multichannel spike templates. Two event detection methods are currently implemented. The &#x0201c;bipolar amplitude&#x0201d; method looks for simple threshold crossings of either polarity. The &#x0201c;dynamic multiphasic&#x0201d; method searches for two consecutive threshold crossings of opposite polarity within a defined period of time. The second crossing's threshold is dynamically set according to the amplitude of the first phase of the spike. For both methods, primary thresholds are calculated separately for each channel, based on the standard deviation or median noise level of either the entire recording or of a narrow sliding window thereof. Spatiotemporal detection lockouts prevent double triggering off of the same spike, while minimizing the chance of missed spikes.</p><p>Some algorithms, such as these event detection methods, cannot be easily vectorized and require a custom loop. Due to its dynamic typing and interpreted nature, long loops are slow to execute in Python. For the majority of software development, this is not an issue. Developer time is usually much more valuable than CPU time (Hetland, <xref ref-type="bibr" rid="B6">2005</xref>), but numerically intensive software is the exception. Writing fast Python extensions in C has always been possible, but the C interface code required by Python's API is tedious to write, and writing in C eliminates the convenience of working in Python syntax. To get around this, the Cython<xref ref-type="fn" rid="fn9">9</xref> package (a fork of the Pyrex package) specifies a sublanguage almost identical to Python, with some extra keywords to declare loop variables as static C types. After issuing the standard <monospace>python setup.py build</monospace> command, such code is automatically translated into an intermediary C file including all of the tedious interface code. This is subsequently compiled into object code and is accessible as a standard C extension module from within Python, just as a handwritten C extension would be. This yields the computational speed of C loops when needed, with the developmental speed, convenience and familiarity of Python syntax to implement them. Cython was used to write the custom loop that iterates over timepoints and channels for each of the event detection methods. For 25&#x02009;kHz sampled waveform data on 54 channels, this amounts to 1.35 million iterations per second of data. On an average single-core notebook computer (Pentium M 1.6&#x02009;GHz), this loop runs at about 5&#x000d7; real time.</p><p>The data is partitioned into blocks (typically 1&#x02009;s long), and each is searched independently, allowing multiple core CPUs to be exploited. Search speed scales roughly proportionally with the number of cores available. Due to the &#x0201c;global interpreter lock&#x0201d; (GIL) in the C implementation of Python, multiple processes must typically be used instead of multiple threads to take advantage of multiple cores. Unfortunately, a process can require significantly more memory and more time to create than a thread. There are ways around the GIL, but the best solution for spyke is not yet clear.</p><p>Search options are controlled in the &#x0201c;detect&#x0201d; tab in spyke's main window (Figure <xref ref-type="fig" rid="F3">3</xref>). Searches can be limited to specific time ranges in the file, in the number of events detected, and whether to search linearly or randomly. Random sampling is important to build up a temporally unbiased collection of detected events with which to build templates. Searching for the next or previous spike relative to the current timestamp can be done quickly using the keyboard. Searches are restricted to enabled channels, allowing for a targeted increase in the number of events belonging to a spatially localized template. This is useful for building up templates of neurons that rarely fire.</p><p>When a search completes, the sort window (Figure <xref ref-type="fig" rid="F4">4</xref>A) opens and is populated with any newly detected events. The user then visually sorts the detected events (typically only a fraction of all spikes in the recording) into templates corresponding to isolated neurons. This is accomplished by plotting spikes over top of each other. Any number of event or template mean waveforms can be overplotted with each other. Although the mouse may be used, keyboard commands are more efficient for toggling the display of events and templates, and moving events and keyboard focus around between the sorted template tree (left column) and unsorted event list (right column). The event list has sortable columns for event ID, maximum channel, timestamp, and match error. All the events in the list can be matched against the currently selected template, and those match errors populate the error column. Sorting the event list by maximum channel or match error makes manual template generation much easier, because it clusters similar events close to each other in the unsorted event list.</p><fig id="F4" position="float"><label>Figure 4</label><caption><p><bold>(A)</bold> An example of spyke's sort window. Templates and their member spikes are represented in the tree (<italic>left</italic>), and unsorted detected events in the list (<italic>middle</italic>). Selecting a template or event in either the tree or the list plots its waveform (<italic>right</italic>). The tree currently has keyboard focus, making its selections more distinctly coloured than those of the list. Unsorted events have colour coded channels, while each template (and its member spikes) has a single identifying colour. Here, template 0 (red), a putative neuron near the top of the polytrode, has 6 member spikes, and its mean waveform is being overplotted with an unsorted event (#1260, multicoloured), which fits quite well. Template 1 (orange) and all of its member spikes are plotted near the middle of the polytrode. Also plotted further down is another unsorted event (#1150, multicoloured), which obviously does not fit either template. The error values listed are from a match against template 0. <bold>(B)</bold> The integrated PyShell window exposes all of spyke's objects and functionality at the Python command line. Template 0's dictionary (a mapping from names to values) of its 6 member events is referenced and returned on lines 1&#x02013;2. The &#x0201c;Sort&#x0201d; object's attributes and methods are displayed in a popup on line 3.</p></caption><graphic xlink:href="fninf-02-009-g004"/></fig><p>Once templates have been generated, a full event detection is run across the whole recording, and the templates are matched against each detected event. Or, each template can be slid across the recording and matched against every timepoint in the recording (Blanche et al., <xref ref-type="bibr" rid="B2">2005</xref>). Either way, matching to target and non-target spikes or noise generally yields a non-overlapping bimodal error distribution. For each template, a threshold is manually set at the trough between the two peaks in the distribution, and events whose match errors fall below this threshold are classified as spikes of that template.</p><p>At any point in the sorting process, the entire &#x0201c;Sort&#x0201d; session object, which among other information includes detected events, generated templates, and sorted spikes, can be saved to disk as a .sort file, again using Python's <monospace>pickle</monospace> module. Sort sessions can then be restored from disk and sorting can resume in spyke, or their sorted spike times can be used for spike train analysis (see <xref ref-type="sec" rid="s1">neuropy</xref> section). Waveform data for detected events and sorted spikes is saved within the .sort file. This increases the file size, but allows for review of detected and sorted spikes without the need to access the original multi GB continuous data acquisition file.</p><p>Integrated into spyke is Patrick O'Brien's PyShell (Figure <xref ref-type="fig" rid="F4">4</xref>B), an enhanced Python command line that is part of the wxPython package. This permits live command line inspection and modification of all objects comprising spyke. This was, and continues to be, a very useful tool for testing existing features and for developing new ones. Neuropy (or almost any other Python package) can be imported and used directly from this command line. For example, spike sorting validation is not yet implemented in spyke's GUI, but all of neuropy's functionality including autocorrelograms (to check refractory periods) can be accessed by typing <monospace>import neuropy</monospace> in spyke's PyShell.</p></sec></sec><sec id="s1"><title>Neuropy: Spike Train Analysis</title><p>After spike sorting, we needed a way to analyse spike trains and their relation to stimuli. Our initial decision was to use MatLab for spike train analysis, and we soon developed a collection of MatLab scripts for the job, with one function per .m file. For example, one .m file would load each neuron's data from disk and return all of them in a cell array of structures. This was highly procedural instead of object-oriented. Furthermore, the code became difficult to manage as each additional function required an additional .m file. We were also faced with out of memory errors, limited GUI capabilities, and a high licensing cost.</p><p>Although MatLab's toolboxes are a major benefit, SciPy<xref ref-type="fn" rid="fn10">10</xref> (Jones et al., <xref ref-type="bibr" rid="B7">2001</xref>), an extensive Python library of scientific routines, provides most of the equivalent functionality. Much of SciPy is a wrapper for decades-old, highly tested and optimized Fortran code. Another package, mlabwrap<xref ref-type="fn" rid="fn11">11</xref>, allows a licensed MatLab user to access all of MatLab's functionality, including all of its toolboxes, directly from within Python. Although in the end we did not need to use mlabwrap, its existence erased any remaining hesitations about switching to Python for analysis.</p><p>A data-centric object hierarchy (Figure <xref ref-type="fig" rid="F5">5</xref>A) quickly emerged as a natural way to organize neuropy. Each object in the hierarchy has an attribute that references its parent object, as well as all of its child objects. Specifically, &#x0201c;Data&#x0201d; is an abstract object from which all &#x0201c;Animals&#x0201d; are accessible. Each Animal has polytrode &#x0201c;Tracks&#x0201d;, each Track has &#x0201c;Recordings&#x0201d;, and each Recording has both &#x0201c;Sorts&#x0201d; (spike sorting sessions) and &#x0201c;Experiments&#x0201d; (which describe stimuli). Finally, each Sort contains a number of &#x0201c;Neurons&#x0201d;, one of whose attributes is a NumPy array of spike times.</p><fig id="F5" position="float"><label>Figure 5</label><caption><p><bold>(A)</bold> Neuropy's object hierarchy. <bold>(B)</bold> Example code using neuropy to plot the spike-triggered average (STA) of two neurons in response to an m-sequence noise movie (see text for details). <bold>(C)</bold> The resulting plot window. Each row corresponds to a neuron, and each column corresponds to the STA within a fixed time range following the m-sequence white noise stimulus. ON responses are red, OFF responses are blue.</p></caption><graphic xlink:href="fninf-02-009-g005"/></fig><p>Neuropy relies on a hierarchy of data folders on the disk with a fairly rigid naming scheme, such that animal, track, recording, experiment, and sort IDs can be extracted from file and folder names. This forces the user to keep sorted data organized. All objects have a unique ID under the scope of their parent, but not necessarily under the scope of their grandparent. All data can be loaded in at once by creating an instance of the Data class and then calling its .load() method. However, most often only a subset of data is needed, such as only the data from a given animal, track, or recording. For example, an object representing recording 92 from the default track of the default animal can be instantiated by typing <monospace>Recording(92)</monospace> at the command line. This recording's data can then be loaded from disk into the object by calling its .load() method. Default animal and track IDs can be modified from the command line. A recording loads the neurons from its default sort, which can also be modified.</p><p>Some analyses are written as simple methods of one of the data objects, but most have their own separate class which is instantiated by a data object's method call. Many analyses generate plots, some of them interactive (such as the population spike raster plot), again using matplotlib and wxPython. Currently implemented analyses include interspike interval histograms, instantaneous firing rates and their distributions, cross-correlograms and autocorrelograms, and spike-triggered averages (STAs) (Dayan and Abbott, <xref ref-type="bibr" rid="B4">2001</xref>). More specialized analyses include binary codes of population spike trains, their correlation coefficient distributions, maximum entropy Ising modelling of such codes (using <monospace>scipy.maxent</monospace>), and several other related analyses (Schneidman et al., <xref ref-type="bibr" rid="B13">2006</xref>; Shlens et al., <xref ref-type="bibr" rid="B14">2006</xref>; Spacek et al., <xref ref-type="bibr" rid="B15">2007</xref>). Because of the data-centric organization, new analyses are easy to add.</p><p>Neuropy is used interactively as a library from the Python command prompt, usually in an enhanced shell such as PyShell (Figure <xref ref-type="fig" rid="F4">4</xref>B) or the more widely used IPython<xref ref-type="fn" rid="fn12">12</xref>. An example of neuropy use is shown in Figure <xref ref-type="fig" rid="F5">5</xref>B, which calculates and plots the STA of neurons 2 and 5 of the default animal and track. The STA estimates a neuron's spatiotemporal receptive field by averaging the stimulus (in this case, an m-sequence noise movie) at fixed time intervals preceding each spike. Recording 92&#x02009;was recorded during m-sequence noise movie playback, and is used in this example. Line&#x02009;1 imports all of neuropy's functionality into the local namespace. Next, an object representing recording 92 is instantiated and bound to the name <monospace>r92</monospace> for convenience, and its data is loaded from disk (lines 2&#x02013;3). Its dictionary of available experiments is requested and printed out (lines 4&#x02013;5); only one experiment is available, with ID 0. STAs are calculated with respect to this experiment by calling its .sta() method and passing the IDs of the desired neurons (line 6). The calculated STAs are returned in an &#x0201c;STAs&#x0201d; object, which upon further inspection contains two &#x0201c;STA&#x0201d; objects, one per requested neuron (lines 7&#x02013;10). Finally, the STAs object's .plot() method is called with default options, displaying the result for both neurons (Figure <xref ref-type="fig" rid="F5">5</xref>C).</p><p>Python's object orientation has benefits even at the command line. It allows the user to quickly discover what methods and attributes are available for any given object, eliminating the need to recall them from memory (Figure <xref ref-type="fig" rid="F4">4</xref>B). Instead of immediately returning the raw result or plotting it, most analyses in neuropy return an analysis object, which usually has .calc() and .plot() methods. The .calc() method is run automatically on instantiation, and the results are stored as attributes of the analysis object. Settings used to do the calculation are also stored as attributes. These can be modified, and .calc() can be called again to update the result attributes. Once satisfied with the calculation, the user can call the .plot() method. This can be done several times to generate different plots with different plot settings. Each time a new plot is generated, it does so from the existing results, saving on unnecessary recalculation time.</p></sec><sec><title>Conclusion</title><p>We have described Python packages for three tasks pertinent to systems neuroscience: visual stimulus generation, waveform visualization and spike sorting, and spike train analysis. Python allowed us to meet these software challenges with a level of performance not normally associated with a dynamically typed interpreted language. Performance challenges included time-critical display and communication of visual stimuli, parsing and streaming of multiplexed data from GB sized files, on the fly Nyquist interpolation and SHD correction, fast execution of non-vectorizable algorithms, and parallelization. Other challenges, whose solutions were simpler than in a statically compiled language, included a cross-platform native GUI, the storage and retrieval of relatively complex data structures to and from file (.parse and .sort files), and a command line environment for interactive data analysis.</p><p>Dimstim is the oldest of the three packages, and the most stable. Spyke is the most recent and remains under heavy development, while new analyses are added to neuropy as needed. As with most other Python packages, all three can be used alone or from within another Python module. All three depend on each other to a limited extent. Neuropy relies on the stimulus description and timing signals generated by dimstim, and on the spike sorting results from spyke. Spyke can use parts of neuropy for spike sorting validation. These three packages depend on many other open source packages, which themselves rely on yet other packages (e.g. the Vision Egg currently depends on PyOpenGL and PyGame). Modularity and code reuse is thus maximized across the community.</p><p>Because it greatly encourages object-oriented programming, Python code is easier to organize and reuse than MatLab code. This is important for scientific code which tends to continually evolve as new avenues are explored. Often, scientific code is quickly written and bug-tested, used once or twice, and then forgotten about, with little chance of re-use outside of copying and pasting. Python has reduced this tendency for us. Its object orientation and excellent error handling have also helped to reduce bugs.</p><p>Finally, Python was chosen for these projects for its clear, succinct syntax. Dimstim, spyke, and neuropy have roughly 3000, 5000, and 4000 lines of code respectively (excluding comments and blank lines). Fewer lines make code maintenance easier, not just because there is less code to maintain, but also because each line is closer to all other lines, making it easier to navigate. Concise syntax also makes collaboration easier.</p><p>We encourage others in neuroscience to consider Python for their programming needs, and hope that our three examples (available at <monospace><uri xlink:type="simple" xlink:href="http://swindale.ecc.ubc.ca/code">http://swindale.ecc.ubc.ca/code</uri></monospace>) may be of use to others, whether directly or otherwise. Rallying around a common open-source language may help foster efforts to increase sharing of data and code, efforts deemed necessary (Teeters et al., <xref ref-type="bibr" rid="B17">2008</xref>) to push forward progress in systems neuroscience.</p></sec><sec><title>Conflict of Interest Statement</title><p>The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p></sec></body><back><ack><p>Keith Godfrey wrote dimstim's C extension to interface with the Data Translations board. Reza Lotun contributed code to early versions of spyke. Funding came from grants from the Canadian Institutes of Health Research, and the Natural Sciences and Engineering Research Council of Canada.</p></ack><ref-list><title>References</title><ref id="B1"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Blanche</surname><given-names>T. J.</given-names></name></person-group> (<year>2005</year>). <article-title>Large scale neuronal recording</article-title>. Ph.D. dissertation, University of British Columbia, Vancouver, BC.</citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Blanche</surname><given-names>T. J.</given-names></name><name><surname>Spacek</surname><given-names>M. A.</given-names></name><name><surname>Hetke</surname><given-names>J. F.</given-names></name><name><surname>Swindale</surname><given-names>N. V.</given-names></name></person-group> (<year>2005</year>). <article-title>Polytrodes: high-density silicon electrode arrays for large-scale multiunit recording</article-title>. <source>J. Neurophysiol.</source><volume>93</volume>, <fpage>2987</fpage>&#x02013;<lpage>3000</lpage><pub-id pub-id-type="doi">10.1152/jn.01023.2004</pub-id><pub-id pub-id-type="pmid">15548620</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Blanche</surname><given-names>T. J.</given-names></name><name><surname>Swindale</surname><given-names>N. V.</given-names></name></person-group> (<year>2006</year>). <article-title>Nyquist interpolation improves neuron yield in multiunit recordings</article-title>. <source>J. Neurosci. Methods</source><volume>155</volume>, <fpage>81</fpage>&#x02013;<lpage>91</lpage><pub-id pub-id-type="doi">10.1016/j.jneumeth.2005.12.031</pub-id><pub-id pub-id-type="pmid">16481043</pub-id></citation></ref><ref id="B4"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Dayan</surname><given-names>P.</given-names></name><name><surname>Abbott</surname><given-names>L. F.</given-names></name></person-group> (<year>2001</year>). <article-title>Theoretical Neuroscience: Computational and Mathematical Modeling of Neural Systems</article-title>. <publisher-loc>Cambridge, MA</publisher-loc>, <publisher-name>MIT Press</publisher-name></citation></ref><ref id="B5"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Golomb</surname><given-names>S. W.</given-names></name></person-group> (<year>1967</year>). <article-title>Shift Register Sequences</article-title>. <publisher-loc>San Francisco</publisher-loc>, <publisher-name>Holden-Day</publisher-name></citation></ref><ref id="B6"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Hetland</surname><given-names>M. L.</given-names></name></person-group> (<year>2005</year>). <article-title>Beginning Python: From Novice to Professional</article-title>. <publisher-loc>Berkeley, CA</publisher-loc>, <publisher-name>Apress</publisher-name></citation></ref><ref id="B7"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Jones</surname><given-names>E.</given-names></name><name><surname>Oliphant</surname><given-names>T.</given-names></name><name><surname>Peterson</surname><given-names>P.</given-names></name><etal/></person-group> (<year>2001</year>). <article-title>SciPy: open source scientific tools for Python</article-title>. <uri xlink:type="simple" xlink:href="http://scipy.org">http://scipy.org</uri></citation></ref><ref id="B8"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Langtangen</surname><given-names>H. P.</given-names></name></person-group> (<year>2008</year>). <article-title>Python Scripting for Computational Science</article-title>, <edition>3rd Edn.</edition><publisher-loc>Berlin</publisher-loc>, <publisher-name>Springer-Verlag.</publisher-name></citation></ref><ref id="B9"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Lutz</surname><given-names>M.</given-names></name></person-group> (<year>2006</year>). <article-title>Programming Python</article-title>, <edition>3rd Edn.</edition><publisher-loc>Sebastopol, CA</publisher-loc>, <publisher-name>O'Reilly</publisher-name></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Mainen</surname><given-names>Z. F.</given-names></name><name><surname>Sejnowski</surname><given-names>T. J.</given-names></name></person-group> (<year>1995</year>). <article-title>Reliability of spike timing in neocortical neurons</article-title>. <source>Science</source><volume>268</volume>, <fpage>1503</fpage><pub-id pub-id-type="doi">10.1126/science.7770778</pub-id><pub-id pub-id-type="pmid">7770778</pub-id></citation></ref><ref id="B11"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Peters</surname><given-names>T.</given-names></name></person-group> (<year>2004</year>). <article-title>The Zen of Python</article-title>. <uri xlink:type="simple" xlink:href="http://www.python.org/dev/peps/pep-0020">http://www.python.org/dev/peps/pep-0020</uri></citation></ref><ref id="B12"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Rappin</surname><given-names>N.</given-names></name><name><surname>Dunn</surname><given-names>R.</given-names></name></person-group> (<year>2006</year>). <article-title>wxPython in Action</article-title>. <publisher-loc>Greenwich, CT</publisher-loc>, <publisher-name>Manning</publisher-name></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Schneidman</surname><given-names>E.</given-names></name><name><surname>Berry</surname><given-names>M. J.</given-names><suffix>II</suffix></name><name><surname>Segev</surname><given-names>R.</given-names></name><name><surname>Bialek</surname><given-names>W.</given-names></name></person-group> (<year>2006</year>). <article-title>Weak pairwise correlations imply strongly correlated network states in a neural population</article-title>. <source>Nature</source><volume>440</volume>, <fpage>1007</fpage>&#x02013;<lpage>1012</lpage><pub-id pub-id-type="doi">10.1038/nature04701</pub-id><pub-id pub-id-type="pmid">16625187</pub-id></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Shlens</surname><given-names>J.</given-names></name><name><surname>Field</surname><given-names>G. D.</given-names></name><name><surname>Gauthier</surname><given-names>J. L.</given-names></name><name><surname>Grivich</surname><given-names>M. I.</given-names></name><name><surname>Petrusca</surname><given-names>D.</given-names></name><name><surname>Sher</surname><given-names>A.</given-names></name><name><surname>Litke</surname><given-names>A. M.</given-names></name><name><surname>Chichilnisky</surname><given-names>E. J.</given-names></name></person-group> (<year>2006</year>). <article-title>The structure of multi-neuron firing patterns in primate retina</article-title>. <source>J. Neurosci.</source><volume>26</volume>, <fpage>8254</fpage>&#x02013;<lpage>8266</lpage><pub-id pub-id-type="doi">10.1523/JNEUROSCI.1282-06.2006</pub-id><pub-id pub-id-type="pmid">16899720</pub-id></citation></ref><ref id="B15"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Spacek</surname><given-names>M. A.</given-names></name><name><surname>Blanche</surname><given-names>T. J.</given-names></name><name><surname>Seamans</surname><given-names>J. K.</given-names></name><name><surname>Swindale</surname><given-names>N. V.</given-names></name></person-group> (<year>2007</year>). <article-title>Accounting for network states in cortex: are (local) pairwise correlations sufficient?</article-title><source>Soc. Neurosci. Abstr.</source><volume>33</volume>, <fpage>790.1.</fpage><uri xlink:type="simple" xlink:href="http://swindale.ecc.ubc.ca/Publications">http://swindale.ecc.ubc.ca/Publications</uri></citation></ref><ref id="B16"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Straw</surname><given-names>A. D.</given-names></name></person-group> (<year>2008</year>). <article-title>Vision Egg: an open-source library for realtime visual stimulus generation</article-title>. <source>Front. Neuroinform.</source><volume>2</volume>, <fpage>4</fpage><pub-id pub-id-type="doi">10.3389/neuro.11.004.2008</pub-id></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Teeters</surname><given-names>J. L.</given-names></name><name><surname>Harris</surname><given-names>K. D.</given-names></name><name><surname>Millman</surname><given-names>K. J.</given-names></name><name><surname>Olshausen</surname><given-names>B. A.</given-names></name><name><surname>Sommer</surname><given-names>F. T.</given-names></name></person-group> (<year>2008</year>). <article-title>Data sharing for computational neuroscience</article-title>. <source>Neuroinformatics</source><volume>6</volume>, <fpage>47</fpage>&#x02013;<lpage>55</lpage><pub-id pub-id-type="doi">10.1007/s12021-008-9009-y</pub-id><pub-id pub-id-type="pmid">18259695</pub-id></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>VanRullen</surname><given-names>R.</given-names></name><name><surname>Thorpe</surname><given-names>S. J.</given-names></name></person-group> (<year>2002</year>). <article-title>Surfing a spike wave down the ventral stream</article-title>. <source>Vis. Res.</source><volume>42</volume>, <fpage>2593</fpage>&#x02013;<lpage>2615</lpage><pub-id pub-id-type="doi">10.1016/S0042-6989(02)00298-5</pub-id><pub-id pub-id-type="pmid">12446033</pub-id></citation></ref><ref id="B19"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Williams</surname><given-names>P. E.</given-names></name><name><surname>Mechler</surname><given-names>F.</given-names></name><name><surname>Gordon</surname><given-names>J.</given-names></name><name><surname>Shapley</surname><given-names>R.</given-names></name><name><surname>Hawken</surname><given-names>M. J.</given-names></name></person-group> (<year>2004</year>). <article-title>Entrainment to video displays in primary visual cortex of macaque and humans</article-title>. <source>J. Neurosci.</source><volume>24</volume>, <fpage>8278</fpage>&#x02013;<lpage>8288</lpage><pub-id pub-id-type="doi">10.1523/JNEUROSCI.2716-04.2004</pub-id><pub-id pub-id-type="pmid">15385611</pub-id></citation></ref><ref id="B20"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Wollman</surname><given-names>D. E.</given-names></name><name><surname>Palmer</surname><given-names>L. A.</given-names></name></person-group> (<year>1995</year>). <article-title>Phase locking of neuronal responses to the vertical refresh of computer display monitors in cat lateral geniculate nucleus and striate cortex</article-title>. <source>J. Neurosci. Methods</source><volume>60</volume>, <fpage>107</fpage>&#x02013;<lpage>113</lpage><pub-id pub-id-type="doi">10.1016/0165-0270(94)00226-7</pub-id><pub-id pub-id-type="pmid">8544468</pub-id></citation></ref></ref-list><fn-group><fn id="fn1"><p><sup>1</sup><monospace><uri xlink:type="simple" xlink:href="http://numpy.org">http://numpy.org</uri></monospace></p></fn><fn id="fn2"><p><sup>2</sup><monospace><uri xlink:type="simple" xlink:href="http://visionegg.org">http://visionegg.org</uri></monospace></p></fn><fn id="fn3"><p><sup>3</sup><monospace><uri xlink:type="simple" xlink:href="http://opengl.org">http://opengl.org</uri></monospace></p></fn><fn id="fn4"><p><sup>4</sup><monospace><uri xlink:type="simple" xlink:href="http://freenet.org.nz/y4m">http://freenet.org.nz/y4m</uri></monospace></p></fn><fn id="fn5"><p><sup>5</sup><monospace><uri xlink:type="simple" xlink:href="http://wxpython.org">http://wxpython.org</uri></monospace></p></fn><fn id="fn6"><p><sup>6</sup><monospace><uri xlink:type="simple" xlink:href="http://wxglade.sf.net">http://wxglade.sf.net</uri></monospace></p></fn><fn id="fn7"><p><sup>7</sup><monospace>See bugs #626 and #2307 at <uri xlink:type="simple" xlink:href="http://trac.wxwidgets.org">http://trac.wxwidgets.org</uri></monospace></p></fn><fn id="fn8"><p><sup>8</sup><monospace><uri xlink:type="simple" xlink:href="http://matplotlib.sf.net">http://matplotlib.sf.net</uri></monospace></p></fn><fn id="fn9"><p><sup>9</sup><monospace><uri xlink:type="simple" xlink:href="http://cython.org">http://cython.org</uri></monospace></p></fn><fn id="fn10"><p><sup>10</sup><monospace><uri xlink:type="simple" xlink:href="http://scipy.org">http://scipy.org</uri></monospace></p></fn><fn id="fn11"><p><sup>11</sup><monospace><uri xlink:type="simple" xlink:href="http://mlabwrap.sf.net">http://mlabwrap.sf.net</uri></monospace></p></fn><fn id="fn12"><p><sup>12</sup><monospace><uri xlink:type="simple" xlink:href="http://ipython.scipy.org">http://ipython.scipy.org</uri></monospace></p></fn></fn-group></back></article>