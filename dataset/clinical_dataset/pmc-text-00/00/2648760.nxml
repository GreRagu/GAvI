<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208182</article-id><article-id pub-id-type="pmc">2648760</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S9</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S9</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Sorting by reversals, block interchanges, tandem duplications, and deletions</article-title></title-group><contrib-group><contrib id="A1" corresp="yes" contrib-type="author"><name><surname>Bader</surname><given-names>Martin</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>martin.bader@uni-ulm.de</email></contrib></contrib-group><aff id="I1"><label>1</label>Institute of Theoretical Computer Science, University of Ulm, 89069 Ulm, Germany</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S9</fpage><lpage>S9</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S9"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Bader; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Bader; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Bader               Martin                              martin.bader@uni-ulm.de            </dc:author><dc:title>            Sorting by reversals, block interchanges, tandem duplications, and deletions         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S9-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S9&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>Finding sequences of evolutionary operations that transform one genome into another is a classic problem in comparative genomics. While most of the genome rearrangement algorithms assume that there is exactly one copy of each gene in both genomes, this does not reflect the biological reality very well &#x02013; most of the studied genomes contain duplicated gene content, which has to be removed before applying those algorithms. However, dealing with unequal gene content is a very challenging task, and only few algorithms allow operations like duplications and deletions. Almost all of these algorithms restrict these operations to have a fixed size.</p></sec><sec><title>Results</title><p>In this paper, we present a heuristic algorithm to sort an ancestral genome (with unique gene content) into a genome of a descendant (with arbitrary gene content) by reversals, block interchanges, tandem duplications, and deletions, where tandem duplications and deletions are of arbitrary size.</p></sec><sec><title>Conclusion</title><p>Experimental results show that our algorithm finds sorting sequences that are close to an optimal sorting sequence when the ancestor and the descendant are closely related. The quality of the results decreases when the genomes get more diverged or the genome size increases. Nevertheless, the calculated distances give a good approximation of the true evolutionary distances.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>During evolution, genomes are subject to genome rearrangements, which are large scale mutations that can alter the ordering and orientation (strandedness) of the genes on the chromosomes or even change the genome content by inserting, deleting, or duplicating genes. Because these events are rare compared to point mutations, they can give us valuable information about ancient events in the evolutionary history of organisms. For this reason, one is interested in the most "plausible" genome rearrangement scenario between two genomes. More precisely, given two genomes, one wants to find an optimal (shortest) sequence of rearrangements that transforms this genome into the other. In the classical approach, each gene has exactly one copy in each genome, and only operations that do not change the genome content are considered. These "classical operations" are nowadays a well-studied subject, where the most important operations are <italic>reversals </italic>(also called <italic>inversions</italic>), where a section of the genome is excised, reversed in orientation, and reinserted, and <italic>transpositions</italic>, where a section of the genome is excised and reinserted at a new position in the genome. While the problem of <italic>Sorting by reversals </italic>can be solved in polynomial time [<xref ref-type="bibr" rid="B1">1</xref>-<xref ref-type="bibr" rid="B3">3</xref>], and the reversal distance can be determined in linear time [<xref ref-type="bibr" rid="B4">4</xref>], the problem gets more complicated if one also considers transpositions, and there are only approximation algorithms known [<xref ref-type="bibr" rid="B5">5</xref>-<xref ref-type="bibr" rid="B7">7</xref>]. To simplify the existing algorithms, Yancopoulos et al. invented the <italic>double cut and join </italic>operator, which can simulate reversals and block interchanges (a more generalized form of a transposition), resulting in a simple and efficient algorithm [<xref ref-type="bibr" rid="B8">8</xref>].</p><p>However, restricting the genes to be unique in each genome does not reflect the biological reality very well, as in most genomes that have been studied, there are some genes that are present in two or more copies. This holds especially for the genomes of plants, and one of the most prominent genomes is the one of the flowering plant <italic>Arabidopsis thaliana</italic>, where large segments of the genome have been duplicated (see e.g. [<xref ref-type="bibr" rid="B9">9</xref>]). There are various evolutionary events that can change the content of the genome, like duplications of single genes, horizontal gene transfer, or tandem duplications. For a nice overview in the context of comparative genomics, see [<xref ref-type="bibr" rid="B10">10</xref>]. From an algorithmic point of view, the existence of duplicated genes complicates many existing algorithms, for example the problem of sorting arbitrary strings by reversals [<xref ref-type="bibr" rid="B11">11</xref>] and the problem of sorting by reversals and duplications [<xref ref-type="bibr" rid="B12">12</xref>] have been proven to be NP-hard. So far, most of the existing algorithms restrict duplications to have a fixed length [<xref ref-type="bibr" rid="B13">13</xref>], or simulate duplications by arbitrary insertions [<xref ref-type="bibr" rid="B14">14</xref>-<xref ref-type="bibr" rid="B16">16</xref>]. Even with these restrictions, it is hard to solve most of the problems exactly, and heuristics have to be used.</p><sec><title>Related work</title><p>While genome rearrangement problems without duplications is a well studied subject, considering genomes with duplicated genes is a rather new field of research. One of the first works on this topic was done by Sankoff [<xref ref-type="bibr" rid="B17">17</xref>], where the following problem was examined. Given two genomes with duplicated genes, identify in both genomes the "true exemplars" of each gene and remove all other genes, such that the rearrangement distance between these modified genomes is minimized. This approach minimizes the number of classical rearrangement operations, but not the one of duplications and deletions. In the work of El-Mabrouk [<xref ref-type="bibr" rid="B18">18</xref>], for a given genome with duplicated gene content, one searches for a hypothetical ancestor with unique gene content such that the reversal and duplication distance towards this ancestor is minimized. Bertrand et al. [<xref ref-type="bibr" rid="B13">13</xref>] developed an algorithm for the following problem. Given two genomes with duplicated gene content, find a hypothetical ancestor such that the sum of the reversal and duplication distance of both genomes to this ancestor is minimized. However, in this work, duplications are restricted to have the length of one marker, i.e. a duplication can only duplicate segments that are identical in the initial genomes. Therefore, this approach is disadvantageous if large segmental duplications happened during evolution. Fu et al. extended this approach to the greedy algorithm MSOAR for assigning orthologous genes, which works well in practice [<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B19">19</xref>]. Other approaches [<xref ref-type="bibr" rid="B14">14</xref>-<xref ref-type="bibr" rid="B16">16</xref>] simulate duplications by arbitrary insertions. Recently, Yancopoulos and Friedberg provided a mathematical model of a genome rearrangement distance for genomes with unequal gene content [<xref ref-type="bibr" rid="B20">20</xref>], combining the DCJ operator [<xref ref-type="bibr" rid="B8">8</xref>] with arbitrary but length-weighted insertions and deletions. Another field of research is the "Genome halving problem", where a rearrangement scenario consists of a whole genome duplication followed by a series of classical rearrangement operations. It has been studied first for reversals and translocations [<xref ref-type="bibr" rid="B21">21</xref>,<xref ref-type="bibr" rid="B22">22</xref>] and recently has been extended to the double cut and join operator [<xref ref-type="bibr" rid="B23">23</xref>,<xref ref-type="bibr" rid="B24">24</xref>].</p><p>To the best of our knowledge, the only approach that creates a rearrangement scenario between two genomes, consisting of duplications of arbitrary length and classical genome rearrangements, is the one of Ozery-Flato and Shamir [<xref ref-type="bibr" rid="B25">25</xref>]. They use a greedy algorithm that starts with one genome and in each step applies the simplest and most evident operation that brings this genome closer to the target genome. If there is no evident operation, the algorithm aborts. Although this approach fails on complicated rearrangement scenarios, they were able to find rearrangement scenarios for more than 98% of the karyotypes in the "Mitelman database of chromosome aberrations in cancer" [<xref ref-type="bibr" rid="B26">26</xref>].</p></sec><sec><title>Our contribution</title><p>In this paper, we will focus on the following problem. Given an ancestral genome with unique gene content and the genome of a descendant with arbitrary gene content, find the shortest sequence of reversals, block interchanges, tandem duplications, and deletions that transforms the ancient genome into the one of the descendant. In contrast to most of the previous works, tandem duplications and deletions can be of arbitrary length. We developed a lower bound for the distance, and a heuristic greedy algorithm based on this lower bound. The approach can be extended to also include general duplications and insertions of single elements, as described in Section "Discussion". Experimental results on simulated data show that our algorithm works well in practice.</p></sec></sec><sec><title>Results</title><sec><title>Preliminaries</title><p>A <italic>genome &#x003c0; </italic>= (<italic>&#x003c0;</italic><sub>1 </sub>... <italic>&#x003c0;</italic><sub><italic>n</italic></sub>) is a string over the alphabet {1, ..., <italic>n</italic>}, where each element may have a positive or negative orientation (indicated by <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S9-i1" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> or <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S9-i2" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02190;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>). An <italic>augmented genome </italic>is a genome where the element <italic>&#x003c0;</italic><sub>0 </sub>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S9-i3" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mn>0</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> is added at the beginning and the element <italic>&#x003c0;</italic><sub><italic>n</italic>+1 </sub>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S9-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">&#x02192;</mml:mo></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula> is added at the end. As our algorithm works on augmented genomes, we will use the term "genome" as short hand for augmented genome. The genome <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S9-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mn>0</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>1</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>&#x022ef;</mml:mo><mml:mover accent="true"><mml:mi>n</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">&#x02192;</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> is called the <italic>identity genome id</italic>. The <italic>multiplicity </italic>of an element is the number of its occurrences (with arbitrary orientation) in <italic>&#x003c0;</italic>. Two consecutive elements <italic>&#x003c0;</italic><sub><italic>i </italic></sub><italic>&#x003c0;</italic><sub><italic>i</italic>+1 </sub>form an <italic>adjacency </italic>if <italic>&#x003c0;</italic><sub><italic>i </italic></sub>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S9-i1" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> and <italic>&#x003c0;</italic><sub><italic>i</italic>+1 </sub>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S9-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">&#x02192;</mml:mo></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula>, or if <italic>&#x003c0;</italic><sub><italic>i </italic></sub>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S9-i2" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02190;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> and <italic>&#x003c0;</italic><sub><italic>i</italic>+1 </sub>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S9-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">&#x02190;</mml:mo></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula>. Otherwise, they form a <italic>breakpoint</italic>. A <italic>segment &#x003c0;</italic><sub><italic>i </italic></sub>... <italic>&#x003c0;</italic><sub><italic>j </italic></sub>(with <italic>i </italic>&#x02264; <italic>j</italic>) of a genome <italic>&#x003c0; </italic>is a consecutive sequence of elements in <italic>&#x003c0;</italic>, with <italic>&#x003c0;</italic><sub><italic>i </italic></sub>as first element and <italic>&#x003c0;</italic><sub><italic>j </italic></sub>as last element. A <italic>genome rearrangement problem </italic>is defined as follows. Given two genomes <italic>&#x003c0;</italic>' and <italic>&#x003c0; </italic>and a set of possible operations, where each operation is assigned a weight, find a sequence of minimum weight that transforms <italic>&#x003c0;</italic>' into <italic>&#x003c0;</italic>. This minimum weight will be denoted by <italic>d</italic>(<italic>&#x003c0;</italic>', <italic>&#x003c0;</italic>). In our algorithm, we will restrict the set of operations to <italic>reversals, deletions, tandem duplications </italic>(all of weight 1), and <italic>block interchanges </italic>(of weight 2), as defined in the next subsection. For simplification, we will also assume that <italic>&#x003c0;</italic>' = <italic>id</italic>, i.e. we search for a sequence of operations that transforms the identity genome into <italic>&#x003c0;</italic>, and we write <italic>d</italic>(<italic>&#x003c0;</italic>) as short hand for <italic>d</italic>(<italic>id</italic>, <italic>&#x003c0;</italic>).</p></sec><sec><title>Operations</title><p>In our algorithm, we will restrict the set of operations to the following four types of operations. A <italic>reversal rev</italic>(<italic>i</italic>, <italic>j</italic>) (with 0 &#x0003c;<italic>i </italic>&#x0003c;<italic>j </italic>&#x0003c;<italic>n </italic>+ 1) is an operation that inverts the the order of the elements of the segment <italic>&#x003c0;</italic><sub><italic>i </italic></sub>... <italic>&#x003c0;</italic><sub><italic>j</italic>-1</sub>. Additionally, the orientation of every element in the segment is flipped. A <italic>block interchange bi</italic>(<italic>i</italic>, <italic>j</italic>, <italic>k</italic>, <italic>l</italic>) (with 0 &#x0003c;<italic>i </italic>&#x02264; <italic>j </italic>&#x02264; <italic>k </italic>&#x02264; <italic>l </italic>&#x0003c;<italic>n </italic>+ 1) is an operation that changes the positions of the segments <italic>&#x003c0;</italic><sub><italic>i </italic></sub>... <italic>&#x003c0;</italic><sub><italic>j</italic>-1 </sub>and <italic>&#x003c0;</italic><sub><italic>k </italic></sub>... <italic>&#x003c0;</italic><sub><italic>l</italic>-1 </sub>in <italic>&#x003c0;</italic>. A <italic>tandem duplication td</italic>(<italic>i</italic>, <italic>j</italic>) (with 0 &#x0003c;<italic>i </italic>&#x0003c;<italic>j </italic>&#x0003c;<italic>n </italic>+ 1) is an operation that adds a copy of the segment <italic>&#x003c0;i </italic>... <italic>&#x003c0;</italic><sub><italic>j</italic>-1 </sub>before the element <italic>&#x003c0;</italic><sub><italic>j</italic></sub>. A <italic>deletion del</italic>(<italic>i</italic>, <italic>j</italic>) (with 0 &#x0003c;<italic>i </italic>&#x0003c;<italic>j </italic>&#x0003c;<italic>n </italic>+ 1) cuts the segment <italic>&#x003c0;</italic><sub><italic>i </italic></sub>... <italic>&#x003c0;</italic><sub><italic>j</italic>-1 </sub>out of <italic>&#x003c0;</italic>.</p><p>We will use the double cut and join operator (short DCJ) to simulate reversals and transpositions. A <italic>double cut and join DCJ</italic>(<italic>i</italic>, <italic>j</italic>, <italic>x</italic>) (with 0 &#x0003c;<italic>i </italic>&#x0003c;<italic>j </italic>&#x0003c;<italic>n </italic>+ 1 and <italic>x </italic>&#x02208; {+, -}) cuts the genome <italic>&#x003c0; </italic>before the elements <italic>&#x003c0;</italic><sub><italic>i </italic></sub>and <italic>&#x003c0;</italic><sub><italic>j </italic></sub>(i.e. we get the segments <italic>&#x003c0;</italic><sub>0 </sub>... <italic>&#x003c0;</italic><sub><italic>i</italic>-1</sub>, <italic>&#x003c0;</italic><sub><italic>i </italic></sub>... <italic>&#x003c0;</italic><sub><italic>j</italic>-1</sub>, and <italic>&#x003c0;</italic><sub><italic>j </italic></sub>... <italic>&#x003c0;</italic><sub><italic>n</italic>+1</sub>), and rejoins the cut ends in two new pairs. If <italic>x </italic>= +, we rejoin such that the elements <italic>&#x003c0;</italic><sub><italic>i</italic>-1 </sub>and <italic>&#x003c0;</italic><sub><italic>j</italic>-1 </sub>as well as the elements <italic>&#x003c0;</italic><sub><italic>i </italic></sub>and <italic>&#x003c0;</italic><sub><italic>j</italic>-1 </sub>become adjacent. This is equivalent to a the reversal of the segment <italic>&#x003c0;</italic><sub><italic>i </italic></sub>... <italic>&#x003c0;</italic><sub><italic>j</italic>-1</sub>, i.e. <italic>DCJ</italic>(<italic>i</italic>, <italic>j</italic>, +) = <italic>rev</italic>(<italic>i</italic>, <italic>j</italic>). If <italic>x </italic>= -, we rejoin such that the elements <italic>&#x003c0;</italic><sub><italic>i</italic>-1 </sub>and <italic>&#x003c0;</italic><sub><italic>j </italic></sub>as well as the elements <italic>&#x003c0;</italic><sub><italic>i </italic></sub>and <italic>&#x003c0;</italic><sub><italic>j</italic>-1 </sub>become adjacent. This cuts the genome into the linear genome <italic>&#x003c0;</italic><sub>0 </sub>... <italic>&#x003c0;</italic><sub><italic>i</italic>-1 </sub><italic>&#x003c0;</italic><sub><italic>j </italic></sub>... <italic>&#x003c0;</italic><sub><italic>n</italic>+1 </sub>and the circular genome ... <italic>&#x003c0;</italic><sub><italic>j</italic>-2 </sub><italic>&#x003c0;</italic><sub><italic>j</italic>-1 </sub><italic>&#x003c0;</italic><sub><italic>i </italic></sub><italic>&#x003c0;</italic><sub><italic>i</italic>+1 </sub>.... This circular genome can be absorbed by applying another DCJ with one cutting point in the linear genome and the other cutting point in the circular genome. Depending on how we rejoin, those two DCJs are equivalent to either two consecutive reversals or to one block interchange. Thus, we can reduce the set of operations to DCJs, tandem duplications, and deletions, provided that we demand that circular genomes must be absorbed in the next step.</p></sec><sec><title>The breakpoint graph</title><p>Our main tool for visualization is the breakpoint graph. This graph has been introduced by Bafna and Pevzner to solve rearrangement problems on genomes without duplicated genes [<xref ref-type="bibr" rid="B27">27</xref>]. We extend this graph such that it can also be used for genomes with duplicated genes. The breakpoint graph of a genome <italic>&#x003c0; </italic>can be constructed as follows. First, we write the set of vertices {+0, -1, +1, -2, +2, ..., -<italic>n</italic>, +<italic>n</italic>, -(<italic>n </italic>+ 1)} from left to right on a straight line. Second, we add a <italic>reality edge </italic>(+<italic>i</italic>, -(<italic>i </italic>+ 1)) for each <italic>i </italic>&#x02208; [0, <italic>n</italic>]. Third, we add a <italic>desire edge </italic>(<italic>v</italic>, <italic>v'</italic>) for each <italic>i </italic>&#x02208; [0, <italic>n</italic>], where <italic>v </italic>= +<italic>&#x003c0;</italic><sub><italic>i </italic></sub>if <italic>&#x003c0;</italic><sub><italic>i </italic></sub>has a positive orientation, <italic>v </italic>= -<italic>&#x003c0;</italic><sub><italic>i </italic></sub>otherwise, and <italic>v' </italic>= -<italic>&#x003c0;</italic><sub><italic>i</italic>+1 </sub>if <italic>&#x003c0;</italic><sub><italic>i</italic>+1 </sub>has a positive orientation, <italic>v' </italic>= +<italic>&#x003c0;</italic><sub><italic>i</italic>+1 </sub>otherwise. For better readability, we draw reality edges as straight lines and desire edges as arcs. For an example, see Fig. <xref ref-type="fig" rid="F1">1</xref>. In contrast to the original breakpoint graph, each vertex can be the endpoint of several desire edges. In fact, the number of desire edges connected to a vertex +<italic>x </italic>or -<italic>x </italic>is exactly the multiplicity of the element <italic>x </italic>in <italic>&#x003c0;</italic>. The <italic>multiplicity </italic>of an edge (<italic>v</italic>, <italic>v'</italic>) is the number of desire edges between <italic>v </italic>and <italic>v'</italic>. A desire edge (<italic>v</italic>, <italic>v</italic>) is called a <italic>loop</italic>. Let <italic>S</italic>(<italic>&#x003c0;</italic>) denote the number of vertices with a loop. Two vertices <italic>v</italic>, <italic>v' </italic>are in the same <italic>componen</italic>t of the graph if and only if there is a path (consisting of reality edges and desire edges) from v to <italic>v'</italic>. Let <italic>C</italic>(<italic>&#x003c0;</italic>) denote the number of components in the breakpoint graph of <italic>&#x003c0;</italic>. An edge is called a <italic>1-bridge </italic>if the removal of this edge increases <italic>C</italic>(<italic>&#x003c0;</italic>). A pair of edges is called a <italic>2-bridge </italic>if none of the edges is a 1-bridge and the removal of both edges increases <italic>C</italic>.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>The breakpoint graph</bold>. The breakpoint graph of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S9-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mn>0</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>1</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>3</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>3</mml:mn><mml:mo>&#x02190;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>5</mml:mn><mml:mo>&#x02190;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>4</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>3</mml:mn><mml:mo>&#x02190;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>5</mml:mn><mml:mo>&#x02190;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>4</mml:mn><mml:mo>&#x02190;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>3</mml:mn><mml:mo>&#x02190;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>6</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. The edge (-3, +5) has a multiplicity of 2, all other edges have a multiplicity of 1. The edge (+3, +3) is a loop. The breakpoint graph consists of three components, the edge (+1, -3) is a 1-bridge, and the pair of edges (+3, +4), (-4, -5) is a 2-bridge.</p></caption><graphic xlink:href="1471-2105-10-S1-S9-1"/></fig><p>Note that two different genomes can have the same breakpoint graph, like e.g. <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S9-i9" overflow="scroll"><mml:semantics><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mn>0</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>1</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>2</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>1</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>3</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S9-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mn>0</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>1</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>2</mml:mn><mml:mo>&#x02190;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>1</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mn>3</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. However, this will not cause problems in our algorithm, because we use the identity genome as ancestral genome, which has a unique breakpoint graph.</p></sec><sec><title>A lower bound</title><p>Instead of searching for a sequence of operations <italic>op</italic><sub>1</sub>, ..., <italic>op</italic><sub><italic>k </italic></sub>that sorts <italic>id </italic>into <italic>&#x003c0;</italic>, one can also search for the inverse sequence <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-S1-S9-i11" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>o</mml:mi><mml:msubsup><mml:mi>p</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>&#x022ef;</mml:mo><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:msubsup><mml:mi>p</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> that sorts <italic>&#x003c0; </italic>into <italic>id</italic>. This is more convenient, as it is easier to track the changes in the breakpoint graph caused by the performed operations (remember that the reality edges are defined as the adjacencies in the identity genome). Thus, we only apply inverse operations, i.e. we sort a genome <italic>&#x003c0; </italic>into <italic>id </italic>by DCJs, inverse tandem duplications, and inverse deletions. Note that the inverse of a DCJ is still a DCJ, while an inverse deletion is an insertion. To keep our original problem in mind, we will use the term "inverse deletion" and not "insertion".</p><p><bold>Lemma 1</bold>. <italic>The breakpoint graph of the identity genome has n </italic>+ 1 <italic>components and no loops. No breakpoint graph has more components. If a breakpoint graph has n </italic>+ 1 <italic>components, it is the breakpoint graph of the identity genome if and only if it has no loops</italic>.</p><p><italic>Proof</italic>. The first statement is easy to verify. As each vertex is connected with another vertex by a reality edge, the maximum possible number of components in the breakpoint graph is <italic>n </italic>+ 1. If a genome is not the <italic>id</italic>, it must contain a breakpoint. The desire edge corresponding to this breakpoint either is a loop, or it connects two vertices that are not connected by a reality edge. In the latter case, the breakpoint graph contains a component with at least 4 vertices and therefore cannot have <italic>n </italic>+ 1 components.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><p>We will now examine how an operation can change the number of components and loops.</p><sec><title>DCJ</title><p>A DCJ cuts the genome at two positions, and rejoins the cut ends. This has the following effect on the breakpoint graph. Two desire edges (<italic>u</italic>, <italic>v</italic>) and (<italic>w</italic>, <italic>x</italic>) are removed, and w.l.o.g. the desire edges (<italic>u</italic>, <italic>w</italic>) and (<italic>v</italic>, <italic>x</italic>) are added to the breakpoint graph. This can increase <italic>C </italic>by at most 1. If one of the removed edges is a loop, all three vertices are in the same component after the operation, i.e. <italic>C </italic>will not be increased by this operation. As a DCJ removes only two edges, <italic>S </italic>can be decreased by at most 2.</p></sec><sec><title>Inverse tandem duplication</title><p>An inverse tandem duplication deletes the following desire edges. (a) Edges that are inside the duplicated segment. All these edges have a multiplicity &#x02265; 2, thus deleting these edges neither changes <italic>C </italic>nor <italic>S</italic>. (b) The edge between the last node of the segment and the first node of the copy. This can increase <italic>C </italic>by 1, or decrease <italic>S </italic>by 1 (but not both).</p></sec><sec><title>Inverse deletion</title><p>An inverse deletion splits the genome at one position and adds arbitrary elements. In the breakpoint graph, one desire edge is removed and several desire edges are added. Therefore, a deletion can increase <italic>C </italic>by at most 1 or decrease <italic>S </italic>by at most 1. As <italic>C </italic>can only be decreased if the removed edge is a 1-bridge, an inverse deletion cannot increase <italic>C </italic>and decrease <italic>S</italic>.</p><p><bold>Theorem 1</bold>. <italic>A lower bound lb</italic>(<italic>&#x003c0;</italic>) <italic>of the distance d</italic>(<italic>&#x003c0;</italic>) <italic>is</italic></p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-10-S1-S9-i12" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mi>d</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>&#x003c0;</mml:mi>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>&#x02265;</mml:mo>                              <mml:mi>l</mml:mi>                              <mml:mi>b</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>&#x003c0;</mml:mi>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>=</mml:mo>                              <mml:mi>n</mml:mi>                              <mml:mo>+</mml:mo>                              <mml:mn>1</mml:mn>                              <mml:mo>&#x02212;</mml:mo>                              <mml:mi>C</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>&#x003c0;</mml:mi>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>+</mml:mo>                              <mml:mstyle displaystyle="true">                                 <mml:munder>                                    <mml:mo>&#x02211;</mml:mo>                                    <mml:mrow>                                       <mml:mi>C</mml:mi>                                       <mml:mi>o</mml:mi>                                       <mml:mi>m</mml:mi>                                       <mml:mi>p</mml:mi>                                       <mml:mi>o</mml:mi>                                       <mml:mi>n</mml:mi>                                       <mml:mi>e</mml:mi>                                       <mml:mi>n</mml:mi>                                       <mml:mi>t</mml:mi>                                       <mml:mi>s</mml:mi>                                    </mml:mrow>                                 </mml:munder>                                 <mml:mrow>                                    <mml:mrow>                                       <mml:mo>&#x02308;</mml:mo>                                       <mml:mrow>                                          <mml:mfrac>                                             <mml:mrow>                                                <mml:msub>                                                   <mml:mi>S</mml:mi>                                                   <mml:mi>i</mml:mi>                                                </mml:msub>                                             </mml:mrow>                                             <mml:mn>2</mml:mn>                                          </mml:mfrac>                                       </mml:mrow>                                       <mml:mo>&#x02309;</mml:mo>                                    </mml:mrow>                                 </mml:mrow>                              </mml:mstyle>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p><italic>where S</italic><sub><italic>i </italic></sub><italic>is the number of vertices with a loop in component C</italic><sub><italic>i</italic></sub>.</p><p><italic>Proof</italic>. Operations that increase <italic>C</italic>(<italic>&#x003c0;</italic>) by 1 or decrease <italic>S</italic>(<italic>&#x003c0;</italic>) by 1 decrease the lower bound at most by 1. For an operation that remove two loops, there are two cases. (a) It acts on two loops of the same component <italic>C</italic><sub><italic>i</italic></sub>. This decreases <italic>S</italic><sub><italic>i </italic></sub>by 2 and the lower bound is decreased by 1. (b) It acts on two loops in two components <italic>C</italic><sub><italic>i </italic></sub>and <italic>C</italic><sub><italic>j</italic></sub>. This can decrease two of the summands by 1, but the components <italic>C</italic><sub><italic>i </italic></sub>and <italic>C</italic><sub><italic>j </italic></sub>are merged and <italic>C </italic>is decreased by 1, thus the lower bound is decreased by at most 1.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p></sec></sec><sec><title>The algorithm</title><p>The algorithm uses a greedy strategy to sort the genome. In each step, it searches for operations that decrease the lower bound, i.e. we search for operations that increase <italic>C </italic>or decrease <italic>S</italic>, and check their effect on the lower bound. If there is no such operation, we will use additional heuristics to search for small sequences of operations that bring us closer to our goal. The main idea behind these heuristics is to reduce the number of missing elements and duplicates and to create adjacencies.</p></sec><sec><title>Operations that decrease the lower bound</title><p>As a DCJ removes two desire edges and rejoins the endpoints with two new desire edges, it can only increase <italic>C </italic>if the removed desire edges are a 2-bridge, or two 1-bridges in the same component. If the DCJ rejoins the endpoints such that we get a linear and a circular genome, we need a lookahead to search for another DCJ that absorbs this DCJ. Those two DCJs are directly merged into two reversals or one block interchange with a weight of 2. Inverse tandem duplications can only remove one desire edge with a multiplicity of 1 (the one between the duplicated segments), thus an inverse tandem duplication can increase <italic>C </italic>only if this edge is a 1-bridge. Additionally, one has to check whether the segments on both sides of the cutting point are identical. Inverse deletions just remove one desire edge, thus also an inverse deletion can increase <italic>C </italic>only if the removed edge is a 1-bridge. Additionally, one has to check whether there is a segment that can be inserted such that no desire edge in the inserted segment merges two components. Although there is such a segment in most cases, practical tests have shown that it is better to only insert segments that have no breakpoints, i.e. we perform only an inverse deletion if the breakpoint is of the form <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-10-S1-S9-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula> or <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1471-2105-10-S1-S9-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo>&#x02190;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02190;</mml:mo></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula> with <italic>x </italic>&#x0003c;<italic>y</italic>. In summary, the main task in finding operations that increase <italic>C </italic>is to find 1-bridges and 2-bridges in the breakpoint graph, which can be done very efficiently by following the algorithm devised in [<xref ref-type="bibr" rid="B28">28</xref>].</p><p>Finding operations that decrease <italic>S </italic>is rather straightforward, as we just have to scan the breakpoint graph for loops with a multiplicity of 1 and find the corresponding position in the genome. An operation that decreases <italic>S </italic>can be an inverse tandem duplication or an inverse deletion that removes this loop, or a DCJ that removes two loops with a multiplicity of 1, or a DCJ on a loop and another desire edge of the same component.</p></sec><sec><title>Heuristics for the remaining cases</title><p>If there is no operation that decreases the lower bound, one heuristic would be to decrease the number of duplicated elements without increasing the lower bound. If there are two consecutive copies of the same segment, we can remove one of them by an inverse tandem duplication. As an inverse tandem duplication only removes desire edges, it can never increase the lower bound. This is different in the general case of an inverse duplication, where the duplicated segments are separated by a non-empty segment in the genome. In this case, the removal of one of these segments (which can be simulated by a block interchange and an inverse tandem duplication) creates a new desire edge between the last element before the removed segment and the first element after the removed segment. If the corresponding vertices in the breakpoint graph are in different components, or if they are identical and the new desire edge would increase &#x0230a;<italic>S</italic><sub><italic>i</italic></sub>/2&#x0230b; of this component, the operation would increase the lower bound, i.e. we cannot easily provide a sequence of operations that removes one of the duplicated segments and does not increase the lower bound. However, the situation is different if we have at least three copies of the segment.</p><p><bold>Lemma 2</bold>. <italic>If there are three identical copies of a segment that are maximal (i.e. they cannot be extended in any direction such that still all three copies are identical), then there exists a sequence of operations that removes two of these copies and does not increase the lower bound</italic>.</p><p><italic>Proof</italic>. Let <italic>a </italic>be the vertex corresponding to the leftmost element of the segment, and let <italic>b </italic>be the vertex corresponding to the rightmost vertex of the segment. There are reality edges (<italic>v</italic><sub>1</sub>, <italic>a</italic>) and (<italic>b</italic>, <italic>w</italic><sub>1</sub>), (v<sub>2</sub>, <italic>a</italic>) and (<italic>b</italic>, <italic>w</italic><sub>2</sub>), and (<italic>v</italic><sub>3</sub>, <italic>a</italic>) and (<italic>b</italic>, <italic>w</italic><sub>3</sub>) (from the elements enclosing the first, second, and third copy of the segment). Because the segment is maximal, we can assume w.l.o.g. that <italic>w</italic><sub>1 </sub>&#x02260; <italic>w</italic><sub>2</sub>. As <italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>, and <italic>v</italic><sub>3 </sub>are all adjacent to <italic>a</italic>, they must be in the same component, as well as <italic>w</italic><sub>1</sub>, <italic>w</italic><sub>2</sub>, and <italic>w</italic><sub>3</sub>. By deleting the first two segments, we remove the desire edges (<italic>v</italic><sub>1</sub>, <italic>a</italic>), (<italic>b</italic>, <italic>w</italic><sub>1</sub>), (<italic>v</italic><sub>2</sub>, <italic>a</italic>), and (<italic>b</italic>, <italic>w</italic><sub>2</sub>), and get the new desire edges (<italic>v</italic><sub>1</sub>, <italic>w</italic><sub>1</sub>) and (<italic>v</italic><sub>2</sub>, <italic>w</italic><sub>2</sub>). If this merges two components, the new desire edges are a 2-bridge, and we can apply a DCJ that replaces them by the desire edges (<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) and (<italic>w</italic><sub>1</sub>, <italic>w</italic><sub>2</sub>). If <italic>v</italic><sub>1 </sub>= <italic>v</italic><sub>2 </sub>this can create a new loop. This loop can be removed by another DCJ between the edges (<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>) and (<italic>v</italic><sub>3</sub>, <italic>a</italic>) (note that <italic>v</italic><sub>3 </sub>&#x02260; <italic>v</italic><sub>1 </sub>because the segments are maximal, and <italic>v</italic><sub>1 </sub>&#x02260; <italic>a </italic>because otherwise the loop was already there before the operation). In fact, the operations of the sequence can be arranged such that all DCJs are reversals, so we do not have to find appropriate follow-ups. An illustration of the sequence is depicted in Fig. <xref ref-type="fig" rid="F2">2</xref>.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Sequences for elements with multiplicity = 3</bold>. An example for a sequence if an element &#x000d7; has a multiplicity &#x02265; 3. First, we remove two of the copies of <italic>x </italic>by two block interchanges and inverse tandem duplications. If this merges two components, the component can be cut by an additional reversal. For other orientations of the element <italic>x</italic>, similar sequences can be applied.</p></caption><graphic xlink:href="1471-2105-10-S1-S9-2"/></fig><p>We will now examine what we can do with elements with a multiplicity of at most 2. A first strategy would be to create adjacencies wherever this is possible without creating loops (note that creating adjacencies cannot decrease <italic>C</italic>). As a precondition, there must be a reality edge (<italic>a</italic>, <italic>b</italic>) and the desire edges (<italic>a</italic>, <italic>c</italic>) and (<italic>b</italic>, <italic>d</italic>) with <italic>c </italic>&#x02260; <italic>d</italic>.</p><p>If there are no further adjacencies to create, and all elements have a multiplicity of at most 2, all the possible cases for a reality edge and its adjacent desire edges are depicted in Fig. <xref ref-type="fig" rid="F3">3</xref>.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>The remaining cases</bold>. The different configurations in which each vertex is adjacent to at most two desire edges, and no adjacencies can be created without creating a loop. In all cases, the picture shows a reality edge (horizontal line) and its adjacent desire edges (all other lines).</p></caption><graphic xlink:href="1471-2105-10-S1-S9-3"/></fig><p><bold>Lemma 3</bold>. <italic>If all elements in &#x003c0; have a multiplicity &#x02264; </italic>2<italic>, and there is no DCJ that creates an adjacency without creating a loop, then there is a reality edge with adjacent desire edges corresponding to Case A, B, or C in Fig</italic>. <xref ref-type="fig" rid="F3">3</xref><italic>. For these cases, there is an operation or a sequence of operations that removes this configuration</italic>.</p><p><italic>Proof</italic>. If a reality edge and its adjacent desire edges correspond to Case D or E, then the reality edge starting at vertex <italic>a </italic>must correspond to Case C (this follows from the preconditions). Now, let us assume that all reality edges correspond to one of the Cases F and G. The elements adjacent to a reality edge of these cases occur either twice in the genome, or they do not occur at all. As we work with augmented genomes, there must be at least two elements that occur exactly once in the genome and have a breakpoint, otherwise the genome is the <italic>id</italic>. This is a contradiction to our assumption, therefore there must be at least one reality edge corresponding to Cases A, B, or C. We will now provide sequences for these cases.</p><sec><title>Case A</title><p>The genome is of the form <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17" name="1471-2105-10-S1-S9-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>&#x02026;</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>, the element <italic>x </italic>- 1 is missing. Let <italic>y </italic>be the largest element &#x0003c;<italic>x </italic>that is not missing. We apply an inverse deletion of the elements <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18" name="1471-2105-10-S1-S9-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">&#x02192;</mml:mo></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula> to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19" name="1471-2105-10-S1-S9-i17" overflow="scroll"><mml:semantics><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">&#x02192;</mml:mo></mml:mover></mml:mrow></mml:semantics></mml:math></inline-formula> between <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20" name="1471-2105-10-S1-S9-i18" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M21" name="1471-2105-10-S1-S9-i1" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>, i.e. <italic>&#x003c0; </italic>becomes <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M22" name="1471-2105-10-S1-S9-i19" overflow="scroll"><mml:semantics><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">&#x02192;</mml:mo></mml:mover><mml:mo>&#x02026;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>&#x02026;</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. The desire edge (+<italic>a</italic>, -<italic>x</italic>) is removed, the inserted desire edges are the edge (+<italic>a</italic>, -(<italic>y </italic>+ 1)) and some adjacencies. The reality edge (+(<italic>x </italic>- 1), -<italic>x</italic>) is split from the component, the edge (+<italic>a</italic>, -(<italic>y </italic>+ 1)) may merge two components, so the overall number of components cannot be decreased. As the element <italic>y </italic>+ 1 was not present in the original genome, the edge (+<italic>a</italic>, -(<italic>y </italic>+ 1)) cannot be a loop.</p></sec><sec><title>Case B</title><p><italic>x </italic>is in a duplicated segment, w.l.o.g. the segment is left-maximal. We extend it to the right until it is also right-maximal. Nevertheless, we will denote the leftmost vertex of the duplicated segment by -<italic>x </italic>and the rightmost vertex by +<italic>x</italic>, i.e. <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M23" name="1471-2105-10-S1-S9-i20" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>&#x02026;</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>&#x02026;</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> (the copies of <italic>x </italic>can also have negative orientation). As the segment is right-maximal, -<italic>b </italic>&#x02260; -<italic>c </italic>or the segments have different orientation and touch each other, i.e. <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M24" name="1471-2105-10-S1-S9-i21" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02190;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02190;</mml:mo></mml:mover><mml:mo>&#x02026;</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. In the first case, we remove the copy of <italic>x </italic>that is not adjacent to <italic>x </italic>- 1, i.e. we remove the desire edges (+<italic>a</italic>, -<italic>x</italic>) and (+<italic>x</italic>, -<italic>c</italic>), and create the new desire edge (+<italic>a</italic>, -<italic>c</italic>). If +<italic>a </italic>= -<italic>c</italic>, the loop can be removed by a DCJ on this edge and the edge (+<italic>x</italic>, -<italic>b</italic>). In the second case, we remove the copy of <italic>x </italic>that is not adjacent to <italic>x </italic>- 1, i.e. we remove the loop and the desire edge (+<italic>a</italic>, -<italic>x</italic>), and we create the desire edge (+<italic>x</italic>, +<italic>a</italic>). In both cases, the desire edge (+(<italic>x </italic>- 1), -<italic>x</italic>) is split from the component, and adding one new desire edge can merge only two components, so the overall number of components does not decrease. Additionally, also <italic>S </italic>cannot increase.</p></sec><sec><title>Case C</title><p>The genome is of the form <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M25" name="1471-2105-10-S1-S9-i22" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>&#x02026;</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>d</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mo>&#x02026;</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. We remove the second copy of <italic>x</italic>. This removes the desire edges (+<italic>b</italic>, -<italic>x</italic>) and (+<italic>x</italic>, -<italic>d</italic>) and adds the desire edge (+<italic>b</italic>, -<italic>d</italic>). If this has merged two components, then (+<italic>a</italic>, -<italic>x</italic>) and (+<italic>b</italic>, -<italic>d</italic>) are 1-bridges with disjoint endpoints (remember that there is no desire edge from vertex +(<italic>x </italic>- 1)), so a DCJ on these two edges splits the component again. If +<italic>b </italic>= -<italic>d</italic>, we have a loop, so we will not apply this sequence. Instead, we use the symmetrical case in which we remove the first copy of <italic>x</italic>. If both +<italic>b </italic>= -<italic>d </italic>and +<italic>a </italic>= -<italic>c</italic>, we can remove the loop (+<italic>b</italic>, -<italic>d</italic>) by applying a DCJ on it and the desire edge (+a, -<italic>x</italic>). Note that there is the possibility that the first DCJ creates a circular genome that cannot be absorbed in the next step. In this case, we can apply the sequence for Case A twice, i.e. we add the same elements before both copies of <italic>x</italic>.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p></sec></sec><sec><title>Completeness of the algorithm</title><p>Whenever the algorithm cannot apply an operation that decreases the lower bound, it searches for sequences that remove duplicated segments, for operations that create adjacencies, and for sequences according to the cases A to C in the previous subsection. Then, one of these sequences is selected and applied to the genome. The pseudocode of the algorithm can be seen in Fig. <xref ref-type="fig" rid="F4">4</xref>.</p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>The algorithm</bold>. The algorithm in pseudocode.</p></caption><graphic xlink:href="1471-2105-10-S1-S9-4"/></fig><p>To prove the completeness of the algorithm, we need the following lemma.</p><p><bold>Lemma 4</bold>. <italic>Let m</italic>(<italic>&#x003c0;</italic>) <italic>be the number of missing elements in &#x003c0;, let r</italic>(<italic>&#x003c0;</italic>) <italic>the number of elements that have to be removed from &#x003c0; (i.e. r</italic>(<italic>&#x003c0;</italic>) = |<italic>&#x003c0;</italic>| + <italic>m</italic>(<italic>&#x003c0;</italic>) - (<italic>n </italic>+ 2)<italic>), and let a</italic>(<italic>&#x003c0;</italic>) <italic>be the number of adjacencies in &#x003c0;. Then, &#x003c4;</italic>(<italic>&#x003c0;</italic>): = <italic>a</italic>(<italic>&#x003c0;</italic>) - 2&#x000b7;(<italic>m</italic>(<italic>&#x003c0;</italic>) + <italic>r</italic>(<italic>&#x003c0;</italic>)) <italic>is maximal if and only if &#x003c0; = id</italic>.</p><p>Proof. Let <italic>&#x003c0; </italic>be a genome such that <italic>&#x003c4;</italic>(<italic>&#x003c0;</italic>) is maximal. If <italic>m</italic>(<italic>&#x003c0;</italic>) &#x0003e; 0 we could transform <italic>&#x003c0; </italic>by adding all missing elements without increasing <italic>r</italic>(<italic>&#x003c0;</italic>) or decreasing <italic>a</italic>(<italic>&#x003c0;</italic>). This would be a contradiction to the fact that <italic>&#x003c4;</italic>(<italic>&#x003c0;</italic>) is maximal, therefore <italic>m</italic>(<italic>&#x003c0;</italic>) = 0. Now, let us assume that <italic>r</italic>(<italic>&#x003c0;</italic>) &#x0003e; 0, and let <italic>x </italic>be the smallest element that is duplicated. As <italic>x </italic>- 1 has a multiplicity of 1, there is at least one copy of <italic>x </italic>that has a breakpoint. Removing this copy decreases <italic>r</italic>(<italic>&#x003c0;</italic>) by 1 and <italic>a</italic>(<italic>&#x003c0;</italic>) by at most 1, while <italic>m</italic>(<italic>&#x003c0;</italic>) remains unchanged. This would increase <italic>&#x003c4;</italic>(<italic>&#x003c0;</italic>), and lead to a contradiction. Therefore, <italic>&#x003c0; </italic>is the genome without duplicated or missing elements with the maximum number of adjacencies, i.e. <italic>&#x003c0; </italic>= <italic>id</italic>.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><p>We are now ready to prove the following theorem.</p><p><bold>Theorem 2</bold>. <italic>The algorithm terminates after a finite number of steps. When the algorithm terminates, the genome &#x003c0; is transformed into id</italic>.</p><p><italic>Proof</italic>. As none of the operations and sequences of operations discussed above increases the lower bound, and the lower bound is minimized for <italic>id</italic>, only a finite number of operations that decrease the lower bound can be applied. As we have shown in the last subsections, the algorithm always finds a sequence of operations as long as <italic>&#x003c0; </italic>&#x02260; <italic>id</italic>. Table <xref ref-type="table" rid="T1">1</xref> shows the changes of <italic>&#x003c4;</italic>(<italic>&#x003c0;</italic>) when applying these sequences. As all sequences increase <italic>&#x003c4;</italic>(<italic>&#x003c0;</italic>), only a finite number of those sequences can be applied between two operations that decrease the lower bound. Therefore, the algorithm must terminate, and <italic>&#x003c0; </italic>is transformed into <italic>id</italic>.&#x000a0;&#x000a0;&#x000a0;&#x025a1;</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Estimating &#x00394;<italic>&#x003c4;</italic>. Changes of <italic>m</italic>(<italic>&#x003c0;</italic>), r(<italic>&#x003c0;</italic>), <italic>a</italic>(<italic>&#x003c0;</italic>), and <italic>&#x003c4; </italic>(<italic>&#x003c0;</italic>) by applying the different sequences of operations described in this section. Case C' is the case where we cannot solve Case C directly and have to apply the sequence for Case A twice.<italic>l </italic>denotes the length of inserted or removed segments. Note that for all sequences, &#x00394;<italic>&#x003c4; </italic>&#x0003e; 0.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Sequence</td><td align="center">&#x00394;<italic>m</italic>(<italic>&#x003c0;</italic>)</td><td align="center">&#x00394;<italic>r</italic>(<italic>&#x003c0;</italic>)</td><td align="center">&#x00394;<italic>a</italic>(<italic>&#x003c0;</italic>)</td><td align="center">&#x00394;<italic>&#x003c4;</italic>(<italic>&#x003c0;</italic>)</td></tr></thead><tbody><tr><td align="left">Inverse Tandem Duplication</td><td align="center">0</td><td align="center">-<italic>l</italic></td><td align="center">&#x02265; -<italic>l</italic></td><td align="center">&#x02265; <italic>l</italic></td></tr><tr><td align="left">Segments with multiplicity &#x02265; 3</td><td align="center">0</td><td align="center">-2<italic>l</italic></td><td align="center">&#x02265; -2<italic>l </italic>- 1</td><td align="center">&#x02265; 2<italic>l </italic>- 1</td></tr><tr><td align="left">Creating adjacencies</td><td align="center">0</td><td align="center">0</td><td align="center">&#x02265; 1</td><td align="center">&#x02265; 1</td></tr><tr><td align="left">Case A</td><td align="center">-<italic>l</italic></td><td align="center">0</td><td align="center"><italic>l</italic></td><td align="center">2<italic>l</italic></td></tr><tr><td align="left">Case B</td><td align="center">0</td><td align="center">-<italic>l</italic></td><td align="center">&#x02265; -<italic>l</italic></td><td align="center">&#x02265; <italic>l</italic></td></tr><tr><td align="left">Case C</td><td align="center">0</td><td align="center"><italic>l</italic></td><td align="center">&#x02265; -<italic>l</italic></td><td align="center">&#x02265; <italic>l</italic></td></tr><tr><td align="left">Case C'</td><td align="center">-<italic>l</italic></td><td align="center"><italic>l</italic></td><td align="center">2<italic>l</italic></td><td align="center">2<italic>l</italic></td></tr></tbody></table></table-wrap></sec><sec><title>Testing</title><p>We used simulated data to assess the performance of our algorithm. We generated test cases by creating the identity genome <italic>id </italic>of size <italic>n </italic>and applying random sequences of <italic>&#x003b1;n </italic>operations for different values of <italic>n </italic>and <italic>&#x003b1; </italic>(namely <italic>n </italic>&#x02208; {20, 50, 80, 100} and <italic>&#x003b1; </italic>from 0.1 to 1 in steps of 0.1). For each value of <italic>n </italic>and <italic>&#x003b1;</italic>, we created 10 test cases. The operations of the sequences are independently distributed, with tandem duplications and deletions having a probability of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M26" name="1471-2105-10-S1-S9-i23" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>3</mml:mn></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>, reversals having a probability of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M27" name="1471-2105-10-S1-S9-i24" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mn>2</mml:mn><mml:mn>9</mml:mn></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>, and block interchanges having a probability of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M28" name="1471-2105-10-S1-S9-i25" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>9</mml:mn></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula> (thus the expected numbers of DCJs, tandem duplications, and deletions are equal). Once the type of an operation was determined, the operation was selected uniformly distributed among all operations of this type. As long deletions can cancel the effects of previous operations, deletions were restricted to have a length of at most 0.1 times the current genome length. To keep the size of the genome approximately constant, also tandem duplications were restricted to have a length of at most 0.1 times the current genome length.</p><p>We then calculated the lower bounds of the test cases, and used our algorithm to reconstruct the sequence of operations. The results of these experiments can be seen in Fig. <xref ref-type="fig" rid="F5">5</xref>. On average, our algorithm finds good sequences (mostly with less operations than used to create the test case) as long as the lower bound is close to the number of operations used to create the test case. As this coherence lessens for increasing values of <italic>n </italic>and <italic>&#x003b1;</italic>, the length of the calculated sequences increases. However, even for higher values of <italic>n </italic>and <italic>&#x003b1;</italic>, the calculated distances are still a good approximation for the original distance. If one examines the frequency of the different types of operations, the number of performed duplications and block interchanges approximately fits the expected values. The algorithm tends to overestimate the number of reversals and underestimate the number of deletions, especially for higher values of <italic>n</italic>. For details, see Fig. <xref ref-type="fig" rid="F6">6</xref>.</p><fig position="float" id="F5"><label>Figure 5</label><caption><p><bold>Performance</bold>. Performance of our algorithm on simulated data. In each diagram, the x-axis corresponds to the sequence weight used to obtain the test case, while the y-axis corresponds to the weight of the reconstructed sequence. Each value is the average of 10 created test cases.</p></caption><graphic xlink:href="1471-2105-10-S1-S9-5"/></fig><fig position="float" id="F6"><label>Figure 6</label><caption><p><bold>Frequencies of the operations</bold>. The relative frequencies of the different operations.</p></caption><graphic xlink:href="1471-2105-10-S1-S9-6"/></fig></sec></sec><sec><title>Discussion</title><p>In the following, we will discuss how the set of operations could be extended.</p><sec><title>Duplications</title><p>While our algorithm only considers tandem duplications, one might also be interested in including arbitrary duplications. This would be rather easy if tandem duplications have weight 1, and all other duplications have weight 2, since the general case of a duplication can change the lower bound by at most 2. However, weighting all duplications equally is a more complicated subject. If all duplications have weight 2, this could be disadvantageous in detecting tandem duplications, as an inverse tandem duplication can decrease the lower bound by at most 1. On the other hand, if all duplications have weight 1, duplications would be favored over DCJs. This could lead to sequences of many small duplications, instead of first merging the segments and then just applying one big duplication.</p></sec><sec><title>Insertions</title><p>Insertions of single elements could be easily included in our algorithm, because the inverse of this operation decreases the lower bound by at most 1. Insertions of arbitrary length are more complicated. On the other hand, allowing insertions of arbitrary length are neither biologically meaningful nor do they make sense in combination with arbitrary deletions, because one could solve every sorting problem by just one deletion and one insertion step. Thus, further research in including insertions should also include a reasonable length depending weighting of the insertions.</p></sec></sec><sec><title>Conclusion</title><p>We presented an algorithm that works well for smaller genomes and distances. Although our results are promising, this algorithm should be seen as a first step in handling duplications of arbitrary length. Further research could improve the algorithm itself by finding closer lower bounds and better heuristics, or extend the algorithm such that it considers more different operations (as described in Section "Discussion") and can also handle multichromosomal genomes.</p></sec><sec><title>Competing interests</title><p>The author declares that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>MB designed the algorithm, implemented it, performed the tests, and drafted this manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>The author thanks Sophia Yancopoulos, who suggested to investigate whether duplications and DCJs can be combined into one algorithm. This initial idea and further invaluable discussions with her and Michal Ozery-Flato laid the foundation for this work.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hannenhalli</surname><given-names>S</given-names></name><name><surname>Pevzner</surname><given-names>P</given-names></name></person-group><article-title>Transforming cabbage into turnip: polynomial algorithm for sorting signed permutations by reversals</article-title><source>Journal of the ACM</source><year>1999</year><volume>46</volume><fpage>1</fpage><lpage>27</lpage></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Tannier</surname><given-names>E</given-names></name><name><surname>Bergeron</surname><given-names>A</given-names></name><name><surname>Sagot</surname><given-names>MF</given-names></name></person-group><article-title>Advances on sorting by reversals</article-title><source>Discrete Applied Mathematics</source><year>2007</year><volume>155</volume><fpage>881</fpage><lpage>888</lpage></citation></ref><ref id="B3"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Han</surname><given-names>Y</given-names></name></person-group><article-title>Improving the efficiency of sorting by reversals</article-title><source>Proc International Conference on Bioinformatics and Computational Biology</source><year>2006</year><publisher-name>CSREA Press</publisher-name><fpage>406</fpage><lpage>409</lpage></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bader</surname><given-names>D</given-names></name><name><surname>Moret</surname><given-names>B</given-names></name><name><surname>Yan</surname><given-names>M</given-names></name></person-group><article-title>A Linear-Time Algorithm for Computing Inversion Distance between Signed Permutations with an Experimental Study</article-title><source>Journal of Computational Biology</source><year>2001</year><volume>8</volume><fpage>483</fpage><lpage>491</lpage><pub-id pub-id-type="pmid">11694179</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hartman</surname><given-names>T</given-names></name><name><surname>Shamir</surname><given-names>R</given-names></name></person-group><article-title>A Simpler and Faster 1.5-Approximation Algorithm for Sorting by Transpositions</article-title><source>Information and Computation</source><year>2006</year><volume>204</volume><fpage>275</fpage><lpage>290</lpage></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Elias</surname><given-names>I</given-names></name><name><surname>Hartman</surname><given-names>T</given-names></name></person-group><article-title>A 1.375-Approximation Algorithm for Sorting by Transpositions</article-title><source>IEEE/ACM Transactions on Computational Biology and Bioinformatics</source><year>2006</year><volume>3</volume><fpage>369</fpage><lpage>379</lpage><pub-id pub-id-type="pmid">17085846</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hartman</surname><given-names>T</given-names></name><name><surname>Sharan</surname><given-names>R</given-names></name></person-group><article-title>A 1.5-Approximation Algorithm for Sorting by Transpositions and Transreversals</article-title><source>Journal of Computer and System Sciences</source><year>2005</year><volume>70</volume><fpage>300</fpage><lpage>320</lpage></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Yancopoulos</surname><given-names>S</given-names></name><name><surname>Attie</surname><given-names>O</given-names></name><name><surname>Friedberg</surname><given-names>R</given-names></name></person-group><article-title>Efficient sorting of genomic permutations by translocation, inversion and block interchange</article-title><source>Bioinformatics</source><year>2005</year><volume>21</volume><fpage>3340</fpage><lpage>3346</lpage><pub-id pub-id-type="pmid">15951307</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Blanc</surname><given-names>G</given-names></name><name><surname>Barakat</surname><given-names>A</given-names></name><name><surname>Guyot</surname><given-names>R</given-names></name><name><surname>Cooke</surname><given-names>R</given-names></name><name><surname>Delseny</surname><given-names>M</given-names></name></person-group><article-title>Extensive Duplication and Reshuffling in the Arabidopsis Genome</article-title><source>The Plant Cell</source><year>2000</year><volume>12</volume><fpage>1093</fpage><lpage>1101</lpage><pub-id pub-id-type="pmid">10899976</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sankoff</surname><given-names>D</given-names></name></person-group><article-title>Gene and genome duplication</article-title><source>Current Opinion in Genetics and Development</source><year>2001</year><volume>11</volume><fpage>681</fpage><lpage>684</lpage><pub-id pub-id-type="pmid">11682313</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Christie</surname><given-names>D</given-names></name><name><surname>Irving</surname><given-names>R</given-names></name></person-group><article-title>Sorting Strings by Reversals and by Transpositions</article-title><source>SIAM Journal on Discrete Mathematics</source><year>2001</year><volume>14</volume><fpage>193</fpage><lpage>206</lpage></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>X</given-names></name><name><surname>Zheng</surname><given-names>J</given-names></name><name><surname>Fu</surname><given-names>Z</given-names></name><name><surname>Nan</surname><given-names>P</given-names></name><name><surname>Zhong</surname><given-names>Y</given-names></name><name><surname>Lonardi</surname><given-names>S</given-names></name><name><surname>Jiang</surname><given-names>T</given-names></name></person-group><article-title>The assignment of orthologous genes via genome rearrangement</article-title><source>IEEE/ACM Transactions on Computational Biology and Bioinformatics</source><year>2005</year><volume>2</volume><fpage>302</fpage><lpage>315</lpage><pub-id pub-id-type="pmid">17044168</pub-id></citation></ref><ref id="B13"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Bertrand</surname><given-names>D</given-names></name><name><surname>Lajoie</surname><given-names>M</given-names></name><name><surname>El-Mabrouk</surname><given-names>N</given-names></name><name><surname>Gascuel</surname><given-names>O</given-names></name></person-group><article-title>Evolution of Tandemly Repeated Sequences Through Duplication and Inversion</article-title><source>Proc 4th RECOMB Comparative Genomics Satellite Workshop</source><year>2006</year><volume>4205</volume><publisher-name>Lecture Notes in Computer Science, Springer-Verlag</publisher-name><fpage>129</fpage><lpage>140</lpage></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>El-Mabrouk</surname><given-names>N</given-names></name></person-group><article-title>Sorting Signed Permutations by Reversals and Insertions/Deletions of Contiguous Segments</article-title><source>Journal of Discrete Algorithms</source><year>2001</year><volume>1</volume><fpage>105</fpage><lpage>122</lpage></citation></ref><ref id="B15"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Marron</surname><given-names>M</given-names></name><name><surname>Swenson</surname><given-names>K</given-names></name><name><surname>Moret</surname><given-names>B</given-names></name></person-group><article-title>Genomic Distances under Deletions and Insertions</article-title><source>Theoretical Computer Science</source><year>2004</year><volume>325</volume><fpage>347</fpage><lpage>360</lpage></citation></ref><ref id="B16"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Swenson</surname><given-names>K</given-names></name><name><surname>Marron</surname><given-names>M</given-names></name><name><surname>Earnest-DeYoung</surname><given-names>J</given-names></name><name><surname>Moret</surname><given-names>B</given-names></name></person-group><article-title>Approximating the True Evolutionary Distance Between Two Genomes</article-title><source>ACM Journal of Experimental Algorithmics (to appear)</source><year>2008</year></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Sankoff</surname><given-names>D</given-names></name></person-group><article-title>Genome Rearrangement with Gene Families</article-title><source>Bioinformatics</source><year>1999</year><volume>15</volume><fpage>909</fpage><lpage>917</lpage><pub-id pub-id-type="pmid">10743557</pub-id></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>El-Mabrouk</surname><given-names>N</given-names></name></person-group><article-title>Reconstructing an ancestral genome using minimum segments duplications and reversals</article-title><source>Journal of Computer and System Sciences</source><year>2002</year><volume>65</volume><fpage>442</fpage><lpage>464</lpage></citation></ref><ref id="B19"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Fu</surname><given-names>Z</given-names></name><name><surname>Chen</surname><given-names>X</given-names></name><name><surname>Vacic</surname><given-names>V</given-names></name><name><surname>Nan</surname><given-names>P</given-names></name><name><surname>Zhong</surname><given-names>Y</given-names></name><name><surname>Jiang</surname><given-names>T</given-names></name></person-group><article-title>A Parsiomony Approach to Genome-Wide Ortholog Assignment</article-title><source>Proc 10th Annual International Conference on Research in Computational Molecular Biology</source><year>2006</year><publisher-name>Lecture Notes in Computer Science, Springer-Verlag</publisher-name><fpage>578</fpage><lpage>594</lpage></citation></ref><ref id="B20"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Yancopoulos</surname><given-names>S</given-names></name><name><surname>Friedberg</surname><given-names>R</given-names></name></person-group><article-title>Sorting genomes with insertions, deletions and duplications by DCJ</article-title><source>Proc 6th Annual RECOMB Satellite Workshop on Comparative Genomics</source><year>2008</year><publisher-name>Lecture Notes in Bioinformatics, Springer-Verlag, vol 5267</publisher-name><fpage>170</fpage><lpage>183</lpage></citation></ref><ref id="B21"><citation citation-type="book"><person-group person-group-type="author"><name><surname>El-Mabrouk</surname><given-names>N</given-names></name><name><surname>Nadeau</surname><given-names>J</given-names></name><name><surname>Sankoff</surname><given-names>D</given-names></name></person-group><article-title>Genome Halving</article-title><source>Proc 9th Annual Symposium on Combinatorial Pattern Matching</source><year>1998</year><volume>1448</volume><publisher-name>Lecture Notes in Bioinformatics, Springer-Verlag</publisher-name><fpage>235</fpage><lpage>250</lpage></citation></ref><ref id="B22"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>El-Mabrouk</surname><given-names>N</given-names></name><name><surname>Sankoff</surname><given-names>D</given-names></name></person-group><article-title>The reconstruction of doubled genomes</article-title><source>SIAM Journal on Computing</source><year>2003</year><volume>32</volume><fpage>754</fpage><lpage>792</lpage></citation></ref><ref id="B23"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Warren</surname><given-names>R</given-names></name><name><surname>Sankoff</surname><given-names>D</given-names></name></person-group><article-title>Genome Halving with Double Cut and Join</article-title><source>Proc 6th Asia Pacific Bioinformatics Conference</source><year>2008</year><publisher-name>World Scientific</publisher-name><fpage>231</fpage><lpage>240</lpage></citation></ref><ref id="B24"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Mixtacki</surname><given-names>J</given-names></name></person-group><article-title>Genome Halving under DCJ revisited</article-title><source>Proc 14th Annual International Computing and Combinatorics Conference</source><year>2008</year><volume>5092</volume><publisher-name>Lecture Notes in Computer Science, Springer-Verlag</publisher-name><fpage>276</fpage><lpage>286</lpage></citation></ref><ref id="B25"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Ozery-Flato</surname><given-names>M</given-names></name><name><surname>Shamir</surname><given-names>R</given-names></name></person-group><article-title>On the frequency of genome rearrangement events in cancer karyotypes</article-title><source>Proc 1st RECOMB Satellite Workshop in Computational Cancer Biology</source><year>2007</year><fpage>17</fpage></citation></ref><ref id="B26"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Mitelman</surname><given-names>F</given-names></name><name><surname>Johansson</surname><given-names>B</given-names></name><name><surname>MF</surname><given-names/></name><collab>Eds</collab></person-group><source>Mitelman Database of Chromosome Aberrations in Cancer</source><year>2008</year><ext-link ext-link-type="uri" xlink:href="http://cgap.nci.nih.gov/Chromosomes/Mitelman"/></citation></ref><ref id="B27"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bafna</surname><given-names>V</given-names></name><name><surname>Pevzner</surname><given-names>P</given-names></name></person-group><article-title>Genome Rearrangements and Sorting by Reversals</article-title><source>SIAM Journal on Computing</source><year>1996</year><volume>25</volume><fpage>272</fpage><lpage>289</lpage></citation></ref><ref id="B28"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Nagamochi</surname><given-names>H</given-names></name><name><surname>Ibaraki</surname><given-names>T</given-names></name></person-group><article-title>A linear time algorithm for computing 3-edge-connected components in a multigraph</article-title><source>Japan Journal of Industrial and Applied Mathematics</source><year>1992</year><volume>9</volume><fpage>163</fpage><lpage>180</lpage></citation></ref></ref-list></back></article>