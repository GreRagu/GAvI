<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article" xml:lang="EN"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Front Neuroinformatics</journal-id><journal-id journal-id-type="publisher-id">Front. Neuroinform.</journal-id><journal-title>Frontiers in Neuroinformatics</journal-title><issn pub-type="epub">1662-5196</issn><publisher><publisher-name>Frontiers Research Foundation</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19225577</article-id><article-id pub-id-type="pmc">2644618</article-id><article-id pub-id-type="doi">10.3389/neuro.11.005.2009</article-id><article-categories><subj-group subj-group-type="heading"><subject>Neuroscience</subject><subj-group><subject>Original Research</subject></subj-group></subj-group></article-categories><title-group><article-title>OMPC: an Open-Source MATLAB<sup>&#x000ae;</sup>-to-Python Compiler</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Jurica</surname><given-names>Peter</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="author-notes" rid="fn001">*</xref></contrib><contrib contrib-type="author"><name><surname>van Leeuwen</surname><given-names>Cees</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff1"><sup>1</sup><institution>Perceptual Dynamics Laboratory, RIKEN Brain Science Institute, Wako-Shi</institution><country>Saitama, Japan</country></aff><author-notes><fn fn-type="edited-by"><p>Edited by: Rolf K&#x000f6;tter, Radboud University Nijmegen, The Netherlands</p></fn><fn fn-type="edited-by"><p>Reviewed by: Eilif Muller, Brain Mind Institute, EPFL, Switzerland; Dan Goodman, &#x000c9;cole Normale Sup&#x000e9;rieure, France</p></fn><corresp id="fn001">*Correspondence: Peter Jurica, Perceptual Dynamics Laboratory, RIKEN Brain Science Institute, Hirosawa 2-1, 351-0198 Wako-Shi, Saitama, Japan. e-mail: <email>pjurica@brain.riken.jp</email></corresp></author-notes><pub-date pub-type="epreprint"><day>13</day><month>10</month><year>2008</year></pub-date><pub-date pub-type="epub"><day>10</day><month>2</month><year>2009</year></pub-date><pub-date pub-type="collection"><year>2009</year></pub-date><volume>3</volume><elocation-id>5</elocation-id><history><date date-type="received"><day>14</day><month>9</month><year>2008</year></date><date date-type="accepted"><day>30</day><month>1</month><year>2009</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2009 Jurica and van Leeuwen.</copyright-statement><copyright-year>2009</copyright-year><license license-type="open-access" xlink:href="http://www.frontiersin.org/licenseagreement"><p>This is an open-access article subject to an exclusive license agreement between the authors and the Frontiers Research Foundation, which permits unrestricted use, distribution, and reproduction in any medium, provided the original authors and source are credited.</p></license></permissions><abstract><p>Free access to scientific information facilitates scientific progress. Open-access scientific journals are a first step in this direction; a further step is to make auxiliary and supplementary materials that accompany scientific publications, such as methodological procedures and data-analysis tools, open and accessible to the scientific community. To this purpose it is instrumental to establish a software base, which will grow toward a comprehensive free and open-source language of technical and scientific computing. Endeavors in this direction are met with an important obstacle. MATLAB<sup>&#x000ae;</sup>, the predominant computation tool in many fields of research, is a closed-source commercial product. To facilitate the transition to an open computation platform, we propose Open-source MATLAB<sup>&#x000ae;</sup>-to-Python Compiler (OMPC), a platform that uses syntax adaptation and emulation to allow transparent import of existing MATLAB<sup>&#x000ae;</sup> functions into Python programs. The imported MATLAB<sup>&#x000ae;</sup> modules will run independently of MATLAB<sup>&#x000ae;</sup>, relying on Python's numerical and scientific libraries. Python offers a stable and mature open source platform that, in many respects, surpasses commonly used, expensive commercial closed source packages. The proposed software will therefore facilitate the transparent transition towards a free and general open-source <italic>lingua franca</italic> for scientific computation, while enabling access to the existing methods and algorithms of technical computing already available in MATLAB<sup>&#x000ae;</sup>. OMPC is available at <uri xlink:type="simple" xlink:href="http://ompc.juricap.com">http://ompc.juricap.com</uri>.</p></abstract><kwd-group><kwd>technical computation</kwd><kwd>Python</kwd><kwd>Matlab</kwd><kwd>compiler</kwd></kwd-group><counts><fig-count count="2"/><table-count count="0"/><equation-count count="0"/><ref-count count="11"/><page-count count="9"/><word-count count="6856"/></counts></article-meta></front><body><sec sec-type="introduction"><title>Introduction</title><p>Scientific progress is optimally served when everyone has access to the relevant information. No matter how effective commercial organizations, such as publishers or software houses, are in distributing information; their copyright and proper use requirements are often an impediment to information sharing. Open-access scientific journals attempt to remedy this problem; but this is only a first step, involving the free distribution of scientific results. The next step is to make auxiliary and supplementary materials that accompany scientific publications, such as methodological and data-analysis procedures, open and accessible to the scientific community in the form of freely downloadable software.</p><p>Sharing software tools requires a common platform. Currently one platform dominates the sciences: MATLAB<sup>&#x000ae;</sup>. As a commercial product, this language has successfully conquered the market for scientific communication (Moler, <xref ref-type="bibr" rid="B5">2004</xref>, <xref ref-type="bibr" rid="B6">2006</xref>) because it is easy to adopt for beginners as well as professionals, and because of its policy to offer licenses at reduced rates to educational institutions. However, it does not meet our criteria to be used as a common standard for free sharing of software tools. Using a method implemented in MATLAB<sup>&#x000ae;</sup> requires a full MATLAB<sup>&#x000ae;</sup> license. Moreover, its core software is closed source, preventing users from verifying, updating, and improving it.</p><p>While some MATLAB<sup>&#x000ae;</sup> users find the features of the language sufficient and see no reason to switch to an alternative, those who want to move to another platform feel the weight of code already written in MATLAB<sup>&#x000ae;</sup> impeding on their decision. Developers who have tried to offer an open-source alternative have made efforts to offer a level of compatibility with MATLAB<sup>&#x000ae;</sup>. Examples of such products are Octave and Scilab. None of these packages ever reached 100% compatibility and failed to meet the challenge of catching up with a platform with substantial financial support.</p><p>We propose OMPC as a possible alternative strategy to facilitate transition to an open-source platform. OMPC aims to offer a bridge between MATLAB<sup>&#x000ae;</sup> and Python. Development of the Python programming language project was started in late 1980s (<uri xlink:type="simple" xlink:href="http://www.artima.com/intv/python.html">http://www.artima.com/intv/python.html</uri>) at the National Research Institute for Mathematics and Computer Science in the Netherlands as an open-source scripting language for gluing components of an operating system. Today, powerful hardware allows Python to be used as a general purpose programming language. Over the years, the community contributing to the development of the Python language has grown considerably. Programmers and scientists alike are attracted by the simplicity of its syntax and its powerful set of features. Python is a good bet for a future free and open-source product that will develop far and fast enough to become the new <italic>lingua franca</italic> of technical computing (Fangohr, <xref ref-type="bibr" rid="B2">2004</xref>; Langtangen, <xref ref-type="bibr" rid="B4">2006</xref>).</p><p>Since the early stages there have been attempts to develop a Python package that offers certain features available in MATLAB<sup>&#x000ae;</sup>-compatible languages (<uri xlink:type="simple" xlink:href="http://matpy.sourceforge.net/">http://matpy.sourceforge.net/</uri>). Scientific computation libraries were developed in the 1990s (Oliphant, <xref ref-type="bibr" rid="B7">2006</xref>) and have been updated several times (Ascher et al., <xref ref-type="bibr" rid="B1">2001</xref>; Oliphant, <xref ref-type="bibr" rid="B8">2007</xref>), gaining in reliability, stability and versatility over years of development and use. The most important ones, especially in the context of our project, are <italic>numpy</italic>, <italic>scipy</italic> and <italic>matplotlib</italic> (<uri xlink:type="simple" xlink:href="http://numpy.scipy.org/">http://numpy.scipy.org/</uri>, <uri xlink:type="simple" xlink:href="http://www.scipy.org/">http://www.scipy.org/</uri> and <uri xlink:type="simple" xlink:href="http://matplotlib.sourceforge.net/">http://matplotlib.sourceforge.net/</uri> respectively). The first two provide functions largely equivalent to those of MATLAB<sup>&#x000ae;</sup>, while <italic>matplotlib</italic> is providing plotting functionality. Within the controlled development of Python, a proposal was made in 2000 to enhance Python with a feature that has been one of the major assets of MATLAB<sup>&#x000ae;</sup>: the availability of both matrix and element-wise operators (Zhu and Lielens, <xref ref-type="bibr" rid="B11">2000</xref>). Another proposal has been to include a numerical array package <italic>numpy</italic> into the standard Python library, resulting in a revision of the buffer interface for the Python 3.0 (Oliphant and Banks, <xref ref-type="bibr" rid="B9">2006</xref>). The new buffer interface facilitates the sharing of multi-dimensional data between different Python extension modules. All these developments point to an expanding role for Python in scientific computation.</p><p>The main problem with these packages is that each offers only a subset of MATLAB<sup>&#x000ae;</sup> features, but they lack a common, standardized interface. Our first aim, therefore, is to organize the available numerical libraries and provide them with a common interface. Our second aim is to provide 100% compatibility with MATLAB<sup>&#x000ae;</sup> syntax and with its dynamic interpreter (the MATLAB<sup>&#x000ae;</sup> engine). One advantage is that users will be able to download MATLAB<sup>&#x000ae;</sup> applications and run them for free. For programmers, OMPC offers the advantage of a free and open collaboration platform allowing reuse of code developed for the commercial MATLAB<sup>&#x000ae;</sup> platform without laborious rewriting.</p><p>OMPC is basically a translator of MATLAB<sup>&#x000ae;</sup> code to Python-compatible syntax. This paper discusses the compiler and the fundamental concepts that allow it to generate interpretable code; in particular code that will handle certain dynamic MATLAB<sup>&#x000ae;</sup> features not present in Python. For the generated code to work, OMPC needs to be complemented by a library that will ensure the proper interpretation of the translated code. We refer to this library as OMPClib. OMPClib contains, in particular, numerical objects that emulate the dynamical behavior of their MATLAB<sup>&#x000ae;</sup> counterparts. Proof-of-concept implementations of OMPClib that possess additional functionality just sufficient to reproduce the results of a spiking neural-network simulation (from Izhikevich, <xref ref-type="bibr" rid="B3">2003</xref>) are presented in the Supplementary Material. OMPClib is a work in progress. A regularly updated version is found at the project's website (<uri xlink:type="simple" xlink:href="http://ompc.juricap.com">http://ompc.juricap.com</uri>). The current implementation of the OMPClib is an integral component of the OMPC package and is based on the extension modules <italic>numpy</italic>, <italic>scipy</italic> and <italic>matplotlib</italic>.</p></sec><sec><title>Problem Statement</title><p>In part, the translation of MATLAB<sup>&#x000ae;</sup> into Python code is a straightforward, technical problem. We need a compiler to generate Python compatible code from MATLAB<sup>&#x000ae;</sup> code (see <xref ref-type="sec" rid="s1">The Compiler</xref>). In addition, there are four MATLAB<sup>&#x000ae;</sup> types (string, cell array, array, and slice) that have features not available in the corresponding Python objects. For these, we introduce Python objects that act as proxies for their MATLAB<sup>&#x000ae;</sup> equivalents (see <xref ref-type="sec" rid="s2">Numerical Library</xref>).</p><p>The central, unique feature of the present translation problem is that both languages are interpreted languages, but have different dynamic features. Usually &#x0201c;dynamic&#x0201d; refers to a property of variable types and means that variables do not have to have a declared purpose or type &#x02013; we refer to an object by its name and the interpreter decides at run-time if an operation on the variable is allowed. However, MATLAB<sup>&#x000ae;</sup> also adds dynamics to a number of other aspects of the language. The dynamic features of the MATLAB<sup>&#x000ae;</sup> engine differ from those of Python as well as most other general-purpose interpreters, because of the specific purpose for which MATLAB<sup>&#x000ae;</sup> was designed. These issues include: array slicing, on-demand updating of the variable namespace and populating it with implied variables such as <italic>nargin/nargout</italic>, element-wise operations, and implied returns. The dynamic feature of MATLAB<sup>&#x000ae;</sup> that is the most difficult to implement in languages other than Python is the <italic>nargin/nargout</italic> implied variable. The slicing syntax, although available in Python, differs in syntax. In subsequent Sections <xref ref-type="sec" rid="s3">&#x0201c;Array Slicing, Index Base 1&#x0201d;</xref>, <xref ref-type="sec" rid="s4">&#x0201c;Dynamic Update of the Variable Name Space, Emulation of <italic>nargin/nargout</italic>&#x0201d;</xref>, <xref ref-type="sec" rid="s5">&#x0201c;Assignments to Novel Variables, Assignments to Slices&#x0201d;</xref>, <xref ref-type="sec" rid="s6">&#x0201c;Element-wise Operations&#x0201d;</xref> and <xref ref-type="sec" rid="s7">&#x0201c;Implied Returns&#x0201d;</xref>, we show how each of these particular problems can be solved. In Section <xref ref-type="sec" rid="s8">&#x0201c;The <italic>mfunction</italic> Decorator&#x0201d;</xref> we mention how OMPC allows integration of these solutions with a minimum impact on the structure of the original MATLAB<sup>&#x000ae;</sup> code. Our approach illustrates that it is possible, given enough knowledge of the compiler of a particular language, to interpret code written in an arbitrary programming language, provided that the emulated language has a subset of the features of the emulating one. This translation maxim may apply universally between any pair of languages. However, as we argue, Python in addition is syntactically close, sufficiently dynamic, and has a large enough library to enable translation that leaves the original structure intact.</p><p>Any platform for technical and scientific computation should keep up to the standards of speed and quality of MATLAB<sup>&#x000ae;</sup>. This is only possible if such a platform is built on the base of standard numerical packages. Indeed at the base of all of currently competing scientific packages we find ATLAS (Automatically Tuned Linear Algebra Software). This is the reason why results of operations on matrices are bit-by-bit equivalent in MATLAB<sup>&#x000ae;</sup>, Python, Octave and many other tools. Also the speed of execution of operations defined in this library does not change significantly between different engines. There is no essential difference in speed of execution compared to compiled languages like C/C+++; C/C++ code written by the average user can even be slower compared to implementations available from the ATLAS BLAS/LAPACK libraries used by <italic>numpy/scipy</italic>. This is because optimization of the elementary operations is done automatically at the time of compilation of the library and the speed of the result in not affected by the programming language from which this library is initiated (except for translation of parameters). The functionality of many toolboxes of MATLAB<sup>&#x000ae;</sup> is dependent on a number of other open-source packages as well. These are all available to Python users and probably have already been wrapped into a Python package. For custom made, non-standard packages (MEX extensions), we still need a way to allow OMPC to use them. This issue is discussed in Section <xref ref-type="sec" rid="s9">&#x0201c;OMPC Extensions&#x0201d;</xref>.</p></sec><sec><title>Proposed Solution</title><p>An underappreciated aspect of Python, especially in scientific computing, is a feature known as introspection. Python offers built-in modules that allow run-time inspection of its own bytecode. Bytecode is the equivalent of the machine language in interpreted and just-in-time compiled languages. Introspection makes possible the run-time modification of the bytecode of a program, provided that the engine allows this. Python offers this facility. Where the specific dynamic features of the MATLAB<sup>&#x000ae;</sup> engine have made it impossible for Python to interpret MATLAB<sup>&#x000ae;</sup> code directly, we show that with the help of introspection it is possible to emulate the remaining features. The following section presents specific features that together implement the proposed solution. Supplementary Material files on the project site include Python scripts that demonstrate the features presented in this section.</p></sec><sec><title>OMPC &#x02013; a MATLAB<sup>&#x000ae;</sup>-to-Python Compiler</title><p>OMPC is a compiler that translates MATLAB<sup>&#x000ae;</sup> code to functionally equivalent Python code. The design philosophy of OMPC is to enable seamless integration of existing MATLAB<sup>&#x000ae;</sup> code in Python programs. As a feature of convenience, OMPC allows automatic loading and translation of .<italic>m</italic> files using the Python <italic>import</italic> statement. Thus, assuming there is an m-function called <italic>add</italic> implemented in a file called <italic>add.m</italic>, an example Python session using this file would look as follows<xref ref-type="fn" rid="fn1">1</xref>:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; import ompc&#x0003e;&#x0003e;&#x0003e; import add&#x0003e;&#x0003e;&#x0003e; add(1,2)ans = 3</monospace></preformat></p><p>The steps taken during execution are schematically illustrated in Figure <xref ref-type="fig" rid="F1">1</xref>. They are:<fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>OMPC structure</bold>. Each .<italic>m</italic> file has to be translated to Python compatible syntax. Statements for an .<italic>m</italic> file are replaced by their Python equivalents with minimal structural changes that allow emulation. This translated code relies on features implemented in a numerical object similar to <italic>ndarray</italic> of the <italic>numpy</italic> module.</p></caption><graphic xlink:href="fninf-03-005-g001"/></fig><list list-type="order"><list-item><p><bold>import ompc</bold> &#x02013; OMPC installs a so-called import hook into the current instance of the interpreter. This allows OMPC to act at every import statement and compile <italic>m-files</italic> to Python code on demand. From this point on it is possible to import .<italic>m</italic> files.</p></list-item><list-item><p><bold>import add</bold> &#x02013; the OMPC import hook is called and searches for <italic>add.m</italic> on the current path (an equivalent to MATLAB<sup>&#x000ae;</sup>'s path variable). OMPC compiles <italic>add.m</italic> to a .<italic>pym</italic> file and submits this file to Python's built-in <italic>__import__</italic> function that will compile this file as any other regular Python file.</p></list-item><list-item><p><bold>add(1, 2)</bold> &#x02013; is a Python function call. It is running in the current Python instance as a Python function working with Python variables. In other words, MATLAB<sup>&#x000ae;</sup> is not involved at any stage of this process.</p></list-item></list></p><p>OMPC is complemented by the module <italic>OMPClib</italic>. This module provides implementations of objects that act as proxies of dynamic features specific to MATLAB<sup>&#x000ae;</sup>.</p><p>Note that the mentioned enhancement of functionality is realized without any change to the Python language itself. It is absolutely important not to change the Python language in favor of a single package. Changes to the interpreter should only be made if they are met with general acceptance among the users of the language. Otherwise it would lead to the opposite of the unification aimed for. Moreover, a program translated by OMPC preserves the structure of the original MATLAB<sup>&#x000ae;</sup> program. The resulting program, in all but three cases (function declaration, switch statement, multiple statements on a single line), corresponds line by line to its MATLAB<sup>&#x000ae;</sup> source code. An example of equivalent MATLAB<sup>&#x000ae;</sup> and Python compatible codes can be found in the <xref ref-type="sec" rid="s10">&#x0201c;Results&#x0201d;</xref> section.</p><sec id="s1"><title>The compiler</title><p>To use MATLAB<sup>&#x000ae;</sup> code in Python, an intermediate step of MATLAB<sup>&#x000ae;</sup>-to-Python <italic>syntax adaptation</italic> is needed. The MATLAB<sup>&#x000ae;</sup> code must be parsed and translated into Python code that is functionally equivalent to its original. To parse MATLAB<sup>&#x000ae;</sup> source code we used a free 100% Python implementation of lex and yacc parsing tools called PLY (<uri xlink:type="simple" xlink:href="http://www.dabeaz.com/ply/">http://www.dabeaz.com/ply/</uri>). The compiler is implemented in a single Python file (examples/ompc/ompcply.py). This file is a collection of grammar definitions. Each definition is associated with a processing function for a specific language construct (keyword, number, assignment, index access and others). The grammatical rule for each construct is specified in the documentation string of its processing function. The functions are designed to cover every syntactically correct MATLAB<sup>&#x000ae;</sup> language statement. The <italic>PLY module</italic> uses the grammar file to generate a parser, which searches a source text for language constructs and passes these to their corresponding processing functions. The parser produces the translated Python-compatible code. In the case of strings, the syntactical rule is the regular expression <italic>STRING = r&#x02033;&#x02032;((?:&#x02033;</italic>|<italic>[^\n&#x02032;])*)&#x02032;&#x02033;</italic> and the processing function looks as follows:<preformat position="float" xml:space="preserve"><monospace>def p_expression_string(p):    "expression : STRING"    p[0]&#x02009;=&#x02009;"mstring(%s)"%p[1]</monospace></preformat></p><p>Every MATLAB<sup>&#x000ae;</sup> string that passes through this function will be enclosed in the expression mstring(.). Such a string can have all the features of a MATLAB<sup>&#x000ae;</sup> string. If this is not required, it is possible to replace the last line with <italic>p[0]&#x02009;=&#x02009;p[1]</italic>. As a result the strings from the original will stay intact.</p><p>The important advantage of using Python for the translation is that its code is easy to read and can be easily modified. Modifying a Python program does not require installation of a large complicated development system, common for low level languages like C++ or Java. The development advantages outweigh the negligible differences in processing speed.</p></sec><sec id="s2"><title>Numerical library</title><p>Here we present the additional objects necessary for full compatibility with MATLAB<sup>&#x000ae;</sup>. The following MATLAB<sup>&#x000ae;</sup> example illustrates the impossibility of differentiating between variables and functions at translation.<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e; add&#x02009;=&#x02009;@(a,b) a+b;&#x0003e;&#x0003e; add(1,2)                % Python -&#x0003e; add(1,2)ans&#x02009;=&#x02009;3&#x0003e;&#x0003e; add = 1:10;&#x0003e;&#x0003e; add(1,2)ans&#x02009;=&#x02009;2                     % Python -&#x0003e; add[0,1]</monospace></preformat></p><p>MATLAB<sup>&#x000ae;</sup> uses the same syntax for calling a function and retrieving elements from an array. This makes it impossible to determine if an identifier <italic>add</italic> in the above listing is a variable or a function. Therefore it is not possible to correctly translate the statement &#x0003e;&#x0003e; <italic>add(1,2)</italic> at compilation time. Our solution is based on the fact that object-oriented programming allows overloading of operators. We therefore have the option to overload the object's <italic>__call__</italic> function. Thus the OMPC code can be executed in Python, behaving equivalently to its MATLAB<sup>&#x000ae;</sup> original, independently of whether <italic>add</italic> is a function or a variable. Note that this added feature enhances the original numerical array (<italic>numpy</italic> in our examples) without altering its original function. The new object <italic>marray</italic> inherits all functionality from the original numerical array. This object enhanced by an overloaded <italic>__call__</italic> operator allows the following example to run in Python:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; add = lambda a,b: a+b;&#x0003e;&#x0003e;&#x0003e; add(1,2)3&#x0003e;&#x0003e;&#x0003e; add = mslice[1:10];&#x0003e;&#x0003e;&#x0003e; add(1,2)ans = 2.0</monospace></preformat></p><p>The supplementary OMPC numerical object is currently based on <italic>numpy</italic>'s array object. This is however not the only option. It is possible to use base objects from another package like <italic>Numarray</italic>, <italic>CVXOPT</italic> (<uri xlink:type="simple" xlink:href="http://abel.ee.ucla.edu/cvxopt">http://abel.ee.ucla.edu/cvxopt</uri>) or others. For non-numerical objects we can enhance Python built-in types. For example the OMPC string is based on the Python string implementation. The OMPC's cell array object is based on the Python built-in list object, which is equivalent in features to the cell array but, as is obvious from the following example, the performance boost achieved by using the Python list object is considerable.<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e; m = {}; tic, for i=1:100000, m{i} = 12; end, tocElapsed time is 9.637410 seconds.</monospace></preformat></p><p>Python does not allow on-demand growing of lists, but this feature can easily be emulated:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; class mcellarray(list):    def __setitem__(self,i,v):        if i &#x0003e;= len(self):            self.extend([None]*(i-len(self))&#x02009;+&#x02009;[v])&#x0003e;&#x0003e;&#x0003e; m&#x02009;=&#x02009;mcellarray()&#x0003e;&#x0003e;&#x0003e; tic()&#x0003e;&#x0003e;&#x0003e; for i in xrange(100000): m[i] = 12&#x0003e;&#x0003e;&#x0003e; toc()Elapsed time is 0.372690 seconds.</monospace></preformat></p><p>The above example is not the optimal way of using the cell array. Such incorrect use of MATLAB<sup>&#x000ae;</sup>'s benevolent interpreter is, however, very common. As the last example shows, Python can help to greatly enhance the usability of such sub-optimal code.</p></sec><sec id="s3"><title>Array slicing, index base 1</title><p>The first element of a Python sequence type is 0, while MATLAB<sup>&#x000ae;</sup> uses 1 as the base for indexing, for instance a[0] in Python is equivalent to <italic>a(1)</italic> in MATLAB<sup>&#x000ae;</sup>. OMPC solves this incompatibility by overloading the numerical object's <italic>__call__</italic> method. The same technique of overloading the <italic>__call__</italic> function also makes it possible to use MATLAB<sup>&#x000ae;</sup> style array slicing. Consider again:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; b = a(1:10);</monospace></preformat></p><p>it is unclear until run-time if <italic>a</italic> is a function accepting a vector or a vector from which we are retrieving the first 10 elements. Python does not allow using a slice object outside of the index <italic>[]</italic> operator. By translating this statement into Python acceptable syntax<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; b = a(mslice[1:10]);</monospace></preformat></p><p>and making <italic>a</italic> an object with overloaded <italic>__call__</italic> operation, this code can be executed in Python, behaving equivalently to its MATLAB<sup>&#x000ae;</sup> original independently of whether <italic>a</italic> is a function or a variable.</p><p>The <italic>mslice</italic> proxy object does two things. First it allows a slice object to be used as a parameter to a function call. Secondly it adapts MATLAB<sup>&#x000ae;</sup> index-base-1 slices from the syntax <italic>start:step:stop</italic> to Python's <italic>start:stop:step</italic>. Python's slice object returns slices up to the stop element, while MATLAB<sup>&#x000ae;</sup>'s slices range up to the stop element including it.</p></sec><sec id="s4"><title>Dynamic update of the variable name space, emulation of <italic>nargin/nargout</italic></title><p>Python comes with a built-in module called <italic>inspect</italic>. Using this module it is possible to look into the execution stack to see in what context a function is being executed. This means that at any time a function is called we can look a couple of steps back in history and ask the interpreter about the code from which our function has been called. Consider the following statement:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; [a, b]&#x02009;=&#x02009;sort(rand(10,1))</monospace></preformat></p><p>Python accepts both <italic>a, b</italic>, and <italic>[a, b]</italic> (the correct syntax in MATLAB<sup>&#x000ae;</sup>) as left-value for an assignment. The <italic>inspect</italic> module makes it possible to ask the interpreter for the number of arguments on the left side of the assignment at the moment just before a function was called. The <italic>OMPClib</italic> module contains a function <italic>_getnargout</italic> that does exactly this. The following Python statement that leaves <italic>nargout</italic> undefined:<preformat position="float" xml:space="preserve"><monospace>def f(x):    if nargout == 2:        return 1, 2    else:        return 1</monospace></preformat></p><p>can thus be rewritten to:<preformat position="float" xml:space="preserve"><monospace>def f(x):    nargout&#x02009;=&#x02009;_getnargout()    if nargout == 2:        return 1, 2    else:        return 1</monospace></preformat></p><p>The mfuction decorator, which will be discussed in detail in Section <xref ref-type="sec" rid="s8">&#x0201c;The <italic>mfunction</italic> Decorator&#x0201d;</xref>, makes sure that a call to the <italic>_getnargout</italic> function is inserted in the preamble of all functions translated by OMPC. This means that the original MATLAB<sup>&#x000ae;</sup> function body again can stay intact; we only need to apply the <italic>mfunction</italic> decorator that inserts <italic>nargout</italic> and, similarly, <italic>nargin</italic> into the variable namespace of the function during runtime.</p></sec><sec id="s5"><title>Assignments to novel variables, assignments to slices</title><p>We explained that it is possible to use the <italic>__call__</italic> function to allow MATLAB<sup>&#x000ae;</sup>-style array slicing. There is one exception, however: Python does not allow function calls to be used for assignment. We circumvent this restriction by assigning to a property of the slice. The property mediates the assignment operation and makes the syntax acceptable to the Python parser. For instance,<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; a(1)&#x02009;=&#x02009;1          # Syntax error</monospace></preformat></p><p>is not allowed, but the following is:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; a(1).lvalue&#x02009;=&#x02009;1</monospace></preformat></p><p>MATLAB<sup>&#x000ae;</sup> allows assignment to slices of variables that were not previously initialized. The module <italic>inspect</italic> allows us to detect assignment to non-existent variables. In the translated code, the variables are initialized during runtime by the <italic>mfunction</italic> decorator (see <xref ref-type="sec" rid="s8">The <italic>mfunction</italic> Decorator</xref>).</p></sec><sec id="s6"><title>Element-wise operations</title><p>MATLAB<sup>&#x000ae;</sup> offers a convenient way of differentiating between operations for matrices and their element-wise equivalents. Although such a differentiation was repeatedly proposed for Python (Zhu and Lielens, <xref ref-type="bibr" rid="B11">2000</xref>) it never gained enough support from the broader Python community. In <italic>numpy</italic>, all numerical operations on arrays are element-wise by default. In principle, it would not have been a problem to use function calls to differentiate between these and matrix operations, for instance:<preformat position="float" xml:space="preserve"><monospace>a .* b&#x02009;=&#x0003e; multiply(a, b)    and    a * b&#x02009;=&#x0003e; dot(a, b)</monospace></preformat></p><p>However in accordance with our principle to preserve as much as possible the original structure of the MATLAB<sup>&#x000ae;</sup> code, we suggest another solution. This solution is inspired by a recipe from the community-driven Python cookbook (<uri xlink:type="simple" xlink:href="http://code.activestate.com/recipes/384122/">http://code.activestate.com/recipes/384122/</uri>). Python allows overriding of operators on either side of an operand. This feature is commonly used to enable automatic coercion of types. For example, it allows the user to apply an arithmetic operation between a <italic>numpy</italic> array and anything else. So, for adding to array <italic>x</italic> a list <italic>[1,2]</italic>, instead of having to convert it to an array: <italic>x</italic> + array([1,2]), we can simply write: <italic>x</italic> + [1,2]. Therefore it is possible to change the above translation rule as follows:<preformat position="float" xml:space="preserve"><monospace>a .* b&#x02009;=&#x0003e; a *elmul* b       and        a * b&#x02009;=&#x0003e; a * b</monospace></preformat></p><p>The <italic>elmul</italic> is an instance of an object that has overloaded the * operator (the <italic>__mul__</italic> and <italic>__rmul__</italic> function). Independently of the execution order of the operations in the statement, the <italic>elmul</italic> object remembers the operand from the first multiplication and instructs the second operand to perform element-wise multiplication (<italic>a*elmul -</italic>&#x0003e; <italic>elmul.left</italic>&#x02009;=&#x02009;<italic>a, elmul</italic>*<italic>b</italic> -&#x0003e; <italic>elmul.left</italic>*<italic>b</italic>).</p></sec><sec id="s7"><title>Implied returns</title><p>MATLAB<sup>&#x000ae;</sup> uses implied returns; the &#x0201c;return&#x0201d; statement without parameters serves only for breaking the execution of a function. The return parameters of a function are specified in the function declaration. Python requires specification of these variables at each point of exit from the function. Python's return statement consists of a list of variables to be returned from a function call. Absence of the list means the empty object <italic>None</italic> is returned.<preformat position="float" xml:space="preserve"><monospace>function [mi,ma] = minmax(a)mi&#x02009;=&#x02009;min(a);if nargout &#x0003e; 1, ma = max(a); end@mfunction("mi, ma")def minmax(a=None)    mi&#x02009;=&#x02009;min(a)    if nargout &#x0003e; 1: ma = max(a)</monospace></preformat></p><p>In the above example it is not possible to simply append a return statement <italic>return mi, ma</italic>. Because its value is being assigned to a single object (<italic>mi</italic>), the <italic>minmax</italic> function is expecting to return a single value. Python would therefore automatically assign a sequence, or tuple, containing both return values to the single variable at the output of the function call. This is illustrated in the following:<preformat position="float" xml:space="preserve"><monospace>&#x0003e;&#x0003e;&#x0003e; mi&#x02009;=&#x02009;minmax(rand(1,10));ans = (0.0574, None)</monospace></preformat></p><p>It would, in principle, be possible to add a statement <italic>return (mi, ma)[:nargout]</italic> in all locations where function exit could occur. This strategy would already rely on the introspection function to determine the value of <italic>nargout</italic>. However, adding such statements is cumbersome and destroys the structure of the original syntax. Introspection allows us to preserve the structure by automatically modifying the bytecode of translated functions, inserting the equivalent code wherever needed. This and other previously mentioned modifications to the bytecode are handled by the <italic>mfunction</italic> decorator.</p></sec><sec id="s8"><title>The <italic>mfunction</italic> decorator</title><p>Python offers the feature of decorators since version 2.4. Simply put, decorators are function factories. They allow us to turn a regular Python function into one that behaves like a MATLAB<sup>&#x000ae;</sup> function. A Python decorator receives a function just before it is loaded into the current workspace. The decorator can manipulate the function in arbitrary ways. The <italic>mfunction</italic> decorator modifies each function translated by OMPC. We use the decorator to emulate the existence of the variables <italic>nargin/nargout</italic>, to allow assignments to novel variables, and to implement implied returns (Figure <xref ref-type="fig" rid="F2">2</xref>).</p><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>Code injection by the <italic>mfunction</italic> decorator</bold>. Top-left panel: original MATLAB<sup>&#x000ae;</sup> code; Bottom-left panel <bold>(A)</bold>: translation with added code necessary for execution in Python without <italic>mfunction</italic>; Right panel <bold>(B)</bold>: illustration of how <italic>mfunction</italic> inserts byte-code into automatically translated functions at runtime. This is done only the first time each <italic>mfunction</italic> is loaded into the Python interpreter. Because these additions are invisible to the user, the structure of the original code remains intact.</p></caption><graphic xlink:href="fninf-03-005-g002"/></fig><p>This modification of byte-code happens at run-time. It happens only once when the interpreter loads a function, not every time the function is called. The performance of the decorated function does not differ from the performance of a function where modifications are stated explicitly in the source code.</p></sec><sec id="s9"><title>OMPC extensions</title><p>Here we deal with the issue of how OMPC handles C/C++ and FORTRAN (MEX) extensions for MATLAB<sup>&#x000ae;</sup>. Both MATLAB<sup>&#x000ae;</sup> and Python allow extensions and both have an official protocol for writing them. However, the interface between platform and extension differs considerably between the two respective languages. Extensions written for MATLAB<sup>&#x000ae;</sup>, therefore, do not work in Python. We can solve this problem by implementing a C support library that allows compilation of extensions independently of MATLAB. Compilation turns these routines into dynamic-link libraries that can be called by any language, including Python. The Supplementary Material has an example that shows how the <italic>mxCreateDoubleMatrix</italic> function can be implemented for example, using the Standard Template Library of C++.</p><p>In general it is very easy in Python to wrap external libraries by using the open-source application GCCXML (<uri xlink:type="simple" xlink:href="http://www.gccxml.org/">http://www.gccxml.org/</uri>). The Python community extensively uses this application for automatically generating Python extensions for libraries with complex structure and large numbers of exported symbols. The advantage of GCCXML over tools like Cython or Pyrex (<uri xlink:type="simple" xlink:href="http://cython.org/">http://cython.org/</uri>) and the multipurpose Swig (<uri xlink:type="simple" xlink:href="http://www.swig.org/">http://www.swig.org/</uri>) is that it is based on a production-stable GCC compiler. This means that any large project that relies on the latest features of C++, including the use of templates, can be automatically correctly parsed and analyzed to be further processed to generate extensions (<uri xlink:type="simple" xlink:href="http://www.boost.org/doc/libs/release/libs/python/doc/">www.boost.org/doc/libs/release/libs/python/doc/</uri>, <uri xlink:type="simple" xlink:href="http://pypi.python.org/pypi/ctypeslib/">http://pypi.python.org/pypi/ctypeslib/</uri> and many others).</p></sec></sec><sec id="s10"><title>Results</title><p>A website has been created for the project, <uri xlink:type="simple" xlink:href="http://ompc.juricap.com/">http://ompc.juricap.com/</uri>. The compiler is also available on-line at <uri xlink:type="simple" xlink:href="http://ompclib.appspot.com/">http://ompclib.appspot.com/</uri>. This site will serve as a bug-tracking utility that will allow users to submit files that are not correctly processed by OMPC.</p><p>Because the formal specification of the MATLAB<sup>&#x000ae;</sup> syntax is not publicly available, it is difficult to properly test the OMPC compiler. However, we have successfully translated <italic>m-files</italic> that are part of the standard MATLAB<sup>&#x000ae;</sup> distribution. In addition, the compiler was tested successfully using source code collected from a number of users within the RIKEN Brain Science Institute and outside collaborators. The styling of MATLAB<sup>&#x000ae;</sup> source code varied significantly from person to person.</p><p>The following example consists of original source code, contained in online Supplementary Material to a neuroscience publication (Izhikevich, <xref ref-type="bibr" rid="B3">2003</xref>). The example shows the original MATLAB<sup>&#x000ae;</sup> <italic>m-file</italic> and its fully automatic translation by OMPC.<preformat position="float" xml:space="preserve"><monospace>% Created by Eugene M. Izhikevich, February 25, 2003% Excitatory neurons   Inhibitory neuronsNe=800;                Ni=200;re=rand(Ne,1);         ri=rand(Ni,1); a=[0.02*ones(Ne,1);    0.02+0.08*ri];b=[0.2*ones(Ne,1);     0.25&#x02212;0.05*ri];c=[&#x02212;65+15*re.^2;      &#x02212;65*ones(Ni,1)];d=[8&#x02212;6*re.^2;          2*ones(Ni,1)];S=[0.5*rand(Ne+Ni,Ne),&#x02212;rand(Ne+Ni,Ni)]; v=&#x02212;65*ones(Ne+Ni,1);  % Initial values of vu=b.*v;               % Initial values of ufirings=[];           % spike timingsfor t=1:1000          % simulation of 1000 ms    I=[5*randn(Ne,1);2*randn(Ni,1)]; % thalamic input    fired=find(v&#x0003e;=30); % indices of spikes   if &#x0223c;isempty(fired)      firings=[firings; t+0*fired, fired];           v(fired)=c(fired);        u(fired)=u(fired)+d(fired);      I=I+sum(S(:,fired),2);   end;   v=v+0.5*(0.04*v.^2+5*v+140&#x02212;u+I);   v=v+0.5*(0.04*v.^2+5*v+140&#x02212;u+I);   u=u+a.*(b.*v&#x02212;u);end;plot(firings(:,1),firings(:,2),'.');</monospace></preformat></p><p>The OMPC equivalent is:<preformat position="float" xml:space="preserve"><monospace># Created by Eugene M. Izhikevich, February 25, 2003# Excitatory neurons   Inhibitory neuronsNe&#x02009;=&#x02009;800Ni&#x02009;=&#x02009;200;re&#x02009;=&#x02009;rand(Ne, 1)ri&#x02009;=&#x02009;rand(Ni, 1);a&#x02009;=&#x02009;mcat([0.02 * ones(Ne, 1),         OMPCSEMI, 0.02&#x02009;+&#x02009;0.08 * ri])b&#x02009;=&#x02009;mcat([0.2 * ones(Ne, 1),         OMPCSEMI, 0.25 &#x02212; 0.05 * ri])c&#x02009;=&#x02009;mcat([&#x02212;65&#x02009;+&#x02009;15 * re **elpow** 2,         OMPCSEMI, &#x02212;65 * ones(Ni, 1)])d&#x02009;=&#x02009;mcat([8 &#x02212; 6 * re **elpow** 2,         OMPCSEMI, 2 * ones(Ni, 1)])S = mcat([0.5 * rand(Ne + Ni, Ne), &#x02212;rand(Ne + Ni, Ni)])v = &#x02212;65 * ones(Ne + Ni, 1)      # Initial values of vu = b *elmul* v                 # Initial values of ufirings = mcat([])              # spike timingsfor t in mslice[1:1000]:        # simulation of 1000 ms     I = mcat([5 * randn(Ne, 1), OMPCSEMI,              2 * randn(Ni, 1)]) # thalamic input     fired = find(v &#x0003e;= 30)       # indices of spikes    if not isempty(fired):        firings&#x02009;=&#x02009;mcat([firings, OMPCSEMI,                       t&#x02009;+&#x02009;0 * fired, fired])        v(fired).lvalue&#x02009;=&#x02009;c(fired)        u(fired).lvalue&#x02009;=&#x02009;u(fired)&#x02009;+&#x02009;d(fired)        I = I + sum(S(mslice[:], fired), 2)     end     v = v + 0.5 * (0.04 * v **elpow** 2 + 5 *                     v + 140 &#x02212; u + I)     v = v + 0.5 * (0.04 * v **elpow** 2 + 5 *                     v + 140 &#x02212; u + I)     u = u + a *elmul* (b *elmul* v &#x02212; u)endplot(firings(mslice[:], 1), firings(mslice[:], 2),      mstring('.'))</monospace></preformat></p><p>In this example we observe how well the translation preserves the structure of the original MATLAB<sup>&#x000ae;</sup> program. The above OMPC code is generated using rules that result in maximum compatibility. For example the last line contains the Python object <italic>mstring(&#x02018;.&#x02019;)</italic> that emulates the MATLAB<sup>&#x000ae;</sup> string object. As a consequence, the string is modifiable, as in the original. Since this is not necessary in the context of this program, a simple Python string could be used instead, as explained in Section <xref ref-type="sec" rid="s1">&#x0201c;The Compiler&#x0201d;</xref>. It is possible to further simplify the syntax by syntactical shortcuts, so called <italic>index tricks</italic> (<italic>r_</italic>, <italic>c_</italic>, <italic>mgrid</italic>), that are already part of the <italic>numpy</italic> library (Oliphant, <xref ref-type="bibr" rid="B7">2006</xref>). The <italic>plot</italic> statement of the last program could therefore be simplified to, for example:<preformat position="float" xml:space="preserve"><monospace>plot(firings(m_[:], 1), firings(m_[:], 2), &#x02018;.&#x02019;)</monospace></preformat></p><p>The structural equivalence of both programs was made possible by using the introspection functionality of Python. Some of the dynamical features, however, can equally well be resolved by the OMPC compiler, provided that we are willing to compromise on structural equivalence. This would enhance the clarity of code for Python developers not familiar with implied variables of MATLAB<sup>&#x000ae;</sup>. Only adopting and testing OMPC will allow the users to make the correct decision. The final form of code generated by OMPC has still to be agreed upon. Future developments of the compiler will enable such options through switches.</p><p>In the Supplementary Material to this paper, we provide OMPC executables of the spiking neuron model described in (Izhikevich, <xref ref-type="bibr" rid="B3">2003</xref>). At the moment of writing, two versions are available. One is based on the <italic>ndarray</italic> numerical array of the <italic>numpy</italic> library. However, optimized numerical packages such as <italic>numpy</italic> are not available yet for the newest Python interpreters. The other version, therefore, shows a pure Python implementation of an <italic>n</italic>-dimensional numerical array. This version is significantly slower for operations on large arrays but, because it runs on a clean Python installation, can be run on other realizations of Python as well; we have successfully tested this for Jython2.5a1, Python 2.6 and 3.0. The standard Python modules <italic>array</italic>, <italic>random</italic> and <italic>math</italic> are at the core of this second version; any Python interpreter sufficiently developed to contain these modules will execute the model. Maintaining a pure Python version of OMPC could enable acceleration of OMPC modules using PyPy (<uri xlink:type="simple" xlink:href="http://codespeak.net/pypy/">http://codespeak.net/pypy/</uri>, Rigo and Pedroni, <xref ref-type="bibr" rid="B10">2006</xref>) or Shedskin (An Optimizing Python-to-C++ compiler, <uri xlink:type="simple" xlink:href="http://shed-skin.blogspot.com/">http://shed-skin.blogspot.com/</uri>).</p></sec><sec><title>Discussion</title><p>A number of different implementations of Python are currently available. We choose CPython because it is the primary Python engine; the most mature and stable implementation. All numerical extensions were originally developed for CPython. CPython, moreover, offers by default the <italic>ctypes</italic> module, which is of crucial importance as a support library for OMPC. CPython allows easy and efficient access to extension modules written in C/C++, FORTRAN and many other languages that allow us to create dynamic-link libraries.</p><p>Amongst forthcoming Python implementations that may influence the future development of OMPC, the most interesting one is PyPy. PyPy is an implementation of Python in Python itself and supports compilation of a restricted subset called RPython (Restricted Python, <uri xlink:type="simple" xlink:href="http://codespeak.net/pypy/dist/pypy/doc/coding-guide.html#rpython">http://codespeak.net/pypy/dist/pypy/doc/coding-guide.html#rpython</uri>, Section 1.4) into the C language and from there on into native binary executables. Although this possibility has not been tested, if PyPy will support specific CPython features it should be possible to compile OMPC generated files to native executables.</p><p>OMPC aims ultimately to offer full compatibility with the syntax <italic>and</italic> the engine of MATLAB<sup>&#x000ae;</sup>. A number of its features, however, have not yet been addressed in this article. The most sought after ones relate to its GUI components. Implementing these is practicable, based on the fact that the MATLAB<sup>&#x000ae;</sup> application GUI-designer stores its information in &#x0201c;.fig&#x0201d; files, which are actually .mat data files. This means that they can be loaded into Python using OMPC, enabled through the <italic>scipy.io</italic> module. These files hold enough information to identify and reconstruct the GUI components within a figure.</p><p>There is currently no plan to implement embedded Java, because we consider it not to be a crucial part of MATLAB<sup>&#x000ae;</sup>. While Java can be useful in MATLAB<sup>&#x000ae;</sup>, for example, for networking applications, the verbosity and complexity of Java are a great obstacle to use for anybody without a professional software engineering background. Moreover, all features that Java offers as an enhancement of MATLAB<sup>&#x000ae;</sup> are, most likely, present in Python as well. For networking purposes, therefore, Python is a much more suitable extension than Java for a high level language such as MATLAB<sup>&#x000ae;</sup>. Python includes support for networking by default. It contains modules with ready-to-use implementations of client-server applications. A good example is the OMPC on-line compiler currently hosted as a Python service at <uri xlink:type="simple" xlink:href="http://ompclib.appspot.com/">http://ompclib.appspot.com/</uri>.</p><p>In a broader scope, one of the great advantages of being able to parse source code is that it allows analysis and possible optimization of the code that will be executed. This is the approach taken by platforms based on virtual machines like.NET, Java and LLVM. Source code that can be parsed and translated into an intermediate format (CIL, formerly known as MSIL, Java Bytecode, or LLVM IR) can be run or translated to another low-level language including machine code. PyPy uses this technique to translate a sufficiently static subset of Python into C (Rigo and Pedroni, <xref ref-type="bibr" rid="B10">2006</xref>). OMPC is an example of how to use Python byte-code as an intermediate representation.</p><p>Choosing Python as a platform for technical computation offers a number of additional benefits. As a popular general-purpose language, Python offers up-to-date facilities for online sharing, and enhancing the visibility of projects, in which computational methods are naturally embedded. The online OMPC compiler included in the Supplementary Material is one example of such an application. Python is currently one of the most popular tools in server-side Web 2.0 development.</p><p>The introduction mentions a number of attempts to provide MATLAB<sup>&#x000ae;</sup> functionality in Python. Currently there is only one actively developed project MlabWrap (<uri xlink:type="simple" xlink:href="http://mlabwrap.sourceforge.net/">http://mlabwrap.sourceforge.net/</uri>) that allows the use of MATLAB<sup>&#x000ae;</sup> functions along with the numerical extensions of Python. This project embeds the MATLAB<sup>&#x000ae;</sup> engine in a Python extension. This extension however requires a licensed copy of MATLAB<sup>&#x000ae;</sup>. A similar approach could be taken with the open-source library <italic>liboctave</italic> that is at the core of the GNU Octave (<uri xlink:type="simple" xlink:href="http://www.gnu.org/software/octave/">http://www.gnu.org/software/octave/</uri>). The design of OMPC allows any implementation of OMPClib to be used for execution of the OMPC generated Python code. An OMPClib could be built with liboctave's Array class as its base numerical object. The advantage of wrapping a library instead of embedding an interpreter is the great simplification of memory management. Embedding a interpreter in an extension is very similar to running a second process of which the data in memory are not directly accessible to Python and another extensions.</p><p>The interest of the scientific community in the Python language is growing (Langtangen, <xref ref-type="bibr" rid="B4">2006</xref>, <uri xlink:type="simple" xlink:href="http://www.scipy.org/, http://www.neuralensemble.org/">http://www.scipy.org/, http://www.neuralensemble.org/</uri>), making it ever more likely that it will become the main open-source language of scientific computation. One of the important obstacles in this transition is the large amount of legacy code written in MATLAB<sup>&#x000ae;</sup>. A fully automatic translation system could enable the reuse of large projects, the size of which makes human translation infeasible. By presenting OMPC, we demonstrated that Python could adopt MATLAB<sup>&#x000ae;</sup> code for reuse; without human intervention this code can be translated into Python. OMPC does this in a manner that, whenever possible, preserves the structure of the original. The syntax and design of MATLAB<sup>&#x000ae;</sup> language proved to be easy for beginners. In MATLAB<sup>&#x000ae;</sup> every object is also a multi-dimensional array, even a number is a 1 &#x000d7; 1 matrix. Python users however face the challenge of understanding concepts such as different types (numbers and arrays) and others common in programming, for example object reference. A number of MATLAB<sup>&#x000ae;</sup> inspired features could help removing many obstacles for a user introduced to Python's numerical facilities. We discussed such features and their implementation in OMPC. By providing automatic translation of MATLAB<sup>&#x000ae;</sup> code to Python and the enhanced ease of use, OMPC will promote Python as the open-source alternative for scientific computation. To the Python community, OMPC offers this bridge as an incentive towards the further enhancement of numerical computation capabilities.</p></sec><sec><title>Supplementary Material</title><p>The Supplemental Data for this article can be found online at <uri xlink:type="simple" xlink:href="http://ompc.juricap.com/">http://ompc.juricap.com/</uri>.</p></sec><sec><title>Conflict of Interest Statement</title><p>The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p></sec></body><back><ack><p>MATLAB<sup>&#x000ae;</sup> is a registered trademark of The MathWorks, Inc. &#x0201c;Python&#x0201d; and the Python logos are trademarks or registered trademarks of the Python Software Foundation.</p></ack><ref-list><title>References</title><ref id="B1"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Ascher</surname><given-names>D.</given-names></name><name><surname>Dubois</surname><given-names>P. F.</given-names></name><name><surname>Hinsen</surname><given-names>K.</given-names></name><name><surname>Hugunin</surname><given-names>J.</given-names></name><name><surname>Oliphant</surname><given-names>T.</given-names></name></person-group> (<year>2001</year>). <article-title>Numerical Python, Technical Report UCRL-MA-128569, Lawrence Livermore National Laboratory</article-title>. Available at: <uri xlink:type="simple" xlink:href="http://numpy.scipy.org">http://numpy.scipy.org</uri></citation></ref><ref id="B2"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Fangohr</surname><given-names>H.</given-names></name></person-group> (<year>2004</year>). <article-title>A Comparison of C, MATLAB, and Python as Teaching Languages in Engineering, Lecture Notes in Computer Science</article-title>, Vol. <volume>3039/2004</volume> <publisher-loc>Berlin/Heidelberg</publisher-loc>, <publisher-name>Springer</publisher-name>, pp. <fpage>1210</fpage>&#x02013;<lpage>1217</lpage></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Izhikevich</surname><given-names>E. M.</given-names></name></person-group> (<year>2003</year>). <article-title>Simple model of spiking neurons</article-title>. <source>IEEE Trans. Neural Netw.</source><volume>14</volume>, <fpage>1569</fpage>&#x02013;<lpage>1572</lpage><pub-id pub-id-type="doi">10.1109/TNN.2003.820440</pub-id><pub-id pub-id-type="pmid">18244602</pub-id></citation></ref><ref id="B4"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Langtangen</surname><given-names>H. P.</given-names></name></person-group> (<year>2006</year>). <article-title>Python Scripting for Computational Science</article-title>. <publisher-loc>Basel</publisher-loc>, <publisher-name>Birkh&#x000e4;user</publisher-name></citation></ref><ref id="B5"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Moler</surname><given-names>C.</given-names></name><collab>The Creator of MATLAB</collab></person-group> (<year>2004</year>). <article-title>The Origins of MATLAB</article-title>. Available at: <uri xlink:type="simple" xlink:href="http://www.mathworks.com/company/newsletters/news_notes/clevescorner/dec04.html">http://www.mathworks.com/company/newsletters/news_notes/clevescorner/dec04.html</uri></citation></ref><ref id="B6"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Moler</surname><given-names>C.</given-names></name></person-group> (<year>2006</year>). <article-title>The Growth of MATLAB and The MathWorks over Two Decades</article-title>. Available at: <uri xlink:type="simple" xlink:href="http://www.mathworks.com/company/newsletters/news_notes/clevescorner/jan06.pdf">http://www.mathworks.com/company/newsletters/news_notes/clevescorner/jan06.pdf</uri></citation></ref><ref id="B7"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Oliphant</surname><given-names>T. E.</given-names></name></person-group> (<year>2006</year>). <article-title>Guide to NumPy</article-title>. <publisher-loc>Trelgol Publishing</publisher-loc>, <publisher-name>Spanish Fork, UT</publisher-name> Available at: <uri xlink:type="simple" xlink:href="http://numpy.scipy.org">http://numpy.scipy.org</uri></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Oliphant</surname><given-names>T. E.</given-names></name></person-group> (<year>2007</year>). <article-title>Python for scientific computing</article-title>. <source>Comput. Sci. Eng.</source><volume>9</volume>, <fpage>10</fpage>&#x02013;<lpage>20</lpage><pub-id pub-id-type="doi">10.1109/MCSE.2007.58</pub-id></citation></ref><ref id="B9"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Oliphant</surname><given-names>T. E.</given-names></name><name><surname>Banks</surname><given-names>C.</given-names></name></person-group> (<year>2006</year>). <article-title>Index of Python Enhancement Proposals (PEPs), PEP 3118: Revising the Buffer Protocol</article-title>. Available at: <uri xlink:type="simple" xlink:href="http://www.python.org/dev/peps/pep-3118/">http://www.python.org/dev/peps/pep-3118/</uri></citation></ref><ref id="B10"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Rigo</surname><given-names>A.</given-names></name><name><surname>Pedroni</surname><given-names>S.</given-names></name></person-group> (<year>2006</year>). <article-title>PyPy's Approach to Virtual Machine Construction, Dynamic Languages Symposium at OOPSLA</article-title>. Available at: <uri xlink:type="simple" xlink:href="http://codespeak.net/svn/pypy/extradoc/talk/dls2006/pypy-vm-construction.pdf">http://codespeak.net/svn/pypy/extradoc/talk/dls2006/pypy-vm-construction.pdf</uri></citation></ref><ref id="B11"><citation citation-type="web"><person-group person-group-type="author"><name><surname>Zhu</surname><given-names>H.</given-names></name><name><surname>Lielens</surname><given-names>G.</given-names></name></person-group> (<year>2000</year>). <article-title>Index of Python Enhancement Proposals (PEPs), PEP 225: Elementwise/Objectwise Operators</article-title>. Available at: <uri xlink:type="simple" xlink:href="http://www.python.org/dev/peps/pep-0225/">http://www.python.org/dev/peps/pep-0225/</uri></citation></ref></ref-list><fn-group><fn id="fn1"><p><sup>1</sup>The following sections contain listings of code in both programming languages. We adhere to the following convention: The mark &#x0003e;&#x0003e; at the beginning of a statement signifies a MATLAB<sup>&#x000ae;</sup> program, while the mark &#x0003e;&#x0003e;&#x0003e; signifies Python code. Each of the concepts introduced in the following subsections has a corresponding executable script that is part of the Supplementary Material.</p></fn></fn-group></back></article>