<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208160</article-id><article-id pub-id-type="pmc">2648735</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S57</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S57</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Finding motif pairs in the interactions between heterogeneous proteins via bootstrapping and boosting</article-title></title-group><contrib-group><contrib id="A1" contrib-type="author"><name><surname>Kim</surname><given-names>Jisu</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>sujiper@inhainan.net</email></contrib><contrib id="A2" contrib-type="author"><name><surname>Huang</surname><given-names>De-Shuang</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>dshuang@iim.ac.cn</email></contrib><contrib id="A3" corresp="yes" contrib-type="author"><name><surname>Han</surname><given-names>Kyungsook</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>khan@inha.ac.kr</email></contrib></contrib-group><aff id="I1"><label>1</label>School of Computer Science and Engineering, Inha University, Incheon, South Korea</aff><aff id="I2"><label>2</label>Hefei Institute of Intelligent Machines, Chinese Academy of Sciences, China</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S57</fpage><lpage>S57</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S57"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Kim and Han; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Kim and Han; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Kim               Jisu                              sujiper@inhainan.net            </dc:author><dc:title>            Finding motif pairs in the interactions between heterogeneous proteins via bootstrapping and boosting         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S57-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S57&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>Supervised learning and many stochastic methods for predicting protein-protein interactions require both negative and positive interactions in the training data set. Unlike positive interactions, negative interactions cannot be readily obtained from interaction data, so these must be generated. In protein-protein interactions and other molecular interactions as well, taking all non-positive interactions as negative interactions produces too many negative interactions for the positive interactions. Random selection from non-positive interactions is unsuitable, since the selected data may not reflect the original distribution of data.</p></sec><sec><title>Results</title><p>We developed a bootstrapping algorithm for generating a negative data set of arbitrary size from protein-protein interaction data. We also developed an efficient boosting algorithm for finding interacting motif pairs in human and virus proteins. The boosting algorithm showed the best performance (84.4% sensitivity and 75.9% specificity) with balanced positive and negative data sets. The boosting algorithm was also used to find potential motif pairs in complexes of human and virus proteins, for which structural data was not used to train the algorithm. Interacting motif pairs common to multiple folds of structural data for the complexes were proven to be statistically significant. The data set for interactions between human and virus proteins was extracted from BOND and is available at <ext-link ext-link-type="uri" xlink:href="http://virus.hpid.org/interactions.aspx"/>. The complexes of human and virus proteins were extracted from PDB and their identifiers are available at <ext-link ext-link-type="uri" xlink:href="http://virus.hpid.org/PDB_IDs.html"/>.</p></sec><sec><title>Conclusion</title><p>When the positive and negative training data sets are unbalanced, the result via the prediction model tends to be biased. Bootstrapping is effective for generating a negative data set, for which the size and distribution are easily controlled. Our boosting algorithm could efficiently predict interacting motif pairs from protein interaction and sequence data, which was trained with the balanced data sets generated via the bootstrapping method.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>Linear motifs are known to facilitate many protein-protein interactions [<xref ref-type="bibr" rid="B1">1</xref>]. Despite the availability of a large volume of data about protein-protein interactions and their sequences, linear motifs are difficult to discover, due to their short length, which is between three and ten amino acids [<xref ref-type="bibr" rid="B2">2</xref>]. Recently, several methods have been developed for discovering linear motifs of protein-protein interactions [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B3">3</xref>], but most methods focus on detecting individual linear motifs rather than interacting motif pairs. Motif pairs are more useful than motifs for filtering many spurious protein interactions in current high-throughput data, and for identifying a functional target.</p><p>Supervised learning or stochastic methods are often used to predict linear motifs involved in protein-protein interactions. Both negative and positive interactions are required to train the methods. Unlike positive interaction data, negative samples cannot be readily obtained from protein-protein interaction data. Assuming a negative interaction where there is no explicit evidence of a positive interaction results in a much larger negative data set than a positive data set. Such an unbalance between positive and negative data sets makes a prediction biased [<xref ref-type="bibr" rid="B4">4</xref>,<xref ref-type="bibr" rid="B5">5</xref>]. Generating a negative data set via random selection often does not reflect the original distribution of data, thus it does not produce a good prediction model.</p><p>There are a few methods for generating a negative data set. Jansen et al. [<xref ref-type="bibr" rid="B6">6</xref>] generate a data set of negative interactions by assuming that proteins in different subcellular compartments of a cell do not interact. However, different subcellular locations only indicate that the proteins have a lower chance of binding than those in the same location, and some proteins are found in more than one subcellular compartment of a cell [<xref ref-type="bibr" rid="B7">7</xref>]. The method developed by Gomez et al. [<xref ref-type="bibr" rid="B8">8</xref>] assumes a negative protein interaction, if there is no explicit evidence of an interaction. However, this assumption generates a negative data set that is too large, resulting in low sensitivity in interaction predictions. The method that uses the shortest path [<xref ref-type="bibr" rid="B7">7</xref>] has difficulty in obtaining a negative data set of the desired size. The method that uses sequence similarity [<xref ref-type="bibr" rid="B9">9</xref>] also has difficulty in controlling the size of the negative data set.</p><p>In this study, we developed a bootstrapping algorithm for generating a negative data set of protein-protein interactions, and a new boosting algorithm for finding interacting motif pairs from positive and negative data sets. The remainder of the paper describes the algorithms and their experimental results with various parameter values.</p></sec><sec><title>Results and discussion</title><p>We measured the prediction performance of the boosting algorithm in terms of sensitivity, specificity and accuracy.</p><p><disp-formula id="bmcM1"><label>(1)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S57-i1" overflow="scroll">                  <mml:semantics>                     <mml:mrow>                        <mml:mi>S</mml:mi>                        <mml:mi>e</mml:mi>                        <mml:mi>n</mml:mi>                        <mml:mi>s</mml:mi>                        <mml:mi>i</mml:mi>                        <mml:mi>t</mml:mi>                        <mml:mi>i</mml:mi>                        <mml:mi>v</mml:mi>                        <mml:mi>i</mml:mi>                        <mml:mi>t</mml:mi>                        <mml:mi>y</mml:mi>                        <mml:mo>=</mml:mo>                        <mml:mfrac>                           <mml:mrow>                              <mml:mi>T</mml:mi>                              <mml:mi>P</mml:mi>                           </mml:mrow>                           <mml:mrow>                              <mml:mi>T</mml:mi>                              <mml:mi>P</mml:mi>                              <mml:mo>+</mml:mo>                              <mml:mi>F</mml:mi>                              <mml:mi>N</mml:mi>                           </mml:mrow>                        </mml:mfrac>                     </mml:mrow>                                       </mml:semantics>               </mml:math></disp-formula></p><p><disp-formula id="bmcM2"><label>(2)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S57-i2" overflow="scroll">                  <mml:semantics>                     <mml:mrow>                        <mml:mi>S</mml:mi>                        <mml:mi>p</mml:mi>                        <mml:mi>e</mml:mi>                        <mml:mi>c</mml:mi>                        <mml:mi>i</mml:mi>                        <mml:mi>f</mml:mi>                        <mml:mi>i</mml:mi>                        <mml:mi>c</mml:mi>                        <mml:mi>i</mml:mi>                        <mml:mi>t</mml:mi>                        <mml:mi>y</mml:mi>                        <mml:mo>=</mml:mo>                        <mml:mfrac>                           <mml:mrow>                              <mml:mi>T</mml:mi>                              <mml:mi>N</mml:mi>                           </mml:mrow>                           <mml:mrow>                              <mml:mi>T</mml:mi>                              <mml:mi>N</mml:mi>                              <mml:mo>+</mml:mo>                              <mml:mi>F</mml:mi>                              <mml:mi>P</mml:mi>                           </mml:mrow>                        </mml:mfrac>                     </mml:mrow>                                       </mml:semantics>               </mml:math></disp-formula></p><p><disp-formula id="bmcM3"><label>(3)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S57-i3" overflow="scroll">                  <mml:semantics>                     <mml:mrow>                        <mml:mi>A</mml:mi>                        <mml:mi>c</mml:mi>                        <mml:mi>c</mml:mi>                        <mml:mi>u</mml:mi>                        <mml:mi>r</mml:mi>                        <mml:mi>a</mml:mi>                        <mml:mi>c</mml:mi>                        <mml:mi>y</mml:mi>                        <mml:mo>=</mml:mo>                        <mml:mfrac>                           <mml:mrow>                              <mml:mi>T</mml:mi>                              <mml:mi>P</mml:mi>                              <mml:mo>+</mml:mo>                              <mml:mi>T</mml:mi>                              <mml:mi>N</mml:mi>                           </mml:mrow>                           <mml:mrow>                              <mml:mi>T</mml:mi>                              <mml:mi>P</mml:mi>                              <mml:mo>+</mml:mo>                              <mml:mi>F</mml:mi>                              <mml:mi>P</mml:mi>                              <mml:mo>+</mml:mo>                              <mml:mi>T</mml:mi>                              <mml:mi>N</mml:mi>                              <mml:mo>+</mml:mo>                              <mml:mi>F</mml:mi>                              <mml:mi>N</mml:mi>                           </mml:mrow>                        </mml:mfrac>                     </mml:mrow>                                       </mml:semantics>               </mml:math></disp-formula></p><p>In the following description, the <italic>sampling size S </italic>is the number of negative samples that were examined to generate a single negative data via bootstrapping. When the number of negative samples with <italic>m</italic>-th feature = 1 is greater than the <italic>acceptance ratio A</italic>, the <italic>m</italic>-th feature of the re-sampled negative data is set to 1. The feature vector and the acceptance ratio are described in detail in the method section.</p><sec><title>Affect of acceptance ratios</title><p>From the interactions between human and virus proteins, we generated four different negative data sets, by executing the bootstrapping algorithm with four acceptance ratios (1/10, 1/8, 1/6, 1/4). Then, we used both the negative and positive data sets to test the boosting algorithm via five-fold cross validation. Motif pairs predicted from each fold were combined as follows: M<sub>i </sub>= {motif pairs found in at least <italic>i </italic>folds} where i = {1, 2, ..., 5} [<xref ref-type="bibr" rid="B7">7</xref>]. Table <xref ref-type="table" rid="T1">1</xref> shows the number of motif pairs predicted with different acceptance ratios.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Motif pairs found during five-fold cross validation</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="left">A = 1/10</td><td align="left">A = 1/8</td><td align="left">A = 1/6</td><td align="left">A = 1/4</td></tr></thead><tbody><tr><td align="left">M<sub>1</sub></td><td align="left">12563</td><td align="left">21821</td><td align="left">50634</td><td align="left">142395</td></tr><tr><td align="left">M<sub>2</sub></td><td align="left">3479</td><td align="left">4866</td><td align="left">12472</td><td align="left">38008</td></tr><tr><td align="left">M<sub>3</sub></td><td align="left">1047</td><td align="left">1181</td><td align="left">3498</td><td align="left">15220</td></tr><tr><td align="left">M<sub>4</sub></td><td align="left">189</td><td align="left">344</td><td align="left">874</td><td align="left">6970</td></tr><tr><td align="left">M<sub>5</sub></td><td align="left">28</td><td align="left">105</td><td align="left">141</td><td align="left">2134</td></tr></tbody></table><table-wrap-foot><p>M<sub>i </sub>denotes a set of motif pairs found in at least <italic>i </italic>folds during five-fold cross validation.</p></table-wrap-foot></table-wrap><p>As the acceptance ratio increases, re-sampled negative data have fewer nonzero features, resulting in more motif pairs. This is because the nonzero features of negative data are used to filter out the features that are also nonzero in positive data.</p><p>With the sampling size of 120, most non-interaction data were re-sampled to generate a negative data set. We compared the prediction performance of the algorithm with respect to four different acceptance ratios. As shown in Table <xref ref-type="table" rid="T2">2</xref>, prediction of motif pairs with a larger acceptance ratio shows a much better performance than that with a smaller acceptance ratio. As the acceptance ratio increases, negative data have more nonzero features. Hence, data with many zero features are easily classified as negative samples.</p><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Prediction performance with respect to acceptance ratios of bootstrapping</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="left">A = 1/10</td><td align="left">A = 1/8</td><td align="left">A = 1/6</td><td align="left">A = 1/4</td></tr></thead><tbody><tr><td align="left">Sensitivity</td><td align="left">58.35%</td><td align="left">75.88%</td><td align="left">82.42%</td><td align="left">90.42%</td></tr><tr><td align="left">Specificity</td><td align="left">78.83%</td><td align="left">84.40%</td><td align="left">92.29%</td><td align="left">96.02%</td></tr><tr><td align="left">Accuracy</td><td align="left">66.09%</td><td align="left">80.14%</td><td align="left">87.35%</td><td align="left">93.22%</td></tr></tbody></table><table-wrap-foot><p>As the acceptance ratio A increases, the prediction performance of motif pairs is improved.</p></table-wrap-foot></table-wrap></sec><sec><title>Affect of proportions of positive and negative data sets</title><p>For the purpose of comparing the prediction performance with respect to different proportions of positive and negative data sets, we generated three negative data sets with the sampling size of 120 and acceptance ratio of 1/8. The data set for 1,712 interactions between human proteins and virus proteins was used as the positive data set. Table <xref ref-type="table" rid="T3">3</xref> and Figure <xref ref-type="fig" rid="F1">1</xref> show the prediction performance with respect to three different proportions of positive and negative data sets. As the proportion of positive data increases, sensitivity increases, but specificity decreases. It is interesting to note that the size of the negative data sets alone affects the performance.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Sensitivity and specificity of predictions with respect to proportions of positive and the negative data</bold>. As the proportion of positive data increases, the sensitivity increases but the specificity decreases.</p></caption><graphic xlink:href="1471-2105-10-S1-S57-1"/></fig><table-wrap position="float" id="T3"><label>Table 3</label><caption><p>Prediction performance with respect to proportions of positive and negative data</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Data ratio<break/>(P: N)</td><td align="left">1712: 2283<break/>(2: 3)</td><td align="left">1712: 1712<break/>(1: 1)</td><td align="left">1712: 1141<break/>(3: 2)</td></tr></thead><tbody><tr><td align="left">Sensitivity</td><td align="left">68.98%</td><td align="left">75.88%</td><td align="left">77.80%</td></tr><tr><td align="left">Specificity</td><td align="left">87.03%</td><td align="left">84.40%</td><td align="left">77.56%</td></tr><tr><td align="left">Accuracy</td><td align="left">79.30%</td><td align="left">80.14%</td><td align="left">77.70%</td></tr></tbody></table><table-wrap-foot><p>P: positive data, N: negative data.</p></table-wrap-foot></table-wrap></sec><sec><title>Affect of boosting algorithms</title><p>The execution time of the boosting algorithm is influenced by the number of hypotheses (T; for Yu's AdaBoost algorithm only), the number of partitioned data sets (S), and the number of randomly selected training data for weak hypotheses (R). Suppose that we set parameters; T = 4, S = 5 and R = 100,000. Yu's AdaBoost uses 5 &#x000d7; 4 = 20 weak hypotheses. But, our boosting algorithm uses only five weak hypotheses. While Yu's AdaBoost uses four weak hypotheses per data set, our boosting algorithm uses only one weak hypothesis per data set. With fewer weak hypotheses than Yu's AdaBoost algorithm, our algorithm has a better performance, as shown in Table <xref ref-type="table" rid="T4">4</xref>.</p><table-wrap position="float" id="T4"><label>Table 4</label><caption><p>Prediction performance of two boosting algorithms</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Boosting algorithm</td><td align="left">AdaBoost algorithm</td><td align="left">Our Boosting algorithm</td></tr></thead><tbody><tr><td align="left">Sensitivity</td><td align="left">70.55%</td><td align="left">75.88%</td></tr><tr><td align="left">Specificity</td><td align="left">84.21%</td><td align="left">84.40%</td></tr><tr><td align="left">Accuracy</td><td align="left">77.37%</td><td align="left">80.14%</td></tr></tbody></table><table-wrap-foot><p>Parameter values: T = 4, S = 5, R = 100,000.</p></table-wrap-foot></table-wrap></sec><sec><title>Motif pairs found in complexes of human and virus proteins</title><p>Table <xref ref-type="table" rid="T5">5</xref> shows the p-values for each set of motif pairs. The p-value of M<sub>1 </sub>= 1, implying that motif pairs of M<sub>1 </sub>had no more significance than random motif pairs. However, motif pairs of M<sub>2</sub>-M<sub>5 </sub>were more significant than random motif pairs. Figure <xref ref-type="fig" rid="F2">2</xref> shows a complex of human and HIV-1 proteins (PDB ID: <ext-link ext-link-type="pdb" xlink:href="1AGF">1AGF</ext-link>). Among the total of 63 contact residues between chains A and C, 16 residue pairs were included in M<sub>2</sub>.</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Motif pairs predicted for 1AGF</bold>. <italic>Red balls</italic>: contact residue pairs correctly predicted, <italic>Cyan balls</italic>: contact residue pairs missed in the prediction, <italic>Gray wireframe</italic>: non-contact residues</p></caption><graphic xlink:href="1471-2105-10-S1-S57-2"/></fig><table-wrap position="float" id="T5"><label>Table 5</label><caption><p>Motif pairs found in each fold</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center">Set</td><td align="center"># of motif pairs</td><td align="center">p-value</td></tr></thead><tbody><tr><td align="center">M<sub>1</sub></td><td align="center">334</td><td align="center">1</td></tr><tr><td align="center">M<sub>2</sub></td><td align="center">87</td><td align="center">3.13e-3</td></tr><tr><td align="center">M<sub>3</sub></td><td align="center">22</td><td align="center">3.02e-3</td></tr><tr><td align="center">M<sub>4</sub></td><td align="center">7</td><td align="center">2.25e-2</td></tr><tr><td align="center">M<sub>5</sub></td><td align="center">2</td><td align="center">1.79e-1</td></tr></tbody></table><table-wrap-foot><p>The number of motif pairs predicted by our boosting algorithm for complexes of human and virus proteins.</p></table-wrap-foot></table-wrap></sec></sec><sec><title>Conclusion</title><p>When positive and negative training data sets are unbalanced, the result via the prediction model tends to be biased. We developed a bootstrapping algorithm for generating a negative data set of arbitrary size from protein-protein interaction data. We also developed an efficient boosting algorithm for finding interacting motif pairs in human and virus proteins. The boosting algorithm showed the best performance (84.4% sensitivity and 75.9% specificity) with balanced positive and negative data sets. The boosting algorithm was also used to find potential motif pairs in complexes of human and virus proteins, for which structural data was not used for training the algorithm. Interacting motif pairs common to multiple folds of structural data of complexes were proven to be statistically significant.</p><p>This method predicts protein-protein interactions and motif pairs using the protein sequence data. The sequence information alone is insufficient to predict motif pairs for some proteins, but our method provides a useful model for predicting motif pairs in protein-protein interactions when the sequence is the only information available. The data set for interactions between human and virus proteins was extracted from BOND and is available at <ext-link ext-link-type="uri" xlink:href="http://virus.hpid.org/interactions.aspx"/>. The complexes of human and virus proteins were extracted from PDB and their identifiers are available at <ext-link ext-link-type="uri" xlink:href="http://virus.hpid.org/PDB_IDs.html"/>.</p></sec><sec sec-type="methods"><title>Methods</title><sec><title>Data set</title><p>We extracted the latest data of interactions between human and virus proteins from BOND [<xref ref-type="bibr" rid="B10">10</xref>]. As of May, 2008, there were 1,712 interactions between 1,029 human proteins and 603 virus proteins. These interactions were considered as positive data. From 1,712 interactions, we constructed three negative data sets of 2,252, 1,712, and 2,283 samples via the bootstrapping method.</p></sec><sec><title>Feature vector</title><p>The way of extracting features in our study was similar to the one used in the studies of Gomez et al. [<xref ref-type="bibr" rid="B8">8</xref>] and Yu et al. [<xref ref-type="bibr" rid="B7">7</xref>]. In the study by Gomez et al., four-tuple features were used to identify a subsequence of four amino acids. Based on biochemical similarities of amino acids, twenty amino acids were classified into six categories: {IVLM}, {FYW}, {HKR}, {DE}, {QNTP}, and {ACGS} [<xref ref-type="bibr" rid="B11">11</xref>]. After classification, there were 6<sup>4 </sup>= 1,296 possible substrings of length four.</p><p>For a given protein sequence, a four-tuple feature is represented as a 1,296-bit binary vector, in which each bit indicates whether the corresponding length-four string occurs in the protein. The encoding scheme for the interaction binary vector is described in Table <xref ref-type="table" rid="T6">6</xref>.</p><table-wrap position="float" id="T6"><label>Table 6</label><caption><p>Encoding scheme for the interacting motif pairs</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left" colspan="2">Biochemical property</td><td align="center" colspan="3">4-tuple pairs (M bits)</td></tr></thead><tbody><tr><td></td><td></td><td></td><td align="center" colspan="2">Candidate motif pair</td></tr><tr><td></td><td></td><td></td><td colspan="2"><hr></hr></td></tr><tr><td align="left">Classification</td><td align="center">Category number</td><td align="center">Bit number</td><td align="center">Human 4-tuple</td><td align="center">Virus 4-tuple</td></tr><tr><td colspan="5"><hr></hr></td></tr><tr><td align="left">{I, V, L, M}</td><td align="center">0</td><td align="center">1</td><td align="center">0000</td><td align="center">0000</td></tr><tr><td align="left">{F, Y, W}</td><td align="center">1</td><td align="center">2</td><td align="center">0000</td><td align="center">0001</td></tr><tr><td align="left">{H, K, R}</td><td align="center">2</td><td align="center">&#x022ee;</td><td align="center">&#x022ee;</td><td align="center">&#x022ee;</td></tr><tr><td align="left">{D, E}</td><td align="center">3</td><td></td><td></td><td></td></tr><tr><td align="left">{Q, N, T, P}</td><td align="center">4</td><td align="center">M-1</td><td align="center">5555</td><td align="center">5554</td></tr><tr><td align="left">{A, C, G, S}</td><td align="center">5</td><td align="center">M</td><td align="center">5555</td><td align="center">5555</td></tr></tbody></table><table-wrap-foot><p>The total number of possible motif pairs is 1,679,616, 1-bit for each motif pair. 1 represents the corresponding motif pair exists in the pair of proteins, and 0 represents the motif pair is absent.</p></table-wrap-foot></table-wrap><p>Both our previous study [<xref ref-type="bibr" rid="B9">9</xref>] and the study of Yu et al. [<xref ref-type="bibr" rid="B7">7</xref>] found interacting motif pairs in yeast proteins. A binary vector representing an interacting motif pair is a palindrome, so the total number M<sub>symmetric </sub>of possible motif pairs is determined by</p><p><disp-formula id="bmcM4"><label>(4)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S57-i4" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>M</mml:mi>                              <mml:mrow>                                 <mml:mi>s</mml:mi>                                 <mml:mi>y</mml:mi>                                 <mml:mi>m</mml:mi>                                 <mml:mi>m</mml:mi>                                 <mml:mi>e</mml:mi>                                 <mml:mi>t</mml:mi>                                 <mml:mi>r</mml:mi>                                 <mml:mi>i</mml:mi>                                 <mml:mi>c</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo>=</mml:mo>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mtable>                                    <mml:mtr>                                       <mml:mtd>                                          <mml:mrow>                                             <mml:msup>                                                <mml:mn>6</mml:mn>                                                <mml:mn>4</mml:mn>                                             </mml:msup>                                          </mml:mrow>                                       </mml:mtd>                                    </mml:mtr>                                    <mml:mtr>                                       <mml:mtd>                                          <mml:mn>2</mml:mn>                                       </mml:mtd>                                    </mml:mtr>                                 </mml:mtable>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                           <mml:mo>+</mml:mo>                           <mml:msup>                              <mml:mn>6</mml:mn>                              <mml:mn>4</mml:mn>                           </mml:msup>                           <mml:mo>=</mml:mo>                           <mml:mn>840</mml:mn>                           <mml:mo>,</mml:mo>                           <mml:mn>456</mml:mn>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>The interactions between human and virus proteins are the interactions between heterogeneous proteins. Hence, the total number M<sub>asymmetric </sub>of possible motif pairs is as follows.</p><p><disp-formula id="bmcM5"><label>(5)</label><italic>M</italic><sub><italic>asymmetric </italic></sub>= 6<sup>4</sup>&#x000b7;6<sup>4 </sup>= 1,679,616</disp-formula></p><p>Our method is intended for finding motif pairs with 4 consecutive residues (i, i+1, i+2 and i+3) in each motif. Hence, a motif with non-consecutive residues cannot be found even if the residues are spatially close to each other. Since the total number of possible motif pairs is 6<sup><italic>m</italic></sup>&#x000b7;6<sup><italic>m </italic></sup>= (6<sup><italic>m</italic></sup>)<sup>2 </sup>= 6<sup>2<italic>m </italic></sup>for a motif of size <italic>m </italic>(equation 5), the total number of possible motif pairs increases exponentially as the size of <italic>m </italic>increases. The total number of possible motif pairs can be reduced with a motif of a smaller size (e.g., 2 or 3 residues), but the motif of a small size has too many occurrences in the sequences, which significantly reduces the selectivity of the motif.</p></sec><sec><title>Bootstrapping for re-sampling</title><p>As in Gomez et al.'s method [<xref ref-type="bibr" rid="B8">8</xref>], we assumed a negative interaction if there was no explicit evidence of an interaction. However, this assumption generates a much larger number of negative samples than positive samples. If we randomly select only some of the negative samples, we might miss information from unselected negative samples. Dupret and Koda [<xref ref-type="bibr" rid="B5">5</xref>] used bootstrapping to identify the optimal re-sampling proportions in binary classification experiments.</p><p>In our study, we used bootstrapping to generate negative data sets via re-sampling negative data. Algorithm 1 describes our bootstrapping method, which is controlled by the sampling size <italic>S </italic>and acceptance ratio <italic>A</italic>. Executing the bootstrapping algorithm yields a single re-sampled negative data from <italic>S </italic>negative data. The re-sampled negative data is represented as a feature vector Y = {y<sub>1</sub>, y<sub>2</sub>, ..., y<sub>M</sub>} via Algorithm 1. The number of 1's in the feature vector Y is controlled by the acceptance ratio <italic>A</italic>. A larger value of <italic>A </italic>produces a feature vector with fewer nonzero elements.</p></sec><sec><title>Algorithm 1 &#x02013; Bootstrapping algorithm</title><p>This algorithm generates the feature vector Y for a single negative data from S samples, where S is the sampling size and A is the acceptance ratio for setting a feature to 1.</p><p>1. Randomly sample S protein pairs (P<sub>s1</sub>, P<sub>s2</sub>) with replacement from non-interacting protein pairs, where s = {1, 2, ..., S}.</p><p>2. Initialize n<sub>i </sub>= 0 for i = {1, 2, ..., M}</p><p>3. Initialize y<sub>i </sub>= 0 for i = {1, 2, ..., M}</p><p>4. For s == {1, 2, ..., S}</p><p>&#x000a0;&#x000a0;&#x000a0;a. Make a binary vector X<sub>s </sub>= {x<sub>s1</sub>, x<sub>s2</sub>, ..., x<sub>sM</sub>} for a pair of proteins (P<sub>s1</sub>, P<sub>s2</sub>)</p><p>&#x000a0;&#x000a0;&#x000a0;b. For m = {1...M}</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;If x<sub>sm </sub>= 1, n<sub>m </sub>= n<sub>m </sub>+ 1 {n<sub>m </sub>is the number of samples for which the <italic>m</italic>-th feature = 1}</p><p>5. For m = {1...M}</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;If n<sub>m</sub>/S &#x0003e; A, set y<sub>m </sub>= 1</p><p>6. Y = {y<sub>1</sub>, y<sub>2</sub>, ..., y<sub>M</sub>} is a feature vector representing re-sampled negative data.</p></sec><sec><title>The boosting algorithm</title><p>In general, the boosting method finds a highly accurate hypothesis by combining weak hypotheses, each of which is only moderately accurate. Typically, each weak hypothesis is a simple classification rule. In AdaBoost (Adaptive Boosting), each weak hypothesis generates not only a classification rule but also a confidence score that estimates the reliability of the classification [<xref ref-type="bibr" rid="B12">12</xref>].</p><p>The study of Yu et al. [<xref ref-type="bibr" rid="B7">7</xref>] uses the AdaBoost algorithm for finding motif pairs in homogeneous protein interactions. One of the differences between Yu's algorithm and ours is the number of weak hypotheses used in the algorithms. In Yu's AdaBoost algorithm, if the weight (&#x003b1;<sub>s1</sub>) of the first weak hypothesis is much greater than the weights of other hypotheses, the final hypothesis is determined mainly by the first weak hypothesis and other hypotheses have negligible effect on the final hypothesis.</p><p>Our boosting algorithm determines the weights of weak hypotheses and uses the training data in a different way from Yu's algorithm. While Yu's AdaBoost algorithm uses different weights and the same training data per weak hypothesis, our algorithm uses the same weights and different training data per weak hypothesis. Our boosting algorithm uses fewer weak hypotheses than Yu's algorithm, and requires much less time than their algorithm.</p><p>Our algorithm consists of two parts: boosting algorithm and WINNOW2 algorithm. The boosting algorithm described in Algorithm 2 takes as input a training set (x<sub>1</sub>, y<sub>1</sub>), ..., (x<sub>n</sub>, y<sub>n</sub>), where each pair is a binary vector of length M, which represents an interaction with a label in the label set Y. Y = {-1, +1} indicates whether each interaction is positive or negative. The boosting algorithm calls the WINNOW2 algorithm to obtain a weak hypothesis in an iterative series of rounds, where t = {1, ..., S}. In each round, the boosting algorithm computes the weight (&#x003b1;<sub>t</sub>) of the weak hypothesis <italic>h</italic><sub><italic>c</italic>,<italic>t</italic></sub>. The final hypothesis <italic>H</italic><sub><italic>t </italic></sub>for <italic>Set</italic><sub><italic>t </italic></sub>is the weighted sum of weak hypotheses <italic>h</italic><sub><italic>c</italic>,<italic>i </italic></sub>(<italic>i </italic>= 1, ..., <italic>S </italic>and <italic>i </italic>&#x02260; <italic>t</italic>).</p><p>We used a regulated stochastic WINNOW2 algorithm [<xref ref-type="bibr" rid="B13">13</xref>] with R = 200,000 as a weak classifier (Algorithm 3). The WINNOW2 algorithm is similar to that of Yu et al. [<xref ref-type="bibr" rid="B7">7</xref>], except for the step of updating learner factors. Yu's algorithm updates learner factors when x<sub>ki </sub>(feature vector) is 0, but our algorithm updates them when x<sub>ki </sub>is 1. Yu's algorithm takes as input a training set and computes normalized sample weights in each boosting round. In the step of drawing a sample data, data with larger weights are drawn more frequently than those with smaller weights. Since the sample weights are difficult to adjust in each round, our algorithm uses the same weight for every sample and draws samples with equal frequency. But, the training data is changed in every round, and the call to the WINNOW2 algorithm produces different hypotheses according to the training data. Finally, additional regulation is performed to discover effective components. The components with large learner factors are identified as effective components. These effective components are considered as the motif pairs of protein-protein interactions.</p><p>Suppose that there are five data sets (S = 5) and four weak hypotheses (T = 4 in Yu's algorithm) per round. Yu's AdaBoost algorithm requires 5 &#x000d7; 4 = 20 weak hypotheses to classify the data. In contrast, our boosting algorithm requires only one weak hypothesis per round, and five weak hypotheses in total, thus it does not need the parameter T. Since the execution times of the algorithms are proportional to the number of hypotheses, our algorithm is more than four times faster than Yu's algorithm for the same data set, without reducing the prediction accuracy [<xref ref-type="bibr" rid="B9">9</xref>]. The frameworks for both algorithms are shown in Figures <xref ref-type="fig" rid="F3">3</xref> and <xref ref-type="fig" rid="F4">4</xref>.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>Framework for Yu's AdaBoost algorithm</bold>. The AdaBoost algorithm requires 20 weak hypotheses for T = 4 and S = 5.</p></caption><graphic xlink:href="1471-2105-10-S1-S57-3"/></fig><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>The framework of our boosting algorithm</bold>. Our algorithm requires only 5 weak hypotheses for S = 5.</p></caption><graphic xlink:href="1471-2105-10-S1-S57-4"/></fig></sec><sec><title>Algorithm 2 &#x02013; boosting algorithm</title><p>The boosting algorithm calls the WINNOW2 algorithm to obtain weak hypotheses. S is the number of divided data sets.</p><p>1. Given divided data set <italic>Set</italic><sub>1</sub>, <italic>Set</italic><sub>2</sub>, ..., <italic>Set</italic><sub><italic>S </italic></sub>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S57-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>&#x0222a;</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>S</mml:mi></mml:munderover><mml:mrow><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>.</p><p>2. For <italic>t </italic>= 1, ..., <italic>S</italic></p><p>&#x000a0;&#x000a0;&#x000a0;a. Given training data (<italic>x</italic><sub>1</sub>, <italic>y</italic><sub>1</sub>), (<italic>x</italic><sub>2</sub>, <italic>y</italic><sub>2</sub>), ..., (<italic>x</italic><sub><italic>n</italic></sub>, <italic>y</italic><sub><italic>n</italic></sub>) from <italic>Set</italic><sub><italic>t </italic></sub>where <italic>x</italic><sub><italic>i </italic></sub>&#x02208; {0, 1}<sup><italic>M</italic></sup>, <italic>y</italic><sub><italic>i </italic></sub>&#x02208; <italic>Y </italic>= {-1, +1} for {<italic>i </italic>= 1, 2, ..., <italic>n</italic>}</p><p>&#x000a0;&#x000a0;&#x000a0;b. Call the WINNOW2 algorithm to obtain the weak hypothesis <italic>h</italic><sub><italic>c</italic>,<italic>t</italic></sub>.</p><p>&#x000a0;&#x000a0;&#x000a0;c. Compute the error <italic>r</italic><sub><italic>t </italic></sub>of the weak hypothesis <italic>h</italic><sub><italic>c</italic>,<italic>t </italic></sub>at level c.</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S57-i6" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>r</mml:mi>                              <mml:mi>t</mml:mi>                           </mml:msub>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mn>1</mml:mn>                              <mml:mi>n</mml:mi>                           </mml:mfrac>                           <mml:mstyle displaystyle="true">                              <mml:msub>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mi>i</mml:mi>                              </mml:msub>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>y</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                              </mml:mrow>                           </mml:mstyle>                           <mml:msub>                              <mml:mi>h</mml:mi>                              <mml:mrow>                                 <mml:mi>c</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>t</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:msub>                              <mml:mi>x</mml:mi>                              <mml:mi>i</mml:mi>                           </mml:msub>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>&#x000a0;&#x000a0;&#x000a0;d. Compute the weight <italic>&#x003b1;</italic><sub><italic>t </italic></sub>of the weak hypothesis</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S57-i7" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>&#x003b1;</mml:mi>                              <mml:mi>t</mml:mi>                           </mml:msub>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mn>1</mml:mn>                              <mml:mn>2</mml:mn>                           </mml:mfrac>                           <mml:mi>ln</mml:mi>                           <mml:mo>&#x02061;</mml:mo>                           <mml:mrow>                              <mml:mo>(</mml:mo>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mn>1</mml:mn>                                       <mml:mo>+</mml:mo>                                       <mml:msub>                                          <mml:mi>r</mml:mi>                                          <mml:mi>t</mml:mi>                                       </mml:msub>                                    </mml:mrow>                                    <mml:mrow>                                       <mml:mn>1</mml:mn>                                       <mml:mo>&#x02212;</mml:mo>                                       <mml:msub>                                          <mml:mi>r</mml:mi>                                          <mml:mi>t</mml:mi>                                       </mml:msub>                                    </mml:mrow>                                 </mml:mfrac>                              </mml:mrow>                              <mml:mo>)</mml:mo>                           </mml:mrow>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>3. Output the final hypothesis for <italic>Set</italic><sub><italic>t</italic></sub>:</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S57-i8" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>H</mml:mi>                              <mml:mi>t</mml:mi>                           </mml:msub>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>x</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>=</mml:mo>                           <mml:mi>s</mml:mi>                           <mml:mi>i</mml:mi>                           <mml:mi>g</mml:mi>                           <mml:mi>n</mml:mi>                           <mml:mstyle displaystyle="true">                              <mml:munderover>                                 <mml:mo>&#x02211;</mml:mo>                                 <mml:mrow>                                    <mml:mi>i</mml:mi>                                    <mml:mo>=</mml:mo>                                    <mml:mn>1</mml:mn>                                 </mml:mrow>                                 <mml:mrow>                                    <mml:mtable>                                       <mml:mtr>                                          <mml:mtd>                                             <mml:mrow>                                                <mml:mi>S</mml:mi>                                                <mml:mo>,</mml:mo>                                                <mml:mi>i</mml:mi>                                                <mml:mo>&#x02260;</mml:mo>                                                <mml:mi>t</mml:mi>                                             </mml:mrow>                                          </mml:mtd>                                       </mml:mtr>                                    </mml:mtable>                                 </mml:mrow>                              </mml:munderover>                              <mml:mrow>                                 <mml:msub>                                    <mml:mi>&#x003b1;</mml:mi>                                    <mml:mi>i</mml:mi>                                 </mml:msub>                              </mml:mrow>                           </mml:mstyle>                           <mml:msub>                              <mml:mi>h</mml:mi>                              <mml:mrow>                                 <mml:mi>c</mml:mi>                                 <mml:mo>,</mml:mo>                                 <mml:mi>i</mml:mi>                              </mml:mrow>                           </mml:msub>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>x</mml:mi>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>.</mml:mo>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p></sec><sec><title>Algorithm 3 &#x02013; WINNOW2 algorithm</title><p>The WINNOW2 algorithm trains the weak hypothesis. R is the number of randomly selected data.</p><p>1. Given training data (<italic>x</italic><sub>1</sub>, <italic>y</italic><sub>1</sub>), (<italic>x</italic><sub>2</sub>, <italic>y</italic><sub>2</sub>)..., (<italic>x</italic><sub><italic>n</italic></sub>, y<sub><italic>n</italic></sub>).</p><p>2. Initialize learner factor <italic>w</italic><sub><italic>i </italic></sub>= 1 for <italic>i </italic>= {1, 2, ..., <italic>M</italic>}, and threshold <italic>&#x003b8; </italic>= <italic>M</italic>/2</p><p>3. For <italic>r </italic>= {1, ..., <italic>R</italic>}</p><p>&#x000a0;&#x000a0;&#x000a0;a. Randomly select a sample data (<italic>x</italic><sub><italic>k</italic></sub>, <italic>y</italic><sub><italic>k</italic></sub>), and let vector <italic>x</italic><sub><italic>k </italic></sub>denote (<italic>x</italic><sub><italic>k</italic>1</sub>, <italic>x</italic><sub><italic>k</italic>2</sub>, ..., <italic>x</italic><sub><italic>kM</italic></sub>)</p><p>&#x000a0;&#x000a0;&#x000a0;b. The learner responds as follows:</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S57-i9" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mrow>                              <mml:mo>{</mml:mo>                              <mml:mrow>                                 <mml:mtable columnalign="left">                                    <mml:mtr columnalign="left">                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:mi>h</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>x</mml:mi>                                                <mml:mi>k</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo>=</mml:mo>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mn>1</mml:mn>                                          </mml:mrow>                                       </mml:mtd>                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:mi>i</mml:mi>                                             <mml:mi>f</mml:mi>                                          </mml:mrow>                                       </mml:mtd>                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:mstyle displaystyle="true">                                                <mml:msubsup>                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mrow>                                                      <mml:mi>i</mml:mi>                                                      <mml:mo>=</mml:mo>                                                      <mml:mn>1</mml:mn>                                                   </mml:mrow>                                                   <mml:mi>M</mml:mi>                                                </mml:msubsup>                                                <mml:mrow>                                                   <mml:msub>                                                      <mml:mi>w</mml:mi>                                                      <mml:mi>i</mml:mi>                                                   </mml:msub>                                                   <mml:msub>                                                      <mml:mi>x</mml:mi>                                                      <mml:mrow>                                                         <mml:mi>k</mml:mi>                                                         <mml:mi>i</mml:mi>                                                      </mml:mrow>                                                   </mml:msub>                                                   <mml:mo>&#x0003e;</mml:mo>                                                   <mml:mi>&#x003b8;</mml:mi>                                                </mml:mrow>                                             </mml:mstyle>                                          </mml:mrow>                                       </mml:mtd>                                    </mml:mtr>                                    <mml:mtr columnalign="left">                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:mi>h</mml:mi>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>x</mml:mi>                                                <mml:mi>k</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo>=</mml:mo>                                             <mml:mn>1</mml:mn>                                          </mml:mrow>                                       </mml:mtd>                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:mi>i</mml:mi>                                             <mml:mi>f</mml:mi>                                          </mml:mrow>                                       </mml:mtd>                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:mstyle displaystyle="true">                                                <mml:msubsup>                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mrow>                                                      <mml:mi>i</mml:mi>                                                      <mml:mo>=</mml:mo>                                                      <mml:mn>1</mml:mn>                                                   </mml:mrow>                                                   <mml:mi>M</mml:mi>                                                </mml:msubsup>                                                <mml:mrow>                                                   <mml:msub>                                                      <mml:mi>w</mml:mi>                                                      <mml:mi>i</mml:mi>                                                   </mml:msub>                                                   <mml:msub>                                                      <mml:mi>x</mml:mi>                                                      <mml:mrow>                                                         <mml:mi>k</mml:mi>                                                         <mml:mi>i</mml:mi>                                                      </mml:mrow>                                                   </mml:msub>                                                   <mml:mo>&#x02264;</mml:mo>                                                   <mml:mi>&#x003b8;</mml:mi>                                                </mml:mrow>                                             </mml:mstyle>                                          </mml:mrow>                                       </mml:mtd>                                    </mml:mtr>                                 </mml:mtable>                              </mml:mrow>                           </mml:mrow>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>&#x000a0;&#x000a0;&#x000a0;c. Update learner factors <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S57-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:semantics></mml:math></inline-formula></p><p>4. Define a regulated classifier <italic>h</italic><sub><italic>c </italic></sub>at level <italic>c </italic>as follows:</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S57-i11" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mrow>                              <mml:mo>{</mml:mo>                              <mml:mrow>                                 <mml:mtable columnalign="left">                                    <mml:mtr columnalign="left">                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>h</mml:mi>                                                <mml:mi>c</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>x</mml:mi>                                                <mml:mi>k</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo>=</mml:mo>                                             <mml:mn>1</mml:mn>                                          </mml:mrow>                                       </mml:mtd>                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:mi>i</mml:mi>                                             <mml:mi>f</mml:mi>                                          </mml:mrow>                                       </mml:mtd>                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:mstyle displaystyle="true">                                                <mml:msubsup>                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mrow>                                                      <mml:mi>i</mml:mi>                                                      <mml:mo>=</mml:mo>                                                      <mml:mn>1</mml:mn>                                                   </mml:mrow>                                                   <mml:mi>M</mml:mi>                                                </mml:msubsup>                                                <mml:mrow>                                                   <mml:msub>                                                      <mml:mi>w</mml:mi>                                                      <mml:mrow>                                                         <mml:mi>i</mml:mi>                                                         <mml:mo>,</mml:mo>                                                         <mml:mi>c</mml:mi>                                                      </mml:mrow>                                                   </mml:msub>                                                   <mml:msub>                                                      <mml:mi>x</mml:mi>                                                      <mml:mrow>                                                         <mml:mi>k</mml:mi>                                                         <mml:mi>i</mml:mi>                                                      </mml:mrow>                                                   </mml:msub>                                                   <mml:mo>&#x0003e;</mml:mo>                                                   <mml:mi>&#x003b8;</mml:mi>                                                </mml:mrow>                                             </mml:mstyle>                                          </mml:mrow>                                       </mml:mtd>                                    </mml:mtr>                                    <mml:mtr columnalign="left">                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:msub>                                                <mml:mi>h</mml:mi>                                                <mml:mi>c</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">(</mml:mo>                                             <mml:msub>                                                <mml:mi>x</mml:mi>                                                <mml:mi>k</mml:mi>                                             </mml:msub>                                             <mml:mo stretchy="false">)</mml:mo>                                             <mml:mo>=</mml:mo>                                             <mml:mo>&#x02212;</mml:mo>                                             <mml:mn>1</mml:mn>                                          </mml:mrow>                                       </mml:mtd>                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:mi>i</mml:mi>                                             <mml:mi>f</mml:mi>                                          </mml:mrow>                                       </mml:mtd>                                       <mml:mtd columnalign="left">                                          <mml:mrow>                                             <mml:mstyle displaystyle="true">                                                <mml:msubsup>                                                   <mml:mo>&#x02211;</mml:mo>                                                   <mml:mrow>                                                      <mml:mi>i</mml:mi>                                                      <mml:mo>=</mml:mo>                                                      <mml:mn>1</mml:mn>                                                   </mml:mrow>                                                   <mml:mi>M</mml:mi>                                                </mml:msubsup>                                                <mml:mrow>                                                   <mml:msub>                                                      <mml:mi>w</mml:mi>                                                      <mml:mrow>                                                         <mml:mi>i</mml:mi>                                                         <mml:mo>,</mml:mo>                                                         <mml:mi>c</mml:mi>                                                      </mml:mrow>                                                   </mml:msub>                                                   <mml:msub>                                                      <mml:mi>x</mml:mi>                                                      <mml:mrow>                                                         <mml:mi>k</mml:mi>                                                         <mml:mi>i</mml:mi>                                                      </mml:mrow>                                                   </mml:msub>                                                   <mml:mo>&#x02264;</mml:mo>                                                   <mml:mi>&#x003b8;</mml:mi>                                                </mml:mrow>                                             </mml:mstyle>                                          </mml:mrow>                                       </mml:mtd>                                    </mml:mtr>                                 </mml:mtable>                              </mml:mrow>                           </mml:mrow>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where <italic>w</italic><sub><italic>i</italic>,<italic>c </italic></sub>= <italic>w</italic><sub><italic>i </italic></sub>if <italic>w</italic><sub><italic>i </italic></sub>&#x02265; <italic>c</italic>, and <italic>w</italic><sub><italic>i</italic>,<italic>c </italic></sub>= 0 otherwise.</p><p>5. Let <italic>N</italic><sub><italic>c </italic></sub>denote the number of positive predictions by classifier <italic>h</italic>(<italic>c</italic>) in the training data and <italic>N</italic><sub>0 </sub>denote the number of positive predictions with the cutoff of 0.</p><p>&#x000a0;&#x000a0;&#x000a0;Output the classifier <italic>h</italic><sub><italic>C </italic></sub>where <italic>C </italic>= arg max {<italic>c </italic>| <italic>N</italic><sub><italic>c </italic></sub>= <italic>N</italic><sub>0</sub>}.</p><p>6. The features with non-zero w<sub>i,c </sub>are effective motif pairs.</p></sec></sec><sec><title>Verification with structural data</title><p>To further evaluate the algorithm for the structures of heterogeneous multi-protein complexes, we extracted structural data for complexes of human and virus proteins from PDB [<xref ref-type="bibr" rid="B14">14</xref>]. Complexes with RNA or DNA chains were not retrieved. Circa June 2008, there were a total of 105 complexes of human and virus proteins in PDB.</p><p>We used five-fold cross validation to evaluate the algorithm. The data set was split into five parts of equal size. The boosting algorithm using the WINNOW2 algorithm for weak hypotheses was trained with one part and tested with the remaining four parts. The train-test procedure consisted of five iterations.</p><p>When a residue pair in different chains contained an atomic pair within the distance of 5 &#x000c5;, we considered the residue pair as a <italic>contact residue pair</italic>. If a motif pair had at least one contact residue pair, we considered the motif pair as a <italic>verifiable motif pair </italic>[<xref ref-type="bibr" rid="B7">7</xref>]. To assess the statistical significance of motif pairs predicted by our algorithm, we estimated the p-value of motif pairs by executing Algorithm 4 with <italic>m </italic>= 100,000 [<xref ref-type="bibr" rid="B9">9</xref>]. Motif pairs with lower p-values are more significant than those with higher p-values.</p><sec><title>Algorithm 4 &#x02013; Estimation of p-values of motif pairs</title><p>A motif pair with a smaller p-value is more significant than a random motif pair R<sub>i</sub>.</p><p>1. Given a set <italic>S </italic>of motif pairs collected by weak hypotheses.</p><p>2. Randomly draw <italic>m </italic>motif pairs {<italic>R</italic><sub>1</sub>, <italic>R</italic><sub>2</sub>, ..., <italic>R</italic><sub><italic>m</italic></sub>} where <italic>R</italic><sub><italic>i </italic></sub>has the same size as M<sub>k </sub>(k = 1, 2, ...., 5)</p><p>3. Compute the p-value of the set S as follows:</p><p><disp-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S57-i12" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mtable>                              <mml:mtr>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:mi>p</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>S</mml:mi>                                       <mml:mo stretchy="false">)</mml:mo>                                       <mml:mo>=</mml:mo>                                       <mml:mfrac>                                          <mml:mrow>                                             <mml:mo>#</mml:mo>                                             <mml:mrow>                                                <mml:mo>(</mml:mo>                                                <mml:mrow>                                                   <mml:mi>V</mml:mi>                                                   <mml:mrow>                                                      <mml:mo>(</mml:mo>                                                      <mml:mrow>                                                         <mml:msub>                                                            <mml:mi>R</mml:mi>                                                            <mml:mi>i</mml:mi>                                                         </mml:msub>                                                      </mml:mrow>                                                      <mml:mo>)</mml:mo>                                                   </mml:mrow>                                                   <mml:mo>&#x02265;</mml:mo>                                                   <mml:mi>V</mml:mi>                                                   <mml:mrow>                                                      <mml:mo>(</mml:mo>                                                      <mml:mi>S</mml:mi>                                                      <mml:mo>)</mml:mo>                                                   </mml:mrow>                                                </mml:mrow>                                                <mml:mo>)</mml:mo>                                             </mml:mrow>                                          </mml:mrow>                                          <mml:mi>m</mml:mi>                                       </mml:mfrac>                                       <mml:mo>,</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                                 <mml:mtd>                                    <mml:mrow>                                       <mml:mi>i</mml:mi>                                       <mml:mo>=</mml:mo>                                       <mml:mo>{</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo>,</mml:mo>                                       <mml:mn>2</mml:mn>                                       <mml:mo>,</mml:mo>                                       <mml:mn>...</mml:mn>                                       <mml:mo>,</mml:mo>                                       <mml:mi>m</mml:mi>                                       <mml:mo>}</mml:mo>                                       <mml:mo>.</mml:mo>                                    </mml:mrow>                                 </mml:mtd>                              </mml:mtr>                           </mml:mtable>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>where <italic>V</italic>(<italic>S</italic>) is the number of verifiable motif pairs.</p></sec></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>This work was supported by the Korea Research Foundation Grant funded by the Korean Government (KRF-2006-D00038).</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Davey</surname><given-names>NE</given-names></name><name><surname>Shields</surname><given-names>DC</given-names></name><name><surname>Edwards</surname><given-names>RJ</given-names></name></person-group><article-title>SLiMDisc: short, linear motif discovery, correcting for common evolutionary</article-title><source>Nucleic Acid Res</source><year>2006</year><volume>34</volume><fpage>3546</fpage><lpage>3554</lpage><pub-id pub-id-type="pmid">16855291</pub-id><pub-id pub-id-type="doi">10.1093/nar/gkl486</pub-id></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Neduva</surname><given-names>V</given-names></name><name><surname>Russel</surname><given-names>RB</given-names></name></person-group><article-title>Linear motifs: Evolutionary interaction switches</article-title><source>FEBS Letters</source><year>2005</year><volume>579</volume><fpage>3342</fpage><lpage>3345</lpage><pub-id pub-id-type="pmid">15943979</pub-id><pub-id pub-id-type="doi">10.1016/j.febslet.2005.04.005</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Neduva</surname><given-names>V</given-names></name><name><surname>Russel</surname><given-names>RB</given-names></name></person-group><article-title>DILIMOT: discovery of linear motifs in proteins</article-title><source>Nucleic Acid Res</source><year>2006</year><volume>34</volume><fpage>W350</fpage><lpage>W355</lpage><pub-id pub-id-type="pmid">16845024</pub-id><pub-id pub-id-type="doi">10.1093/nar/gkl159</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Olson</surname><given-names>DL</given-names></name></person-group><article-title>Data Set Balancing</article-title><source>Lecture Notes in Artificial Intelligence</source><year>2004</year><volume>3327</volume><fpage>71</fpage><lpage>80</lpage></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Dupret</surname><given-names>G</given-names></name><name><surname>Koda</surname><given-names>M</given-names></name></person-group><article-title>Bootstrap re-sampling for unbalanced data in supervised learning</article-title><source>European Journal of Operational Research</source><year>2001</year><volume>134</volume><fpage>141</fpage><lpage>156</lpage><pub-id pub-id-type="doi">10.1016/S0377-2217(00)00244-7</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jansen</surname><given-names>R</given-names></name><name><surname>Gerstein</surname><given-names>M</given-names></name></person-group><article-title>Analyzing protein function on a genomic scale: the importance gold-standard positives and negatives for network prediction</article-title><source>Current opinion in Microbiology</source><year>2004</year><volume>7</volume><fpage>535</fpage><lpage>545</lpage><pub-id pub-id-type="pmid">15451510</pub-id><pub-id pub-id-type="doi">10.1016/j.mib.2004.08.012</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Yu</surname><given-names>H</given-names></name><name><surname>Qian</surname><given-names>M</given-names></name><name><surname>Deng</surname><given-names>M</given-names></name></person-group><article-title>Using a Stochastic AdaBoost Algorithm to Discover Interactome Motif Pairs from Sequences</article-title><source>Lecture Notes in Bioinformatics</source><year>2006</year><volume>4115</volume><fpage>622</fpage><lpage>630</lpage></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gomez</surname><given-names>SM</given-names></name><name><surname>Noble</surname><given-names>WS</given-names></name><name><surname>Rzhetsky</surname><given-names>A</given-names></name></person-group><article-title>Learning to Predict Protein-Protein Interactions from Protein Sequences</article-title><source>Bioinformatics</source><year>2003</year><volume>19</volume><fpage>1875</fpage><lpage>1881</lpage><pub-id pub-id-type="pmid">14555619</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btg352</pub-id></citation></ref><ref id="B9"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>J</given-names></name><name><surname>Park</surname><given-names>B</given-names></name><name><surname>Han</surname><given-names>K</given-names></name></person-group><article-title>Prediction of Interacting Motif Pairs using Stochastic Boosting</article-title><source>Proceedings of Frontiers in the Convergence of Bioscience and Information Technologies</source><year>2007</year><fpage>95</fpage><lpage>100</lpage></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Alfarano</surname><given-names>C</given-names></name><name><surname>Andrade</surname><given-names>CE</given-names></name><name><surname>Anthony</surname><given-names>K</given-names></name><etal></etal></person-group><article-title>The Biomolecular Interaction Network Database and related tools 2005 update</article-title><source>Nucleic Acid Res</source><year>2005</year><volume>33</volume><fpage>D418</fpage><lpage>D424</lpage><pub-id pub-id-type="pmid">15608229</pub-id><pub-id pub-id-type="doi">10.1093/nar/gki051</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Taylor</surname><given-names>WR</given-names></name><name><surname>Jones</surname><given-names>DT</given-names></name></person-group><article-title>Deriving an amino acid distance matrix</article-title><source>Journal of Theoretical Biology</source><year>1993</year><volume>164</volume><fpage>65</fpage><lpage>83</lpage><pub-id pub-id-type="pmid">8264244</pub-id><pub-id pub-id-type="doi">10.1006/jtbi.1993.1140</pub-id></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Schapire</surname><given-names>RE</given-names></name><name><surname>Singer</surname><given-names>Y</given-names></name></person-group><article-title>Improved Boosting Algorithms Using Confidence-rated Predictions</article-title><source>Machine Learning</source><year>1999</year><volume>37</volume><fpage>297</fpage><lpage>336</lpage><pub-id pub-id-type="doi">10.1023/A:1007614523901</pub-id></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Littlestone</surname><given-names>N</given-names></name></person-group><article-title>Learning Quickly When Irrelevant Attributes Abound. A New Linear-threshold Algorithm</article-title><source>Machine Learning</source><year>1988</year><volume>2</volume><fpage>285</fpage><lpage>318</lpage></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Deshpande</surname><given-names>N</given-names></name><name><surname>Addess</surname><given-names>KJ</given-names></name><name><surname>Bluhm</surname><given-names>WF</given-names></name><etal></etal></person-group><article-title>The RCSB Protein Data Bank: a redesigned query system and relational database based on the mmCIF schema</article-title><source>Nucleic Acids Research</source><year>2005</year><volume>33</volume><fpage>D233</fpage><lpage>D237</lpage><pub-id pub-id-type="pmid">15608185</pub-id><pub-id pub-id-type="doi">10.1093/nar/gki057</pub-id></citation></ref></ref-list></back></article>