<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd"><article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">19208138</article-id><article-id pub-id-type="pmc">2648794</article-id><article-id pub-id-type="publisher-id">1471-2105-10-S1-S37</article-id><article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S37</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Fine-grained parallel RNAalifold algorithm for RNA secondary structure prediction on FPGA</article-title></title-group><contrib-group><contrib id="A1" corresp="yes" contrib-type="author"><name><surname>Xia</surname><given-names>Fei</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>xcyphoenix@nudt.edu.cn</email></contrib><contrib id="A2" corresp="yes" contrib-type="author"><name><surname>Dou</surname><given-names>Yong</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>yongdou@nudt.edu.cn</email></contrib><contrib id="A3" contrib-type="author"><name><surname>Zhou</surname><given-names>Xingming</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>xmzhou@nudt.edu.cn</email></contrib><contrib id="A4" contrib-type="author"><name><surname>Yang</surname><given-names>Xuejun</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>yangxuejun@nudt.edu.cn</email></contrib><contrib id="A5" contrib-type="author"><name><surname>Xu</surname><given-names>Jiaqing</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>xjqanswer@hotmail.com</email></contrib><contrib id="A6" contrib-type="author"><name><surname>Zhang</surname><given-names>Yang</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>youngzhxm@gmail.com</email></contrib></contrib-group><aff id="I1"><label>1</label>National Laboratory for Parallel&#x00026;Distributed Processing, Department of Computer Science, National University of Defense Technology, ChangSha, 410073, PR China</aff><pub-date pub-type="collection"><year>2009</year></pub-date><pub-date pub-type="epub"><day>30</day><month>1</month><year>2009</year></pub-date><volume>10</volume><issue>Suppl 1</issue><supplement><named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content><named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content></supplement><fpage>S37</fpage><lpage>S37</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S37"/><permissions><copyright-statement>Copyright &#x000a9; 2009 Xia et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2009</copyright-year><copyright-holder>Xia et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>               Xia               Fei                              xcyphoenix@nudt.edu.cn            </dc:author><dc:title>            Fine-grained parallel RNAalifold algorithm for RNA secondary structure prediction on FPGA         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S37-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S37&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>In the field of RNA secondary structure prediction, the RNAalifold algorithm is one of the most popular methods using free energy minimization. However, general-purpose computers including parallel computers or multi-core computers exhibit parallel efficiency of no more than 50%. Field Programmable Gate-Array (FPGA) chips provide a new approach to accelerate RNAalifold by exploiting fine-grained custom design.</p></sec><sec><title>Results</title><p>RNAalifold shows complicated data dependences, in which the dependence distance is variable, and the dependence direction is also across two dimensions. We propose a systolic array structure including one master Processing Element (PE) and multiple slave PEs for fine grain hardware implementation on FPGA. We exploit data reuse schemes to reduce the need to load energy matrices from external memory. We also propose several methods to reduce energy table parameter size by 80%.</p></sec><sec><title>Conclusion</title><p>To our knowledge, our implementation with 16 PEs is the only FPGA accelerator implementing the complete RNAalifold algorithm. The experimental results show a factor of 12.2 speedup over the RNAalifold (<italic>ViennaPackage </italic>&#x02013; 1.6.5) software for a group of aligned RNA sequences with 2981-residue running on a Personal Computer (PC) platform with Pentium 4 2.6 GHz CPU.</p></sec></abstract><conference><conf-date>13&#x02013;16 January 2009</conf-date><conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name><conf-loc>Beijing, China</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>Ribonucleic Acid (RNA) is an important molecule that performs a wide range of functions in biological systems, such as synthesizing proteins, catalyzing reactions, splicing introns and regulating cellular activities. The function of an RNA molecule generally can be derived from its secondary structure. Currently, the only completely accurate method of determining the folded structure of an RNA molecule is by X-ray crystallography and nuclear magnetic resonance (NMR), however, those methods are time consuming and very expensive. Therefore, computational methods have been widely used in the field of RNA secondary structures prediction, such as thermodynamic energy minimization methods, homologous comparative sequences, stochastic context-free grammar methods (SCFG) and genetic algorithm and so on. Among which the most popular structure prediction algorithm is the Minimum Free Energy (MFE) method [<xref ref-type="bibr" rid="B1">1</xref>]. It was presented in 1981 by M. Zuker and has been implemented by three famous programs: Mfold [<xref ref-type="bibr" rid="B2">2</xref>], RNAfold [<xref ref-type="bibr" rid="B3">3</xref>] and RNAalifold [<xref ref-type="bibr" rid="B4">4</xref>] (the Vienna RNA package [<xref ref-type="bibr" rid="B5">5</xref>]).</p><p>Both Mfold and RNAfold implement the Zuker algorithm for computing minimal free energy (MFE) structures by folding a single sequence and employ the same thermodynamic parameters [<xref ref-type="bibr" rid="B6">6</xref>]. The time complexity is <italic>O</italic>(<italic>n</italic><sup>3</sup>) and the spatial complexity is <italic>O</italic>(<italic>n</italic><sup>2</sup>) by limiting the length of interior loops, where <italic>n </italic>is the sequence length. RNAalifold [<xref ref-type="bibr" rid="B4">4</xref>] implements an extension of the Zuker algorithm for computing a consensus structure from RNA alignments. The algorithm computes an averaged energy matrix and a covariation score matrix, augmented with penalties for inconsistent sequences. The algorithm requires extreme computational resources <italic>O</italic>(<italic>m </italic>&#x000d7; <italic>n</italic><sup>2 </sup>+ <italic>n</italic><sup>3</sup>) in time, and <italic>O</italic>(<italic>n</italic><sup>2</sup>) in space, where <italic>n </italic>is the sequence length and <italic>m </italic>is the number of sequences in the alignment [<xref ref-type="bibr" rid="B7">7</xref>].</p><p>Free energy minimization is the most common method for RNA secondary prediction. However, this method typically suffers two drawbacks. The first one is the limitation of structure prediction accuracy. The reason is that the thermodynamic rules are incomplete and the current model itself is an estimate of the real physics of RNA folding [<xref ref-type="bibr" rid="B8">8</xref>]. In practice, benchmarks of prediction accuracy on single RNA sequence show that current RNA folding programs get about 50&#x02013;70% of base pairs correct on average [<xref ref-type="bibr" rid="B9">9</xref>]. The second one is the extreme demand for computational resources. The cost is intolerable with the growth in RNA database.</p><p>There are two kinds of parallel processing solutions based on MFE method at present, but both of them only considered the application of single sequence folding, Mfold and RNAfold, which are based on Zuke algorithm. High performance parallel computers with shared or distributed memory, such as SMP multiprocessor [<xref ref-type="bibr" rid="B10">10</xref>] or cluster systems [<xref ref-type="bibr" rid="B11">11</xref>] are widely used to accelerate Zuker algorithm [<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>]. The main idea is to partition the matrix in a regular fashion and to distribute tasks to multiple processors.</p><p>Unfortunately, the simple coarse-grain zone blocking method (1 million cells in a region) results in severe load imbalance because the size of the computation for each element is closely related with its position in the matrix. In [<xref ref-type="bibr" rid="B14">14</xref>-<xref ref-type="bibr" rid="B16">16</xref>], the authors presented some parallel implementations of the Zuker algorithm and methods for load balance. However, they did not consider communication delays, which account for 50% of the execution time for a sequence length 9212, due to fine grain data transfer. They achieve a 19&#x000d7; speedup on a 32-processor system, DAWNING 4000A [<xref ref-type="bibr" rid="B10">10</xref>], and 8&#x000d7; on a cluster with 16 Opteron processors running at 2.2 GHz, each with 3 GB memory [<xref ref-type="bibr" rid="B11">11</xref>]. The other solution to accelerate the Zuker algorithm is using multi-core architecture. Based on the IBM Cyclops64 simulator, G.M. Tan et al. [<xref ref-type="bibr" rid="B17">17</xref>] presented a parallel Zuker algorithm. They report a 30&#x000d7; speedup on 64 cores for an RNA sequence length of 2048. Parallel efficiency is greatly limited by complicated data dependency and tight synchronization. Thus, efficiently executing the MFE algorithm on a general-purpose computer or a multi-core architecture becomes very awkward.</p><p>Recently, the use of Field Programmable Gate-Array (FPGA) coprocessors has become a promising approach for accelerating bioinformatics applications. The computational capability of FPGAs is increasing rapidly. The top level FPGA chip from Xilinx Virtex5 series contains 51840 slices and 10368 K bits storage. The reconfigurability of FPGA chips also enables algorithms to be implemented with different computing structures on the same hardware platform.</p><p>Accelerating the MFE algorithm on FPGA chips is a challenging task. First, the non-uniform multi-dimensional data dependences with variable dependence distance make it difficult to find a well-behaved task assignment for load balance. Second, the irregular spatial locality with a great deal of small granularity access operations make it difficult to optimize memory scheduling for efficient external access. Third, multiple copies of free energy parameters for parallel processing consume a large amount of on-chip memory and memory ports limiting the physical scale of parallel processing. Finally, the limited on-chip memory cannot hold all <italic>O</italic>(<italic>n</italic><sup>2</sup>) matrices, resulting in long-latency matrix loads from external Dynamic Random Access Memory (DRAM). So far, the algorithm accelerator based on MFE method is still under research. G.M. Tan et al. [<xref ref-type="bibr" rid="B18">18</xref>] introduced a fine-grained parallelization of the Zuker algorithm which considers only the interior loop calculation rather than the whole algorithm. A recent paper, Arpith Jacob et al. [<xref ref-type="bibr" rid="B19">19</xref>], implemented the simplest RNA folding algorithm, Nussinov algorithm [<xref ref-type="bibr" rid="B20">20</xref>], on a Virtex-II 6000 FPGA, but only input sequences with 30 ~ 60 bases can be predicted. Both presented results from simulation only.</p><p>In this paper, we propose a systolic array structure including one master PE and multiple slave PEs for fine grain hardware RNAalifold algorithm implementation on FPGA. We optimize the nested loop structure and reorganize the computation order by analyzing the data dependency in the original RNAalifold algorithm and improve the spatial locality in folding process. For load balance, we partition tasks by columns and assign tasks to PEs. We aggressively exploit data reuse schemes to minimize the need for loading energy matrices from external memory. Specifically, we add a cache to buffer a triangular sliding window of one of the matrices, most of which will be used in computing the next element in the column. We also transfer local elements directly to the next adjoining PE. In our design, only the master PE loads energy matrices from external DRAM. The remaining slave PEs simply wait for data from the previous PE. We also propose several methods that collectively reduce the storage requirements of the energy parameter tables by 80%-fitting curves with piecewise linear function, replacing scattered points with register constants and compressing the address space while shortening data length. The whole array structure is carefully pipelined in order to overlap multiple PE's column computations, master PE's load operations and multiple PE's write-back operations as much as possible. We implemented an RNAalifold algorithm accelerator with 16 processing elements on a single FPGA chip. The experimental results show a factor of 12&#x000d7; speedup over the <italic>ViennaRNA</italic>-1.6.5 software for a group of aligned RNA sequences with 2981-residue each running on a PC platform with Pentium 4 2.6 GHz CPU. Moreover, the power consumption is only about 1/8 of general-purpose microprocessor.</p></sec><sec><title>Overview of the RNAalifold algorithm</title><sec><title>Brief introduction</title><p>The RNAalifold algorithm predicts a consensus secondary structure from a group of aligned RNA sequences by calculating an averaged minimum free energy for the alignment, incorporating covariance information into the energy model [<xref ref-type="bibr" rid="B21">21</xref>]. The essential idea of RNAalifold algorithm is still the thermodynamic energy minimization theory, which was first presented by M. Zuker in 1981. It uses a "nearest neighbor" model and empirical estimates of thermodynamic parameters for neighboring interactions and loop entropies to score structures [<xref ref-type="bibr" rid="B7">7</xref>]. The data input of RNAalifold is the result of multiple sequence alignment and the common secondary structure (base pairing result) will be generated through below three processing phases.</p><sec><title>Calculating co-variance bonus</title><p>The function of this stage is calculating the co-variance bonus for each pair depending on compensatory or consistent mutations. Then it uses the bonus to judge if the residues located on the two positions can consist a base-pair and direct the energy filling process.</p></sec><sec><title>Filling energy matrices</title><p>Suppose <italic>S</italic>[0], <italic>S</italic>[1], ..., <italic>S</italic>[<italic>m</italic>] is a group of aligned RNA sequences as shown in Figure <xref ref-type="fig" rid="F1">1</xref>. <italic>r</italic><sub>1</sub><italic>r</italic><sub>2</sub>...<italic>r</italic><sub><italic>i</italic></sub>...<italic>r</italic><sub><italic>j</italic></sub>...<italic>r</italic><sub><italic>n </italic></sub>is an RNA sequence, which consists of four nucleotides: A, C, G, U and a blank inserted by multiple sequence alignment tool, where <italic>i </italic>and <italic>j </italic>represent the nucleotides' location in RNA sequence, <italic>k </italic>is the ID of current input sequence and <italic>n </italic>is the sequence length.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>An example of input sequences</bold>. <italic>S</italic>[0], <italic>S</italic>[1], ..., <italic>S</italic>[<italic>m</italic>] represent a group of aligned RNA sequences. Where <italic>i </italic>and <italic>j </italic>represent the nucleotides' location in RNA sequence, <italic>k </italic>is the ID of current input sequence and <italic>n </italic>is the sequence length.</p></caption><graphic xlink:href="1471-2105-10-S1-S37-1"/></fig><p>The core of energy matrices filling stage in RNAalifold is a triple cycle operation as shown in Figure <xref ref-type="fig" rid="F2">2</xref>. The two control variables, <italic>i </italic>and <italic>j </italic>in surrounding loops, moves alone the horizontal axis to pass through every place and search for the potential base-pairs. The inner loop, control variable <italic>k</italic>, moves down and implements the free energy accumulation of substructure located on (<italic>i</italic>, <italic>j</italic>) position in different energy matrices. The value of <italic>V</italic>(<italic>i</italic>, <italic>j</italic>) equals the minimum value among the four energy parameters that four fundamental substructures corresponding respectively, which stands for the energy of an consensus optimal structure of the common subsequence <italic>r</italic><sub><italic>i</italic></sub>...<italic>r</italic><sub><italic>j</italic></sub>.</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>The RNAalifold algorithm description</bold>. This figure describes the core of energy matrices filling stage in RNAalifold.</p></caption><graphic xlink:href="1471-2105-10-S1-S37-2"/></fig><p>The vector <italic>W </italic>holds the minimal free energy for certain structures of common subsequences. The element, <italic>W</italic>(<italic>j</italic>), is the energy of a consensus optimal structure of the common subsequence <italic>r</italic><sub>1</sub><italic>r</italic><sub>2</sub>...<italic>r</italic><sub><italic>j</italic></sub>. Once the longest fragment, the complete sequence, is considered, the lowest conformational free energy is calculated then the filling step ends and <italic>W</italic>(<italic>n</italic>) stands for the energy of the most energetically stable structure of the aligned RNA sequences. The calculation of <italic>W</italic>(<italic>j</italic>) depends on its left elements from <italic>W</italic>(1) to <italic>W</italic>(<italic>j</italic>-1) and the <italic>j</italic>th column in matrix <italic>V</italic>, <italic>V </italic>(*, <italic>j</italic>).</p><p>As for one of the input RNA sequence, <italic>S</italic>[<italic>k</italic>], the energy computing for each base-pair (<italic>r</italic><sub><italic>i</italic></sub>&#x000b7;<italic>r</italic><sub><italic>j</italic></sub>) involves four triangular matrices: <italic>V</italic>, <italic>VBI</italic>, <italic>VM</italic>, <italic>WM </italic>and three energy functions: <italic>eS</italic>(<italic>i</italic>, <italic>j</italic>), <italic>eH</italic>(<italic>i</italic>, <italic>j</italic>), <italic>eL</italic>(<italic>i</italic>, <italic>j</italic>, <italic>i'</italic>, <italic>j'</italic>). The recurrence relations as shown in Figure <xref ref-type="fig" rid="F3">3</xref>.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>The recurrence relations in RNAalifold</bold>. The energy computing recurrence relations for each base-pair (<italic>r</italic><sub><italic>i</italic></sub>&#x000b7;<italic>r</italic><sub><italic>j</italic></sub>) in RNA sequence.</p></caption><graphic xlink:href="1471-2105-10-S1-S37-3"/></fig><p><italic>V </italic>(<italic>i</italic>, <italic>j</italic>) is the energy of the optimal structure of the subsequence <italic>r</italic><sub><italic>i</italic></sub><italic>r</italic><sub><italic>i</italic>+1</sub>&#x022ef;<italic>r</italic><sub><italic>j </italic></sub>where <italic>r</italic><sub><italic>i</italic></sub><italic>r</italic><sub><italic>j </italic></sub>comprises a base pair. <italic>VBI</italic>(<italic>i</italic>, <italic>j</italic>) is the energy of the subsequence from <italic>r</italic><sub><italic>i </italic></sub>through <italic>r</italic><sub><italic>j </italic></sub>where <italic>r</italic><sub><italic>i</italic></sub><italic>r</italic><sub><italic>j </italic></sub>closes a bulge or an internal loop. <italic>VM</italic>(<italic>i</italic>, <italic>j</italic>) is the energy of the subsequence from <italic>r</italic><sub><italic>i </italic></sub>through <italic>r</italic><sub><italic>j </italic></sub>where <italic>r</italic><sub><italic>i</italic></sub><italic>r</italic><sub><italic>j </italic></sub>closes a multi-branched loop. <italic>WM </italic>(<italic>i</italic>, <italic>j</italic>) is the energy of the subsequence from <italic>r</italic><sub><italic>i </italic></sub>through <italic>r</italic><sub><italic>j </italic></sub>that constitutes part of a multi-branched loop structure. <italic>eS</italic>(<italic>i</italic>, <italic>j</italic>), <italic>eH</italic>(<italic>i</italic>, <italic>j</italic>) and <italic>eL</italic>(<italic>i</italic>, <italic>j</italic>, <italic>i'</italic>, <italic>j'</italic>) are free energy functions, which are used to compute the energy of stacked pair, hairpin loop and internal loop respectively. In software folding solution, these free energy functions are calculated by looking up tables of the standard free energy parameters, which are detected by experimental method. The storage requirement of those tables is about 1 M Byte.</p></sec><sec><title>Backtracking</title><p>When the corresponding energy matrices of all input sequences have been filled out, the free energy for optimal consensus structure is known, which is stored in the element <italic>W</italic>(<italic>n</italic>), but the structure is unknown. The phase of backtracking is performed to determine the structure leading to the lowest free energy, using the free energies calculated in the filling step to revivify the exact structure. Experiments show that the energy matrices filling step consumes more than 99% of the total execution time. Thus, computing energy matrices quickly is critical.</p></sec></sec><sec><title>Characteristics of RNAalifold</title><p>We make five observations about the characteristics of the RNAalifold algorithm. These observations suggest details of the parallel implementation.</p><sec><title>Observation 1. The computation size of each element in an energy matrix is variable and closely related with its position</title><p>Considering the most time-consuming calculation of matrix <italic>V </italic>for each input sequence, which is an upper triangle matrix as described in formula (1). The computation size (the number of add operations) for each element, <italic>C</italic>(<italic>i</italic>, <italic>j</italic>), is closely related with the indices <italic>i </italic>and <italic>j</italic>, as shown in formula (5).</p><p><disp-formula id="bmcM5"><label>(5)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-10-S1-S37-i1" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mi>C</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>i</mml:mi>                              <mml:mo>,</mml:mo>                              <mml:mi>j</mml:mi>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>=</mml:mo>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>j</mml:mi>                              <mml:mo>&#x02212;</mml:mo>                              <mml:mi>i</mml:mi>                              <mml:mo>+</mml:mo>                              <mml:mn>1</mml:mn>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>+</mml:mo>                              <mml:mrow>                                 <mml:mo>{</mml:mo>                                 <mml:mrow>                                    <mml:mtable columnalign="left">                                       <mml:mtr columnalign="left">                                          <mml:mtd columnalign="left">                                             <mml:mrow>                                                <mml:mfrac>                                                   <mml:mrow>                                                      <mml:mn>30</mml:mn>                                                      <mml:mo>&#x000d7;</mml:mo>                                                      <mml:mn>31</mml:mn>                                                   </mml:mrow>                                                   <mml:mn>2</mml:mn>                                                </mml:mfrac>                                                <mml:mo>,</mml:mo>                                                <mml:mi>j</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mi>i</mml:mi>                                                <mml:mo>&#x0003e;</mml:mo>                                                <mml:mn>30</mml:mn>                                                <mml:mo>;</mml:mo>                                             </mml:mrow>                                          </mml:mtd>                                       </mml:mtr>                                       <mml:mtr columnalign="left">                                          <mml:mtd columnalign="left">                                             <mml:mrow>                                                <mml:mfrac>                                                   <mml:mrow>                                                      <mml:mo stretchy="false">(</mml:mo>                                                      <mml:mi>j</mml:mi>                                                      <mml:mo>&#x02212;</mml:mo>                                                      <mml:mi>i</mml:mi>                                                      <mml:mo stretchy="false">)</mml:mo>                                                      <mml:mo>&#x000d7;</mml:mo>                                                      <mml:mo stretchy="false">(</mml:mo>                                                      <mml:mi>j</mml:mi>                                                      <mml:mo>&#x02212;</mml:mo>                                                      <mml:mi>i</mml:mi>                                                      <mml:mo>+</mml:mo>                                                      <mml:mn>1</mml:mn>                                                      <mml:mo stretchy="false">)</mml:mo>                                                   </mml:mrow>                                                   <mml:mn>2</mml:mn>                                                </mml:mfrac>                                                <mml:mo>,</mml:mo>                                                <mml:mi>j</mml:mi>                                                <mml:mo>&#x02212;</mml:mo>                                                <mml:mi>i</mml:mi>                                                <mml:mo>&#x02264;</mml:mo>                                                <mml:mn>30</mml:mn>                                             </mml:mrow>                                          </mml:mtd>                                       </mml:mtr>                                    </mml:mtable>                                 </mml:mrow>                              </mml:mrow>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>The computation size of <italic>jth </italic>column <italic>V</italic>(*, <italic>j</italic>), <italic>C</italic>(*, <italic>j</italic>), is the sum of <italic>C</italic>(<italic>i</italic>, <italic>j</italic>) in the <italic>jth </italic>column:</p><p><disp-formula id="bmcM6"><label>(6)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-10-S1-S37-i2" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mi>C</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mo>&#x02217;</mml:mo>                              <mml:mo>,</mml:mo>                              <mml:mi>j</mml:mi>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>=</mml:mo>                              <mml:mfrac>                                 <mml:mrow>                                    <mml:mi>j</mml:mi>                                    <mml:mo>&#x022c5;</mml:mo>                                    <mml:mo stretchy="false">(</mml:mo>                                    <mml:mi>j</mml:mi>                                    <mml:mo>&#x02212;</mml:mo>                                    <mml:mn>1</mml:mn>                                    <mml:mo stretchy="false">)</mml:mo>                                 </mml:mrow>                                 <mml:mn>2</mml:mn>                              </mml:mfrac>                              <mml:mo>+</mml:mo>                              <mml:mrow>                                 <mml:mo>{</mml:mo>                                 <mml:mrow>                                    <mml:mtable columnalign="left">                                       <mml:mtr columnalign="left">                                          <mml:mtd columnalign="left">                                             <mml:mrow>                                                <mml:mtable>                                                   <mml:mtr>                                                      <mml:mtd>                                                         <mml:mrow>                                                            <mml:mi>S</mml:mi>                                                            <mml:mo>,</mml:mo>                                                         </mml:mrow>                                                      </mml:mtd>                                                      <mml:mtd>                                                         <mml:mrow>                                                            <mml:mn>3</mml:mn>                                                            <mml:mo>&#x02264;</mml:mo>                                                            <mml:mi>j</mml:mi>                                                            <mml:mo>&#x02264;</mml:mo>                                                            <mml:mn>30</mml:mn>                                                            <mml:mo>;</mml:mo>                                                         </mml:mrow>                                                      </mml:mtd>                                                   </mml:mtr>                                                </mml:mtable>                                             </mml:mrow>                                          </mml:mtd>                                       </mml:mtr>                                       <mml:mtr columnalign="left">                                          <mml:mtd columnalign="left">                                             <mml:mrow>                                                <mml:mi>S</mml:mi>                                                <mml:mo>+</mml:mo>                                                <mml:mfrac>                                                   <mml:mrow>                                                      <mml:mn>30</mml:mn>                                                      <mml:mo>&#x000d7;</mml:mo>                                                      <mml:mn>31</mml:mn>                                                      <mml:mo>&#x000d7;</mml:mo>                                                      <mml:mo stretchy="false">(</mml:mo>                                                      <mml:mi>j</mml:mi>                                                      <mml:mo>&#x02212;</mml:mo>                                                      <mml:mn>30</mml:mn>                                                      <mml:mo stretchy="false">)</mml:mo>                                                   </mml:mrow>                                                   <mml:mn>2</mml:mn>                                                </mml:mfrac>                                                <mml:mo>,</mml:mo>                                                <mml:mi>j</mml:mi>                                                <mml:mo>&#x0003e;</mml:mo>                                                <mml:mn>30</mml:mn>                                                <mml:mo>;</mml:mo>                                             </mml:mrow>                                          </mml:mtd>                                       </mml:mtr>                                    </mml:mtable>                                 </mml:mrow>                              </mml:mrow>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>Where, <italic>S </italic>= 1 + 3 + 6 + &#x022ef; + <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-10-S1-S37-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula> &#x000d7; (<italic>j </italic>- 1) &#x000d7; (<italic>j </italic>- 2). The difference in computation size between column <italic>j </italic>and column <italic>j </italic>+ 1 is &#x00394;<italic>C</italic>(<italic>j</italic>, <italic>j </italic>+ 1):</p><p><disp-formula id="bmcM7"><label>(7)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-10-S1-S37-i4" overflow="scroll">                        <mml:semantics>                           <mml:mrow>                              <mml:mi>&#x00394;</mml:mi>                              <mml:mi>C</mml:mi>                              <mml:mo stretchy="false">(</mml:mo>                              <mml:mi>j</mml:mi>                              <mml:mo>,</mml:mo>                              <mml:mi>j</mml:mi>                              <mml:mo>+</mml:mo>                              <mml:mn>1</mml:mn>                              <mml:mo stretchy="false">)</mml:mo>                              <mml:mo>=</mml:mo>                              <mml:mi>j</mml:mi>                              <mml:mo>+</mml:mo>                              <mml:mrow>                                 <mml:mo>{</mml:mo>                                 <mml:mrow>                                    <mml:mtable columnalign="left">                                       <mml:mtr columnalign="left">                                          <mml:mtd columnalign="left">                                             <mml:mrow>                                                <mml:mfrac>                                                   <mml:mrow>                                                      <mml:mi>j</mml:mi>                                                      <mml:mo>&#x000d7;</mml:mo>                                                      <mml:mo stretchy="false">(</mml:mo>                                                      <mml:mi>j</mml:mi>                                                      <mml:mo>&#x02212;</mml:mo>                                                      <mml:mn>1</mml:mn>                                                      <mml:mo stretchy="false">)</mml:mo>                                                   </mml:mrow>                                                   <mml:mn>2</mml:mn>                                                </mml:mfrac>                                                <mml:mo>,</mml:mo>                                                <mml:mn>3</mml:mn>                                                <mml:mo>&#x02264;</mml:mo>                                                <mml:mi>j</mml:mi>                                                <mml:mo>&#x02264;</mml:mo>                                                <mml:mn>30</mml:mn>                                                <mml:mo>;</mml:mo>                                             </mml:mrow>                                          </mml:mtd>                                       </mml:mtr>                                       <mml:mtr columnalign="left">                                          <mml:mtd columnalign="left">                                             <mml:mrow>                                                <mml:mfrac>                                                   <mml:mrow>                                                      <mml:mn>30</mml:mn>                                                      <mml:mo>&#x000d7;</mml:mo>                                                      <mml:mn>31</mml:mn>                                                   </mml:mrow>                                                   <mml:mn>2</mml:mn>                                                </mml:mfrac>                                                <mml:mo>,</mml:mo>                                                <mml:mi>j</mml:mi>                                                <mml:mo>&#x0003e;</mml:mo>                                                <mml:mn>30</mml:mn>                                                <mml:mo>;</mml:mo>                                             </mml:mrow>                                          </mml:mtd>                                       </mml:mtr>                                    </mml:mtable>                                 </mml:mrow>                              </mml:mrow>                           </mml:mrow>                                                   </mml:semantics>                     </mml:math></disp-formula></p><p>We can find that the computation size gradually increases with the matrix location moving up from bottom to top in the same column and increases with the location moving right in the same row. Specifically, the workload of <italic>V</italic>(1, <italic>n</italic>) is the heaviest one, it depends on the entire row and column elements of <italic>WM </italic>matrix and the bottom-left triangle region of <italic>V</italic>(1, <italic>n</italic>) with the maximum size <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-10-S1-S37-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula> &#x000d7; 30 &#x000d7; 31. This workload imbalance suggests a cyclic column allocation scheme, in which each processing element (PE) is assigned one column of matrix <italic>V</italic>. Each PE processes its column from bottom to top.</p></sec><sec><title>Observation 2. Parallel computation of <italic>V </italic>requires multiple copies of the free energy parameters</title><p>The calculation of each element of matrix <italic>V </italic>involves looking up parameter tables to get the values of the free energy functions <italic>eH</italic>, <italic>eS </italic>and <italic>eL</italic>, obtained from experimental methods. The tables are addressed by pairs of RNA residues. To calculate <italic>V</italic>(<italic>i</italic>, <italic>j</italic>), we first find the residue pair indexed by <italic>i </italic>and <italic>j </italic>in the RNA sequence, then lookup the tables to obtain the energy values. The number of query operations in RNAalifold for computing matrix <italic>V </italic>is <italic>O</italic>(<italic>n</italic><sup>3</sup>), <italic>n </italic>is the RNA sequence size. For parallel computing, centralized tables will become the performance bottleneck. We have to distribute the parameter table to each PE so that energy values can be read without memory conflict. But the storage requirement of entire free energy parameter tables at 37&#x000b0;<italic>C </italic>is more than 128 KByte. In addition to other storage requirements for data buffers, the total storage requirement will greatly exceed the capacity of the current largest FPGA chip if the number of PEs is over 4. As a result, for RNAalifold, the storage factor has a major effect on the scalability of parallel processing.</p><p>We figured out several efficient compression approaches to reduce the storage overhead of the free energy parameters. First, we partition the loop destabilizing energies into segmented linear functions. The transformation from query operations to arithmetic operations reduces the requirements for memory ports and storage capacity. The linear functions are simple, require little logic, and have no impact on accuracy. Second, we represent a few scattered points using registers. Some parameters in free energy tables are scattered too widely to be fitted by simple linear functions. Instead of using block RAM to hold these parameters, we assign these parameters to registers. Third, we compress the address space and shorten the data length. Interior loop energy data occupies more than 80% of the total parameter tables, when four nucleotides, <italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>U </italic>are encoded directly. Instead, we encode the six base pairs, <italic>AU</italic>, <italic>CG</italic>, <italic>CU</italic>, <italic>GC</italic>, <italic>UA </italic>and <italic>UC </italic>using 3 bits. The table address length reduces from 16-bit occupying 64 K entries to 14-bit for 16 K entries. The storage requirement is compressed by 75%. Finally, we transform the raw data of free energy parameter tables from signed decimal fraction into complementary integer reducing data width from 16-bit to 8-bit without affecting accuracy. With the above schemes, the storage requirement of free energy parameter tables drops by 80%. As a result, more processing elements can be fitted in FPGA chip.</p></sec><sec><title>Observation 3. We can use a sliding window to reuse data within a column</title><p>From formula (2), we observe the element <italic>VBI</italic>(<italic>i</italic>, <italic>j</italic>), which is used to calculate <italic>V </italic>(<italic>i</italic>, <italic>j</italic>), depends on the elements located in the bottom-left triangle region of <italic>V </italic>(<italic>i</italic>, <italic>j</italic>). As shown in Figure <xref ref-type="fig" rid="F4">4</xref>, the region is a triangle window with the maximum size of 30 &#x000d7; 30 due to the limitation of the interior loop length. In Figure <xref ref-type="fig" rid="F4">4</xref>, the blue triangle window in matrix <italic>V</italic>, called window A, contains the necessary data for computing the element A of <italic>VBI</italic>. With the computation traveling upward in the same column from <italic>A</italic>, <italic>A</italic>1, to <italic>A</italic>2, the triangle window moves from bottom to top.</p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>The data dependence in RNAalifold</bold>. (a) shows the elements of matrix VBI depend on a triangle window of matrix <italic>V</italic>; (b) shows the sliding window moving upward; (c) shows the data reusing between adjoining columns.</p></caption><graphic xlink:href="1471-2105-10-S1-S37-4"/></fig><p>We observe that only one row of elements is updated when the window slides from <italic>A </italic>to <italic>A</italic>1, the other elements remain unchanged. We use a local buffer of 465 elements (<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-10-S1-S37-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula> &#x000d7; 30 &#x000d7; 31) and prefetch 30 elements of <italic>V </italic>into it before calculating each element of <italic>VBI</italic>, saving 435 elements. This greatly reduces the memory bandwidth requirements for loading elements of <italic>V </italic>from external DRAM.</p></sec><sec><title>Observation 4. We can use a sliding window to reuse data between adjoining columns</title><p>The triangle windows in adjoining columns exhibit an overlapped area which can be exploited for additional data reuse. Assuming the four elements A, B, C and D located in four adjoining columns in Figure <xref ref-type="fig" rid="F4">4(c)</xref>, we arrange four PEs, PE1, PE2, PE3 and PE4 for parallel computing, respectively. In Figure <xref ref-type="fig" rid="F4">4(c)</xref>, we observe that triangle B contains two parts, one is a sub-triangle residing in triangle A completely, and the other is a column of A with a maximum size of 30 elements which becomes available before element A is computed. The same overlapped area can be found between B and C, C and D. This observation implies that except that the first column PE1 has to hold the entire triangle window, the other column PEs have to wait only for the elements transferred from the previous PE. A similar scenario is found in the computation of <italic>WM</italic>. As a result, by transferring data between the adjoining columns processing, we can greatly reduce the memory bandwidth requirements for loading elements of <italic>V </italic>and <italic>WM </italic>from external DRAM.</p></sec><sec><title>Observation 5. We can reorganize the computation order in parameter accumulating among multiple energy matrices to improve the spatial locality</title><p>In order to recover the consensus structure of the common subsequences from position <italic>i </italic>to <italic>j </italic>in a group of aligned RNA sequences, the sum of energy value of all fragments located in the same position (<italic>i</italic>, <italic>j</italic>) must be figured out. In the original RNAalifold algorithm, the sum-of-energy is calculated by adding up the energy of the same position in all input sequences one by one (the parameter <italic>k </italic>increases from 1 to <italic>m </italic>in the inner loop as shown in Figure <xref ref-type="fig" rid="F5">5(a)</xref>). According the recurrence relations (1)~(4) and the observations 3 and 4, the parameter <italic>V</italic>(<italic>i</italic>, <italic>j</italic>) of each sequence corresponding is depend on its energy matrices <italic>V </italic>and <italic>WM</italic>.</p><fig position="float" id="F5"><label>Figure 5</label><caption><p><bold>The contrast between original and optimized RNAalifold algorithm</bold>. (a) shows the kernel loops of energy filling stage in the original RNAalifold algorithm; (b) shows those of energy filling stage in the optimized RNAalifold algorithm. The main difference lies in the inner loop (variable <italic>k</italic>) of RNAalifold, which is brought out and the free energy computation (the <italic>Calculate </italic>statement, which implements the recurrence relations (1)~(4)) and accumulation (the 4 assignment statements) process are separated. In optimized algorithm, the free energy matrices of each RNA sequence corresponding are calculated and stored by executing the triple For-loop operations at first. Then, the independent For-loop statement implements the accumulation operation for adding up the free energy parameters for all input sequences. At last, the matrices <italic>V </italic>and <italic>W </italic>are calculated for backtracking.</p></caption><graphic xlink:href="1471-2105-10-S1-S37-5"/></fig><p>The jumping of current energy computing and accumulation operand among the multiple energy matrices will cause the high-frequency data exchanging (RNA sequences and the elements located in sliding triangle window in every energy matrix <italic>V</italic>) between FPGA and off-chip memory. As a result the poor spatial locality and low efficiency of external memory access will become the performance bottleneck in FPGA implementation.</p><p>To address the problem, we improved the nest relationship of the triple cycle operation in original algorithm. In the original algorithm as shown in Figure <xref ref-type="fig" rid="F5">5(a)</xref>, only the current computing result, the four energy components on position (<italic>i</italic>, <italic>j</italic>) (<italic>eH </italic>(<italic>i</italic>, <italic>j</italic>)<sub><italic>k</italic></sub>, <italic>eS' </italic>(<italic>i</italic>, <italic>j</italic>)<sub><italic>k</italic></sub>, <italic>VBI </italic>(<italic>i</italic>, <italic>j</italic>)<sub><italic>k</italic></sub>, <italic>VM </italic>(<italic>i</italic>, <italic>j</italic>)<sub><italic>k</italic></sub>), can be reused.</p><p>However, in the optimized algorithm, the elements located in the triangle region of <italic>V </italic>(<italic>i</italic>, <italic>j</italic>) and current rowcolumn of <italic>WM </italic>(<italic>i</italic>, <italic>j</italic>) can be reused for computing the next elements <italic>V </italic>(<italic>i </italic>- 1, <italic>j</italic>) and V (<italic>i</italic>, <italic>j </italic>+ 1). As a result, we can eliminate the high-frequency data exchanging between FPGA and off-chip memory and improve the access efficiency of external memory.</p></sec></sec></sec><sec sec-type="methods"><title>Methods</title><sec><title>System architecture</title><p>Our RNA folding computation platform consists of an algorithm accelerator and a host processor. The accelerator receives a group of aligned RNA sequences with a co-variance bonus matrix, executes the energy matrices filling and backtracking phases, and reports the consensus RNA secondary structure represented in base pairs back to the host for display. The structure is shown in Figure <xref ref-type="fig" rid="F6">6</xref>.</p><fig position="float" id="F6"><label>Figure 6</label><caption><p><bold>The structure of RNAalifold algorithm accelerator</bold>. This figure describes the structure of our RNAalifold algorithm accelerator. The accelerator comprises one FPGA chip, two SDRAM modules, and one I/O channel to the host PC.</p></caption><graphic xlink:href="1471-2105-10-S1-S37-6"/></fig><p>The accelerator engine comprises one FPGA chip, two SDRAM modules, and one I/O channel to the host PC. Two SDRAM DIMMs store the energy matrices of each sequence for energy accumulating and backtracking, and are connected to the FPGA pad directly. The host interface channel is responsible for transferring initial RNA data, co-variance bonus and final results between the accelerator and the host. The core of the RNAalifold algorithm accelerator is composed of a PE Array Controller, a PE array, a Shared Memory Module, an Energy Matrices Superposition Module and a Trace-back Module. The PE Array Controller is responsible for assigning column tasks to the PE array and switching from the filling phase to the backtracking phase. The Shared Memory module contains a <italic>V </italic>cache, which holds the triangular sliding window and a <italic>WM </italic>column buffer, which stores the current <italic>p </italic>column elements for writing back to SDRAM, where <italic>p </italic>is the number of PEs. The PE array performs the free energy calculation in parallel. The array consists of a series of PE modules, in which the first one, PE1 is the master and the others are slaves. Each PE is augmented with a local memory to store a copy of the current RNA sequence and a register for the current column elements of matrix <italic>WM</italic>. The registers between adjoining PEs, called the Trans Regs, are used for delivering reusable data including <italic>WM </italic>row/column elements and the bottom-left elements of <italic>V</italic>(<italic>i</italic>, <italic>j</italic>). The Energy Matrices Superposition Module is responsible for energy accumulating and generating the energy matrices (<italic>V</italic>, <italic>WM</italic>, <italic>W</italic>) for backtracking.</p></sec><sec><title>Master-slave PE array algorithm</title><p>Free energy computing (the Calculate statement in the triple For-loop as shown in Figure <xref ref-type="fig" rid="F5">5</xref>) is the kernel in the RNAalifold algorithm. As implied by observation 1, the upper-triangular shaped energy matrices are partitioned into columns. Each PE holds one column cyclically in turn. Every group of <italic>p </italic>contiguous columns forms a section as shown in Figure <xref ref-type="fig" rid="F7">7</xref>. Figure <xref ref-type="fig" rid="F8">8</xref> describes the parallel RNAalifold algorithm in a Single-Program Multiple-Data (SPMD) style.</p><fig position="float" id="F7"><label>Figure 7</label><caption><p><bold>The task partitioning and the computation order with 4-PE array</bold>. There are 4 dark columns assigned to PE1 to PE4 in the middle area representing the current section. The positions belonging to the same diagonal marked with stars represent the current computation points of the 4 PEs. The parallel RNAalifold algorithm is divided into three phases, energy calculation, columns synchronization and section advance.</p></caption><graphic xlink:href="1471-2105-10-S1-S37-7"/></fig><fig position="float" id="F8"><label>Figure 8</label><caption><p><bold>The master-slave PE array algorithm</bold>. The first part of Figure 8 shows the parameter and variable definitions. At the initial phase, each PE assigns its PE identifier, PID, to the column index indicating the initial column assignment. Before the energy calculation phase several data items are loaded into local memory as shown in S21. Only the master PE loads data from SDRAM and the <italic>V </italic>cache, the other slave PEs only load data from Trans Regs of the previous adjoining PE. When the energy data are ready in local memory, the free energy calculation is performed as shown in S22. From S23 to S25, all PEs transfer data received from the previous adjoining PEs to their own Trans Regs, store results to local memory, and move the computation point upward in the same column. When the computation point moves to the top of the current column, the PE enters the column synchronization phase, during which it writes its local results to SDRAM. When all PEs arrive at the synchronization points, indicating the end of the current section, the section advances by each PE adding <italic>p </italic>to its column index. The process repeats until the column index is greater than the RNA sequence length.</p></caption><graphic xlink:href="1471-2105-10-S1-S37-8"/></fig></sec><sec><title>Performance measures</title><p>The execution time of our parallel RNAalifold algorithm can be predicted in cycles due to the tight synchronization of the systolic array structure. The total execution time (<italic>T</italic>) is the sum of matrices filling time (<italic>T</italic><sub><italic>f</italic></sub>), matrices accumulating time (<italic>T</italic><sub><italic>a</italic></sub>) and the time for trace-back (<italic>T</italic><sub><italic>t</italic></sub>). Moreover, the matrices filling time (<italic>T</italic><sub><italic>f</italic></sub>) equals the energy computation time (<italic>T</italic><sub><italic>c</italic></sub>) plus the external memory access time (<italic>T</italic><sub><italic>m</italic></sub>). Assuming <italic>p </italic>is the number of PEs, <italic>n </italic>is the length of the aligned RNA sequence, <italic>m </italic>is the number of input sequences and <italic>s </italic>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-10-S1-S37-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>&#x0230a;</mml:mo><mml:mrow><mml:mfrac><mml:mi>N</mml:mi><mml:mi>p</mml:mi></mml:mfrac></mml:mrow><mml:mo>&#x0230b;</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula>, we have energy computation time (<italic>T</italic><sub><italic>c</italic></sub>) in (8)</p><p><disp-formula id="bmcM8"><label>(8)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-10-S1-S37-i6" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>T</mml:mi>                              <mml:mi>c</mml:mi>                           </mml:msub>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mn>1</mml:mn>                              <mml:mn>4</mml:mn>                           </mml:mfrac>                           <mml:mi>p</mml:mi>                           <mml:mo>&#x022c5;</mml:mo>                           <mml:mi>&#x00394;</mml:mi>                           <mml:msub>                              <mml:mi>t</mml:mi>                              <mml:mn>1</mml:mn>                           </mml:msub>                           <mml:mo>&#x022c5;</mml:mo>                           <mml:mrow>                              <mml:mo>[</mml:mo>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>s</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>s</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                    <mml:mn>2</mml:mn>                                 </mml:mfrac>                                 <mml:mo>+</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>s</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>s</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mn>2</mml:mn>                                       <mml:mi>s</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                    <mml:mn>6</mml:mn>                                 </mml:mfrac>                                 <mml:mi>p</mml:mi>                              </mml:mrow>                              <mml:mo>]</mml:mo>                           </mml:mrow>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>The time for accessing external memory (<italic>T</italic><sub><italic>m</italic></sub>) is <italic>T</italic><sub><italic>m </italic></sub>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-10-S1-S37-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>&#x000b7;&#x00394;<italic>t</italic><sub>2</sub>. Thus, the filling time for all energy matrices (<italic>T</italic><sub><italic>f</italic></sub>) is</p><p><disp-formula id="bmcM9"><label>(9)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-10-S1-S37-i8" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:msub>                              <mml:mi>T</mml:mi>                              <mml:mi>f</mml:mi>                           </mml:msub>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:mi>m</mml:mi>                                 <mml:mo>&#x022c5;</mml:mo>                                 <mml:mi>p</mml:mi>                                 <mml:mo>&#x022c5;</mml:mo>                                 <mml:mi>&#x00394;</mml:mi>                                 <mml:msub>                                    <mml:mi>t</mml:mi>                                    <mml:mn>1</mml:mn>                                 </mml:msub>                              </mml:mrow>                              <mml:mn>4</mml:mn>                           </mml:mfrac>                           <mml:mo>&#x022c5;</mml:mo>                           <mml:mrow>                              <mml:mo>[</mml:mo>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>s</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>s</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                    <mml:mn>2</mml:mn>                                 </mml:mfrac>                                 <mml:mo>+</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>s</mml:mi>                                       <mml:mi>p</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>s</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mn>2</mml:mn>                                       <mml:mi>s</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                    <mml:mn>6</mml:mn>                                 </mml:mfrac>                              </mml:mrow>                              <mml:mo>]</mml:mo>                           </mml:mrow>                           <mml:mo>+</mml:mo>                           <mml:mfrac>                              <mml:mn>1</mml:mn>                              <mml:mn>2</mml:mn>                           </mml:mfrac>                           <mml:mo>&#x022c5;</mml:mo>                           <mml:mi>m</mml:mi>                           <mml:mo>&#x022c5;</mml:mo>                           <mml:mi>n</mml:mi>                           <mml:mo>&#x022c5;</mml:mo>                           <mml:mo stretchy="false">(</mml:mo>                           <mml:mi>n</mml:mi>                           <mml:mo>+</mml:mo>                           <mml:mn>1</mml:mn>                           <mml:mo stretchy="false">)</mml:mo>                           <mml:mo>&#x022c5;</mml:mo>                           <mml:mi>&#x00394;</mml:mi>                           <mml:msub>                              <mml:mi>t</mml:mi>                              <mml:mn>2</mml:mn>                           </mml:msub>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>The matrices accumulation time (<italic>T</italic><sub><italic>a</italic></sub>) is <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-10-S1-S37-i9" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x022c5;</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>&#x000b7;&#x00394;<italic>t</italic><sub>1 </sub>and the time for trace-back (<italic>T</italic><sub><italic>t</italic></sub>) is <italic>T</italic><sub><italic>t </italic></sub>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-10-S1-S37-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mrow><mml:mn>3</mml:mn><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mn>8</mml:mn></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>. Where &#x00394;<italic>t</italic><sub>1 </sub>is the time for each sum operation, which is one cycle in our implementation, &#x00394;<italic>t</italic><sub>2 </sub>is the average access overhead for storing an element to external memory, which is 15 cycles in the worst case. As a result, the total execution time (<italic>T</italic>) is</p><p><disp-formula id="bmcM10"><label>(10)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-10-S1-S37-i11" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>T</mml:mi>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:mi>m</mml:mi>                                 <mml:mi>p</mml:mi>                              </mml:mrow>                              <mml:mn>4</mml:mn>                           </mml:mfrac>                           <mml:mo>&#x022c5;</mml:mo>                           <mml:mrow>                              <mml:mo>[</mml:mo>                              <mml:mrow>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>s</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>s</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                    <mml:mn>2</mml:mn>                                 </mml:mfrac>                                 <mml:mo>+</mml:mo>                                 <mml:mfrac>                                    <mml:mrow>                                       <mml:mi>s</mml:mi>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mi>s</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                       <mml:mo stretchy="false">(</mml:mo>                                       <mml:mn>2</mml:mn>                                       <mml:mi>s</mml:mi>                                       <mml:mo>+</mml:mo>                                       <mml:mn>1</mml:mn>                                       <mml:mo stretchy="false">)</mml:mo>                                    </mml:mrow>                                    <mml:mn>6</mml:mn>                                 </mml:mfrac>                                 <mml:mo>&#x022c5;</mml:mo>                                 <mml:mi>p</mml:mi>                              </mml:mrow>                              <mml:mo>]</mml:mo>                           </mml:mrow>                           <mml:mo>+</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:mn>15</mml:mn>                                 <mml:mi>m</mml:mi>                                 <mml:mi>n</mml:mi>                                 <mml:mo>&#x022c5;</mml:mo>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>n</mml:mi>                                 <mml:mo>+</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mrow>                              <mml:mn>2</mml:mn>                           </mml:mfrac>                           <mml:mo>+</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>m</mml:mi>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mo>&#x022c5;</mml:mo>                                 <mml:msup>                                    <mml:mi>n</mml:mi>                                    <mml:mn>2</mml:mn>                                 </mml:msup>                              </mml:mrow>                              <mml:mn>2</mml:mn>                           </mml:mfrac>                           <mml:mo>+</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:mn>3</mml:mn>                                 <mml:mo>&#x022c5;</mml:mo>                                 <mml:msup>                                    <mml:mi>n</mml:mi>                                    <mml:mn>2</mml:mn>                                 </mml:msup>                              </mml:mrow>                              <mml:mn>8</mml:mn>                           </mml:mfrac>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>According to the formula (9) and (10), we can theoretically analyze the parallel efficiency (<italic>E</italic><sub><italic>c </italic></sub>= <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-10-S1-S37-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>&#x003b1;</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>) of our accelerator, where <italic>&#x003b1; </italic>is</p><p><disp-formula id="bmcM11"><label>(11)</label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-10-S1-S37-i13" overflow="scroll">                     <mml:semantics>                        <mml:mrow>                           <mml:mi>&#x003b1;</mml:mi>                           <mml:mo>=</mml:mo>                           <mml:mfrac>                              <mml:mrow>                                 <mml:mn>3</mml:mn>                                 <mml:msup>                                    <mml:mi>n</mml:mi>                                    <mml:mn>2</mml:mn>                                 </mml:msup>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mn>4</mml:mn>                                 <mml:mi>m</mml:mi>                                 <mml:mo>&#x02212;</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mrow>                              <mml:mrow>                                 <mml:mi>s</mml:mi>                                 <mml:mi>m</mml:mi>                                 <mml:mi>p</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>s</mml:mi>                                 <mml:mo>+</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mn>2</mml:mn>                                 <mml:mi>s</mml:mi>                                 <mml:mi>p</mml:mi>                                 <mml:mo>+</mml:mo>                                 <mml:mi>p</mml:mi>                                 <mml:mo>+</mml:mo>                                 <mml:mn>3</mml:mn>                                 <mml:mo stretchy="false">)</mml:mo>                                 <mml:mo>+</mml:mo>                                 <mml:mn>180</mml:mn>                                 <mml:mi>m</mml:mi>                                 <mml:mi>n</mml:mi>                                 <mml:mo stretchy="false">(</mml:mo>                                 <mml:mi>n</mml:mi>                                 <mml:mo>+</mml:mo>                                 <mml:mn>1</mml:mn>                                 <mml:mo stretchy="false">)</mml:mo>                              </mml:mrow>                           </mml:mfrac>                        </mml:mrow>                                             </mml:semantics>                  </mml:math></disp-formula></p><p>In the general case that <italic>m </italic>= 100, <italic>p </italic>&#x0003c; 128 and <italic>n </italic>&#x0003e; 1024, the parameter <italic>&#x003b1; </italic>is always less than 0.1. As a result, the parallel efficiency can reach more than 90%, showing good parallelism.</p></sec></sec><sec><title>Results and discussion</title><sec><title>Experiment environment</title><p>We implement the RNAalifold algorithm accelerator in an FPGA testbed. The testbed is composed of one FPGA chip, StratixII EP2S130C5 from Altera, two 1 GB SDRAM modules, MT16LSDT12864A from Micron and a USB2.0 interface to the host computer. The folding software, RNAalifold (<italic>ViennaPackage</italic>-1.6.5 download from Vienna RNA web site [<xref ref-type="bibr" rid="B22">22</xref>]), runs on a desktop computer with Intel Pentium4 2.60 GHz CPU and 1 GB Memory at level <italic>O</italic>3 compiler optimization. Both the accelerator and software use the same free energy parameters, RNA free energies at 37&#x000b0;<italic>C</italic>, Version 3.0 downloaded from M. Zuker's homepage. We also measure software execution time on AMD and Xeon platforms to verify the acceleration of our approach.</p></sec><sec><title>Verifying correctness</title><p>We verify the correctness of our implementation in three steps. First, we ensure the correctness of the optimized algorithm by comparing the software folding result. Second, we implement hardware RNAalifold algorithm and verify the function correctness of the hardware using software emulation with ModelSim SE 6.2 h. Then, we run the search in our testbed to compare the base-paring results with the ones produced by software to verify the correctness of the folding result generated by our accelerator. We fold six group of RNA sequences (20 sequences in each group) with the size from 83 bps to 2981 bps by using hardware and software solutions respectively. The experimental results show that the folding results of our accelerator agree with the software version.</p></sec><sec><title>Resource usage</title><p>Besides implementing the accelerator on Altera FPGA chips, we place different numbers of PEs on Xilinx FPGA chips to evaluate the resource usages as well. As shown in the last row of Table <xref ref-type="table" rid="T1">1</xref>, in Altera FPGA chips, one PE consumes 3817 ALUTs and 332 K bits of memory. It consumes 2124 slices and 2013 slices in Xilinx XC4V and XC5V FPGA chips respectively. At most 16 PEs fit on EP2S130C5 because the storage requirement consumes almost all of the memory resources. On XC5VLX330, the latest FPGA from Xilinx, we can fit 20 PEs. All implementation can reach a clock frequency of over 130 MHz.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Resource usage on different FPGA platforms</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center">FPGA</td><td align="center">EP2S130C5</td><td align="center">XC4VLX200-11</td><td align="center">XC5VLX330-2</td></tr></thead><tbody><tr><td align="center">PE Fitted</td><td align="center">16</td><td align="center">16</td><td align="center">20</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">ALUTSlice (%)</td><td align="center">75720 (71%)</td><td align="center">46483 (52%)</td><td align="center">42097 (80%)</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">Total Memory (%)</td><td align="center">6328 Kb (96%)</td><td align="center">6592 Kb (88%)</td><td align="center">11828 Kb (89%)</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">Clock (MHz)</td><td align="center">133</td><td align="center">135</td><td align="center">138</td></tr><tr><td colspan="4"><hr></hr></td></tr><tr><td align="center">Single PE</td><td align="center">3817 ALUTs332Kb</td><td align="center">2124 Slices</td><td align="center">2013 Slice</td></tr></tbody></table></table-wrap></sec><sec><title>Scalability</title><p>To explore the scalability of the proposed accelerator architecture, we folded six group of sequences on our accelerator. As shown in Figure <xref ref-type="fig" rid="F9">9</xref>, the execution time of input RNA sequences with varying length from 83-base to 2981-base on multiple PEs includes computation time, trace-back time and the time for sending sequence query and taking results back for display. Because execution time greatly increases with the increase in sequence length ranging from 0.15s for 83 bases to 199.8s for 2981 bases, we show the execution time in different figures. Considering the longest sequence with 2981 bases, the execution time is shortened sharply from 199.8s for one PE to 16.4s for 16 PEs, a factor of 12.2 speedup. Performance with 20 PEs is estimated according to the formula (10). Figure <xref ref-type="fig" rid="F10">10</xref> shows the speedup with different sequence lengths ranging from 83 to 2981 exhibit similar linear features due to the scalable parallel structure in the accelerator.</p><fig position="float" id="F9"><label>Figure 9</label><caption><p><bold>The execution time (s) on different PE array size for different queries</bold>. The horizontal axis represents PE array size and the vertical axis represents execution time of hardware accelerator. The six curves with different color represent input RNA sequences with different length.</p></caption><graphic xlink:href="1471-2105-10-S1-S37-9"/></fig><fig position="float" id="F10"><label>Figure 10</label><caption><p><bold>The speedup on different PE array size for different queries</bold>. The horizontal coordinate represents PE array size and the vertical coordinate represents the speedup of each group of input RNA sequences.</p></caption><graphic xlink:href="1471-2105-10-S1-S37-10"/></fig></sec><sec><title>Performance compared to ViennaRNA</title><p>The original loops in RNAalifold are unrolled and the calculation order in energy matrices filling stage is reorganized in our fine-grained parallel algorithm. However, the time complexity is undiversified since the number of add and compare operations are not change. In the original algorithm, only two triangle matrices (<italic>V </italic>and <italic>WM</italic>) are stored for each sequence in energy matrices filling stage. In optimized algorithm, the other four substructure matrices (<italic>eS</italic>, <italic>eH</italic>, <italic>V BI</italic>, <italic>VM</italic>) are also stored for energy accumulation. Thus, the parallel algorithm needs triple storage requirement compared to the original RNAalifold software. In order to reduce the bandwidth requirements for external memory access, the six triangle matrices are compressed into two matrices by using component combined strategy. Furthermore, the data reusing in PE array is well exploited with the spatial locality improving. Therefore, the increasing of storage requirements for off-chip memory will not become the bottleneck in FPGA implementation. Taking Pentium 4 as the base, we compare the execution time and speedup among 4 different platforms, including three general-purpose computers and our algorithm accelerator. Despite the variation in CPU type, clock frequency, main memory capacity, cache capacity and software versions, the three general-purpose computers exhibit similar performance. As shown in Table <xref ref-type="table" rid="T2">2</xref>, Athlon shows a little advantage over Pentium and Xeon, achieving at most 1.4&#x000d7; speedup. However, the FPGA accelerator exhibits significant speedup ranging from 8.4 to 12.2.</p><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Execution time(s) and speedup with different input on different platforms</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center">Sequence Size (M = 20)</td><td align="center" colspan="2">N = 154</td><td align="center" colspan="2">N = 387</td><td align="center" colspan="2">N = 1556</td><td align="center" colspan="2">N = 2981</td></tr><tr><td></td><td colspan="8"><hr></hr></td></tr><tr><td></td><td align="center">Time</td><td align="center">Speedup</td><td align="center">Time</td><td align="center">Speedup</td><td align="center">Time</td><td align="center">Speedup</td><td align="center">Time</td><td align="center">Speedup</td></tr></thead><tbody><tr><td align="center">FPGA(16-PE)</td><td align="center">0.05</td><td align="center">8.4</td><td align="center">0.19</td><td align="center">8.7</td><td align="center">5.1</td><td align="center">9.8</td><td align="center">16.4</td><td align="center">12.2</td></tr><tr><td colspan="9"><hr></hr></td></tr><tr><td align="center">Pentium<sup>(1)</sup></td><td align="center">0.42</td><td align="center">1</td><td align="center">1.65</td><td align="center">1</td><td align="center">49.5</td><td align="center">1</td><td align="center">199.8</td><td align="center">1</td></tr><tr><td colspan="9"><hr></hr></td></tr><tr><td align="center">Xeon<sup>(2)</sup></td><td align="center">0.38</td><td align="center">1.1</td><td align="center">1.38</td><td align="center">1.2</td><td align="center">45.1</td><td align="center">1.1</td><td align="center">178.5</td><td align="center">1.1</td></tr><tr><td colspan="9"><hr></hr></td></tr><tr><td align="center">Athlon<sup>(3)</sup></td><td align="center">0.31</td><td align="center">1.4</td><td align="center">1.18</td><td align="center">1.4</td><td align="center">37.8</td><td align="center">1.3</td><td align="center">141.6</td><td align="center">1.4</td></tr></tbody></table><table-wrap-foot><p>The soft/hardware experimental environment of different platforms are listed as follows. Pentium<sup>(1)</sup>: 2.6 G CPU, 1.0 GB memory, 512 KB Cache, Linux 2.6.5, GCC 4.1.0; Xeon<sup>(2)</sup>: 2.8 G CPU, 1.0 GB memory, 1024 KB Cache, Linux 2.4.2, GCC 3.2.3; Athlon<sup>(3)</sup>: 2.0 G CPU, 2.0 GB memory, 512 KB Cache, Linux 2.6.18, GCC 4.1.1;</p></table-wrap-foot></table-wrap></sec><sec><title>Power consumption compared to general-purpose microprocessor</title><p>FPGA accelerator is also energy-efficient relative to general-purpose computers. Our RNAalifold algorithm accelerator with 16 PEs only consumes 9.2 <italic>W </italic>as simulated by Xilinx ISE 9.2 XPower tool. General-purpose microprocessors consume between 80 <italic>W </italic>to 150 <italic>W </italic>on average [<xref ref-type="bibr" rid="B23">23</xref>]. Furthermore, considering the low clock frequency of 130 MHz in FPGA chips, we believe the application-specific fine-grained schemes implemented in our accelerator provides significant advantage over the general-purpose schemes.</p></sec></sec><sec><title>Conclusion</title><p>The minimum free energy (MFE) method plays an important role in the area of RNA secondary structures prediction. Many parallel implementations on general purpose multiprocessors exhibit parallel efficiency of no more than 50%. In this paper, we explore the use of FPGAs to accelerate the RNAalifold algorithm based on MFE method.</p><p>After carefully studying the characteristics of the algorithm, we make five observations to direct our design. We optimize the nested loop structure in original RNAalifold and reorganize the computation order to improve the spatial locality. We propose task assignment in cyclic column order to achieve load balance. We introduce two data reuse schemes that use a sliding window cache and transfer registers between adjoining PEs. We also presented several methods to reduce the storage requirement for holding multiple copies of energy parameter tables. The experimental evaluation demonstrates that the performance of our algorithm accelerator is scalable with multiple PEs and that the FPGA accelerator outperforms general-purpose computers with a speedup of more than 12&#x000d7; on 16 PEs.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>Fei Xia carried out the fine-grained parallel RNAalifold algorithm, participated in the characteristics analysis of the RNAalifold algorithm and drafted the manuscript. Yong Dou conceived of the study, and participated in its design and helped to draft the manuscript. Xingming Zhou and Xuejun Yang participated in the discussion of the study and performed the performance evaluation. Jiaqing Xu participated in the sequence alignment and the analysis of original RNAalifold algorithm. Yang Zhang participated in hardware implementation and correctness verification and power consumption analysis. All authors read and approved the final manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>The authors thank the researchers who provided access, documentation and installation assistance for RNAalifold software. This work is partially sponsored by the National High Technology Research and Development Program (2007AA01Z106) and NSFC (60633050 and 60621003). We would like to thank Prof. Amir Roth for his detailed revising directions and we also thank the anonymous reviewers for their constructive comments.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p></sec></ack><ref-list><ref id="B1"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Mount</surname><given-names>DW</given-names></name></person-group><source>Bioinformatics: sequence and genome analysis</source><year>2004</year><publisher-name>New York: Cold Spring Harbor Laborary Press</publisher-name></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Zuker</surname><given-names>M</given-names></name><name><surname>Stiegler</surname><given-names>P</given-names></name></person-group><article-title>Optimal computer folding of large RNA sequences using thermodynamics and auxiliary information</article-title><source>Nucleic Acids Research</source><year>1981</year><volume>9</volume><fpage>133</fpage><lpage>148</lpage><pub-id pub-id-type="pmid">6163133</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hofacker</surname><given-names>IL</given-names></name><name><surname>Fontana</surname><given-names>W</given-names></name><name><surname>Stadler</surname><given-names>P</given-names></name><name><surname>Bonhoeffer</surname><given-names>L</given-names></name><name><surname>M</surname><given-names>T</given-names></name><name><surname>P</surname><given-names>S</given-names></name></person-group><article-title>Fast folding and comparison of RNA secondary structures</article-title><source>Monatshefte Chemie</source><year>1994</year><volume>125</volume><fpage>167</fpage><lpage>188</lpage></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hofacker</surname><given-names>IL</given-names></name><name><surname>Fekete</surname><given-names>M</given-names></name><name><surname>Stadler</surname><given-names>P</given-names></name></person-group><article-title>Secondary structure prediction for aligned RNA sequences</article-title><source>Journal of Molecular Biology</source><year>2002</year><volume>319</volume><fpage>1059</fpage><lpage>1066</lpage><pub-id pub-id-type="pmid">12079347</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hofacker</surname><given-names>IL</given-names></name></person-group><article-title>Vienna RNA secondary structure server</article-title><source>Nucleic Acids Research</source><year>2003</year><volume>31</volume><fpage>3429</fpage><lpage>3431</lpage><pub-id pub-id-type="pmid">12824340</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Mathews</surname><given-names>DH</given-names></name><name><surname>Sabina</surname><given-names>J</given-names></name><name><surname>Zuker</surname><given-names>M</given-names></name><name><surname>Turner</surname><given-names>DH</given-names></name></person-group><article-title>Expanded sequence dependence of thermodynamic parameters provides robust prediction of RNA secondary structure</article-title><source>Journal of Molecular Biology</source><year>1999</year><volume>288</volume><fpage>911</fpage><lpage>940</lpage><pub-id pub-id-type="pmid">10329189</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gardner</surname><given-names>P</given-names></name><name><surname>Giegerich</surname><given-names>R</given-names></name></person-group><article-title>A comprehensive comparison of comparative RNA structure prediction approaches</article-title><source>BMC Bioinformatics</source><year>2004</year><volume>5</volume><fpage>140</fpage><pub-id pub-id-type="pmid">15458580</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Mathews</surname><given-names>DH</given-names></name><name><surname>Turner</surname><given-names>DH</given-names></name></person-group><article-title>Prediction of RNA secondary structure by free energy minimization</article-title><source>Current Opinion in Structural Biology</source><year>2006</year><volume>16</volume><fpage>270</fpage><lpage>278</lpage><pub-id pub-id-type="pmid">16713706</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Eddy</surname><given-names>SR</given-names></name></person-group><article-title>How do RNA folding algorithms work?</article-title><source>Nature Biotechnology</source><year>2004</year><volume>22</volume><fpage>1457</fpage><lpage>1458</lpage><pub-id pub-id-type="pmid">15529172</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Tan</surname><given-names>G</given-names></name><name><surname>Feng</surname><given-names>S</given-names></name><name><surname>Sun</surname><given-names>N</given-names></name></person-group><article-title>An optimized and efficiently parallelized dynamic programming for RNA secondary structure prediction</article-title><source>Journal of Software</source><year>2006</year><volume>17</volume><fpage>1501</fpage><lpage>1509</lpage></citation></ref><ref id="B11"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Tan</surname><given-names>G</given-names></name><name><surname>Feng</surname><given-names>S</given-names></name><name><surname>Sun</surname><given-names>N</given-names></name></person-group><article-title>Locality and parallelism optimization for dynamic programming algorithm in bioinformatics</article-title><source>Proceedings of the ACM/IEEE SuperComputing 2006 Conference: November 2006, Tampa, Florida, USA</source><year>2006</year></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lyngso</surname><given-names>RB</given-names></name><name><surname>Zuker</surname><given-names>M</given-names></name><name><surname>Pedersen</surname><given-names>CNS</given-names></name></person-group><article-title>Fast evaluation of internal loops in RNA secondary structure prediction</article-title><source>Bioinformatics</source><year>1999</year><volume>15</volume><fpage>440</fpage><lpage>445</lpage><pub-id pub-id-type="pmid">10383469</pub-id></citation></ref><ref id="B13"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Lyngso</surname><given-names>RB</given-names></name><name><surname>Zuker</surname><given-names>M</given-names></name><name><surname>Pedersen</surname><given-names>CNS</given-names></name></person-group><article-title>Internal loops in RNA secondary structure prediction</article-title><source>Proceedings of the third Annual International Conference on Computational Molecular Biology: 1999</source><year>1999</year><publisher-name>Lyon, France</publisher-name><fpage>260</fpage><lpage>267</lpage></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>JH</given-names></name><name><surname>Le</surname><given-names>SY</given-names></name><name><surname>Shapiro</surname><given-names>BA</given-names></name><name><surname>Maizel</surname><given-names>JV</given-names></name></person-group><article-title>Optimization of an RNA folding algorithm for parallel architectures</article-title><source>Parallel Computing</source><year>1998</year><volume>24</volume><fpage>1617</fpage><lpage>1634</lpage></citation></ref><ref id="B15"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Fekete</surname><given-names>IHM</given-names></name><name><surname>Stadler</surname><given-names>PF</given-names></name></person-group><article-title>Prediction of RNA base pairing posibilities for RNA secondary structure</article-title><source>Biopolymers</source><year>1990</year><volume>9</volume><fpage>1105</fpage><lpage>1119</lpage></citation></ref><ref id="B16"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Shapiro</surname><given-names>BA</given-names></name><name><surname>Wu</surname><given-names>JC</given-names></name><name><surname>Bengali</surname><given-names>D</given-names></name><name><surname>Potts</surname><given-names>MJ</given-names></name></person-group><article-title>The massively parallel genetic algorithm for RNA folding: mimd implementation and population variation</article-title><source>Bioinformatics</source><year>2001</year><volume>17</volume><fpage>137</fpage><lpage>148</lpage><pub-id pub-id-type="pmid">11238069</pub-id></citation></ref><ref id="B17"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Tan</surname><given-names>G</given-names></name><name><surname>Sun</surname><given-names>N</given-names></name><name><surname>Gao</surname><given-names>GR</given-names></name></person-group><article-title>A parallel dynamic programming algorithm on a multi-core architecture</article-title><source>Proceedings of the nineteenth Annual ACM Symposium on Parallel Algorithms and Architectures: 2007; San Diego, USA</source><year>2007</year><publisher-name>ACM</publisher-name><fpage>135</fpage><lpage>144</lpage></citation></ref><ref id="B18"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Tan</surname><given-names>G</given-names></name><name><surname>Xu</surname><given-names>L</given-names></name><name><surname>Feng</surname><given-names>S</given-names></name><name><surname>Sun</surname><given-names>N</given-names></name></person-group><article-title>An experimental study of optimizing bioinformatics applications</article-title><source>Proceedings of the 20th IEEE International Parallel and Distributed Processing Symposium: April 2006; Rhodes Island, Greece</source><year>2006</year><fpage>284</fpage></citation></ref><ref id="B19"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Jacob</surname><given-names>A</given-names></name><name><surname>Buhler</surname><given-names>J</given-names></name><name><surname>Chamberlain</surname><given-names>RD</given-names></name></person-group><article-title>Accelerating Nussinov RNA secondary structure prediction with systolic arrays on FPGAs</article-title><source>Proceedings of the 19th IEEE International Conference on Application-specific Systems, Architectures and Processors, 2008; Leuven, Belgium</source><year>2008</year></citation></ref><ref id="B20"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Nussinov</surname><given-names>R</given-names></name><name><surname>Pieczenik</surname><given-names>G</given-names></name><name><surname>Griggs</surname><given-names>JR</given-names></name><name><surname>Kleitman</surname><given-names>DJ</given-names></name></person-group><article-title>Algorithms for loop matchings</article-title><source>SIAM Journal on Applied mathematics</source><year>1978</year><volume>35</volume><fpage>68</fpage><lpage>82</lpage></citation></ref><ref id="B21"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Washietl</surname><given-names>S</given-names></name><name><surname>Hofacker</surname><given-names>IL</given-names></name></person-group><article-title>Consensus folding of aligned sequences as a new measure for the detection of functional RNAs by comparative genomics</article-title><source>Journal of Molecular Biology</source><year>2004</year><volume>342</volume><fpage>19</fpage><lpage>30</lpage><pub-id pub-id-type="pmid">15313604</pub-id></citation></ref><ref id="B22"><citation citation-type="other"><article-title>RNAalifold (Vienna rna folding package)</article-title><ext-link ext-link-type="uri" xlink:href="http://rna.tbi.univie.ac.at/~ivo/RNA/"/></citation></ref><ref id="B23"><citation citation-type="other"><article-title>CPU power dissipation</article-title><ext-link ext-link-type="uri" xlink:href="http://en.wikipedia.org/wiki/CPU_power_dissipation"/></citation></ref></ref-list></back></article>